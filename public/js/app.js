/******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, {
/******/ 				configurable: false,
/******/ 				enumerable: true,
/******/ 				get: getter
/******/ 			});
/******/ 		}
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = 0);
/******/ })
/************************************************************************/
/******/ ({

/***/ "./node_modules/axios/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = __webpack_require__("./node_modules/axios/lib/axios.js");

/***/ }),

/***/ "./node_modules/axios/lib/adapters/xhr.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");
var settle = __webpack_require__("./node_modules/axios/lib/core/settle.js");
var buildURL = __webpack_require__("./node_modules/axios/lib/helpers/buildURL.js");
var parseHeaders = __webpack_require__("./node_modules/axios/lib/helpers/parseHeaders.js");
var isURLSameOrigin = __webpack_require__("./node_modules/axios/lib/helpers/isURLSameOrigin.js");
var createError = __webpack_require__("./node_modules/axios/lib/core/createError.js");
var btoa = typeof window !== 'undefined' && window.btoa && window.btoa.bind(window) || __webpack_require__("./node_modules/axios/lib/helpers/btoa.js");

module.exports = function xhrAdapter(config) {
  return new Promise(function dispatchXhrRequest(resolve, reject) {
    var requestData = config.data;
    var requestHeaders = config.headers;

    if (utils.isFormData(requestData)) {
      delete requestHeaders['Content-Type']; // Let the browser set it
    }

    var request = new XMLHttpRequest();
    var loadEvent = 'onreadystatechange';
    var xDomain = false;

    // For IE 8/9 CORS support
    // Only supports POST and GET calls and doesn't returns the response headers.
    // DON'T do this for testing b/c XMLHttpRequest is mocked, not XDomainRequest.
    if ("development" !== 'test' && typeof window !== 'undefined' && window.XDomainRequest && !('withCredentials' in request) && !isURLSameOrigin(config.url)) {
      request = new window.XDomainRequest();
      loadEvent = 'onload';
      xDomain = true;
      request.onprogress = function handleProgress() {};
      request.ontimeout = function handleTimeout() {};
    }

    // HTTP basic authentication
    if (config.auth) {
      var username = config.auth.username || '';
      var password = config.auth.password || '';
      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);
    }

    request.open(config.method.toUpperCase(), buildURL(config.url, config.params, config.paramsSerializer), true);

    // Set the request timeout in MS
    request.timeout = config.timeout;

    // Listen for ready state
    request[loadEvent] = function handleLoad() {
      if (!request || request.readyState !== 4 && !xDomain) {
        return;
      }

      // The request errored out and we didn't get a response, this will be
      // handled by onerror instead
      // With one exception: request that using file: protocol, most browsers
      // will return status as 0 even though it's a successful request
      if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {
        return;
      }

      // Prepare the response
      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;
      var responseData = !config.responseType || config.responseType === 'text' ? request.responseText : request.response;
      var response = {
        data: responseData,
        // IE sends 1223 instead of 204 (https://github.com/axios/axios/issues/201)
        status: request.status === 1223 ? 204 : request.status,
        statusText: request.status === 1223 ? 'No Content' : request.statusText,
        headers: responseHeaders,
        config: config,
        request: request
      };

      settle(resolve, reject, response);

      // Clean up request
      request = null;
    };

    // Handle low level network errors
    request.onerror = function handleError() {
      // Real errors are hidden from us by the browser
      // onerror should only fire if it's a network error
      reject(createError('Network Error', config, null, request));

      // Clean up request
      request = null;
    };

    // Handle timeout
    request.ontimeout = function handleTimeout() {
      reject(createError('timeout of ' + config.timeout + 'ms exceeded', config, 'ECONNABORTED', request));

      // Clean up request
      request = null;
    };

    // Add xsrf header
    // This is only done if running in a standard browser environment.
    // Specifically not if we're in a web worker, or react-native.
    if (utils.isStandardBrowserEnv()) {
      var cookies = __webpack_require__("./node_modules/axios/lib/helpers/cookies.js");

      // Add xsrf header
      var xsrfValue = (config.withCredentials || isURLSameOrigin(config.url)) && config.xsrfCookieName ? cookies.read(config.xsrfCookieName) : undefined;

      if (xsrfValue) {
        requestHeaders[config.xsrfHeaderName] = xsrfValue;
      }
    }

    // Add headers to the request
    if ('setRequestHeader' in request) {
      utils.forEach(requestHeaders, function setRequestHeader(val, key) {
        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {
          // Remove Content-Type if data is undefined
          delete requestHeaders[key];
        } else {
          // Otherwise add header to the request
          request.setRequestHeader(key, val);
        }
      });
    }

    // Add withCredentials to request if needed
    if (config.withCredentials) {
      request.withCredentials = true;
    }

    // Add responseType to request if needed
    if (config.responseType) {
      try {
        request.responseType = config.responseType;
      } catch (e) {
        // Expected DOMException thrown by browsers not compatible XMLHttpRequest Level 2.
        // But, this can be suppressed for 'json' type as it can be parsed by default 'transformResponse' function.
        if (config.responseType !== 'json') {
          throw e;
        }
      }
    }

    // Handle progress if needed
    if (typeof config.onDownloadProgress === 'function') {
      request.addEventListener('progress', config.onDownloadProgress);
    }

    // Not all browsers support upload events
    if (typeof config.onUploadProgress === 'function' && request.upload) {
      request.upload.addEventListener('progress', config.onUploadProgress);
    }

    if (config.cancelToken) {
      // Handle cancellation
      config.cancelToken.promise.then(function onCanceled(cancel) {
        if (!request) {
          return;
        }

        request.abort();
        reject(cancel);
        // Clean up request
        request = null;
      });
    }

    if (requestData === undefined) {
      requestData = null;
    }

    // Send the request
    request.send(requestData);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");
var bind = __webpack_require__("./node_modules/axios/lib/helpers/bind.js");
var Axios = __webpack_require__("./node_modules/axios/lib/core/Axios.js");
var defaults = __webpack_require__("./node_modules/axios/lib/defaults.js");

/**
 * Create an instance of Axios
 *
 * @param {Object} defaultConfig The default config for the instance
 * @return {Axios} A new instance of Axios
 */
function createInstance(defaultConfig) {
  var context = new Axios(defaultConfig);
  var instance = bind(Axios.prototype.request, context);

  // Copy axios.prototype to instance
  utils.extend(instance, Axios.prototype, context);

  // Copy context to instance
  utils.extend(instance, context);

  return instance;
}

// Create the default instance to be exported
var axios = createInstance(defaults);

// Expose Axios class to allow class inheritance
axios.Axios = Axios;

// Factory for creating new instances
axios.create = function create(instanceConfig) {
  return createInstance(utils.merge(defaults, instanceConfig));
};

// Expose Cancel & CancelToken
axios.Cancel = __webpack_require__("./node_modules/axios/lib/cancel/Cancel.js");
axios.CancelToken = __webpack_require__("./node_modules/axios/lib/cancel/CancelToken.js");
axios.isCancel = __webpack_require__("./node_modules/axios/lib/cancel/isCancel.js");

// Expose all/spread
axios.all = function all(promises) {
  return Promise.all(promises);
};
axios.spread = __webpack_require__("./node_modules/axios/lib/helpers/spread.js");

module.exports = axios;

// Allow use of default import syntax in TypeScript
module.exports.default = axios;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/Cancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * A `Cancel` is an object that is thrown when an operation is canceled.
 *
 * @class
 * @param {string=} message The message.
 */

function Cancel(message) {
  this.message = message;
}

Cancel.prototype.toString = function toString() {
  return 'Cancel' + (this.message ? ': ' + this.message : '');
};

Cancel.prototype.__CANCEL__ = true;

module.exports = Cancel;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/CancelToken.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var Cancel = __webpack_require__("./node_modules/axios/lib/cancel/Cancel.js");

/**
 * A `CancelToken` is an object that can be used to request cancellation of an operation.
 *
 * @class
 * @param {Function} executor The executor function.
 */
function CancelToken(executor) {
  if (typeof executor !== 'function') {
    throw new TypeError('executor must be a function.');
  }

  var resolvePromise;
  this.promise = new Promise(function promiseExecutor(resolve) {
    resolvePromise = resolve;
  });

  var token = this;
  executor(function cancel(message) {
    if (token.reason) {
      // Cancellation has already been requested
      return;
    }

    token.reason = new Cancel(message);
    resolvePromise(token.reason);
  });
}

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
CancelToken.prototype.throwIfRequested = function throwIfRequested() {
  if (this.reason) {
    throw this.reason;
  }
};

/**
 * Returns an object that contains a new `CancelToken` and a function that, when called,
 * cancels the `CancelToken`.
 */
CancelToken.source = function source() {
  var cancel;
  var token = new CancelToken(function executor(c) {
    cancel = c;
  });
  return {
    token: token,
    cancel: cancel
  };
};

module.exports = CancelToken;

/***/ }),

/***/ "./node_modules/axios/lib/cancel/isCancel.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function isCancel(value) {
  return !!(value && value.__CANCEL__);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/Axios.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var defaults = __webpack_require__("./node_modules/axios/lib/defaults.js");
var utils = __webpack_require__("./node_modules/axios/lib/utils.js");
var InterceptorManager = __webpack_require__("./node_modules/axios/lib/core/InterceptorManager.js");
var dispatchRequest = __webpack_require__("./node_modules/axios/lib/core/dispatchRequest.js");

/**
 * Create a new instance of Axios
 *
 * @param {Object} instanceConfig The default config for the instance
 */
function Axios(instanceConfig) {
  this.defaults = instanceConfig;
  this.interceptors = {
    request: new InterceptorManager(),
    response: new InterceptorManager()
  };
}

/**
 * Dispatch a request
 *
 * @param {Object} config The config specific for this request (merged with this.defaults)
 */
Axios.prototype.request = function request(config) {
  /*eslint no-param-reassign:0*/
  // Allow for axios('example/url'[, config]) a la fetch API
  if (typeof config === 'string') {
    config = utils.merge({
      url: arguments[0]
    }, arguments[1]);
  }

  config = utils.merge(defaults, this.defaults, { method: 'get' }, config);
  config.method = config.method.toLowerCase();

  // Hook up interceptors middleware
  var chain = [dispatchRequest, undefined];
  var promise = Promise.resolve(config);

  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {
    chain.unshift(interceptor.fulfilled, interceptor.rejected);
  });

  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {
    chain.push(interceptor.fulfilled, interceptor.rejected);
  });

  while (chain.length) {
    promise = promise.then(chain.shift(), chain.shift());
  }

  return promise;
};

// Provide aliases for supported request methods
utils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url
    }));
  };
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  /*eslint func-names:0*/
  Axios.prototype[method] = function (url, data, config) {
    return this.request(utils.merge(config || {}, {
      method: method,
      url: url,
      data: data
    }));
  };
});

module.exports = Axios;

/***/ }),

/***/ "./node_modules/axios/lib/core/InterceptorManager.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

function InterceptorManager() {
  this.handlers = [];
}

/**
 * Add a new interceptor to the stack
 *
 * @param {Function} fulfilled The function to handle `then` for a `Promise`
 * @param {Function} rejected The function to handle `reject` for a `Promise`
 *
 * @return {Number} An ID used to remove interceptor later
 */
InterceptorManager.prototype.use = function use(fulfilled, rejected) {
  this.handlers.push({
    fulfilled: fulfilled,
    rejected: rejected
  });
  return this.handlers.length - 1;
};

/**
 * Remove an interceptor from the stack
 *
 * @param {Number} id The ID that was returned by `use`
 */
InterceptorManager.prototype.eject = function eject(id) {
  if (this.handlers[id]) {
    this.handlers[id] = null;
  }
};

/**
 * Iterate over all the registered interceptors
 *
 * This method is particularly useful for skipping over any
 * interceptors that may have become `null` calling `eject`.
 *
 * @param {Function} fn The function to call for each interceptor
 */
InterceptorManager.prototype.forEach = function forEach(fn) {
  utils.forEach(this.handlers, function forEachHandler(h) {
    if (h !== null) {
      fn(h);
    }
  });
};

module.exports = InterceptorManager;

/***/ }),

/***/ "./node_modules/axios/lib/core/createError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var enhanceError = __webpack_require__("./node_modules/axios/lib/core/enhanceError.js");

/**
 * Create an Error with the specified message, config, error code, request and response.
 *
 * @param {string} message The error message.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The created error.
 */
module.exports = function createError(message, config, code, request, response) {
  var error = new Error(message);
  return enhanceError(error, config, code, request, response);
};

/***/ }),

/***/ "./node_modules/axios/lib/core/dispatchRequest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");
var transformData = __webpack_require__("./node_modules/axios/lib/core/transformData.js");
var isCancel = __webpack_require__("./node_modules/axios/lib/cancel/isCancel.js");
var defaults = __webpack_require__("./node_modules/axios/lib/defaults.js");
var isAbsoluteURL = __webpack_require__("./node_modules/axios/lib/helpers/isAbsoluteURL.js");
var combineURLs = __webpack_require__("./node_modules/axios/lib/helpers/combineURLs.js");

/**
 * Throws a `Cancel` if cancellation has been requested.
 */
function throwIfCancellationRequested(config) {
  if (config.cancelToken) {
    config.cancelToken.throwIfRequested();
  }
}

/**
 * Dispatch a request to the server using the configured adapter.
 *
 * @param {object} config The config that is to be used for the request
 * @returns {Promise} The Promise to be fulfilled
 */
module.exports = function dispatchRequest(config) {
  throwIfCancellationRequested(config);

  // Support baseURL config
  if (config.baseURL && !isAbsoluteURL(config.url)) {
    config.url = combineURLs(config.baseURL, config.url);
  }

  // Ensure headers exist
  config.headers = config.headers || {};

  // Transform request data
  config.data = transformData(config.data, config.headers, config.transformRequest);

  // Flatten headers
  config.headers = utils.merge(config.headers.common || {}, config.headers[config.method] || {}, config.headers || {});

  utils.forEach(['delete', 'get', 'head', 'post', 'put', 'patch', 'common'], function cleanHeaderConfig(method) {
    delete config.headers[method];
  });

  var adapter = config.adapter || defaults.adapter;

  return adapter(config).then(function onAdapterResolution(response) {
    throwIfCancellationRequested(config);

    // Transform response data
    response.data = transformData(response.data, response.headers, config.transformResponse);

    return response;
  }, function onAdapterRejection(reason) {
    if (!isCancel(reason)) {
      throwIfCancellationRequested(config);

      // Transform response data
      if (reason && reason.response) {
        reason.response.data = transformData(reason.response.data, reason.response.headers, config.transformResponse);
      }
    }

    return Promise.reject(reason);
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/core/enhanceError.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Update an Error with the specified config, error code, and response.
 *
 * @param {Error} error The error to update.
 * @param {Object} config The config.
 * @param {string} [code] The error code (for example, 'ECONNABORTED').
 * @param {Object} [request] The request.
 * @param {Object} [response] The response.
 * @returns {Error} The error.
 */

module.exports = function enhanceError(error, config, code, request, response) {
  error.config = config;
  if (code) {
    error.code = code;
  }
  error.request = request;
  error.response = response;
  return error;
};

/***/ }),

/***/ "./node_modules/axios/lib/core/settle.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var createError = __webpack_require__("./node_modules/axios/lib/core/createError.js");

/**
 * Resolve or reject a Promise based on response status.
 *
 * @param {Function} resolve A function that resolves the promise.
 * @param {Function} reject A function that rejects the promise.
 * @param {object} response The response.
 */
module.exports = function settle(resolve, reject, response) {
  var validateStatus = response.config.validateStatus;
  // Note: status is not exposed by XDomainRequest
  if (!response.status || !validateStatus || validateStatus(response.status)) {
    resolve(response);
  } else {
    reject(createError('Request failed with status code ' + response.status, response.config, null, response.request, response));
  }
};

/***/ }),

/***/ "./node_modules/axios/lib/core/transformData.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

/**
 * Transform the data for a request or a response
 *
 * @param {Object|String} data The data to be transformed
 * @param {Array} headers The headers for the request or response
 * @param {Array|Function} fns A single function or Array of functions
 * @returns {*} The resulting transformed data
 */
module.exports = function transformData(data, headers, fns) {
  /*eslint no-param-reassign:0*/
  utils.forEach(fns, function transform(fn) {
    data = fn(data, headers);
  });

  return data;
};

/***/ }),

/***/ "./node_modules/axios/lib/defaults.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(process) {

var utils = __webpack_require__("./node_modules/axios/lib/utils.js");
var normalizeHeaderName = __webpack_require__("./node_modules/axios/lib/helpers/normalizeHeaderName.js");

var DEFAULT_CONTENT_TYPE = {
  'Content-Type': 'application/x-www-form-urlencoded'
};

function setContentTypeIfUnset(headers, value) {
  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {
    headers['Content-Type'] = value;
  }
}

function getDefaultAdapter() {
  var adapter;
  if (typeof XMLHttpRequest !== 'undefined') {
    // For browsers use XHR adapter
    adapter = __webpack_require__("./node_modules/axios/lib/adapters/xhr.js");
  } else if (typeof process !== 'undefined') {
    // For node use HTTP adapter
    adapter = __webpack_require__("./node_modules/axios/lib/adapters/xhr.js");
  }
  return adapter;
}

var defaults = {
  adapter: getDefaultAdapter(),

  transformRequest: [function transformRequest(data, headers) {
    normalizeHeaderName(headers, 'Content-Type');
    if (utils.isFormData(data) || utils.isArrayBuffer(data) || utils.isBuffer(data) || utils.isStream(data) || utils.isFile(data) || utils.isBlob(data)) {
      return data;
    }
    if (utils.isArrayBufferView(data)) {
      return data.buffer;
    }
    if (utils.isURLSearchParams(data)) {
      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');
      return data.toString();
    }
    if (utils.isObject(data)) {
      setContentTypeIfUnset(headers, 'application/json;charset=utf-8');
      return JSON.stringify(data);
    }
    return data;
  }],

  transformResponse: [function transformResponse(data) {
    /*eslint no-param-reassign:0*/
    if (typeof data === 'string') {
      try {
        data = JSON.parse(data);
      } catch (e) {/* Ignore */}
    }
    return data;
  }],

  timeout: 0,

  xsrfCookieName: 'XSRF-TOKEN',
  xsrfHeaderName: 'X-XSRF-TOKEN',

  maxContentLength: -1,

  validateStatus: function validateStatus(status) {
    return status >= 200 && status < 300;
  }
};

defaults.headers = {
  common: {
    'Accept': 'application/json, text/plain, */*'
  }
};

utils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {
  defaults.headers[method] = {};
});

utils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {
  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);
});

module.exports = defaults;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/axios/lib/helpers/bind.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


module.exports = function bind(fn, thisArg) {
  return function wrap() {
    var args = new Array(arguments.length);
    for (var i = 0; i < args.length; i++) {
      args[i] = arguments[i];
    }
    return fn.apply(thisArg, args);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/btoa.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// btoa polyfill for IE<10 courtesy https://github.com/davidchambers/Base64.js

var chars = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';

function E() {
  this.message = 'String contains an invalid character';
}
E.prototype = new Error();
E.prototype.code = 5;
E.prototype.name = 'InvalidCharacterError';

function btoa(input) {
  var str = String(input);
  var output = '';
  for (
  // initialize result and counter
  var block, charCode, idx = 0, map = chars;
  // if the next str index does not exist:
  //   change the mapping table to "="
  //   check if d has no fractional digits
  str.charAt(idx | 0) || (map = '=', idx % 1);
  // "8 - idx % 1 * 8" generates the sequence 2, 4, 6, 8
  output += map.charAt(63 & block >> 8 - idx % 1 * 8)) {
    charCode = str.charCodeAt(idx += 3 / 4);
    if (charCode > 0xFF) {
      throw new E();
    }
    block = block << 8 | charCode;
  }
  return output;
}

module.exports = btoa;

/***/ }),

/***/ "./node_modules/axios/lib/helpers/buildURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

function encode(val) {
  return encodeURIComponent(val).replace(/%40/gi, '@').replace(/%3A/gi, ':').replace(/%24/g, '$').replace(/%2C/gi, ',').replace(/%20/g, '+').replace(/%5B/gi, '[').replace(/%5D/gi, ']');
}

/**
 * Build a URL by appending params to the end
 *
 * @param {string} url The base of the url (e.g., http://www.google.com)
 * @param {object} [params] The params to be appended
 * @returns {string} The formatted url
 */
module.exports = function buildURL(url, params, paramsSerializer) {
  /*eslint no-param-reassign:0*/
  if (!params) {
    return url;
  }

  var serializedParams;
  if (paramsSerializer) {
    serializedParams = paramsSerializer(params);
  } else if (utils.isURLSearchParams(params)) {
    serializedParams = params.toString();
  } else {
    var parts = [];

    utils.forEach(params, function serialize(val, key) {
      if (val === null || typeof val === 'undefined') {
        return;
      }

      if (utils.isArray(val)) {
        key = key + '[]';
      }

      if (!utils.isArray(val)) {
        val = [val];
      }

      utils.forEach(val, function parseValue(v) {
        if (utils.isDate(v)) {
          v = v.toISOString();
        } else if (utils.isObject(v)) {
          v = JSON.stringify(v);
        }
        parts.push(encode(key) + '=' + encode(v));
      });
    });

    serializedParams = parts.join('&');
  }

  if (serializedParams) {
    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;
  }

  return url;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/combineURLs.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Creates a new URL by combining the specified URLs
 *
 * @param {string} baseURL The base URL
 * @param {string} relativeURL The relative URL
 * @returns {string} The combined URL
 */

module.exports = function combineURLs(baseURL, relativeURL) {
  return relativeURL ? baseURL.replace(/\/+$/, '') + '/' + relativeURL.replace(/^\/+/, '') : baseURL;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/cookies.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs support document.cookie
function standardBrowserEnv() {
  return {
    write: function write(name, value, expires, path, domain, secure) {
      var cookie = [];
      cookie.push(name + '=' + encodeURIComponent(value));

      if (utils.isNumber(expires)) {
        cookie.push('expires=' + new Date(expires).toGMTString());
      }

      if (utils.isString(path)) {
        cookie.push('path=' + path);
      }

      if (utils.isString(domain)) {
        cookie.push('domain=' + domain);
      }

      if (secure === true) {
        cookie.push('secure');
      }

      document.cookie = cookie.join('; ');
    },

    read: function read(name) {
      var match = document.cookie.match(new RegExp('(^|;\\s*)(' + name + ')=([^;]*)'));
      return match ? decodeURIComponent(match[3]) : null;
    },

    remove: function remove(name) {
      this.write(name, '', Date.now() - 86400000);
    }
  };
}() :

// Non standard browser env (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return {
    write: function write() {},
    read: function read() {
      return null;
    },
    remove: function remove() {}
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isAbsoluteURL.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Determines whether the specified URL is absolute
 *
 * @param {string} url The URL to test
 * @returns {boolean} True if the specified URL is absolute, otherwise false
 */

module.exports = function isAbsoluteURL(url) {
  // A URL is considered absolute if it begins with "<scheme>://" or "//" (protocol-relative URL).
  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed
  // by any combination of letters, digits, plus, period, or hyphen.
  return (/^([a-z][a-z\d\+\-\.]*:)?\/\//i.test(url)
  );
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/isURLSameOrigin.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

module.exports = utils.isStandardBrowserEnv() ?

// Standard browser envs have full support of the APIs needed to test
// whether the request URL is of the same origin as current location.
function standardBrowserEnv() {
  var msie = /(msie|trident)/i.test(navigator.userAgent);
  var urlParsingNode = document.createElement('a');
  var originURL;

  /**
  * Parse a URL to discover it's components
  *
  * @param {String} url The URL to be parsed
  * @returns {Object}
  */
  function resolveURL(url) {
    var href = url;

    if (msie) {
      // IE needs attribute set twice to normalize properties
      urlParsingNode.setAttribute('href', href);
      href = urlParsingNode.href;
    }

    urlParsingNode.setAttribute('href', href);

    // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils
    return {
      href: urlParsingNode.href,
      protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',
      host: urlParsingNode.host,
      search: urlParsingNode.search ? urlParsingNode.search.replace(/^\?/, '') : '',
      hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',
      hostname: urlParsingNode.hostname,
      port: urlParsingNode.port,
      pathname: urlParsingNode.pathname.charAt(0) === '/' ? urlParsingNode.pathname : '/' + urlParsingNode.pathname
    };
  }

  originURL = resolveURL(window.location.href);

  /**
  * Determine if a URL shares the same origin as the current location
  *
  * @param {String} requestURL The URL to test
  * @returns {boolean} True if URL shares the same origin, otherwise false
  */
  return function isURLSameOrigin(requestURL) {
    var parsed = utils.isString(requestURL) ? resolveURL(requestURL) : requestURL;
    return parsed.protocol === originURL.protocol && parsed.host === originURL.host;
  };
}() :

// Non standard browser envs (web workers, react-native) lack needed support.
function nonStandardBrowserEnv() {
  return function isURLSameOrigin() {
    return true;
  };
}();

/***/ }),

/***/ "./node_modules/axios/lib/helpers/normalizeHeaderName.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

module.exports = function normalizeHeaderName(headers, normalizedName) {
  utils.forEach(headers, function processHeader(value, name) {
    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {
      headers[normalizedName] = value;
      delete headers[name];
    }
  });
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/parseHeaders.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var utils = __webpack_require__("./node_modules/axios/lib/utils.js");

// Headers whose duplicates are ignored by node
// c.f. https://nodejs.org/api/http.html#http_message_headers
var ignoreDuplicateOf = ['age', 'authorization', 'content-length', 'content-type', 'etag', 'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since', 'last-modified', 'location', 'max-forwards', 'proxy-authorization', 'referer', 'retry-after', 'user-agent'];

/**
 * Parse headers into an object
 *
 * ```
 * Date: Wed, 27 Aug 2014 08:58:49 GMT
 * Content-Type: application/json
 * Connection: keep-alive
 * Transfer-Encoding: chunked
 * ```
 *
 * @param {String} headers Headers needing to be parsed
 * @returns {Object} Headers parsed into an object
 */
module.exports = function parseHeaders(headers) {
  var parsed = {};
  var key;
  var val;
  var i;

  if (!headers) {
    return parsed;
  }

  utils.forEach(headers.split('\n'), function parser(line) {
    i = line.indexOf(':');
    key = utils.trim(line.substr(0, i)).toLowerCase();
    val = utils.trim(line.substr(i + 1));

    if (key) {
      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {
        return;
      }
      if (key === 'set-cookie') {
        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);
      } else {
        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;
      }
    }
  });

  return parsed;
};

/***/ }),

/***/ "./node_modules/axios/lib/helpers/spread.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Syntactic sugar for invoking a function and expanding an array for arguments.
 *
 * Common use case would be to use `Function.prototype.apply`.
 *
 *  ```js
 *  function f(x, y, z) {}
 *  var args = [1, 2, 3];
 *  f.apply(null, args);
 *  ```
 *
 * With `spread` this example can be re-written.
 *
 *  ```js
 *  spread(function(x, y, z) {})([1, 2, 3]);
 *  ```
 *
 * @param {Function} callback
 * @returns {Function}
 */

module.exports = function spread(callback) {
  return function wrap(arr) {
    return callback.apply(null, arr);
  };
};

/***/ }),

/***/ "./node_modules/axios/lib/utils.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var bind = __webpack_require__("./node_modules/axios/lib/helpers/bind.js");
var isBuffer = __webpack_require__("./node_modules/is-buffer/index.js");

/*global toString:true*/

// utils is a library of generic helper functions non-specific to axios

var toString = Object.prototype.toString;

/**
 * Determine if a value is an Array
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Array, otherwise false
 */
function isArray(val) {
  return toString.call(val) === '[object Array]';
}

/**
 * Determine if a value is an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an ArrayBuffer, otherwise false
 */
function isArrayBuffer(val) {
  return toString.call(val) === '[object ArrayBuffer]';
}

/**
 * Determine if a value is a FormData
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an FormData, otherwise false
 */
function isFormData(val) {
  return typeof FormData !== 'undefined' && val instanceof FormData;
}

/**
 * Determine if a value is a view on an ArrayBuffer
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false
 */
function isArrayBufferView(val) {
  var result;
  if (typeof ArrayBuffer !== 'undefined' && ArrayBuffer.isView) {
    result = ArrayBuffer.isView(val);
  } else {
    result = val && val.buffer && val.buffer instanceof ArrayBuffer;
  }
  return result;
}

/**
 * Determine if a value is a String
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a String, otherwise false
 */
function isString(val) {
  return typeof val === 'string';
}

/**
 * Determine if a value is a Number
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Number, otherwise false
 */
function isNumber(val) {
  return typeof val === 'number';
}

/**
 * Determine if a value is undefined
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if the value is undefined, otherwise false
 */
function isUndefined(val) {
  return typeof val === 'undefined';
}

/**
 * Determine if a value is an Object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is an Object, otherwise false
 */
function isObject(val) {
  return val !== null && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object';
}

/**
 * Determine if a value is a Date
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Date, otherwise false
 */
function isDate(val) {
  return toString.call(val) === '[object Date]';
}

/**
 * Determine if a value is a File
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a File, otherwise false
 */
function isFile(val) {
  return toString.call(val) === '[object File]';
}

/**
 * Determine if a value is a Blob
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Blob, otherwise false
 */
function isBlob(val) {
  return toString.call(val) === '[object Blob]';
}

/**
 * Determine if a value is a Function
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Function, otherwise false
 */
function isFunction(val) {
  return toString.call(val) === '[object Function]';
}

/**
 * Determine if a value is a Stream
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a Stream, otherwise false
 */
function isStream(val) {
  return isObject(val) && isFunction(val.pipe);
}

/**
 * Determine if a value is a URLSearchParams object
 *
 * @param {Object} val The value to test
 * @returns {boolean} True if value is a URLSearchParams object, otherwise false
 */
function isURLSearchParams(val) {
  return typeof URLSearchParams !== 'undefined' && val instanceof URLSearchParams;
}

/**
 * Trim excess whitespace off the beginning and end of a string
 *
 * @param {String} str The String to trim
 * @returns {String} The String freed of excess whitespace
 */
function trim(str) {
  return str.replace(/^\s*/, '').replace(/\s*$/, '');
}

/**
 * Determine if we're running in a standard browser environment
 *
 * This allows axios to run in a web worker, and react-native.
 * Both environments support XMLHttpRequest, but not fully standard globals.
 *
 * web workers:
 *  typeof window -> undefined
 *  typeof document -> undefined
 *
 * react-native:
 *  navigator.product -> 'ReactNative'
 */
function isStandardBrowserEnv() {
  if (typeof navigator !== 'undefined' && navigator.product === 'ReactNative') {
    return false;
  }
  return typeof window !== 'undefined' && typeof document !== 'undefined';
}

/**
 * Iterate over an Array or an Object invoking a function for each item.
 *
 * If `obj` is an Array callback will be called passing
 * the value, index, and complete array for each item.
 *
 * If 'obj' is an Object callback will be called passing
 * the value, key, and complete object for each property.
 *
 * @param {Object|Array} obj The object to iterate
 * @param {Function} fn The callback to invoke for each item
 */
function forEach(obj, fn) {
  // Don't bother if no value provided
  if (obj === null || typeof obj === 'undefined') {
    return;
  }

  // Force an array if not already something iterable
  if ((typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) !== 'object') {
    /*eslint no-param-reassign:0*/
    obj = [obj];
  }

  if (isArray(obj)) {
    // Iterate over array values
    for (var i = 0, l = obj.length; i < l; i++) {
      fn.call(null, obj[i], i, obj);
    }
  } else {
    // Iterate over object keys
    for (var key in obj) {
      if (Object.prototype.hasOwnProperty.call(obj, key)) {
        fn.call(null, obj[key], key, obj);
      }
    }
  }
}

/**
 * Accepts varargs expecting each argument to be an object, then
 * immutably merges the properties of each object and returns result.
 *
 * When multiple objects contain the same key the later object in
 * the arguments list will take precedence.
 *
 * Example:
 *
 * ```js
 * var result = merge({foo: 123}, {foo: 456});
 * console.log(result.foo); // outputs 456
 * ```
 *
 * @param {Object} obj1 Object to merge
 * @returns {Object} Result of all merge properties
 */
function merge() /* obj1, obj2, obj3, ... */{
  var result = {};
  function assignValue(val, key) {
    if (_typeof(result[key]) === 'object' && (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object') {
      result[key] = merge(result[key], val);
    } else {
      result[key] = val;
    }
  }

  for (var i = 0, l = arguments.length; i < l; i++) {
    forEach(arguments[i], assignValue);
  }
  return result;
}

/**
 * Extends object a by mutably adding to it the properties of object b.
 *
 * @param {Object} a The object to be extended
 * @param {Object} b The object to copy properties from
 * @param {Object} thisArg The object to bind function to
 * @return {Object} The resulting value of object a
 */
function extend(a, b, thisArg) {
  forEach(b, function assignValue(val, key) {
    if (thisArg && typeof val === 'function') {
      a[key] = bind(val, thisArg);
    } else {
      a[key] = val;
    }
  });
  return a;
}

module.exports = {
  isArray: isArray,
  isArrayBuffer: isArrayBuffer,
  isBuffer: isBuffer,
  isFormData: isFormData,
  isArrayBufferView: isArrayBufferView,
  isString: isString,
  isNumber: isNumber,
  isObject: isObject,
  isUndefined: isUndefined,
  isDate: isDate,
  isFile: isFile,
  isBlob: isBlob,
  isFunction: isFunction,
  isStream: isStream,
  isURLSearchParams: isURLSearchParams,
  isStandardBrowserEnv: isStandardBrowserEnv,
  forEach: forEach,
  merge: merge,
  extend: extend,
  trim: trim
};

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

var icons = {};

/* harmony default export */ __webpack_exports__["default"] = ({
  name: 'icon',
  props: {
    name: {
      type: String,
      validator: function validator(val) {
        if (val) {
          if (!(val in icons)) {
            console.warn('Invalid prop: prop "name" is referring to an unregistered icon "' + val + '".' + '\nPlesase make sure you have imported this icon before using it.');
            return false;
          }
          return true;
        }
        console.warn('Invalid prop: prop "name" is required.');
        return false;
      }
    },
    scale: [Number, String],
    spin: Boolean,
    inverse: Boolean,
    pulse: Boolean,
    flip: {
      validator: function validator(val) {
        return val === 'horizontal' || val === 'vertical';
      }
    },
    label: String
  },
  data: function data() {
    return {
      x: false,
      y: false,
      childrenWidth: 0,
      childrenHeight: 0,
      outerScale: 1
    };
  },

  computed: {
    normalizedScale: function normalizedScale() {
      var scale = this.scale;
      scale = typeof scale === 'undefined' ? 1 : Number(scale);
      if (isNaN(scale) || scale <= 0) {
        console.warn('Invalid prop: prop "scale" should be a number over 0.', this);
        return this.outerScale;
      }
      return scale * this.outerScale;
    },
    klass: function klass() {
      return {
        'fa-icon': true,
        'fa-spin': this.spin,
        'fa-flip-horizontal': this.flip === 'horizontal',
        'fa-flip-vertical': this.flip === 'vertical',
        'fa-inverse': this.inverse,
        'fa-pulse': this.pulse
      };
    },
    icon: function icon() {
      if (this.name) {
        return icons[this.name];
      }
      return null;
    },
    box: function box() {
      if (this.icon) {
        return '0 0 ' + this.icon.width + ' ' + this.icon.height;
      }
      return '0 0 ' + this.width + ' ' + this.height;
    },
    ratio: function ratio() {
      if (!this.icon) {
        return 1;
      }
      var _icon = this.icon,
          width = _icon.width,
          height = _icon.height;

      return Math.max(width, height) / 16;
    },
    width: function width() {
      return this.childrenWidth || this.icon && this.icon.width / this.ratio * this.normalizedScale || 0;
    },
    height: function height() {
      return this.childrenHeight || this.icon && this.icon.height / this.ratio * this.normalizedScale || 0;
    },
    style: function style() {
      if (this.normalizedScale === 1) {
        return false;
      }
      return {
        fontSize: this.normalizedScale + 'em'
      };
    },
    raw: function raw() {
      // generate unique id for each icon's SVG element with ID
      if (!this.icon || !this.icon.raw) {
        return null;
      }
      var raw = this.icon.raw;
      var ids = {};
      raw = raw.replace(/\s(?:xml:)?id=["']?([^"')\s]+)/g, function (match, id) {
        var uniqueId = getId();
        ids[id] = uniqueId;
        return ' id="' + uniqueId + '"';
      });
      raw = raw.replace(/#(?:([^'")\s]+)|xpointer\(id\((['"]?)([^')]+)\2\)\))/g, function (match, rawId, _, pointerId) {
        var id = rawId || pointerId;
        if (!id || !ids[id]) {
          return match;
        }

        return '#' + ids[id];
      });

      return raw;
    }
  },
  mounted: function mounted() {
    var _this = this;

    if (this.icon) {
      return;
    }
    this.$children.forEach(function (child) {
      child.outerScale = _this.normalizedScale;
    });
    var width = 0;
    var height = 0;
    this.$children.forEach(function (child) {
      width = Math.max(width, child.width);
      height = Math.max(height, child.height);
    });
    this.childrenWidth = width;
    this.childrenHeight = height;
    this.$children.forEach(function (child) {
      child.x = (width - child.width) / 2;
      child.y = (height - child.height) / 2;
    });
  },
  register: function register(data) {
    for (var name in data) {
      var icon = data[name];

      if (!icon.paths) {
        icon.paths = [];
      }
      if (icon.d) {
        icon.paths.push({ d: icon.d });
      }

      if (!icon.polygons) {
        icon.polygons = [];
      }
      if (icon.points) {
        icon.polygons.push({ points: icon.points });
      }

      icons[name] = icon;
    }
  },

  icons: icons
});

var cursor = 0xd4937;
function getId() {
  return 'fa-' + (cursor++).toString(16);
}

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//

/* harmony default export */ __webpack_exports__["default"] = ({
    props: {
        title: '',
        body: '',
        icon: {
            default: true
        },
        type: { default: 'info' },
        duration: null
    },

    data: function data() {
        return {
            notif_group: [],
            self_title: this.title,
            self_body: this.body,
            self_type: this.type,
            self_icon: Boolean(this.icon),
            self_duration: this.duration,
            self_show: false
        };
    },
    created: function created() {
        var _this = this;

        this.checkProp();

        EventHub.listen('showNotif', function (data) {
            _this.collectData(data);
        });
    },


    methods: {
        checkForGroup: function checkForGroup() {
            return this.notif_group.length > 1 && this.notif_group.filter(function (item) {
                return item.show == true;
            }).length > 1;
        },
        closeAll: function closeAll() {
            this.notif_group.map(function (item) {
                item.show = false;
                item.duration = null;
            });
        },
        checkProp: function checkProp() {
            var _this2 = this;

            if (this.self_title) {
                this.self_show = true;
            }

            if (this.self_duration !== undefined) {
                setTimeout(function () {
                    _this2.self_show = false;
                }, this.self_duration * 1000);
            }
        },
        collectData: function collectData(data) {
            this.notif_group.push({
                title: data.title,
                body: data.body,
                type: data.type,
                icon: data.icon == null ? true : false,
                duration: data.duration,
                onClose: data.onClose,
                show: true
            });
        },
        IsVisible: function IsVisible(index) {
            var _this3 = this;

            var dur = this.notif_group[index].duration;

            if (dur != undefined || dur != null) {
                setTimeout(function () {
                    _this3.closeNotif(index);
                }, dur * 1000);
            }

            return this.notif_group[index].show;
        },
        closeNotif: function closeNotif(index) {
            this.notif_group[index].show = false;

            if (typeof this.notif_group[index].onClose !== 'undefined' && typeof this.notif_group[index].onClose === 'function') {
                this.notif_group[index].onClose();
            }
        },
        classObj: function classObj(type) {
            return 'notification has-shadow is-' + type;
        },
        getIcon: function getIcon(type) {
            switch (type) {
                case 'primary':
                    return 'track_changes';
                case 'success':
                    return 'check_circle';
                case 'info':
                    return 'live_help';
                case 'warning':
                    return 'power_settings_new';
                case 'danger':
                    return 'add_alert';
                default:
                    return 'error';
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Main/container.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__forms__ = __webpack_require__("./resources/assets/js/Main/forms.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__forms___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__forms__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Tabs_default__ = __webpack_require__("./resources/assets/js/Tabs/default.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__Tabs_default___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__Tabs_default__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Tabs_vendor__ = __webpack_require__("./resources/assets/js/Tabs/vendor.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_2__Tabs_vendor___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_2__Tabs_vendor__);





/* harmony default export */ __webpack_exports__["default"] = ({
    components: { DefaultTab: __WEBPACK_IMPORTED_MODULE_1__Tabs_default___default.a, VendorTab: __WEBPACK_IMPORTED_MODULE_2__Tabs_vendor___default.a },
    name: 'lingo',
    mixins: [__WEBPACK_IMPORTED_MODULE_0__forms___default.a],
    props: ['scanForMissingRoute', 'addNewLocaleRoute', 'addNewFileRoute', 'addNewVendorRoute', 'filesRoute', 'selectedFileDataRoute', 'deleteFileRoute', 'deleteLocaleRoute', 'saveFileRoute', 'lingoTrans'],
    data: function data() {
        return {
            activeTab: 'default-tab',
            new_locale: null,
            new_file: null,
            new_vendor: null,
            localesList: [],
            filesList: [],
            dirsList: [],
            selectedDirName: '',
            selectedFileName: '',
            selectedKeyFormat: '',
            copyKeyFormat: ['trans(\'value\')', '__(\'value\')', '{!! trans(\'value\') !!}', '{!! __(\'value\') !!}', '{{ trans(\'value\') }}', '{{ __(\'value\') }}', '@lang(\'value\')']
        };
    },

    computed: {
        localeExist: function localeExist() {
            return this.localesList && this.localesList.includes(this.new_locale) || false;
        },
        fileExist: function fileExist() {
            return this.filesList && this.filesList.includes(this.new_file) || false;
        },
        dirExist: function dirExist() {
            return this.dirsList && this.dirsList.includes(this.new_vendor) || false;
        }
    },
    beforeMount: function beforeMount() {
        this.preVisited();
    },

    methods: {
        // local-storage
        preVisited: function preVisited() {
            var ls = this.$ls.get('lingo');

            if (ls) {
                this.activeTab = ls.tab;
                this.selectedKeyFormat = ls.format;

                setTimeout(function () {
                    EventHub.fire('ls-dir', ls.dir);
                    EventHub.fire('ls-file', {
                        tab: ls.tab,
                        val: ls.file
                    });
                }, 50);
            } else {
                this.$ls.set('lingo', {
                    tab: this.activeTab,
                    dir: this.selectedDirName,
                    file: this.selectedFileName,
                    format: this.selectedKeyFormat
                });
            }
        },


        // tabs
        activeTabIs: function activeTabIs(tab) {
            return this.activeTab == tab;
        },
        toggleTab: function toggleTab(tab) {
            this.activeTab = tab;
        },


        // ph
        placeHolder: function placeHolder(val) {
            var all = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : '';

            return this.vendorCheck() ? 'lang/vendor/' + this.selectedDirName + '/' + all + val : 'lang/' + all + val;
        },
        vendorPH: function vendorPH(val) {
            return 'lang/vendor/' + val;
        },


        // vendor
        vendorCheck: function vendorCheck() {
            return this.activeTabIs('vendor-tab') && this.selectedDirName;
        },
        newVendor: function newVendor() {
            return this.vendorCheck() && this.filesList.length == 0;
        },


        // utils
        updateLs: function updateLs(obj) {
            var oldLs = this.$ls.get('lingo', {});

            Object.assign(oldLs, obj);
            this.$ls.set('lingo', oldLs);
        },
        resetAll: function resetAll(items) {
            var _this = this;

            items.forEach(function (e) {
                _this[e] = '';
            });
        },
        trans: function trans(key) {
            return this.lingoTrans[key];
        },


        // notifs
        showNotif: function showNotif(msg) {
            var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'success';


            var title = void 0;
            var duration = null;

            switch (s) {
                case 'black':
                case 'danger':
                    title = 'Error';
                    break;
                case 'warning':
                    title = 'Warning';
                    duration = 2;
                    break;
                default:
                    title = 'Success';
                    duration = 3;
            }

            EventHub.fire('showNotif', {
                title: title,
                body: msg,
                type: s,
                duration: duration
            });
        },
        failedAjax: function failedAjax() {
            this.showNotif(this.trans('ajax_error'), 'black');
        },
        missingVal: function missingVal() {
            var msg = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : null;

            this.showNotif(msg || this.trans('no_val'), 'warning');
        }
    },
    watch: {
        activeTab: function activeTab(val) {
            this.updateLs({ tab: val });
        },
        selectedDirName: function selectedDirName(val) {
            this.updateLs({ dir: val });
        },
        selectedFileName: function selectedFileName(val) {
            this.updateLs({ file: val });
        },
        selectedKeyFormat: function selectedKeyFormat(val) {
            if (val == 'clear') {
                this.selectedKeyFormat = '';
            }

            this.updateLs({ format: val });
        }
    },
    render: function render() {}
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/default.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ops__ = __webpack_require__("./resources/assets/js/Tabs/ops.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ops___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__ops__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shared_content__ = __webpack_require__("./resources/assets/js/Tabs/shared/content.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shared_content___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shared_content__);
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
    components: { SharedContent: __WEBPACK_IMPORTED_MODULE_1__shared_content___default.a },
    name: 'default-tab',
    mixins: [__WEBPACK_IMPORTED_MODULE_0__ops___default.a],
    mounted: function mounted() {
        this.getFiles();
    },

    methods: {
        getFiles: function getFiles() {
            var _this = this;

            axios.post(this.routes.filesRoute, {}).then(function (_ref) {
                var data = _ref.data;

                if (data.success) {
                    _this.files = data.message;
                }
            }).catch(function (err) {
                console.error(err);
                _this.parentMethod('failedAjax');
            });
        }
    }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__forms__ = __webpack_require__("./resources/assets/js/Tabs/shared/forms.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__forms___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__forms__);
function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//



/* harmony default export */ __webpack_exports__["default"] = ({
    name: 'content',
    mixins: [__WEBPACK_IMPORTED_MODULE_0__forms___default.a],
    data: function data() {
        return this.$parent.$data;
    },

    computed: {
        itemsCount: function itemsCount() {
            return Object.keys(this.selectedFileDataClone).length;
        }
    },
    updated: function updated() {
        this.tableColumnResize();
    },

    methods: {
        // table ops
        tableColumnResize: function tableColumnResize() {
            var el = void 0;
            var startOffset = void 0;

            document.querySelectorAll('table th').forEach(function (th) {
                th.style.position = 'sticky';

                var grip = document.createElement('div');
                grip.innerHTML = '&nbsp;';
                grip.style.top = 0;
                grip.style.right = 0;
                grip.style.bottom = 0;
                grip.style.width = '10px';
                grip.style.position = 'absolute';
                grip.style.cursor = 'col-resize';
                grip.addEventListener('mousedown', function (e) {
                    el = th;
                    startOffset = th.offsetWidth - e.pageX;
                });

                th.appendChild(grip);
            });

            document.addEventListener('mousemove', function (e) {
                if (el) {
                    el.style.width = startOffset + e.pageX + 'px';
                }
            });

            document.addEventListener('mouseup', function () {
                el = undefined;
            });
        },


        // ops
        addNewItem: function addNewItem() {
            var _this = this;

            var name = 'newItem' + this.newItemCounter;
            var fileData = this.selectedFileDataClone;

            this.dataChanged = true;

            // incase we already have keys == name
            if (fileData.hasOwnProperty(name)) {
                this.newItemCounter++;
                return this.addNewItem();
            }

            this.locales.forEach(function (item) {
                if (!fileData.hasOwnProperty(name)) {
                    _this.$set(fileData, name, _defineProperty({}, item, ''));
                } else {
                    _this.$set(fileData[name], item, '');
                }
            });

            this.newItemCounter++;
        },
        removeItem: function removeItem(item) {
            this.dataChanged = true;
            this.$delete(this.selectedFileDataClone, item);
        },
        resetData: function resetData() {
            var _this2 = this;

            this.dataChanged = false;
            this.newItemCounter = 0;
            this.selectedFileDataClone = JSON.parse(JSON.stringify(this.selectedFileData));

            // hacky fix as newkeys dont reset
            if (this.newKeys) {
                var old = this.selectedFile;

                setTimeout(function () {
                    _this2.selectedFile = old;
                }, 10);

                this.parentMethod('resetAll', ['selectedFile']);
            }

            this.parentMethod('resetAll', ['keyToCopy', 'currentInputRef']);
        },


        // util
        newEntry: function newEntry() {
            this.dataChanged = true;
        },
        saveNewKey: function saveNewKey(e) {
            var old_key = e.target.dataset.mainKey;
            var text = e.target.innerText = e.target.innerText.toLowerCase().replace(/\s/g, '_');
            var new_key = text;

            if (old_key !== new_key) {
                this.dataChanged = true;

                if (this.newKeys) {
                    return this.newKeys[old_key] = new_key;
                }

                this.newKeys = _defineProperty({}, old_key, new_key);
            }
        },
        saveNewValue: function saveNewValue(e) {
            var code = e.target.dataset.code;
            var key = e.target.dataset.mainKey;
            var text = e.target.innerText = e.target.innerText.replace(/\n/g, '<br>');
            var value = text;

            if (this.selectedFileDataClone[key][code] !== value) {
                this.dataChanged = true;
                this.$set(this.selectedFileDataClone[key], code, value);
            }
        },
        formatData: function formatData() {
            var main = this.selectedFileDataClone;
            var newData = this.newKeys;

            var main_keys = Object.keys(main);
            var newData_keys = Object.keys(newData);

            // replace changed keys
            if (newData_keys.length) {
                main_keys.map(function (old_key) {
                    if (newData_keys.includes(old_key)) {
                        var new_key = newData[old_key];

                        Object.defineProperty(main, new_key, Object.getOwnPropertyDescriptor(main, old_key));

                        delete main[old_key];
                    }
                });
            }

            return main;
        },


        // tippy & ctcp
        getPos: function getPos(e) {
            this.currentInputRef = e;
        },
        refocus: function refocus() {
            return this.parentMethod('refocus');
        },
        getKey: function getKey(key) {
            return this.parentMethod('getKey', key);
        },


        // other
        nestCheck: function nestCheck(item) {
            return item.includes('.') ? 'nestedKey' : '';
        },
        dontHaveData: function dontHaveData() {
            return Object.keys(this.selectedFileDataClone).length == 0;
        },
        trans: function trans(key) {
            return this.parentMethod('trans', key);
        },
        parentMethod: function parentMethod(method_name) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            return this.$parent[method_name](args);
        }
    }
});

/***/ }),

/***/ "./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/vendor.vue":
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
Object.defineProperty(__webpack_exports__, "__esModule", { value: true });
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ops__ = __webpack_require__("./resources/assets/js/Tabs/ops.js");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_0__ops___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_0__ops__);
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shared_content__ = __webpack_require__("./resources/assets/js/Tabs/shared/content.vue");
/* harmony import */ var __WEBPACK_IMPORTED_MODULE_1__shared_content___default = __webpack_require__.n(__WEBPACK_IMPORTED_MODULE_1__shared_content__);
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//
//




/* harmony default export */ __webpack_exports__["default"] = ({
    components: { SharedContent: __WEBPACK_IMPORTED_MODULE_1__shared_content___default.a },
    name: 'vendor-tab',
    mixins: [__WEBPACK_IMPORTED_MODULE_0__ops___default.a],
    props: ['dirsRoute', 'deleteVendorRoute'],
    data: function data() {
        return {
            dirs: [],
            selectedDir: ''
        };
    },
    beforeMount: function beforeMount() {
        this.getDirs();
    },
    mounted: function mounted() {
        var _this = this;

        EventHub.listen('ls-dir', function (val) {
            setTimeout(function () {
                if (_this.dirs.length && _this.dirs.includes(val)) {
                    return _this.selectedDir = val;
                }
            }, 100);
        });

        EventHub.listen('new_vendor_added', function (val) {
            _this.getDirs();
            _this.selectedDir = val;
        });
    },

    methods: {
        getDirs: function getDirs() {
            var _this2 = this;

            axios.get(this.dirsRoute).then(function (_ref) {
                var data = _ref.data;

                _this2.dirs = data;
            }).catch(function (err) {
                console.error(err);
                _this2.failedAjax();
            });
        },
        getFiles: function getFiles() {
            var _this3 = this;

            axios.post(this.routes.filesRoute, {
                'dir_name': this.selectedDir
            }).then(function (_ref2) {
                var data = _ref2.data;


                if (data.success) {
                    _this3.files = data.message;

                    if (_this3.files.length == 1) {
                        _this3.selectedFile = _this3.files[0];
                    } else {
                        // when changing dirs with files
                        _this3.resetAll(['selectedFile', 'locales']);
                    }
                } else {
                    // new vendor / no files
                    _this3.resetAll(['selectedFile', 'locales']);
                }

                // get file data or avail locales
                _this3.getFileContent();
            }).catch(function (err) {
                console.error(err);
                _this3.failedAjax();
            });
        },
        removeSelectedDir: function removeSelectedDir() {
            var _this4 = this;

            if (confirm(this.trans('you_sure_package'))) {
                axios.post(this.deleteVendorRoute, {
                    'dir_name': this.selectedDir
                }).then(function (_ref3) {
                    var data = _ref3.data;


                    if (!data.success) {
                        return _this4.showNotif(data.message, 'danger');
                    }

                    _this4.showNotif(data.message);

                    _this4.resetAll(['selectedDir', 'selectedFile', 'locales', 'files', 'selectedFileData', 'selectedFileDataClone']);

                    _this4.getDirs();
                }).catch(function (err) {
                    console.error(err);
                    _this4.failedAjax();
                });
            }
        }
    },
    watch: {
        dirs: function dirs(val) {
            this.$parent.dirsList = val;
        },
        selectedDir: function selectedDir(val) {
            this.$parent.selectedDirName = val;
            this.resetAll(['newKeys', 'currentInputRef', 'keyToCopy']);

            if (val) {
                this.newItemCounter = 0;
                this.getFiles();
            }
        }
    }
});

/***/ }),

/***/ "./node_modules/clipboard/lib/clipboard-action.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__("./node_modules/select/src/select.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports !== "undefined") {
        factory(module, require('select'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, global.select);
        global.clipboardAction = mod.exports;
    }
})(undefined, function (module, _select) {
    'use strict';

    var _select2 = _interopRequireDefault(_select);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    var ClipboardAction = function () {
        /**
         * @param {Object} options
         */
        function ClipboardAction(options) {
            _classCallCheck(this, ClipboardAction);

            this.resolveOptions(options);
            this.initSelection();
        }

        /**
         * Defines base properties passed from constructor.
         * @param {Object} options
         */

        _createClass(ClipboardAction, [{
            key: 'resolveOptions',
            value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.action = options.action;
                this.container = options.container;
                this.emitter = options.emitter;
                this.target = options.target;
                this.text = options.text;
                this.trigger = options.trigger;

                this.selectedText = '';
            }
        }, {
            key: 'initSelection',
            value: function initSelection() {
                if (this.text) {
                    this.selectFake();
                } else if (this.target) {
                    this.selectTarget();
                }
            }
        }, {
            key: 'selectFake',
            value: function selectFake() {
                var _this = this;

                var isRTL = document.documentElement.getAttribute('dir') == 'rtl';

                this.removeFake();

                this.fakeHandlerCallback = function () {
                    return _this.removeFake();
                };
                this.fakeHandler = this.container.addEventListener('click', this.fakeHandlerCallback) || true;

                this.fakeElem = document.createElement('textarea');
                // Prevent zooming on iOS
                this.fakeElem.style.fontSize = '12pt';
                // Reset box model
                this.fakeElem.style.border = '0';
                this.fakeElem.style.padding = '0';
                this.fakeElem.style.margin = '0';
                // Move element out of screen horizontally
                this.fakeElem.style.position = 'absolute';
                this.fakeElem.style[isRTL ? 'right' : 'left'] = '-9999px';
                // Move element to the same position vertically
                var yPosition = window.pageYOffset || document.documentElement.scrollTop;
                this.fakeElem.style.top = yPosition + 'px';

                this.fakeElem.setAttribute('readonly', '');
                this.fakeElem.value = this.text;

                this.container.appendChild(this.fakeElem);

                this.selectedText = (0, _select2.default)(this.fakeElem);
                this.copyText();
            }
        }, {
            key: 'removeFake',
            value: function removeFake() {
                if (this.fakeHandler) {
                    this.container.removeEventListener('click', this.fakeHandlerCallback);
                    this.fakeHandler = null;
                    this.fakeHandlerCallback = null;
                }

                if (this.fakeElem) {
                    this.container.removeChild(this.fakeElem);
                    this.fakeElem = null;
                }
            }
        }, {
            key: 'selectTarget',
            value: function selectTarget() {
                this.selectedText = (0, _select2.default)(this.target);
                this.copyText();
            }
        }, {
            key: 'copyText',
            value: function copyText() {
                var succeeded = void 0;

                try {
                    succeeded = document.execCommand(this.action);
                } catch (err) {
                    succeeded = false;
                }

                this.handleResult(succeeded);
            }
        }, {
            key: 'handleResult',
            value: function handleResult(succeeded) {
                this.emitter.emit(succeeded ? 'success' : 'error', {
                    action: this.action,
                    text: this.selectedText,
                    trigger: this.trigger,
                    clearSelection: this.clearSelection.bind(this)
                });
            }
        }, {
            key: 'clearSelection',
            value: function clearSelection() {
                if (this.trigger) {
                    this.trigger.focus();
                }

                window.getSelection().removeAllRanges();
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this.removeFake();
            }
        }, {
            key: 'action',
            set: function set() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 'copy';

                this._action = action;

                if (this._action !== 'copy' && this._action !== 'cut') {
                    throw new Error('Invalid "action" value, use either "copy" or "cut"');
                }
            },
            get: function get() {
                return this._action;
            }
        }, {
            key: 'target',
            set: function set(target) {
                if (target !== undefined) {
                    if (target && (typeof target === 'undefined' ? 'undefined' : _typeof(target)) === 'object' && target.nodeType === 1) {
                        if (this.action === 'copy' && target.hasAttribute('disabled')) {
                            throw new Error('Invalid "target" attribute. Please use "readonly" instead of "disabled" attribute');
                        }

                        if (this.action === 'cut' && (target.hasAttribute('readonly') || target.hasAttribute('disabled'))) {
                            throw new Error('Invalid "target" attribute. You can\'t cut text from elements with "readonly" or "disabled" attributes');
                        }

                        this._target = target;
                    } else {
                        throw new Error('Invalid "target" value, use a valid Element');
                    }
                }
            },
            get: function get() {
                return this._target;
            }
        }]);

        return ClipboardAction;
    }();

    module.exports = ClipboardAction;
});

/***/ }),

/***/ "./node_modules/clipboard/lib/clipboard.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof2 = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
    if (true) {
        !(__WEBPACK_AMD_DEFINE_ARRAY__ = [module, __webpack_require__("./node_modules/clipboard/lib/clipboard-action.js"), __webpack_require__("./node_modules/tiny-emitter/index.js"), __webpack_require__("./node_modules/good-listener/src/listen.js")], __WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__)) : __WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
    } else if (typeof exports !== "undefined") {
        factory(module, require('./clipboard-action'), require('tiny-emitter'), require('good-listener'));
    } else {
        var mod = {
            exports: {}
        };
        factory(mod, global.clipboardAction, global.tinyEmitter, global.goodListener);
        global.clipboard = mod.exports;
    }
})(undefined, function (module, _clipboardAction, _tinyEmitter, _goodListener) {
    'use strict';

    var _clipboardAction2 = _interopRequireDefault(_clipboardAction);

    var _tinyEmitter2 = _interopRequireDefault(_tinyEmitter);

    var _goodListener2 = _interopRequireDefault(_goodListener);

    function _interopRequireDefault(obj) {
        return obj && obj.__esModule ? obj : {
            default: obj
        };
    }

    var _typeof = typeof Symbol === "function" && _typeof2(Symbol.iterator) === "symbol" ? function (obj) {
        return typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
    } : function (obj) {
        return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj === 'undefined' ? 'undefined' : _typeof2(obj);
    };

    function _classCallCheck(instance, Constructor) {
        if (!(instance instanceof Constructor)) {
            throw new TypeError("Cannot call a class as a function");
        }
    }

    var _createClass = function () {
        function defineProperties(target, props) {
            for (var i = 0; i < props.length; i++) {
                var descriptor = props[i];
                descriptor.enumerable = descriptor.enumerable || false;
                descriptor.configurable = true;
                if ("value" in descriptor) descriptor.writable = true;
                Object.defineProperty(target, descriptor.key, descriptor);
            }
        }

        return function (Constructor, protoProps, staticProps) {
            if (protoProps) defineProperties(Constructor.prototype, protoProps);
            if (staticProps) defineProperties(Constructor, staticProps);
            return Constructor;
        };
    }();

    function _possibleConstructorReturn(self, call) {
        if (!self) {
            throw new ReferenceError("this hasn't been initialised - super() hasn't been called");
        }

        return call && ((typeof call === 'undefined' ? 'undefined' : _typeof2(call)) === "object" || typeof call === "function") ? call : self;
    }

    function _inherits(subClass, superClass) {
        if (typeof superClass !== "function" && superClass !== null) {
            throw new TypeError("Super expression must either be null or a function, not " + (typeof superClass === 'undefined' ? 'undefined' : _typeof2(superClass)));
        }

        subClass.prototype = Object.create(superClass && superClass.prototype, {
            constructor: {
                value: subClass,
                enumerable: false,
                writable: true,
                configurable: true
            }
        });
        if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass;
    }

    var Clipboard = function (_Emitter) {
        _inherits(Clipboard, _Emitter);

        /**
         * @param {String|HTMLElement|HTMLCollection|NodeList} trigger
         * @param {Object} options
         */
        function Clipboard(trigger, options) {
            _classCallCheck(this, Clipboard);

            var _this = _possibleConstructorReturn(this, (Clipboard.__proto__ || Object.getPrototypeOf(Clipboard)).call(this));

            _this.resolveOptions(options);
            _this.listenClick(trigger);
            return _this;
        }

        /**
         * Defines if attributes would be resolved using internal setter functions
         * or custom functions that were passed in the constructor.
         * @param {Object} options
         */

        _createClass(Clipboard, [{
            key: 'resolveOptions',
            value: function resolveOptions() {
                var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

                this.action = typeof options.action === 'function' ? options.action : this.defaultAction;
                this.target = typeof options.target === 'function' ? options.target : this.defaultTarget;
                this.text = typeof options.text === 'function' ? options.text : this.defaultText;
                this.container = _typeof(options.container) === 'object' ? options.container : document.body;
            }
        }, {
            key: 'listenClick',
            value: function listenClick(trigger) {
                var _this2 = this;

                this.listener = (0, _goodListener2.default)(trigger, 'click', function (e) {
                    return _this2.onClick(e);
                });
            }
        }, {
            key: 'onClick',
            value: function onClick(e) {
                var trigger = e.delegateTarget || e.currentTarget;

                if (this.clipboardAction) {
                    this.clipboardAction = null;
                }

                this.clipboardAction = new _clipboardAction2.default({
                    action: this.action(trigger),
                    target: this.target(trigger),
                    text: this.text(trigger),
                    container: this.container,
                    trigger: trigger,
                    emitter: this
                });
            }
        }, {
            key: 'defaultAction',
            value: function defaultAction(trigger) {
                return getAttributeValue('action', trigger);
            }
        }, {
            key: 'defaultTarget',
            value: function defaultTarget(trigger) {
                var selector = getAttributeValue('target', trigger);

                if (selector) {
                    return document.querySelector(selector);
                }
            }
        }, {
            key: 'defaultText',
            value: function defaultText(trigger) {
                return getAttributeValue('text', trigger);
            }
        }, {
            key: 'destroy',
            value: function destroy() {
                this.listener.destroy();

                if (this.clipboardAction) {
                    this.clipboardAction.destroy();
                    this.clipboardAction = null;
                }
            }
        }], [{
            key: 'isSupported',
            value: function isSupported() {
                var action = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : ['copy', 'cut'];

                var actions = typeof action === 'string' ? [action] : action;
                var support = !!document.queryCommandSupported;

                actions.forEach(function (action) {
                    support = support && !!document.queryCommandSupported(action);
                });

                return support;
            }
        }]);

        return Clipboard;
    }(_tinyEmitter2.default);

    /**
     * Helper function to retrieve attribute value.
     * @param {String} suffix
     * @param {Element} element
     */
    function getAttributeValue(suffix, element) {
        var attribute = 'data-clipboard-' + suffix;

        if (!element.hasAttribute(attribute)) {
            return;
        }

        return element.getAttribute(attribute);
    }

    module.exports = Clipboard;
});

/***/ }),

/***/ "./node_modules/css-loader/index.js!./node_modules/tippy.js/dist/tippy.css":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(undefined);
// imports


// module
exports.push([module.i, ".tippy-touch{cursor:pointer!important}.tippy-notransition{-webkit-transition:none!important;transition:none!important}.tippy-popper{max-width:400px;-webkit-perspective:800px;perspective:800px;z-index:9999;outline:0;-webkit-transition-timing-function:cubic-bezier(.165,.84,.44,1);transition-timing-function:cubic-bezier(.165,.84,.44,1);pointer-events:none}.tippy-popper.html-template{max-width:96%;max-width:calc(100% - 20px)}.tippy-popper[x-placement^=top] [x-arrow]{border-top:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;bottom:-7px;margin:0 9px}.tippy-popper[x-placement^=top] [x-arrow].arrow-small{border-top:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;bottom:-5px}.tippy-popper[x-placement^=top] [x-arrow].arrow-big{border-top:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;bottom:-10px}.tippy-popper[x-placement^=top] [x-circle]{-webkit-transform-origin:0 33%;transform-origin:0 33%}.tippy-popper[x-placement^=top] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-55%);transform:scale(1) translate(-50%,-55%);opacity:1}.tippy-popper[x-placement^=top] [x-circle].leave{-webkit-transform:scale(.15) translate(-50%,-50%);transform:scale(.15) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow]{border-top:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-top:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-top:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow]{border-top:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-top:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=top] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-top:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=top] [data-animation=perspective]{-webkit-transform-origin:bottom;transform-origin:bottom}.tippy-popper[x-placement^=top] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(-10px) rotateX(0);transform:translateY(-10px) rotateX(0)}.tippy-popper[x-placement^=top] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(90deg);transform:translateY(0) rotateX(90deg)}.tippy-popper[x-placement^=top] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(-10px);transform:translateY(-10px)}.tippy-popper[x-placement^=top] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=top] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(-10px) scale(1);transform:translateY(-10px) scale(1)}.tippy-popper[x-placement^=top] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=bottom] [x-arrow]{border-bottom:7px solid #333;border-right:7px solid transparent;border-left:7px solid transparent;top:-7px;margin:0 9px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-small{border-bottom:5px solid #333;border-right:5px solid transparent;border-left:5px solid transparent;top:-5px}.tippy-popper[x-placement^=bottom] [x-arrow].arrow-big{border-bottom:10px solid #333;border-right:10px solid transparent;border-left:10px solid transparent;top:-10px}.tippy-popper[x-placement^=bottom] [x-circle]{-webkit-transform-origin:0 -50%;transform-origin:0 -50%}.tippy-popper[x-placement^=bottom] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-45%);transform:scale(1) translate(-50%,-45%);opacity:1}.tippy-popper[x-placement^=bottom] [x-circle].leave{-webkit-transform:scale(.15) translate(-50%,-5%);transform:scale(.15) translate(-50%,-5%);opacity:0}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow]{border-bottom:7px solid #fff;border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-bottom:5px solid #fff;border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-bottom:10px solid #fff;border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow]{border-bottom:7px solid rgba(0,0,0,.7);border-right:7px solid transparent;border-left:7px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-bottom:5px solid rgba(0,0,0,.7);border-right:5px solid transparent;border-left:5px solid transparent}.tippy-popper[x-placement^=bottom] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-bottom:10px solid rgba(0,0,0,.7);border-right:10px solid transparent;border-left:10px solid transparent}.tippy-popper[x-placement^=bottom] [data-animation=perspective]{-webkit-transform-origin:top;transform-origin:top}.tippy-popper[x-placement^=bottom] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateY(10px) rotateX(0);transform:translateY(10px) rotateX(0)}.tippy-popper[x-placement^=bottom] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateY(0) rotateX(-90deg);transform:translateY(0) rotateX(-90deg)}.tippy-popper[x-placement^=bottom] [data-animation=fade].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=fade].leave{opacity:0;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].enter{opacity:1;-webkit-transform:translateY(10px);transform:translateY(10px)}.tippy-popper[x-placement^=bottom] [data-animation=shift].leave{opacity:0;-webkit-transform:translateY(0);transform:translateY(0)}.tippy-popper[x-placement^=bottom] [data-animation=scale].enter{opacity:1;-webkit-transform:translateY(10px) scale(1);transform:translateY(10px) scale(1)}.tippy-popper[x-placement^=bottom] [data-animation=scale].leave{opacity:0;-webkit-transform:translateY(0) scale(0);transform:translateY(0) scale(0)}.tippy-popper[x-placement^=left] [x-arrow]{border-left:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;right:-7px;margin:6px 0}.tippy-popper[x-placement^=left] [x-arrow].arrow-small{border-left:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;right:-5px}.tippy-popper[x-placement^=left] [x-arrow].arrow-big{border-left:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;right:-10px}.tippy-popper[x-placement^=left] [x-circle]{-webkit-transform-origin:50% 0;transform-origin:50% 0}.tippy-popper[x-placement^=left] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=left] [x-circle].leave{-webkit-transform:scale(.15) translate(-50%,-50%);transform:scale(.15) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow]{border-left:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-left:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-left:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow]{border-left:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-left:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=left] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-left:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=left] [data-animation=perspective]{-webkit-transform-origin:right;transform-origin:right}.tippy-popper[x-placement^=left] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(-10px) rotateY(0);transform:translateX(-10px) rotateY(0)}.tippy-popper[x-placement^=left] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(-90deg);transform:translateX(0) rotateY(-90deg)}.tippy-popper[x-placement^=left] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(-10px);transform:translateX(-10px)}.tippy-popper[x-placement^=left] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=left] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(-10px) scale(1);transform:translateX(-10px) scale(1)}.tippy-popper[x-placement^=left] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper[x-placement^=right] [x-arrow]{border-right:7px solid #333;border-top:7px solid transparent;border-bottom:7px solid transparent;left:-7px;margin:6px 0}.tippy-popper[x-placement^=right] [x-arrow].arrow-small{border-right:5px solid #333;border-top:5px solid transparent;border-bottom:5px solid transparent;left:-5px}.tippy-popper[x-placement^=right] [x-arrow].arrow-big{border-right:10px solid #333;border-top:10px solid transparent;border-bottom:10px solid transparent;left:-10px}.tippy-popper[x-placement^=right] [x-circle]{-webkit-transform-origin:-50% 0;transform-origin:-50% 0}.tippy-popper[x-placement^=right] [x-circle].enter{-webkit-transform:scale(1) translate(-50%,-50%);transform:scale(1) translate(-50%,-50%);opacity:1}.tippy-popper[x-placement^=right] [x-circle].leave{-webkit-transform:scale(.15) translate(-50%,-50%);transform:scale(.15) translate(-50%,-50%);opacity:0}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-circle]{background-color:#fff}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow]{border-right:7px solid #fff;border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-small{border-right:5px solid #fff;border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.light-theme [x-arrow].arrow-big{border-right:10px solid #fff;border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-circle]{background-color:rgba(0,0,0,.7)}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow]{border-right:7px solid rgba(0,0,0,.7);border-top:7px solid transparent;border-bottom:7px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-small{border-right:5px solid rgba(0,0,0,.7);border-top:5px solid transparent;border-bottom:5px solid transparent}.tippy-popper[x-placement^=right] .tippy-tooltip.transparent-theme [x-arrow].arrow-big{border-right:10px solid rgba(0,0,0,.7);border-top:10px solid transparent;border-bottom:10px solid transparent}.tippy-popper[x-placement^=right] [data-animation=perspective]{-webkit-transform-origin:left;transform-origin:left}.tippy-popper[x-placement^=right] [data-animation=perspective].enter{opacity:1;-webkit-transform:translateX(10px) rotateY(0);transform:translateX(10px) rotateY(0)}.tippy-popper[x-placement^=right] [data-animation=perspective].leave{opacity:0;-webkit-transform:translateX(0) rotateY(90deg);transform:translateX(0) rotateY(90deg)}.tippy-popper[x-placement^=right] [data-animation=fade].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=fade].leave{opacity:0;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].enter{opacity:1;-webkit-transform:translateX(10px);transform:translateX(10px)}.tippy-popper[x-placement^=right] [data-animation=shift].leave{opacity:0;-webkit-transform:translateX(0);transform:translateX(0)}.tippy-popper[x-placement^=right] [data-animation=scale].enter{opacity:1;-webkit-transform:translateX(10px) scale(1);transform:translateX(10px) scale(1)}.tippy-popper[x-placement^=right] [data-animation=scale].leave{opacity:0;-webkit-transform:translateX(0) scale(0);transform:translateX(0) scale(0)}.tippy-popper .tippy-tooltip.transparent-theme{background-color:rgba(0,0,0,.7)}.tippy-popper .tippy-tooltip.transparent-theme[data-animatefill]{background-color:transparent}.tippy-popper .tippy-tooltip.light-theme{color:#26323d;box-shadow:0 4px 20px 4px rgba(0,20,60,.1),0 4px 80px -8px rgba(0,20,60,.2);background-color:#fff}.tippy-popper .tippy-tooltip.light-theme[data-animatefill]{background-color:transparent}.tippy-tooltip{position:relative;color:#fff;border-radius:4px;font-size:.95rem;padding:.4rem .8rem;text-align:center;will-change:transform;-webkit-font-smoothing:antialiased;-moz-osx-font-smoothing:grayscale;background-color:#333}.tippy-tooltip--small{padding:.25rem .5rem;font-size:.8rem}.tippy-tooltip--big{padding:.6rem 1.2rem;font-size:1.2rem}.tippy-tooltip[data-animatefill]{overflow:hidden;background-color:transparent}.tippy-tooltip[data-interactive]{pointer-events:auto}.tippy-tooltip[data-inertia]{-webkit-transition-timing-function:cubic-bezier(.53,1,.36,.85);transition-timing-function:cubic-bezier(.53,2,.36,.85)}.tippy-tooltip [x-arrow]{position:absolute;width:0;height:0}.tippy-tooltip [x-circle]{position:absolute;will-change:transform;background-color:#333;border-radius:50%;width:130%;width:calc(110% + 2rem);left:50%;top:50%;z-index:-1;overflow:hidden;-webkit-transition:all ease;transition:all ease}.tippy-tooltip [x-circle]:before{content:\"\";padding-top:90%;float:left}@media (max-width:450px){.tippy-popper{max-width:96%;max-width:calc(100% - 20px)}}", ""]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "\n#tippyTemplate[data-v-314333c4] {\n    display: none;\n}\n.c2c[data-v-314333c4] {\n    cursor: pointer;\n}\n", "", {"version":3,"sources":["/Users/kabbouchi/Sites/laravel-lingo/packages/ctf0/lingo/resources/assets/js/Tabs/shared/resources/assets/js/Tabs/shared/content.vue?7df015be"],"names":[],"mappings":";AAwIA;IACA,cAAA;CACA;AAEA;IACA,gBAAA;CACA","file":"content.vue","sourcesContent":["<template>\n    <div>\n        <div class=\"level is-mobile is-marginless\">\n            <!-- items count -->\n            <div class=\"level-left\">\n                <div class=\"level-item\">\n                    <div class=\"field is-grouped is-grouped-left\">\n                        <div class=\"control\" v-if=\"selectedFile\">\n                            <h4 class=\"title is-4\">\"{{ itemsCount }}\" Item/s</h4>\n                        </div>\n                    </div>\n                </div>\n            </div>\n\n            <!-- select file -->\n            <div class=\"level-right\">\n                <div class=\"level-item\">\n                    <div class=\"field is-grouped is-grouped-right\" v-if=\"files.length\">\n                        <div class=\"control has-icons-left\">\n                            <div class=\"select\">\n                                <select v-model=\"selectedFile\">\n                                    <option value=\"\" disabled>{{ trans('select_file') }}</option>\n                                    <option v-for=\"(f, i) in files\" :key=\"i\">{{ f }}</option>\n                                </select>\n                            </div>\n                            <div class=\"icon is-small is-left\"><icon name=\"file\"/></div>\n                        </div>\n                        <div class=\"control\" v-if=\"selectedFile\">\n                            <button class=\"button is-danger\" @click=\"removeSelectedFile()\">\n                                <span class=\"icon\">\n                                    <icon name=\"trash\"/>\n                                </span>\n                            </button>\n                        </div>\n                    </div>\n                </div>\n            </div>\n        </div>\n\n        <!-- data -->\n        <section v-if=\"selectedFile\" class=\"m-t-50\">\n            <!-- table -->\n            <table class=\"table is-fullwidth is-hoverable is-bordered\">\n                <thead>\n                    <tr class=\"is-unselectable\">\n                        <th class=\"is-link\" width=\"1%\">{{ trans('key') }}</th>\n                        <th class=\"is-link\" v-for=\"(l, i) in locales\" :key=\"i\">\n                            <div class=\"tags has-addons\">\n                                <span class=\"tag is-light is-medium\">{{ l }}</span>\n                                <span class=\"tag is-warning is-medium\" @click=\"removeLocale(l)\">\n                                    <icon name=\"trash\"/>\n                                </span>\n                            </div>\n                        </th>\n                        <th class=\"is-link\">{{ trans('ops') }}</th>\n                    </tr>\n                </thead>\n                <tbody>\n                    <tr v-for=\"(mainV, mainK, mainI) in selectedFileDataClone\" :key=\"mainI\">\n                        <td nowrap contenteditable dir=\"auto\"\n                            :title=\"getKey(mainK)\"\n                            v-tippy=\"{ position : 'right', arrow: true, interactive: true, trigger: 'mouseenter'}\"\n                            data-html=\"#tippyTemplate\"\n                            @mouseenter=\"keyToCopy = getKey(mainK)\"\n                            @shown=\"refocus()\"\n\n                            :class=\"nestCheck(mainK)\"\n                            :data-main-key=\"mainK\"\n                            @keydown.enter.prevent\n                            @input=\"newEntry()\"\n                            @focus=\"getPos($event)\"\n                            @blur=\"saveNewKey($event)\">\n                            {{ mainK }}\n                        </td>\n\n                        <td v-for=\"(nestV, nestK, nestI) in mainV\" :key=\"nestI\"\n                            contenteditable dir=\"auto\"\n                            :data-main-key=\"mainK\"\n                            :data-code=\"nestK\"\n                            @input=\"newEntry()\"\n                            @focus=\"getPos($event)\"\n                            @blur=\"saveNewValue($event)\">\n                            {{ nestV }}\n                        </td>\n\n                        <td width=\"1%\">\n                            <button class=\"button is-danger\" @click=\"removeItem(mainK)\">\n                                <span class=\"icon\">\n                                    <icon name=\"trash\"/>\n                                </span>\n                            </button>\n                        </td>\n                    </tr>\n\n                    <!-- nothing found -->\n                    <tr v-if=\"dontHaveData()\">\n                        <td :colspan=\"locales.length + 2\">\n                            {{ trans('no_data') }}\n                        </td>\n                    </tr>\n                </tbody>\n            </table>\n\n            <!-- ops -->\n            <div class=\"level\">\n                <div class=\"level-right\">\n                    <div class=\"level-item\">\n                        <button class=\"button is-link\" @click.prevent=\"addNewItem()\">\n                            {{ trans('add_new') }}\n                        </button>\n                    </div>\n                </div>\n\n                <div class=\"level-left\">\n                    <div class=\"level-item\">\n                        <button class=\"button is-success\" :disabled=\"!dataChanged\" @click=\"submitNewData()\">\n                            {{ trans('save') }}\n                        </button>\n                    </div>\n                    <div class=\"level-item\">\n                        <button class=\"button\" :disabled=\"!dataChanged\" @click=\"resetData()\">\n                            {{ trans('reset') }}\n                        </button>\n                    </div>\n                </div>\n            </div>\n\n            <!-- tippy template -->\n            <div id=\"tippyTemplate\">\n                <span class=\"c2c\">{{ keyToCopy }}</span>\n            </div>\n        </section>\n    </div>\n</template>\n\n<style scoped>\n    #tippyTemplate {\n        display: none;\n    }\n\n    .c2c {\n        cursor: pointer;\n    }\n</style>\n\n<script>\nimport Forms from './forms'\n\nexport default{\n    name: 'content',\n    mixins: [Forms],\n    data() {\n        return this.$parent.$data\n    },\n    computed: {\n        itemsCount() {\n            return Object.keys(this.selectedFileDataClone).length\n        }\n    },\n    updated() {\n        this.tableColumnResize()\n    },\n    methods: {\n        // table ops\n        tableColumnResize() {\n            let el\n            let startOffset\n\n            document.querySelectorAll('table th').forEach((th) => {\n                th.style.position = 'sticky'\n\n                let grip = document.createElement('div')\n                grip.innerHTML = '&nbsp;'\n                grip.style.top = 0\n                grip.style.right = 0\n                grip.style.bottom = 0\n                grip.style.width = '10px'\n                grip.style.position = 'absolute'\n                grip.style.cursor = 'col-resize'\n                grip.addEventListener('mousedown', (e) => {\n                    el = th\n                    startOffset = th.offsetWidth - e.pageX\n                })\n\n                th.appendChild(grip)\n            })\n\n            document.addEventListener('mousemove', (e) => {\n                if (el) {\n                    el.style.width = startOffset + e.pageX + 'px'\n                }\n            })\n\n            document.addEventListener('mouseup', () => {\n                el = undefined\n            })\n        },\n\n        // ops\n        addNewItem() {\n            let name = 'newItem' + this.newItemCounter\n            let fileData = this.selectedFileDataClone\n\n            this.dataChanged = true\n\n            // incase we already have keys == name\n            if (fileData.hasOwnProperty(name)) {\n                this.newItemCounter++\n                return this.addNewItem()\n            }\n\n            this.locales.forEach((item) => {\n                if (!fileData.hasOwnProperty(name)) {\n                    this.$set(fileData, name, {[item]: ''})\n                } else {\n                    this.$set(fileData[name], item, '')\n                }\n            })\n\n            this.newItemCounter++\n        },\n        removeItem(item) {\n            this.dataChanged = true\n            this.$delete(this.selectedFileDataClone, item)\n        },\n        resetData() {\n            this.dataChanged = false\n            this.newItemCounter = 0\n            this.selectedFileDataClone = JSON.parse(JSON.stringify(this.selectedFileData))\n\n            // hacky fix as newkeys dont reset\n            if (this.newKeys) {\n                let old = this.selectedFile\n\n                setTimeout(() => {\n                    this.selectedFile = old\n                }, 10)\n\n                this.parentMethod('resetAll', ['selectedFile'])\n            }\n\n            this.parentMethod('resetAll', ['keyToCopy', 'currentInputRef'])\n        },\n\n        // util\n        newEntry() {\n            this.dataChanged = true\n        },\n        saveNewKey(e) {\n            let old_key = e.target.dataset.mainKey\n            let text = e.target.innerText = e.target.innerText.toLowerCase().replace(/\\s/g, '_')\n            let new_key = text\n\n            if (old_key !== new_key) {\n                this.dataChanged = true\n\n                if (this.newKeys) {\n                    return this.newKeys[old_key] = new_key\n                }\n\n                this.newKeys = {[old_key] : new_key}\n            }\n        },\n        saveNewValue(e) {\n            let code = e.target.dataset.code\n            let key = e.target.dataset.mainKey\n            let text = e.target.innerText = e.target.innerText.replace(/\\n/g, '<br>')\n            let value = text\n\n            if (this.selectedFileDataClone[key][code] !== value) {\n                this.dataChanged = true\n                this.$set(this.selectedFileDataClone[key], code, value)\n            }\n        },\n        formatData() {\n            let main = this.selectedFileDataClone\n            let newData = this.newKeys\n\n            let main_keys = Object.keys(main)\n            let newData_keys = Object.keys(newData)\n\n            // replace changed keys\n            if (newData_keys.length) {\n                main_keys.map((old_key) => {\n                    if (newData_keys.includes(old_key)) {\n                        let new_key = newData[old_key]\n\n                        Object.defineProperty(\n                            main,\n                            new_key,\n                            Object.getOwnPropertyDescriptor(main, old_key)\n                        )\n\n                        delete main[old_key]\n                    }\n                })\n            }\n\n            return main\n        },\n\n        // tippy & ctcp\n        getPos(e) {\n            this.currentInputRef = e\n        },\n        refocus() {\n            return this.parentMethod('refocus')\n        },\n        getKey(key) {\n            return this.parentMethod('getKey', key)\n        },\n\n        // other\n        nestCheck(item) {\n            return item.includes('.') ? 'nestedKey' : ''\n        },\n        dontHaveData() {\n            return Object.keys(this.selectedFileDataClone).length == 0\n        },\n        trans(key) {\n            return this.parentMethod('trans', key)\n        },\n        parentMethod(method_name, args = null) {\n            return this.$parent[method_name](args)\n        }\n    }\n}\n</script>\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "\n.notif-container {\n    padding: 0;\n    position: fixed;\n    top: 4rem;\n    right: 1rem;\n    z-index: 10000;\n}\n", "", {"version":3,"sources":["/Users/kabbouchi/Sites/laravel-lingo/packages/ctf0/lingo/node_modules/vue-notif/src/node_modules/vue-notif/src/Notification.vue?68d1a5aa"],"names":[],"mappings":";AA2DA;IACA,WAAA;IACA,gBAAA;IACA,UAAA;IACA,YAAA;IACA,eAAA;CACA","file":"Notification.vue","sourcesContent":["<template>\n    <div>\n        <!-- single -->\n        <transition name=\"slide-fade\" v-if=\"self_show\">\n            <div :class=\"classObj(self_type)\" class=\"item\">\n\n                <button class=\"delete\" @click=\"self_show = false\"></button>\n                <div class=\"media\">\n                    <div class=\"media-left\" v-if=\"self_icon\">\n                        <figure class=\"icon is-large\">\n                            <i class=\"material-icons\">{{ getIcon(self_type) }}</i>\n                        </figure>\n                    </div>\n                    <div class=\"media-content\">\n                        <h4 class=\"title\">\n                            <strong>{{ self_title }}</strong>\n                        </h4>\n                        <p class=\"subtitle\">{{ self_body }}</p>\n                    </div>\n                </div>\n\n            </div>\n        </transition>\n\n        <!-- events -->\n        <template v-if=\"!self_title\">\n            <span id=\"close_all\" class=\"tag is-dark is-medium\"\n                v-if=\"checkForGroup()\" @click=\"closeAll()\">\n                Close All\n                <button class=\"delete\"></button>\n            </span>\n\n            <transition-group name=\"slide-fade\" tag=\"ul\">\n                <li v-for=\"(one,index) in notif_group\" :key=\"index\"\n                    class=\"item\" :class=\"classObj(one.type)\"\n                    v-if=\"IsVisible(index)\">\n\n                    <button class=\"delete\" @click=\"closeNotif(index)\"></button>\n                    <div class=\"media\">\n                        <div class=\"media-left\" v-if=\"one.icon\">\n                            <figure class=\"icon is-large\">\n                                <i class=\"material-icons\">{{ getIcon(one.type) }}</i>\n                            </figure>\n                        </div>\n                        <div class=\"media-content\">\n                            <h4 class=\"title\">\n                                <strong>{{ one.title }}</strong>\n                            </h4>\n                            <p class=\"subtitle\">{{ one.body }}</p>\n                        </div>\n                    </div>\n\n                </li>\n            </transition-group>\n        </template>\n    </div>\n</template>\n\n<style>\n    .notif-container {\n        padding: 0;\n        position: fixed;\n        top: 4rem;\n        right: 1rem;\n        z-index: 10000;\n    }\n</style>\n\n<style scoped>\n    @import url(https://fonts.googleapis.com/icon?family=Material+Icons);\n\n    /*animation*/\n    .slide-fade-enter-active,\n    .slide-fade-leave-active {\n        transition: all 0.3s ease;\n    }\n    .slide-fade-enter,\n    .slide-fade-leave-to {\n        opacity: 0;\n        transform: translateX(10px);\n    }\n\n    /*notiifcation card*/\n    .item {\n        width: 330px;\n    }\n    .material-icons {\n        font-size: 3rem;\n    }\n    .media-left {\n        align-self: center;\n        position: relative;\n        margin-right: 1.25rem;\n    }\n\n    .has-shadow {\n        box-shadow: 0 2px 4px rgba(0,0,0,0.12), 0 0 6px rgba(0,0,0,0.04);\n    }\n    .notification {\n        padding: 1.25rem;\n        margin-bottom: 10px;\n    }\n\n    .notification .delete {\n        right: 0.5rem;\n        top: 0.5rem;\n    }\n\n    #close_all {\n        background-color: rgba(54, 54, 54, 0.9);\n        cursor: pointer;\n        position: fixed;\n        z-index: 1;\n        top: 1rem;\n        right: 1rem;\n        border-radius: 100vw;\n    }\n    #close_all:hover{\n        background-color: rgb(54, 54, 54);\n    }\n\n    #close_all .delete {\n        margin-left: 0.25rem;\n        margin-right: -0.375rem;\n    }\n</style>\n\n<script>\nexport default {\n    props: {\n        title: '',\n        body: '',\n        icon: {\n            default: true\n        },\n        type: {default: 'info'},\n        duration: null\n    },\n\n    data() {\n        return {\n            notif_group: [],\n            self_title: this.title,\n            self_body: this.body,\n            self_type: this.type,\n            self_icon: Boolean(this.icon),\n            self_duration: this.duration,\n            self_show: false\n        }\n    },\n\n    created() {\n        this.checkProp()\n\n        EventHub.listen('showNotif', (data) => {\n            this.collectData(data)\n        })\n    },\n\n    methods: {\n        checkForGroup() {\n            return this.notif_group.length > 1 &&\n                    this.notif_group.filter((item) => item.show == true).length > 1\n        },\n        closeAll() {\n            this.notif_group.map((item) => {\n                item.show = false\n                item.duration = null\n            })\n        },\n        checkProp() {\n            if (this.self_title) {\n                this.self_show = true\n            }\n\n            if (this.self_duration !== undefined) {\n                setTimeout(() => {\n                    this.self_show = false\n                }, this.self_duration * 1000)\n            }\n        },\n        collectData(data) {\n            this.notif_group.push({\n                title: data.title,\n                body: data.body,\n                type: data.type,\n                icon: data.icon == null ? true : false,\n                duration: data.duration,\n                onClose: data.onClose,\n                show: true\n            })\n        },\n        IsVisible(index) {\n            let dur = this.notif_group[index].duration\n\n            if (dur != undefined || dur != null) {\n                setTimeout(() => {\n                    this.closeNotif(index)\n                }, dur * 1000)\n            }\n\n            return this.notif_group[index].show\n        },\n        closeNotif(index) {\n            this.notif_group[index].show = false\n\n            if (typeof this.notif_group[index].onClose !== 'undefined' && typeof this.notif_group[index].onClose === 'function') {\n                this.notif_group[index].onClose()\n            }\n        },\n        classObj(type) {\n            return `notification has-shadow is-${type}`\n        },\n        getIcon(type) {\n            switch (type) {\n            case 'primary':\n                return 'track_changes'\n            case 'success':\n                return 'check_circle'\n            case 'info':\n                return 'live_help'\n            case 'warning':\n                return 'power_settings_new'\n            case 'danger':\n                return 'add_alert'\n            default:\n                return 'error'\n            }\n        }\n    }\n}\n</script>\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=1&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports
exports.push([module.i, "@import url(https://fonts.googleapis.com/icon?family=Material+Icons);", ""]);

// module
exports.push([module.i, "\n/*animation*/\n.slide-fade-enter-active[data-v-64d817c3],\n.slide-fade-leave-active[data-v-64d817c3] {\n    -webkit-transition: all 0.3s ease;\n    transition: all 0.3s ease;\n}\n.slide-fade-enter[data-v-64d817c3],\n.slide-fade-leave-to[data-v-64d817c3] {\n    opacity: 0;\n    -webkit-transform: translateX(10px);\n            transform: translateX(10px);\n}\n\n/*notiifcation card*/\n.item[data-v-64d817c3] {\n    width: 330px;\n}\n.material-icons[data-v-64d817c3] {\n    font-size: 3rem;\n}\n.media-left[data-v-64d817c3] {\n    -ms-flex-item-align: center;\n        align-self: center;\n    position: relative;\n    margin-right: 1.25rem;\n}\n.has-shadow[data-v-64d817c3] {\n    -webkit-box-shadow: 0 2px 4px rgba(0,0,0,0.12), 0 0 6px rgba(0,0,0,0.04);\n            box-shadow: 0 2px 4px rgba(0,0,0,0.12), 0 0 6px rgba(0,0,0,0.04);\n}\n.notification[data-v-64d817c3] {\n    padding: 1.25rem;\n    margin-bottom: 10px;\n}\n.notification .delete[data-v-64d817c3] {\n    right: 0.5rem;\n    top: 0.5rem;\n}\n#close_all[data-v-64d817c3] {\n    background-color: rgba(54, 54, 54, 0.9);\n    cursor: pointer;\n    position: fixed;\n    z-index: 1;\n    top: 1rem;\n    right: 1rem;\n    border-radius: 100vw;\n}\n#close_all[data-v-64d817c3]:hover{\n    background-color: rgb(54, 54, 54);\n}\n#close_all .delete[data-v-64d817c3] {\n    margin-left: 0.25rem;\n    margin-right: -0.375rem;\n}\n", "", {"version":3,"sources":["/Users/kabbouchi/Sites/laravel-lingo/packages/ctf0/lingo/node_modules/vue-notif/src/node_modules/vue-notif/src/Notification.vue?68d1a5aa"],"names":[],"mappings":";AAuEA,aAAA;AACA;;IAEA,kCAAA;IAAA,0BAAA;CACA;AACA;;IAEA,WAAA;IACA,oCAAA;YAAA,4BAAA;CACA;;AAEA,qBAAA;AACA;IACA,aAAA;CACA;AACA;IACA,gBAAA;CACA;AACA;IACA,4BAAA;QAAA,mBAAA;IACA,mBAAA;IACA,sBAAA;CACA;AAEA;IACA,yEAAA;YAAA,iEAAA;CACA;AACA;IACA,iBAAA;IACA,oBAAA;CACA;AAEA;IACA,cAAA;IACA,YAAA;CACA;AAEA;IACA,wCAAA;IACA,gBAAA;IACA,gBAAA;IACA,WAAA;IACA,UAAA;IACA,YAAA;IACA,qBAAA;CACA;AACA;IACA,kCAAA;CACA;AAEA;IACA,qBAAA;IACA,wBAAA;CACA","file":"Notification.vue","sourcesContent":["<template>\n    <div>\n        <!-- single -->\n        <transition name=\"slide-fade\" v-if=\"self_show\">\n            <div :class=\"classObj(self_type)\" class=\"item\">\n\n                <button class=\"delete\" @click=\"self_show = false\"></button>\n                <div class=\"media\">\n                    <div class=\"media-left\" v-if=\"self_icon\">\n                        <figure class=\"icon is-large\">\n                            <i class=\"material-icons\">{{ getIcon(self_type) }}</i>\n                        </figure>\n                    </div>\n                    <div class=\"media-content\">\n                        <h4 class=\"title\">\n                            <strong>{{ self_title }}</strong>\n                        </h4>\n                        <p class=\"subtitle\">{{ self_body }}</p>\n                    </div>\n                </div>\n\n            </div>\n        </transition>\n\n        <!-- events -->\n        <template v-if=\"!self_title\">\n            <span id=\"close_all\" class=\"tag is-dark is-medium\"\n                v-if=\"checkForGroup()\" @click=\"closeAll()\">\n                Close All\n                <button class=\"delete\"></button>\n            </span>\n\n            <transition-group name=\"slide-fade\" tag=\"ul\">\n                <li v-for=\"(one,index) in notif_group\" :key=\"index\"\n                    class=\"item\" :class=\"classObj(one.type)\"\n                    v-if=\"IsVisible(index)\">\n\n                    <button class=\"delete\" @click=\"closeNotif(index)\"></button>\n                    <div class=\"media\">\n                        <div class=\"media-left\" v-if=\"one.icon\">\n                            <figure class=\"icon is-large\">\n                                <i class=\"material-icons\">{{ getIcon(one.type) }}</i>\n                            </figure>\n                        </div>\n                        <div class=\"media-content\">\n                            <h4 class=\"title\">\n                                <strong>{{ one.title }}</strong>\n                            </h4>\n                            <p class=\"subtitle\">{{ one.body }}</p>\n                        </div>\n                    </div>\n\n                </li>\n            </transition-group>\n        </template>\n    </div>\n</template>\n\n<style>\n    .notif-container {\n        padding: 0;\n        position: fixed;\n        top: 4rem;\n        right: 1rem;\n        z-index: 10000;\n    }\n</style>\n\n<style scoped>\n    @import url(https://fonts.googleapis.com/icon?family=Material+Icons);\n\n    /*animation*/\n    .slide-fade-enter-active,\n    .slide-fade-leave-active {\n        transition: all 0.3s ease;\n    }\n    .slide-fade-enter,\n    .slide-fade-leave-to {\n        opacity: 0;\n        transform: translateX(10px);\n    }\n\n    /*notiifcation card*/\n    .item {\n        width: 330px;\n    }\n    .material-icons {\n        font-size: 3rem;\n    }\n    .media-left {\n        align-self: center;\n        position: relative;\n        margin-right: 1.25rem;\n    }\n\n    .has-shadow {\n        box-shadow: 0 2px 4px rgba(0,0,0,0.12), 0 0 6px rgba(0,0,0,0.04);\n    }\n    .notification {\n        padding: 1.25rem;\n        margin-bottom: 10px;\n    }\n\n    .notification .delete {\n        right: 0.5rem;\n        top: 0.5rem;\n    }\n\n    #close_all {\n        background-color: rgba(54, 54, 54, 0.9);\n        cursor: pointer;\n        position: fixed;\n        z-index: 1;\n        top: 1rem;\n        right: 1rem;\n        border-radius: 100vw;\n    }\n    #close_all:hover{\n        background-color: rgb(54, 54, 54);\n    }\n\n    #close_all .delete {\n        margin-left: 0.25rem;\n        margin-right: -0.375rem;\n    }\n</style>\n\n<script>\nexport default {\n    props: {\n        title: '',\n        body: '',\n        icon: {\n            default: true\n        },\n        type: {default: 'info'},\n        duration: null\n    },\n\n    data() {\n        return {\n            notif_group: [],\n            self_title: this.title,\n            self_body: this.body,\n            self_type: this.type,\n            self_icon: Boolean(this.icon),\n            self_duration: this.duration,\n            self_show: false\n        }\n    },\n\n    created() {\n        this.checkProp()\n\n        EventHub.listen('showNotif', (data) => {\n            this.collectData(data)\n        })\n    },\n\n    methods: {\n        checkForGroup() {\n            return this.notif_group.length > 1 &&\n                    this.notif_group.filter((item) => item.show == true).length > 1\n        },\n        closeAll() {\n            this.notif_group.map((item) => {\n                item.show = false\n                item.duration = null\n            })\n        },\n        checkProp() {\n            if (this.self_title) {\n                this.self_show = true\n            }\n\n            if (this.self_duration !== undefined) {\n                setTimeout(() => {\n                    this.self_show = false\n                }, this.self_duration * 1000)\n            }\n        },\n        collectData(data) {\n            this.notif_group.push({\n                title: data.title,\n                body: data.body,\n                type: data.type,\n                icon: data.icon == null ? true : false,\n                duration: data.duration,\n                onClose: data.onClose,\n                show: true\n            })\n        },\n        IsVisible(index) {\n            let dur = this.notif_group[index].duration\n\n            if (dur != undefined || dur != null) {\n                setTimeout(() => {\n                    this.closeNotif(index)\n                }, dur * 1000)\n            }\n\n            return this.notif_group[index].show\n        },\n        closeNotif(index) {\n            this.notif_group[index].show = false\n\n            if (typeof this.notif_group[index].onClose !== 'undefined' && typeof this.notif_group[index].onClose === 'function') {\n                this.notif_group[index].onClose()\n            }\n        },\n        classObj(type) {\n            return `notification has-shadow is-${type}`\n        },\n        getIcon(type) {\n            switch (type) {\n            case 'primary':\n                return 'track_changes'\n            case 'success':\n                return 'check_circle'\n            case 'info':\n                return 'live_help'\n            case 'warning':\n                return 'power_settings_new'\n            case 'danger':\n                return 'add_alert'\n            default:\n                return 'error'\n            }\n        }\n    }\n}\n</script>\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue":
/***/ (function(module, exports, __webpack_require__) {

exports = module.exports = __webpack_require__("./node_modules/css-loader/lib/css-base.js")(true);
// imports


// module
exports.push([module.i, "\n.fa-icon {\n  display: inline-block;\n  fill: currentColor;\n}\n.fa-flip-horizontal {\n  -webkit-transform: scale(-1, 1);\n          transform: scale(-1, 1);\n}\n.fa-flip-vertical {\n  -webkit-transform: scale(1, -1);\n          transform: scale(1, -1);\n}\n.fa-spin {\n  -webkit-animation: fa-spin 1s 0s infinite linear;\n          animation: fa-spin 1s 0s infinite linear;\n}\n.fa-inverse {\n  color: #fff;\n}\n.fa-pulse {\n  -webkit-animation: fa-spin 1s infinite steps(8);\n          animation: fa-spin 1s infinite steps(8);\n}\n@-webkit-keyframes fa-spin {\n0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n}\n}\n@keyframes fa-spin {\n0% {\n    -webkit-transform: rotate(0deg);\n            transform: rotate(0deg);\n}\n100% {\n    -webkit-transform: rotate(360deg);\n            transform: rotate(360deg);\n}\n}\n", "", {"version":3,"sources":["/Users/kabbouchi/Sites/laravel-lingo/packages/ctf0/lingo/node_modules/vue-awesome/components/node_modules/vue-awesome/components/Icon.vue?21a26982"],"names":[],"mappings":";AAwBA;EACA,sBAAA;EACA,mBAAA;CACA;AAEA;EACA,gCAAA;UAAA,wBAAA;CACA;AAEA;EACA,gCAAA;UAAA,wBAAA;CACA;AAEA;EACA,iDAAA;UAAA,yCAAA;CACA;AAEA;EACA,YAAA;CACA;AAEA;EACA,gDAAA;UAAA,wCAAA;CACA;AAEA;AACA;IACA,gCAAA;YAAA,wBAAA;CACA;AACA;IACA,kCAAA;YAAA,0BAAA;CACA;CACA;AAPA;AACA;IACA,gCAAA;YAAA,wBAAA;CACA;AACA;IACA,kCAAA;YAAA,0BAAA;CACA;CACA","file":"Icon.vue","sourcesContent":["<template>\n  <svg version=\"1.1\"\n    :class=\"klass\"\n    :role=\"label ? 'img' : 'presentation'\"\n    :aria-label=\"label\"\n    :x=\"x\"\n    :y=\"y\"\n    :width=\"width\"\n    :height=\"height\"\n    :viewBox=\"box\"\n    :style=\"style\">\n    <slot>\n      <template v-if=\"icon && icon.paths\">\n        <path v-for=\"(path, i) in icon.paths\" :key=\"`path-${i}`\" v-bind=\"path\"/>\n      </template>\n      <template v-if=\"icon && icon.polygons\">\n        <polygon v-for=\"(polygon, i) in icon.polygons\" :key=\"`polygon-${i}`\" v-bind=\"polygon\"/>\n      </template>\b\n      <template v-if=\"icon && icon.raw\"><g v-html=\"raw\"></g></template>\n    </slot>\n  </svg>\n</template>\n\n<style>\n.fa-icon {\n  display: inline-block;\n  fill: currentColor;\n}\n\n.fa-flip-horizontal {\n  transform: scale(-1, 1);\n}\n\n.fa-flip-vertical {\n  transform: scale(1, -1);\n}\n\n.fa-spin {\n  animation: fa-spin 1s 0s infinite linear;\n}\n\n.fa-inverse {\n  color: #fff;\n}\n\n.fa-pulse {\n  animation: fa-spin 1s infinite steps(8);\n}\n\n@keyframes fa-spin {\n  0% {\n    transform: rotate(0deg);\n  }\n  100% {\n    transform: rotate(360deg);\n  }\n}\n</style>\n\n<script>\nlet icons = {}\n\nexport default {\n  name: 'icon',\n  props: {\n    name: {\n      type: String,\n      validator (val) {\n        if (val) {\n          if (!(val in icons)) {\n            console.warn(`Invalid prop: prop \"name\" is referring to an unregistered icon \"${val}\".` +\n              `\\nPlesase make sure you have imported this icon before using it.`)\n            return false\n          }\n          return true\n        }\n        console.warn(`Invalid prop: prop \"name\" is required.`)\n        return false\n      }\n    },\n    scale: [Number, String],\n    spin: Boolean,\n    inverse: Boolean,\n    pulse: Boolean,\n    flip: {\n      validator (val) {\n        return val === 'horizontal' || val === 'vertical'\n      }\n    },\n    label: String\n  },\n  data () {\n    return {\n      x: false,\n      y: false,\n      childrenWidth: 0,\n      childrenHeight: 0,\n      outerScale: 1\n    }\n  },\n  computed: {\n    normalizedScale () {\n      let scale = this.scale\n      scale = typeof scale === 'undefined' ? 1 : Number(scale)\n      if (isNaN(scale) || scale <= 0) {\n        console.warn(`Invalid prop: prop \"scale\" should be a number over 0.`, this)\n        return this.outerScale\n      }\n      return scale * this.outerScale\n    },\n    klass () {\n      return {\n        'fa-icon': true,\n        'fa-spin': this.spin,\n        'fa-flip-horizontal': this.flip === 'horizontal',\n        'fa-flip-vertical': this.flip === 'vertical',\n        'fa-inverse': this.inverse,\n        'fa-pulse': this.pulse\n      }\n    },\n    icon () {\n      if (this.name) {\n        return icons[this.name]\n      }\n      return null\n    },\n    box () {\n      if (this.icon) {\n        return `0 0 ${this.icon.width} ${this.icon.height}`\n      }\n      return `0 0 ${this.width} ${this.height}`\n    },\n    ratio () {\n      if (!this.icon) {\n        return 1\n      }\n      let { width, height } = this.icon\n      return Math.max(width, height) / 16\n    },\n    width () {\n      return this.childrenWidth || this.icon && this.icon.width / this.ratio * this.normalizedScale || 0\n    },\n    height () {\n      return this.childrenHeight || this.icon && this.icon.height / this.ratio * this.normalizedScale || 0\n    },\n    style () {\n      if (this.normalizedScale === 1) {\n        return false\n      }\n      return {\n        fontSize: this.normalizedScale + 'em'\n      }\n    },\n    raw () {\n      // generate unique id for each icon's SVG element with ID\n      if (!this.icon || !this.icon.raw) {\n        return null\n      }\n      let raw = this.icon.raw\n      let ids = {}\n      raw = raw.replace(/\\s(?:xml:)?id=[\"']?([^\"')\\s]+)/g, (match, id) => {\n        let uniqueId = getId()\n        ids[id] = uniqueId\n        return ` id=\"${uniqueId}\"`\n      })\n      raw = raw.replace(/#(?:([^'\")\\s]+)|xpointer\\(id\\((['\"]?)([^')]+)\\2\\)\\))/g, (match, rawId, _, pointerId) => {\n        let id = rawId || pointerId\n        if (!id || !ids[id]) {\n          return match\n        }\n\n        return `#${ids[id]}`\n      })\n\n      return raw\n    }\n  },\n  mounted () {\n    if (this.icon) {\n      return\n    }\n    this.$children.forEach(child => {\n      child.outerScale = this.normalizedScale\n    })\n    let width = 0\n    let height = 0\n    this.$children.forEach(child => {\n      width = Math.max(width, child.width)\n      height = Math.max(height, child.height)\n    })\n    this.childrenWidth = width\n    this.childrenHeight = height\n    this.$children.forEach(child => {\n      child.x = (width - child.width) / 2\n      child.y = (height - child.height) / 2\n    })\n  },\n  register (data) {\n    for (let name in data) {\n      let icon = data[name]\n\n      if (!icon.paths) {\n        icon.paths = []\n      }\n      if (icon.d) {\n        icon.paths.push({ d: icon.d })\n      }\n\n      if (!icon.polygons) {\n        icon.polygons = []\n      }\n      if (icon.points) {\n        icon.polygons.push({ points: icon.points })\n      }\n\n      icons[name] = icon\n    }\n  },\n  icons\n}\n\nlet cursor = 0xd4937\nfunction getId () {\n  return `fa-${(cursor++).toString(16)}`\n}\n</script>\n"],"sourceRoot":""}]);

// exports


/***/ }),

/***/ "./node_modules/css-loader/lib/css-base.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/
// css base code, injected by the css-loader
module.exports = function (useSourceMap) {
	var list = [];

	// return the list of modules as css string
	list.toString = function toString() {
		return this.map(function (item) {
			var content = cssWithMappingToString(item, useSourceMap);
			if (item[2]) {
				return "@media " + item[2] + "{" + content + "}";
			} else {
				return content;
			}
		}).join("");
	};

	// import a list of modules into the list
	list.i = function (modules, mediaQuery) {
		if (typeof modules === "string") modules = [[null, modules, ""]];
		var alreadyImportedModules = {};
		for (var i = 0; i < this.length; i++) {
			var id = this[i][0];
			if (typeof id === "number") alreadyImportedModules[id] = true;
		}
		for (i = 0; i < modules.length; i++) {
			var item = modules[i];
			// skip already imported module
			// this implementation is not 100% perfect for weird media query combinations
			//  when a module is imported multiple times with different media queries.
			//  I hope this will never occur (Hey this way we have smaller bundles)
			if (typeof item[0] !== "number" || !alreadyImportedModules[item[0]]) {
				if (mediaQuery && !item[2]) {
					item[2] = mediaQuery;
				} else if (mediaQuery) {
					item[2] = "(" + item[2] + ") and (" + mediaQuery + ")";
				}
				list.push(item);
			}
		}
	};
	return list;
};

function cssWithMappingToString(item, useSourceMap) {
	var content = item[1] || '';
	var cssMapping = item[3];
	if (!cssMapping) {
		return content;
	}

	if (useSourceMap && typeof btoa === 'function') {
		var sourceMapping = toComment(cssMapping);
		var sourceURLs = cssMapping.sources.map(function (source) {
			return '/*# sourceURL=' + cssMapping.sourceRoot + source + ' */';
		});

		return [content].concat(sourceURLs).concat([sourceMapping]).join('\n');
	}

	return [content].join('\n');
}

// Adapted from convert-source-map (MIT)
function toComment(sourceMap) {
	// eslint-disable-next-line no-undef
	var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));
	var data = 'sourceMappingURL=data:application/json;charset=utf-8;base64,' + base64;

	return '/*# ' + data + ' */';
}

/***/ }),

/***/ "./node_modules/delegate/src/closest.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var DOCUMENT_NODE_TYPE = 9;

/**
 * A polyfill for Element.matches()
 */
if (typeof Element !== 'undefined' && !Element.prototype.matches) {
    var proto = Element.prototype;

    proto.matches = proto.matchesSelector || proto.mozMatchesSelector || proto.msMatchesSelector || proto.oMatchesSelector || proto.webkitMatchesSelector;
}

/**
 * Finds the closest parent that matches a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @return {Function}
 */
function closest(element, selector) {
    while (element && element.nodeType !== DOCUMENT_NODE_TYPE) {
        if (typeof element.matches === 'function' && element.matches(selector)) {
            return element;
        }
        element = element.parentNode;
    }
}

module.exports = closest;

/***/ }),

/***/ "./node_modules/delegate/src/delegate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var closest = __webpack_require__("./node_modules/delegate/src/closest.js");

/**
 * Delegates event to a selector.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function _delegate(element, selector, type, callback, useCapture) {
    var listenerFn = listener.apply(this, arguments);

    element.addEventListener(type, listenerFn, useCapture);

    return {
        destroy: function destroy() {
            element.removeEventListener(type, listenerFn, useCapture);
        }
    };
}

/**
 * Delegates event to a selector.
 *
 * @param {Element|String|Array} [elements]
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @param {Boolean} useCapture
 * @return {Object}
 */
function delegate(elements, selector, type, callback, useCapture) {
    // Handle the regular Element usage
    if (typeof elements.addEventListener === 'function') {
        return _delegate.apply(null, arguments);
    }

    // Handle Element-less usage, it defaults to global delegation
    if (typeof type === 'function') {
        // Use `document` as the first parameter, then apply arguments
        // This is a short way to .unshift `arguments` without running into deoptimizations
        return _delegate.bind(null, document).apply(null, arguments);
    }

    // Handle Selector-based usage
    if (typeof elements === 'string') {
        elements = document.querySelectorAll(elements);
    }

    // Handle Array-like based usage
    return Array.prototype.map.call(elements, function (element) {
        return _delegate(element, selector, type, callback, useCapture);
    });
}

/**
 * Finds closest match and invokes callback.
 *
 * @param {Element} element
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Function}
 */
function listener(element, selector, type, callback) {
    return function (e) {
        e.delegateTarget = closest(e.target, selector);

        if (e.delegateTarget) {
            callback.call(element, e);
        }
    };
}

module.exports = delegate;

/***/ }),

/***/ "./node_modules/good-listener/src/is.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Check if argument is a HTML element.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.node = function (value) {
  return value !== undefined && value instanceof HTMLElement && value.nodeType === 1;
};

/**
 * Check if argument is a list of HTML elements.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.nodeList = function (value) {
  var type = Object.prototype.toString.call(value);

  return value !== undefined && (type === '[object NodeList]' || type === '[object HTMLCollection]') && 'length' in value && (value.length === 0 || exports.node(value[0]));
};

/**
 * Check if argument is a string.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.string = function (value) {
  return typeof value === 'string' || value instanceof String;
};

/**
 * Check if argument is a function.
 *
 * @param {Object} value
 * @return {Boolean}
 */
exports.fn = function (value) {
  var type = Object.prototype.toString.call(value);

  return type === '[object Function]';
};

/***/ }),

/***/ "./node_modules/good-listener/src/listen.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var is = __webpack_require__("./node_modules/good-listener/src/is.js");
var delegate = __webpack_require__("./node_modules/delegate/src/delegate.js");

/**
 * Validates all params and calls the right
 * listener function based on its target type.
 *
 * @param {String|HTMLElement|HTMLCollection|NodeList} target
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listen(target, type, callback) {
    if (!target && !type && !callback) {
        throw new Error('Missing required arguments');
    }

    if (!is.string(type)) {
        throw new TypeError('Second argument must be a String');
    }

    if (!is.fn(callback)) {
        throw new TypeError('Third argument must be a Function');
    }

    if (is.node(target)) {
        return listenNode(target, type, callback);
    } else if (is.nodeList(target)) {
        return listenNodeList(target, type, callback);
    } else if (is.string(target)) {
        return listenSelector(target, type, callback);
    } else {
        throw new TypeError('First argument must be a String, HTMLElement, HTMLCollection, or NodeList');
    }
}

/**
 * Adds an event listener to a HTML element
 * and returns a remove listener function.
 *
 * @param {HTMLElement} node
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNode(node, type, callback) {
    node.addEventListener(type, callback);

    return {
        destroy: function destroy() {
            node.removeEventListener(type, callback);
        }
    };
}

/**
 * Add an event listener to a list of HTML elements
 * and returns a remove listener function.
 *
 * @param {NodeList|HTMLCollection} nodeList
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenNodeList(nodeList, type, callback) {
    Array.prototype.forEach.call(nodeList, function (node) {
        node.addEventListener(type, callback);
    });

    return {
        destroy: function destroy() {
            Array.prototype.forEach.call(nodeList, function (node) {
                node.removeEventListener(type, callback);
            });
        }
    };
}

/**
 * Add an event listener to a selector
 * and returns a remove listener function.
 *
 * @param {String} selector
 * @param {String} type
 * @param {Function} callback
 * @return {Object}
 */
function listenSelector(selector, type, callback) {
    return delegate(document.body, selector, type, callback);
}

module.exports = listen;

/***/ }),

/***/ "./node_modules/is-buffer/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/*!
 * Determine if an object is a Buffer
 *
 * @author   Feross Aboukhadijeh <https://feross.org>
 * @license  MIT
 */

// The _isBuffer check is for Safari 5-7 support, because it's missing
// Object.prototype.constructor. Remove this eventually
module.exports = function (obj) {
  return obj != null && (isBuffer(obj) || isSlowBuffer(obj) || !!obj._isBuffer);
};

function isBuffer(obj) {
  return !!obj.constructor && typeof obj.constructor.isBuffer === 'function' && obj.constructor.isBuffer(obj);
}

// For Node v0.10 support. Remove this eventually.
function isSlowBuffer(obj) {
  return typeof obj.readFloatLE === 'function' && typeof obj.slice === 'function' && isBuffer(obj.slice(0, 0));
}

/***/ }),

/***/ "./node_modules/process/browser.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


// shim for using process in browser
var process = module.exports = {};

// cached from whatever global is present so that test runners that stub it
// don't break things.  But we need to wrap it in a try catch in case it is
// wrapped in strict mode code which doesn't define any globals.  It's inside a
// function because try/catches deoptimize in certain engines.

var cachedSetTimeout;
var cachedClearTimeout;

function defaultSetTimout() {
    throw new Error('setTimeout has not been defined');
}
function defaultClearTimeout() {
    throw new Error('clearTimeout has not been defined');
}
(function () {
    try {
        if (typeof setTimeout === 'function') {
            cachedSetTimeout = setTimeout;
        } else {
            cachedSetTimeout = defaultSetTimout;
        }
    } catch (e) {
        cachedSetTimeout = defaultSetTimout;
    }
    try {
        if (typeof clearTimeout === 'function') {
            cachedClearTimeout = clearTimeout;
        } else {
            cachedClearTimeout = defaultClearTimeout;
        }
    } catch (e) {
        cachedClearTimeout = defaultClearTimeout;
    }
})();
function runTimeout(fun) {
    if (cachedSetTimeout === setTimeout) {
        //normal enviroments in sane situations
        return setTimeout(fun, 0);
    }
    // if setTimeout wasn't available but was latter defined
    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {
        cachedSetTimeout = setTimeout;
        return setTimeout(fun, 0);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedSetTimeout(fun, 0);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally
            return cachedSetTimeout.call(null, fun, 0);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error
            return cachedSetTimeout.call(this, fun, 0);
        }
    }
}
function runClearTimeout(marker) {
    if (cachedClearTimeout === clearTimeout) {
        //normal enviroments in sane situations
        return clearTimeout(marker);
    }
    // if clearTimeout wasn't available but was latter defined
    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {
        cachedClearTimeout = clearTimeout;
        return clearTimeout(marker);
    }
    try {
        // when when somebody has screwed with setTimeout but no I.E. maddness
        return cachedClearTimeout(marker);
    } catch (e) {
        try {
            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally
            return cachedClearTimeout.call(null, marker);
        } catch (e) {
            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.
            // Some versions of I.E. have different rules for clearTimeout vs setTimeout
            return cachedClearTimeout.call(this, marker);
        }
    }
}
var queue = [];
var draining = false;
var currentQueue;
var queueIndex = -1;

function cleanUpNextTick() {
    if (!draining || !currentQueue) {
        return;
    }
    draining = false;
    if (currentQueue.length) {
        queue = currentQueue.concat(queue);
    } else {
        queueIndex = -1;
    }
    if (queue.length) {
        drainQueue();
    }
}

function drainQueue() {
    if (draining) {
        return;
    }
    var timeout = runTimeout(cleanUpNextTick);
    draining = true;

    var len = queue.length;
    while (len) {
        currentQueue = queue;
        queue = [];
        while (++queueIndex < len) {
            if (currentQueue) {
                currentQueue[queueIndex].run();
            }
        }
        queueIndex = -1;
        len = queue.length;
    }
    currentQueue = null;
    draining = false;
    runClearTimeout(timeout);
}

process.nextTick = function (fun) {
    var args = new Array(arguments.length - 1);
    if (arguments.length > 1) {
        for (var i = 1; i < arguments.length; i++) {
            args[i - 1] = arguments[i];
        }
    }
    queue.push(new Item(fun, args));
    if (queue.length === 1 && !draining) {
        runTimeout(drainQueue);
    }
};

// v8 likes predictible objects
function Item(fun, array) {
    this.fun = fun;
    this.array = array;
}
Item.prototype.run = function () {
    this.fun.apply(null, this.array);
};
process.title = 'browser';
process.browser = true;
process.env = {};
process.argv = [];
process.version = ''; // empty string to avoid regexp issues
process.versions = {};

function noop() {}

process.on = noop;
process.addListener = noop;
process.once = noop;
process.off = noop;
process.removeListener = noop;
process.removeAllListeners = noop;
process.emit = noop;
process.prependListener = noop;
process.prependOnceListener = noop;

process.listeners = function (name) {
    return [];
};

process.binding = function (name) {
    throw new Error('process.binding is not supported');
};

process.cwd = function () {
    return '/';
};
process.chdir = function (dir) {
    throw new Error('process.chdir is not supported');
};
process.umask = function () {
    return 0;
};

/***/ }),

/***/ "./node_modules/select/src/select.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function select(element) {
    var selectedText;

    if (element.nodeName === 'SELECT') {
        element.focus();

        selectedText = element.value;
    } else if (element.nodeName === 'INPUT' || element.nodeName === 'TEXTAREA') {
        var isReadOnly = element.hasAttribute('readonly');

        if (!isReadOnly) {
            element.setAttribute('readonly', '');
        }

        element.select();
        element.setSelectionRange(0, element.value.length);

        if (!isReadOnly) {
            element.removeAttribute('readonly');
        }

        selectedText = element.value;
    } else {
        if (element.hasAttribute('contenteditable')) {
            element.focus();
        }

        var selection = window.getSelection();
        var range = document.createRange();

        range.selectNodeContents(element);
        selection.removeAllRanges();
        selection.addRange(range);

        selectedText = selection.toString();
    }

    return selectedText;
}

module.exports = select;

/***/ }),

/***/ "./node_modules/setimmediate/setImmediate.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, process) {

(function (global, undefined) {
    "use strict";

    if (global.setImmediate) {
        return;
    }

    var nextHandle = 1; // Spec says greater than zero
    var tasksByHandle = {};
    var currentlyRunningATask = false;
    var doc = global.document;
    var registerImmediate;

    function setImmediate(callback) {
        // Callback can either be a function or a string
        if (typeof callback !== "function") {
            callback = new Function("" + callback);
        }
        // Copy function arguments
        var args = new Array(arguments.length - 1);
        for (var i = 0; i < args.length; i++) {
            args[i] = arguments[i + 1];
        }
        // Store and register the task
        var task = { callback: callback, args: args };
        tasksByHandle[nextHandle] = task;
        registerImmediate(nextHandle);
        return nextHandle++;
    }

    function clearImmediate(handle) {
        delete tasksByHandle[handle];
    }

    function run(task) {
        var callback = task.callback;
        var args = task.args;
        switch (args.length) {
            case 0:
                callback();
                break;
            case 1:
                callback(args[0]);
                break;
            case 2:
                callback(args[0], args[1]);
                break;
            case 3:
                callback(args[0], args[1], args[2]);
                break;
            default:
                callback.apply(undefined, args);
                break;
        }
    }

    function runIfPresent(handle) {
        // From the spec: "Wait until any invocations of this algorithm started before this one have completed."
        // So if we're currently running a task, we'll need to delay this invocation.
        if (currentlyRunningATask) {
            // Delay by doing a setTimeout. setImmediate was tried instead, but in Firefox 7 it generated a
            // "too much recursion" error.
            setTimeout(runIfPresent, 0, handle);
        } else {
            var task = tasksByHandle[handle];
            if (task) {
                currentlyRunningATask = true;
                try {
                    run(task);
                } finally {
                    clearImmediate(handle);
                    currentlyRunningATask = false;
                }
            }
        }
    }

    function installNextTickImplementation() {
        registerImmediate = function registerImmediate(handle) {
            process.nextTick(function () {
                runIfPresent(handle);
            });
        };
    }

    function canUsePostMessage() {
        // The test against `importScripts` prevents this implementation from being installed inside a web worker,
        // where `global.postMessage` means something completely different and can't be used for this purpose.
        if (global.postMessage && !global.importScripts) {
            var postMessageIsAsynchronous = true;
            var oldOnMessage = global.onmessage;
            global.onmessage = function () {
                postMessageIsAsynchronous = false;
            };
            global.postMessage("", "*");
            global.onmessage = oldOnMessage;
            return postMessageIsAsynchronous;
        }
    }

    function installPostMessageImplementation() {
        // Installs an event handler on `global` for the `message` event: see
        // * https://developer.mozilla.org/en/DOM/window.postMessage
        // * http://www.whatwg.org/specs/web-apps/current-work/multipage/comms.html#crossDocumentMessages

        var messagePrefix = "setImmediate$" + Math.random() + "$";
        var onGlobalMessage = function onGlobalMessage(event) {
            if (event.source === global && typeof event.data === "string" && event.data.indexOf(messagePrefix) === 0) {
                runIfPresent(+event.data.slice(messagePrefix.length));
            }
        };

        if (global.addEventListener) {
            global.addEventListener("message", onGlobalMessage, false);
        } else {
            global.attachEvent("onmessage", onGlobalMessage);
        }

        registerImmediate = function registerImmediate(handle) {
            global.postMessage(messagePrefix + handle, "*");
        };
    }

    function installMessageChannelImplementation() {
        var channel = new MessageChannel();
        channel.port1.onmessage = function (event) {
            var handle = event.data;
            runIfPresent(handle);
        };

        registerImmediate = function registerImmediate(handle) {
            channel.port2.postMessage(handle);
        };
    }

    function installReadyStateChangeImplementation() {
        var html = doc.documentElement;
        registerImmediate = function registerImmediate(handle) {
            // Create a <script> element; its readystatechange event will be fired asynchronously once it is inserted
            // into the document. Do so, thus queuing up the task. Remember to clean up once it's been called.
            var script = doc.createElement("script");
            script.onreadystatechange = function () {
                runIfPresent(handle);
                script.onreadystatechange = null;
                html.removeChild(script);
                script = null;
            };
            html.appendChild(script);
        };
    }

    function installSetTimeoutImplementation() {
        registerImmediate = function registerImmediate(handle) {
            setTimeout(runIfPresent, 0, handle);
        };
    }

    // If supported, we should attach to the prototype of global, since that is where setTimeout et al. live.
    var attachTo = Object.getPrototypeOf && Object.getPrototypeOf(global);
    attachTo = attachTo && attachTo.setTimeout ? attachTo : global;

    // Don't get fooled by e.g. browserify environments.
    if ({}.toString.call(global.process) === "[object process]") {
        // For Node.js before 0.9
        installNextTickImplementation();
    } else if (canUsePostMessage()) {
        // For non-IE10 modern browsers
        installPostMessageImplementation();
    } else if (global.MessageChannel) {
        // For web workers, where supported
        installMessageChannelImplementation();
    } else if (doc && "onreadystatechange" in doc.createElement("script")) {
        // For IE 68
        installReadyStateChangeImplementation();
    } else {
        // For older browsers
        installSetTimeoutImplementation();
    }

    attachTo.setImmediate = setImmediate;
    attachTo.clearImmediate = clearImmediate;
})(typeof self === "undefined" ? typeof global === "undefined" ? undefined : global : self);
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/process/browser.js")))

/***/ }),

/***/ "./node_modules/style-loader/lib/addStyles.js":
/***/ (function(module, exports, __webpack_require__) {

/*
	MIT License http://www.opensource.org/licenses/mit-license.php
	Author Tobias Koppers @sokra
*/

var stylesInDom = {};

var	memoize = function (fn) {
	var memo;

	return function () {
		if (typeof memo === "undefined") memo = fn.apply(this, arguments);
		return memo;
	};
};

var isOldIE = memoize(function () {
	// Test for IE <= 9 as proposed by Browserhacks
	// @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805
	// Tests for existence of standard globals is to allow style-loader
	// to operate correctly into non-standard environments
	// @see https://github.com/webpack-contrib/style-loader/issues/177
	return window && document && document.all && !window.atob;
});

var getElement = (function (fn) {
	var memo = {};

	return function(selector) {
		if (typeof memo[selector] === "undefined") {
			memo[selector] = fn.call(this, selector);
		}

		return memo[selector]
	};
})(function (target) {
	return document.querySelector(target)
});

var singleton = null;
var	singletonCounter = 0;
var	stylesInsertedAtTop = [];

var	fixUrls = __webpack_require__("./node_modules/style-loader/lib/urls.js");

module.exports = function(list, options) {
	if (typeof DEBUG !== "undefined" && DEBUG) {
		if (typeof document !== "object") throw new Error("The style-loader cannot be used in a non-browser environment");
	}

	options = options || {};

	options.attrs = typeof options.attrs === "object" ? options.attrs : {};

	// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
	// tags it will allow on a page
	if (!options.singleton) options.singleton = isOldIE();

	// By default, add <style> tags to the <head> element
	if (!options.insertInto) options.insertInto = "head";

	// By default, add <style> tags to the bottom of the target
	if (!options.insertAt) options.insertAt = "bottom";

	var styles = listToStyles(list, options);

	addStylesToDom(styles, options);

	return function update (newList) {
		var mayRemove = [];

		for (var i = 0; i < styles.length; i++) {
			var item = styles[i];
			var domStyle = stylesInDom[item.id];

			domStyle.refs--;
			mayRemove.push(domStyle);
		}

		if(newList) {
			var newStyles = listToStyles(newList, options);
			addStylesToDom(newStyles, options);
		}

		for (var i = 0; i < mayRemove.length; i++) {
			var domStyle = mayRemove[i];

			if(domStyle.refs === 0) {
				for (var j = 0; j < domStyle.parts.length; j++) domStyle.parts[j]();

				delete stylesInDom[domStyle.id];
			}
		}
	};
};

function addStylesToDom (styles, options) {
	for (var i = 0; i < styles.length; i++) {
		var item = styles[i];
		var domStyle = stylesInDom[item.id];

		if(domStyle) {
			domStyle.refs++;

			for(var j = 0; j < domStyle.parts.length; j++) {
				domStyle.parts[j](item.parts[j]);
			}

			for(; j < item.parts.length; j++) {
				domStyle.parts.push(addStyle(item.parts[j], options));
			}
		} else {
			var parts = [];

			for(var j = 0; j < item.parts.length; j++) {
				parts.push(addStyle(item.parts[j], options));
			}

			stylesInDom[item.id] = {id: item.id, refs: 1, parts: parts};
		}
	}
}

function listToStyles (list, options) {
	var styles = [];
	var newStyles = {};

	for (var i = 0; i < list.length; i++) {
		var item = list[i];
		var id = options.base ? item[0] + options.base : item[0];
		var css = item[1];
		var media = item[2];
		var sourceMap = item[3];
		var part = {css: css, media: media, sourceMap: sourceMap};

		if(!newStyles[id]) styles.push(newStyles[id] = {id: id, parts: [part]});
		else newStyles[id].parts.push(part);
	}

	return styles;
}

function insertStyleElement (options, style) {
	var target = getElement(options.insertInto)

	if (!target) {
		throw new Error("Couldn't find a style target. This probably means that the value for the 'insertInto' parameter is invalid.");
	}

	var lastStyleElementInsertedAtTop = stylesInsertedAtTop[stylesInsertedAtTop.length - 1];

	if (options.insertAt === "top") {
		if (!lastStyleElementInsertedAtTop) {
			target.insertBefore(style, target.firstChild);
		} else if (lastStyleElementInsertedAtTop.nextSibling) {
			target.insertBefore(style, lastStyleElementInsertedAtTop.nextSibling);
		} else {
			target.appendChild(style);
		}
		stylesInsertedAtTop.push(style);
	} else if (options.insertAt === "bottom") {
		target.appendChild(style);
	} else {
		throw new Error("Invalid value for parameter 'insertAt'. Must be 'top' or 'bottom'.");
	}
}

function removeStyleElement (style) {
	if (style.parentNode === null) return false;
	style.parentNode.removeChild(style);

	var idx = stylesInsertedAtTop.indexOf(style);
	if(idx >= 0) {
		stylesInsertedAtTop.splice(idx, 1);
	}
}

function createStyleElement (options) {
	var style = document.createElement("style");

	options.attrs.type = "text/css";

	addAttrs(style, options.attrs);
	insertStyleElement(options, style);

	return style;
}

function createLinkElement (options) {
	var link = document.createElement("link");

	options.attrs.type = "text/css";
	options.attrs.rel = "stylesheet";

	addAttrs(link, options.attrs);
	insertStyleElement(options, link);

	return link;
}

function addAttrs (el, attrs) {
	Object.keys(attrs).forEach(function (key) {
		el.setAttribute(key, attrs[key]);
	});
}

function addStyle (obj, options) {
	var style, update, remove, result;

	// If a transform function was defined, run it on the css
	if (options.transform && obj.css) {
	    result = options.transform(obj.css);

	    if (result) {
	    	// If transform returns a value, use that instead of the original css.
	    	// This allows running runtime transformations on the css.
	    	obj.css = result;
	    } else {
	    	// If the transform function returns a falsy value, don't add this css.
	    	// This allows conditional loading of css
	    	return function() {
	    		// noop
	    	};
	    }
	}

	if (options.singleton) {
		var styleIndex = singletonCounter++;

		style = singleton || (singleton = createStyleElement(options));

		update = applyToSingletonTag.bind(null, style, styleIndex, false);
		remove = applyToSingletonTag.bind(null, style, styleIndex, true);

	} else if (
		obj.sourceMap &&
		typeof URL === "function" &&
		typeof URL.createObjectURL === "function" &&
		typeof URL.revokeObjectURL === "function" &&
		typeof Blob === "function" &&
		typeof btoa === "function"
	) {
		style = createLinkElement(options);
		update = updateLink.bind(null, style, options);
		remove = function () {
			removeStyleElement(style);

			if(style.href) URL.revokeObjectURL(style.href);
		};
	} else {
		style = createStyleElement(options);
		update = applyToTag.bind(null, style);
		remove = function () {
			removeStyleElement(style);
		};
	}

	update(obj);

	return function updateStyle (newObj) {
		if (newObj) {
			if (
				newObj.css === obj.css &&
				newObj.media === obj.media &&
				newObj.sourceMap === obj.sourceMap
			) {
				return;
			}

			update(obj = newObj);
		} else {
			remove();
		}
	};
}

var replaceText = (function () {
	var textStore = [];

	return function (index, replacement) {
		textStore[index] = replacement;

		return textStore.filter(Boolean).join('\n');
	};
})();

function applyToSingletonTag (style, index, remove, obj) {
	var css = remove ? "" : obj.css;

	if (style.styleSheet) {
		style.styleSheet.cssText = replaceText(index, css);
	} else {
		var cssNode = document.createTextNode(css);
		var childNodes = style.childNodes;

		if (childNodes[index]) style.removeChild(childNodes[index]);

		if (childNodes.length) {
			style.insertBefore(cssNode, childNodes[index]);
		} else {
			style.appendChild(cssNode);
		}
	}
}

function applyToTag (style, obj) {
	var css = obj.css;
	var media = obj.media;

	if(media) {
		style.setAttribute("media", media)
	}

	if(style.styleSheet) {
		style.styleSheet.cssText = css;
	} else {
		while(style.firstChild) {
			style.removeChild(style.firstChild);
		}

		style.appendChild(document.createTextNode(css));
	}
}

function updateLink (link, options, obj) {
	var css = obj.css;
	var sourceMap = obj.sourceMap;

	/*
		If convertToAbsoluteUrls isn't defined, but sourcemaps are enabled
		and there is no publicPath defined then lets turn convertToAbsoluteUrls
		on by default.  Otherwise default to the convertToAbsoluteUrls option
		directly
	*/
	var autoFixUrls = options.convertToAbsoluteUrls === undefined && sourceMap;

	if (options.convertToAbsoluteUrls || autoFixUrls) {
		css = fixUrls(css);
	}

	if (sourceMap) {
		// http://stackoverflow.com/a/26603875
		css += "\n/*# sourceMappingURL=data:application/json;base64," + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + " */";
	}

	var blob = new Blob([css], { type: "text/css" });

	var oldSrc = link.href;

	link.href = URL.createObjectURL(blob);

	if(oldSrc) URL.revokeObjectURL(oldSrc);
}


/***/ }),

/***/ "./node_modules/style-loader/lib/urls.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * When source maps are enabled, `style-loader` uses a link element with a data-uri to
 * embed the css on the page. This breaks all relative urls because now they are relative to a
 * bundle instead of the current page.
 *
 * One solution is to only use full urls, but that may be impossible.
 *
 * Instead, this function "fixes" the relative urls to be absolute according to the current page location.
 *
 * A rudimentary test suite is located at `test/fixUrls.js` and can be run via the `npm test` command.
 *
 */

module.exports = function (css) {
	// get current location
	var location = typeof window !== "undefined" && window.location;

	if (!location) {
		throw new Error("fixUrls requires window.location");
	}

	// blank or null?
	if (!css || typeof css !== "string") {
		return css;
	}

	var baseUrl = location.protocol + "//" + location.host;
	var currentDir = baseUrl + location.pathname.replace(/\/[^\/]*$/, "/");

	// convert each url(...)
	/*
 This regular expression is just a way to recursively match brackets within
 a string.
 	 /url\s*\(  = Match on the word "url" with any whitespace after it and then a parens
    (  = Start a capturing group
      (?:  = Start a non-capturing group
          [^)(]  = Match anything that isn't a parentheses
          |  = OR
          \(  = Match a start parentheses
              (?:  = Start another non-capturing groups
                  [^)(]+  = Match anything that isn't a parentheses
                  |  = OR
                  \(  = Match a start parentheses
                      [^)(]*  = Match anything that isn't a parentheses
                  \)  = Match a end parentheses
              )  = End Group
              *\) = Match anything and then a close parens
          )  = Close non-capturing group
          *  = Match anything
       )  = Close capturing group
  \)  = Match a close parens
 	 /gi  = Get all matches, not the first.  Be case insensitive.
  */
	var fixedCss = css.replace(/url\s*\(((?:[^)(]|\((?:[^)(]+|\([^)(]*\))*\))*)\)/gi, function (fullMatch, origUrl) {
		// strip quotes (if they exist)
		var unquotedOrigUrl = origUrl.trim().replace(/^"(.*)"$/, function (o, $1) {
			return $1;
		}).replace(/^'(.*)'$/, function (o, $1) {
			return $1;
		});

		// already a full url? no change
		if (/^(#|data:|http:\/\/|https:\/\/|file:\/\/\/)/i.test(unquotedOrigUrl)) {
			return fullMatch;
		}

		// convert the url to a full url
		var newUrl;

		if (unquotedOrigUrl.indexOf("//") === 0) {
			//TODO: should we add protocol?
			newUrl = unquotedOrigUrl;
		} else if (unquotedOrigUrl.indexOf("/") === 0) {
			// path should be relative to the base url
			newUrl = baseUrl + unquotedOrigUrl; // already starts with '/'
		} else {
			// path should be relative to current directory
			newUrl = currentDir + unquotedOrigUrl.replace(/^\.\//, ""); // Strip leading './'
		}

		// send back the fixed url(...)
		return "url(" + JSON.stringify(newUrl) + ")";
	});

	// send back the fixed css
	return fixedCss;
};

/***/ }),

/***/ "./node_modules/timers-browserify/main.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var apply = Function.prototype.apply;

// DOM APIs, for completeness

exports.setTimeout = function () {
  return new Timeout(apply.call(setTimeout, window, arguments), clearTimeout);
};
exports.setInterval = function () {
  return new Timeout(apply.call(setInterval, window, arguments), clearInterval);
};
exports.clearTimeout = exports.clearInterval = function (timeout) {
  if (timeout) {
    timeout.close();
  }
};

function Timeout(id, clearFn) {
  this._id = id;
  this._clearFn = clearFn;
}
Timeout.prototype.unref = Timeout.prototype.ref = function () {};
Timeout.prototype.close = function () {
  this._clearFn.call(window, this._id);
};

// Does not start the time, just sets up the members needed.
exports.enroll = function (item, msecs) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = msecs;
};

exports.unenroll = function (item) {
  clearTimeout(item._idleTimeoutId);
  item._idleTimeout = -1;
};

exports._unrefActive = exports.active = function (item) {
  clearTimeout(item._idleTimeoutId);

  var msecs = item._idleTimeout;
  if (msecs >= 0) {
    item._idleTimeoutId = setTimeout(function onTimeout() {
      if (item._onTimeout) item._onTimeout();
    }, msecs);
  }
};

// setimmediate attaches itself to the global object
__webpack_require__("./node_modules/setimmediate/setImmediate.js");
exports.setImmediate = setImmediate;
exports.clearImmediate = clearImmediate;

/***/ }),

/***/ "./node_modules/tiny-emitter/index.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


function E() {
  // Keep this empty so it's easier to inherit from
  // (via https://github.com/lipsmack from https://github.com/scottcorgan/tiny-emitter/issues/3)
}

E.prototype = {
  on: function on(name, callback, ctx) {
    var e = this.e || (this.e = {});

    (e[name] || (e[name] = [])).push({
      fn: callback,
      ctx: ctx
    });

    return this;
  },

  once: function once(name, callback, ctx) {
    var self = this;
    function listener() {
      self.off(name, listener);
      callback.apply(ctx, arguments);
    };

    listener._ = callback;
    return this.on(name, listener, ctx);
  },

  emit: function emit(name) {
    var data = [].slice.call(arguments, 1);
    var evtArr = ((this.e || (this.e = {}))[name] || []).slice();
    var i = 0;
    var len = evtArr.length;

    for (i; i < len; i++) {
      evtArr[i].fn.apply(evtArr[i].ctx, data);
    }

    return this;
  },

  off: function off(name, callback) {
    var e = this.e || (this.e = {});
    var evts = e[name];
    var liveEvents = [];

    if (evts && callback) {
      for (var i = 0, len = evts.length; i < len; i++) {
        if (evts[i].fn !== callback && evts[i].fn._ !== callback) liveEvents.push(evts[i]);
      }
    }

    // Remove event from queue to prevent memory leak
    // Suggested by https://github.com/lazd
    // Ref: https://github.com/scottcorgan/tiny-emitter/commit/c6ebfaa9bc973b33d110a84a307742b7cf94c953#commitcomment-5024910

    liveEvents.length ? e[name] = liveEvents : delete e[name];

    return this;
  }
};

module.exports = E;

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.css":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js!./node_modules/tippy.js/dist/tippy.css");
if(typeof content === 'string') content = [[module.i, content, '']];
// Prepare cssTransformation
var transform;

var options = {}
options.transform = transform
// add the styles to the DOM
var update = __webpack_require__("./node_modules/style-loader/lib/addStyles.js")(content, options);
if(content.locals) module.exports = content.locals;
// Hot Module Replacement
if(false) {
	// When the styles change, update the <style> tags
	if(!content.locals) {
		module.hot.accept("!!../../css-loader/index.js!./tippy.css", function() {
			var newContent = require("!!../../css-loader/index.js!./tippy.css");
			if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
			update(newContent);
		});
	}
	// When the module is disposed, remove the <style> tags
	module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/tippy.js/dist/tippy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global) {var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global.tippy = factory();
})(undefined, function () {
  'use strict';

  var Browser = {};

  if (typeof window !== 'undefined') {
    Browser.SUPPORTED = 'requestAnimationFrame' in window;
    Browser.SUPPORTS_TOUCH = 'ontouchstart' in window;
    Browser.touch = false;
    Browser.dynamicInputDetection = true;
    // Chrome device/touch emulation can make this dynamic
    Browser.iOS = function () {
      return (/iPhone|iPad|iPod/.test(navigator.userAgent) && !window.MSStream
      );
    };
  }

  /**
  * The global storage array which holds all data reference objects
  * from every instance
  * This allows us to hide tooltips from all instances, finding the ref when
  * clicking on the body, and for followCursor
  */
  var Store = [];

  /**
  * Selector constants used for grabbing elements
  */
  var Selectors = {
    POPPER: '.tippy-popper',
    TOOLTIP: '.tippy-tooltip',
    CONTENT: '.tippy-tooltip-content',
    CIRCLE: '[x-circle]',
    ARROW: '[x-arrow]',
    TOOLTIPPED_EL: '[data-tooltipped]',
    CONTROLLER: '[data-tippy-controller]'

    /**
    * The default settings applied to each instance
    */
  };var Defaults = {
    html: false,
    position: 'top',
    animation: 'shift',
    animateFill: true,
    arrow: false,
    arrowSize: 'regular',
    delay: 0,
    trigger: 'mouseenter focus',
    duration: 350,
    interactive: false,
    interactiveBorder: 2,
    theme: 'dark',
    size: 'regular',
    distance: 10,
    offset: 0,
    hideOnClick: true,
    multiple: false,
    followCursor: false,
    inertia: false,
    flipDuration: 350,
    sticky: false,
    stickyDuration: 200,
    appendTo: function appendTo() {
      return document.body;
    },
    zIndex: 9999,
    touchHold: false,
    performance: false,
    dynamicTitle: false,
    popperOptions: {}

    /**
    * The keys of the defaults object for reducing down into a new object
    * Used in `getIndividualSettings()`
    */
  };var DefaultsKeys = Browser.SUPPORTED && Object.keys(Defaults);

  /**
  * Hides all poppers
  * @param {Object} exclude - refData to exclude if needed
  */
  function hideAllPoppers(exclude) {
    Store.forEach(function (refData) {
      var popper = refData.popper,
          tippyInstance = refData.tippyInstance,
          _refData$settings = refData.settings,
          appendTo = _refData$settings.appendTo,
          hideOnClick = _refData$settings.hideOnClick,
          trigger = _refData$settings.trigger;

      // Don't hide already hidden ones

      if (!appendTo.contains(popper)) return;

      // hideOnClick can have the truthy value of 'persistent', so strict check is needed
      var isHideOnClick = hideOnClick === true || trigger.indexOf('focus') !== -1;
      var isNotCurrentRef = !exclude || popper !== exclude.popper;

      if (isHideOnClick && isNotCurrentRef) {
        tippyInstance.hide(popper);
      }
    });
  }

  var matches = {};

  if (typeof Element !== 'undefined') {
    var e = Element.prototype;
    matches = e.matches || e.matchesSelector || e.webkitMatchesSelector || e.mozMatchesSelector || e.msMatchesSelector || function (s) {
      var matches = (this.document || this.ownerDocument).querySelectorAll(s),
          i = matches.length;
      while (--i >= 0 && matches.item(i) !== this) {}
      return i > -1;
    };
  }

  var matches$1 = matches;

  /**
  * Ponyfill to get the closest parent element
  * @param {Element} element - child of parent to be returned
  * @param {String} parentSelector - selector to match the parent if found
  * @return {Element}
  */
  function closest(element, parentSelector) {
    var _closest = Element.prototype.closest || function (selector) {
      var el = this;
      while (el) {
        if (matches$1.call(el, selector)) {
          return el;
        }
        el = el.parentElement;
      }
    };

    return _closest.call(element, parentSelector);
  }

  /**
  * Ponyfill for Array.prototype.find
  * @param {Array} arr
  * @param {Function} checkFn
  * @return item in the array
  */
  function find(arr, checkFn) {
    if (Array.prototype.find) {
      return arr.find(checkFn);
    }

    // use `filter` as fallback
    return arr.filter(checkFn)[0];
  }

  /**
  * Adds the needed event listeners
  */
  function bindEventListeners() {
    var touchHandler = function touchHandler() {
      Browser.touch = true;

      if (Browser.iOS()) {
        document.body.classList.add('tippy-touch');
      }

      if (Browser.dynamicInputDetection && window.performance) {
        document.addEventListener('mousemove', mousemoveHandler);
      }
    };

    var mousemoveHandler = function () {
      var time = void 0;

      return function () {
        var now = performance.now();

        // Chrome 60+ is 1 mousemove per rAF, use 20ms time difference
        if (now - time < 20) {
          Browser.touch = false;
          document.removeEventListener('mousemove', mousemoveHandler);
          if (!Browser.iOS()) {
            document.body.classList.remove('tippy-touch');
          }
        }

        time = now;
      };
    }();

    var clickHandler = function clickHandler(event) {
      // Simulated events dispatched on the document
      if (!(event.target instanceof Element)) {
        return hideAllPoppers();
      }

      var el = closest(event.target, Selectors.TOOLTIPPED_EL);
      var popper = closest(event.target, Selectors.POPPER);

      if (popper) {
        var ref = find(Store, function (ref) {
          return ref.popper === popper;
        });
        var interactive = ref.settings.interactive;

        if (interactive) return;
      }

      if (el) {
        var _ref = find(Store, function (ref) {
          return ref.el === el;
        });
        var _ref$settings = _ref.settings,
            hideOnClick = _ref$settings.hideOnClick,
            multiple = _ref$settings.multiple,
            trigger = _ref$settings.trigger;

        // Hide all poppers except the one belonging to the element that was clicked IF
        // `multiple` is false AND they are a touch user, OR
        // `multiple` is false AND it's triggered by a click

        if (!multiple && Browser.touch || !multiple && trigger.indexOf('click') !== -1) {
          return hideAllPoppers(_ref);
        }

        // If hideOnClick is not strictly true or triggered by a click don't hide poppers
        if (hideOnClick !== true || trigger.indexOf('click') !== -1) return;
      }

      // Don't trigger a hide for tippy controllers, and don't needlessly run loop
      if (closest(event.target, Selectors.CONTROLLER) || !document.querySelector(Selectors.POPPER)) return;

      hideAllPoppers();
    };

    var blurHandler = function blurHandler(event) {
      var _document = document,
          el = _document.activeElement;

      if (el && el.blur && matches$1.call(el, Selectors.TOOLTIPPED_EL)) {
        el.blur();
      }
    };

    // Hook events
    document.addEventListener('click', clickHandler);
    document.addEventListener('touchstart', touchHandler);
    window.addEventListener('blur', blurHandler);

    if (!Browser.SUPPORTS_TOUCH && (navigator.maxTouchPoints > 0 || navigator.msMaxTouchPoints > 0)) {
      document.addEventListener('pointerdown', touchHandler);
    }
  }

  /**
  * To run a single time, once DOM is presumed to be ready
  * @return {Boolean} whether the function has run or not
  */
  function init() {
    if (init.done) return false;
    init.done = true;

    bindEventListeners();

    return true;
  }

  /**
  * Waits until next repaint to execute a fn
  * @param {Function} fn
  */
  function defer(fn) {
    window.requestAnimationFrame(function () {
      setTimeout(fn, 0);
    });
  }

  /**
  * Returns the supported prefixed property - only `webkit` is needed, `moz`, `ms` and `o` are obsolete
  * @param {String} property
  * @return {String} - browser supported prefixed property
  */
  function prefix(property) {
    var prefixes = [false, 'webkit'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length; i++) {
      var _prefix = prefixes[i];
      var prefixedProp = _prefix ? '' + _prefix + upperProp : property;
      if (typeof window.document.body.style[prefixedProp] !== 'undefined') {
        return prefixedProp;
      }
    }

    return null;
  }

  /**
  * Ponyfill for Array.prototype.findIndex
  * @param {Array} arr
  * @param {Function} checkFn
  * @return index of the item in the array
  */
  function findIndex(arr, checkFn) {
    if (Array.prototype.findIndex) {
      return arr.findIndex(checkFn);
    }

    // fallback
    return arr.indexOf(find(arr, checkFn));
  }

  /**
  * Removes the title from the tooltipped element, setting `data-original-title`
  * appropriately
  * @param {Element} el
  */
  function removeTitle(el) {
    var title = el.getAttribute('title');

    // Only set `data-original-title` attr if there is a title
    if (title) {
      el.setAttribute('data-original-title', title);
    }

    el.removeAttribute('title');
  }

  /**
  * Determines if an element is visible in the viewport
  * @param {Element} el
  * @return {Boolean}
  */
  function elementIsInViewport(el) {
    var rect = el.getBoundingClientRect();

    return rect.top >= 0 && rect.left >= 0 && rect.bottom <= (window.innerHeight || document.documentElement.clientHeight) && rect.right <= (window.innerWidth || document.documentElement.clientWidth);
  }

  /**
  * Triggers a document repaint or reflow for CSS transition
  * @param {Element} tooltip
  * @param {Element} circle
  */
  function triggerReflow(tooltip, circle) {
    // Safari needs the specific 'transform' property to be accessed
    circle ? window.getComputedStyle(circle)[prefix('transform')] : window.getComputedStyle(tooltip).opacity;
  }

  /**
  * Modifies elements' class lists
  * @param {Element[]} els - Array of elements
  * @param {Function} callback
  */
  function modifyClassList(els, callback) {
    els.forEach(function (el) {
      if (!el) return;
      callback(el.classList);
    });
  }

  /**
  * Returns inner elements of the popper element
  * @param {Element} popper
  * @return {Object}
  */
  function getInnerElements(popper) {
    return {
      tooltip: popper.querySelector(Selectors.TOOLTIP),
      circle: popper.querySelector(Selectors.CIRCLE),
      content: popper.querySelector(Selectors.CONTENT)
    };
  }

  /**
  * Applies the transition duration to each element
  * @param {Element[]} els - Array of elements
  * @param {Number} duration
  */
  function applyTransitionDuration(els, duration) {
    els.forEach(function (el) {
      if (!el) return;

      var isContent = matches$1.call(el, Selectors.CONTENT);

      var _duration = isContent ? Math.round(duration / 1.3) : duration;

      el.style[prefix('transitionDuration')] = _duration + 'ms';
    });
  }

  /**
  * Determines if a popper is currently visible
  * @param {Element} popper
  * @return {Boolean}
  */
  function isVisible(popper) {
    return popper.style.visibility === 'visible';
  }

  function noop() {}

  function isObjectLiteral(input) {
    return !!input && input.toString() === '[object Object]';
  }

  /**
  * Returns the non-shifted placement (e.g., 'bottom-start' => 'bottom')
  * @param {String} placement
  * @return {String}
  */
  function getCorePlacement(placement) {
    return placement.replace(/-.+/, '');
  }

  /**
  * Mousemove event listener callback method for follow cursor setting
  * @param {MouseEvent} e
  */
  function followCursorHandler(e) {
    var _this = this;

    var data = find(Store, function (data) {
      return data.el === _this;
    });

    var popper = data.popper,
        offset = data.settings.offset;

    var position = getCorePlacement(popper.getAttribute('x-placement'));
    var halfPopperWidth = Math.round(popper.offsetWidth / 2);
    var halfPopperHeight = Math.round(popper.offsetHeight / 2);
    var viewportPadding = 5;
    var pageWidth = document.documentElement.offsetWidth || document.body.offsetWidth;

    var pageX = e.pageX,
        pageY = e.pageY;

    var x = void 0,
        y = void 0;

    switch (position) {
      case 'top':
        x = pageX - halfPopperWidth + offset;
        y = pageY - 2 * halfPopperHeight;
        break;
      case 'bottom':
        x = pageX - halfPopperWidth + offset;
        y = pageY + 10;
        break;
      case 'left':
        x = pageX - 2 * halfPopperWidth;
        y = pageY - halfPopperHeight + offset;
        break;
      case 'right':
        x = pageX + 5;
        y = pageY - halfPopperHeight + offset;
        break;
    }

    var isRightOverflowing = pageX + viewportPadding + halfPopperWidth + offset > pageWidth;
    var isLeftOverflowing = pageX - viewportPadding - halfPopperWidth + offset < 0;

    // Prevent left/right overflow
    if (position === 'top' || position === 'bottom') {
      if (isRightOverflowing) {
        x = pageWidth - viewportPadding - 2 * halfPopperWidth;
      }

      if (isLeftOverflowing) {
        x = viewportPadding;
      }
    }

    popper.style[prefix('transform')] = 'translate3d(' + x + 'px, ' + y + 'px, 0)';
  }

  /**
  * Returns an array of elements based on the selector input
  * @param {String|Element|Element[]} selector
  * @return {Element[]}
  */
  function getArrayOfElements(selector) {
    if (selector instanceof Element || isObjectLiteral(selector)) {
      return [selector];
    }

    if (selector instanceof NodeList) {
      return [].slice.call(selector);
    }

    if (Array.isArray(selector)) {
      return selector;
    }

    try {
      return [].slice.call(document.querySelectorAll(selector));
    } catch (_) {
      return [];
    }
  }

  /**
  * Prepares the callback functions for `show` and `hide` methods
  * @param {Object} data
  * @param {Number} duration
  * @param {Function} callback - callback function to fire once transitions complete
  */
  function onTransitionEnd(data, duration, callback) {
    // Make callback synchronous if duration is 0
    if (!duration) {
      return callback();
    }

    var _getInnerElements = getInnerElements(data.popper),
        tooltip = _getInnerElements.tooltip;

    var transitionendFired = false;

    var listeners = function listeners(action) {
      tooltip[action + 'EventListener']('webkitTransitionEnd', listenerCallback);
      tooltip[action + 'EventListener']('transitionend', listenerCallback);
    };

    var listenerCallback = function listenerCallback(e) {
      if (e.target === tooltip && !transitionendFired) {
        transitionendFired = true;
        listeners('remove');
        callback();
      }
    };

    // Fire callback upon transition completion
    listeners('add');

    // Fallback: transitionend listener sometimes may not fire
    clearTimeout(data._transitionendTimeout);
    data._transitionendTimeout = setTimeout(function () {
      if (!transitionendFired) {
        listeners('remove');
        callback();
      }
    }, duration);
  }

  /**!
   * @fileOverview Kickass library to create and place poppers near their reference elements.
   * @version 1.12.9
   * @license
   * Copyright (c) 2016 Federico Zivolo and contributors
   *
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   */
  var isBrowser = typeof window !== 'undefined' && typeof document !== 'undefined';
  var longerTimeoutBrowsers = ['Edge', 'Trident', 'Firefox'];
  var timeoutDuration = 0;
  for (var i = 0; i < longerTimeoutBrowsers.length; i += 1) {
    if (isBrowser && navigator.userAgent.indexOf(longerTimeoutBrowsers[i]) >= 0) {
      timeoutDuration = 1;
      break;
    }
  }

  function microtaskDebounce(fn) {
    var called = false;
    return function () {
      if (called) {
        return;
      }
      called = true;
      window.Promise.resolve().then(function () {
        called = false;
        fn();
      });
    };
  }

  function taskDebounce(fn) {
    var scheduled = false;
    return function () {
      if (!scheduled) {
        scheduled = true;
        setTimeout(function () {
          scheduled = false;
          fn();
        }, timeoutDuration);
      }
    };
  }

  var supportsMicroTasks = isBrowser && window.Promise;

  /**
  * Create a debounced version of a method, that's asynchronously deferred
  * but called in the minimum time possible.
  *
  * @method
  * @memberof Popper.Utils
  * @argument {Function} fn
  * @returns {Function}
  */
  var debounce = supportsMicroTasks ? microtaskDebounce : taskDebounce;

  /**
   * Check if the given variable is a function
   * @method
   * @memberof Popper.Utils
   * @argument {Any} functionToCheck - variable to check
   * @returns {Boolean} answer to: is a function?
   */
  function isFunction(functionToCheck) {
    var getType = {};
    return functionToCheck && getType.toString.call(functionToCheck) === '[object Function]';
  }

  /**
   * Get CSS computed property of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Eement} element
   * @argument {String} property
   */
  function getStyleComputedProperty(element, property) {
    if (element.nodeType !== 1) {
      return [];
    }
    // NOTE: 1 DOM access here
    var css = getComputedStyle(element, null);
    return property ? css[property] : css;
  }

  /**
   * Returns the parentNode or the host of the element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} parent
   */
  function getParentNode(element) {
    if (element.nodeName === 'HTML') {
      return element;
    }
    return element.parentNode || element.host;
  }

  /**
   * Returns the scrolling parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} scroll parent
   */
  function getScrollParent(element) {
    // Return body, `getScroll` will take care to get the correct `scrollTop` from it
    if (!element) {
      return document.body;
    }

    switch (element.nodeName) {
      case 'HTML':
      case 'BODY':
        return element.ownerDocument.body;
      case '#document':
        return element.body;
    }

    // Firefox want us to check `-x` and `-y` variations as well

    var _getStyleComputedProp = getStyleComputedProperty(element),
        overflow = _getStyleComputedProp.overflow,
        overflowX = _getStyleComputedProp.overflowX,
        overflowY = _getStyleComputedProp.overflowY;

    if (/(auto|scroll)/.test(overflow + overflowY + overflowX)) {
      return element;
    }

    return getScrollParent(getParentNode(element));
  }

  /**
   * Returns the offset parent of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Element} offset parent
   */
  function getOffsetParent(element) {
    // NOTE: 1 DOM access here
    var offsetParent = element && element.offsetParent;
    var nodeName = offsetParent && offsetParent.nodeName;

    if (!nodeName || nodeName === 'BODY' || nodeName === 'HTML') {
      if (element) {
        return element.ownerDocument.documentElement;
      }

      return document.documentElement;
    }

    // .offsetParent will return the closest TD or TABLE in case
    // no offsetParent is present, I hate this job...
    if (['TD', 'TABLE'].indexOf(offsetParent.nodeName) !== -1 && getStyleComputedProperty(offsetParent, 'position') === 'static') {
      return getOffsetParent(offsetParent);
    }

    return offsetParent;
  }

  function isOffsetContainer(element) {
    var nodeName = element.nodeName;

    if (nodeName === 'BODY') {
      return false;
    }
    return nodeName === 'HTML' || getOffsetParent(element.firstElementChild) === element;
  }

  /**
   * Finds the root node (document, shadowDOM root) of the given element
   * @method
   * @memberof Popper.Utils
   * @argument {Element} node
   * @returns {Element} root node
   */
  function getRoot(node) {
    if (node.parentNode !== null) {
      return getRoot(node.parentNode);
    }

    return node;
  }

  /**
   * Finds the offset parent common to the two provided nodes
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element1
   * @argument {Element} element2
   * @returns {Element} common offset parent
   */
  function findCommonOffsetParent(element1, element2) {
    // This check is needed to avoid errors in case one of the elements isn't defined for any reason
    if (!element1 || !element1.nodeType || !element2 || !element2.nodeType) {
      return document.documentElement;
    }

    // Here we make sure to give as "start" the element that comes first in the DOM
    var order = element1.compareDocumentPosition(element2) & Node.DOCUMENT_POSITION_FOLLOWING;
    var start = order ? element1 : element2;
    var end = order ? element2 : element1;

    // Get common ancestor container
    var range = document.createRange();
    range.setStart(start, 0);
    range.setEnd(end, 0);
    var commonAncestorContainer = range.commonAncestorContainer;

    // Both nodes are inside #document

    if (element1 !== commonAncestorContainer && element2 !== commonAncestorContainer || start.contains(end)) {
      if (isOffsetContainer(commonAncestorContainer)) {
        return commonAncestorContainer;
      }

      return getOffsetParent(commonAncestorContainer);
    }

    // one of the nodes is inside shadowDOM, find which one
    var element1root = getRoot(element1);
    if (element1root.host) {
      return findCommonOffsetParent(element1root.host, element2);
    } else {
      return findCommonOffsetParent(element1, getRoot(element2).host);
    }
  }

  /**
   * Gets the scroll value of the given element in the given side (top and left)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {String} side `top` or `left`
   * @returns {number} amount of scrolled pixels
   */
  function getScroll(element) {
    var side = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'top';

    var upperSide = side === 'top' ? 'scrollTop' : 'scrollLeft';
    var nodeName = element.nodeName;

    if (nodeName === 'BODY' || nodeName === 'HTML') {
      var html = element.ownerDocument.documentElement;
      var scrollingElement = element.ownerDocument.scrollingElement || html;
      return scrollingElement[upperSide];
    }

    return element[upperSide];
  }

  /*
   * Sum or subtract the element scroll values (left and top) from a given rect object
   * @method
   * @memberof Popper.Utils
   * @param {Object} rect - Rect object you want to change
   * @param {HTMLElement} element - The element from the function reads the scroll values
   * @param {Boolean} subtract - set to true if you want to subtract the scroll values
   * @return {Object} rect - The modifier rect object
   */
  function includeScroll(rect, element) {
    var subtract = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;

    var scrollTop = getScroll(element, 'top');
    var scrollLeft = getScroll(element, 'left');
    var modifier = subtract ? -1 : 1;
    rect.top += scrollTop * modifier;
    rect.bottom += scrollTop * modifier;
    rect.left += scrollLeft * modifier;
    rect.right += scrollLeft * modifier;
    return rect;
  }

  /*
   * Helper to detect borders of a given element
   * @method
   * @memberof Popper.Utils
   * @param {CSSStyleDeclaration} styles
   * Result of `getStyleComputedProperty` on the given element
   * @param {String} axis - `x` or `y`
   * @return {number} borders - The borders size of the given axis
   */

  function getBordersSize(styles, axis) {
    var sideA = axis === 'x' ? 'Left' : 'Top';
    var sideB = sideA === 'Left' ? 'Right' : 'Bottom';

    return parseFloat(styles['border' + sideA + 'Width'], 10) + parseFloat(styles['border' + sideB + 'Width'], 10);
  }

  /**
   * Tells if you are running Internet Explorer 10
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean} isIE10
   */
  var isIE10 = undefined;

  var isIE10$1 = function isIE10$1() {
    if (isIE10 === undefined) {
      isIE10 = navigator.appVersion.indexOf('MSIE 10') !== -1;
    }
    return isIE10;
  };

  function getSize(axis, body, html, computedStyle) {
    return Math.max(body['offset' + axis], body['scroll' + axis], html['client' + axis], html['offset' + axis], html['scroll' + axis], isIE10$1() ? html['offset' + axis] + computedStyle['margin' + (axis === 'Height' ? 'Top' : 'Left')] + computedStyle['margin' + (axis === 'Height' ? 'Bottom' : 'Right')] : 0);
  }

  function getWindowSizes() {
    var body = document.body;
    var html = document.documentElement;
    var computedStyle = isIE10$1() && getComputedStyle(html);

    return {
      height: getSize('Height', body, html, computedStyle),
      width: getSize('Width', body, html, computedStyle)
    };
  }

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var defineProperty = function defineProperty(obj, key, value) {
    if (key in obj) {
      Object.defineProperty(obj, key, {
        value: value,
        enumerable: true,
        configurable: true,
        writable: true
      });
    } else {
      obj[key] = value;
    }

    return obj;
  };

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
   * Given element offsets, generate an output similar to getBoundingClientRect
   * @method
   * @memberof Popper.Utils
   * @argument {Object} offsets
   * @returns {Object} ClientRect like output
   */
  function getClientRect(offsets) {
    return _extends({}, offsets, {
      right: offsets.left + offsets.width,
      bottom: offsets.top + offsets.height
    });
  }

  /**
   * Get bounding client rect of given element
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} element
   * @return {Object} client rect
   */
  function getBoundingClientRect(element) {
    var rect = {};

    // IE10 10 FIX: Please, don't ask, the element isn't
    // considered in DOM in some circumstances...
    // This isn't reproducible in IE10 compatibility mode of IE11
    if (isIE10$1()) {
      try {
        rect = element.getBoundingClientRect();
        var scrollTop = getScroll(element, 'top');
        var scrollLeft = getScroll(element, 'left');
        rect.top += scrollTop;
        rect.left += scrollLeft;
        rect.bottom += scrollTop;
        rect.right += scrollLeft;
      } catch (err) {}
    } else {
      rect = element.getBoundingClientRect();
    }

    var result = {
      left: rect.left,
      top: rect.top,
      width: rect.right - rect.left,
      height: rect.bottom - rect.top
    };

    // subtract scrollbar size from sizes
    var sizes = element.nodeName === 'HTML' ? getWindowSizes() : {};
    var width = sizes.width || element.clientWidth || result.right - result.left;
    var height = sizes.height || element.clientHeight || result.bottom - result.top;

    var horizScrollbar = element.offsetWidth - width;
    var vertScrollbar = element.offsetHeight - height;

    // if an hypothetical scrollbar is detected, we must be sure it's not a `border`
    // we make this check conditional for performance reasons
    if (horizScrollbar || vertScrollbar) {
      var styles = getStyleComputedProperty(element);
      horizScrollbar -= getBordersSize(styles, 'x');
      vertScrollbar -= getBordersSize(styles, 'y');

      result.width -= horizScrollbar;
      result.height -= vertScrollbar;
    }

    return getClientRect(result);
  }

  function getOffsetRectRelativeToArbitraryNode(children, parent) {
    var isIE10 = isIE10$1();
    var isHTML = parent.nodeName === 'HTML';
    var childrenRect = getBoundingClientRect(children);
    var parentRect = getBoundingClientRect(parent);
    var scrollParent = getScrollParent(children);

    var styles = getStyleComputedProperty(parent);
    var borderTopWidth = parseFloat(styles.borderTopWidth, 10);
    var borderLeftWidth = parseFloat(styles.borderLeftWidth, 10);

    var offsets = getClientRect({
      top: childrenRect.top - parentRect.top - borderTopWidth,
      left: childrenRect.left - parentRect.left - borderLeftWidth,
      width: childrenRect.width,
      height: childrenRect.height
    });
    offsets.marginTop = 0;
    offsets.marginLeft = 0;

    // Subtract margins of documentElement in case it's being used as parent
    // we do this only on HTML because it's the only element that behaves
    // differently when margins are applied to it. The margins are included in
    // the box of the documentElement, in the other cases not.
    if (!isIE10 && isHTML) {
      var marginTop = parseFloat(styles.marginTop, 10);
      var marginLeft = parseFloat(styles.marginLeft, 10);

      offsets.top -= borderTopWidth - marginTop;
      offsets.bottom -= borderTopWidth - marginTop;
      offsets.left -= borderLeftWidth - marginLeft;
      offsets.right -= borderLeftWidth - marginLeft;

      // Attach marginTop and marginLeft because in some circumstances we may need them
      offsets.marginTop = marginTop;
      offsets.marginLeft = marginLeft;
    }

    if (isIE10 ? parent.contains(scrollParent) : parent === scrollParent && scrollParent.nodeName !== 'BODY') {
      offsets = includeScroll(offsets, parent);
    }

    return offsets;
  }

  function getViewportOffsetRectRelativeToArtbitraryNode(element) {
    var html = element.ownerDocument.documentElement;
    var relativeOffset = getOffsetRectRelativeToArbitraryNode(element, html);
    var width = Math.max(html.clientWidth, window.innerWidth || 0);
    var height = Math.max(html.clientHeight, window.innerHeight || 0);

    var scrollTop = getScroll(html);
    var scrollLeft = getScroll(html, 'left');

    var offset = {
      top: scrollTop - relativeOffset.top + relativeOffset.marginTop,
      left: scrollLeft - relativeOffset.left + relativeOffset.marginLeft,
      width: width,
      height: height
    };

    return getClientRect(offset);
  }

  /**
   * Check if the given element is fixed or is inside a fixed parent
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @argument {Element} customContainer
   * @returns {Boolean} answer to "isFixed?"
   */
  function isFixed(element) {
    var nodeName = element.nodeName;
    if (nodeName === 'BODY' || nodeName === 'HTML') {
      return false;
    }
    if (getStyleComputedProperty(element, 'position') === 'fixed') {
      return true;
    }
    return isFixed(getParentNode(element));
  }

  /**
   * Computed the boundaries limits and return them
   * @method
   * @memberof Popper.Utils
   * @param {HTMLElement} popper
   * @param {HTMLElement} reference
   * @param {number} padding
   * @param {HTMLElement} boundariesElement - Element used to define the boundaries
   * @returns {Object} Coordinates of the boundaries
   */
  function getBoundaries(popper, reference, padding, boundariesElement) {
    // NOTE: 1 DOM access here
    var boundaries = { top: 0, left: 0 };
    var offsetParent = findCommonOffsetParent(popper, reference);

    // Handle viewport case
    if (boundariesElement === 'viewport') {
      boundaries = getViewportOffsetRectRelativeToArtbitraryNode(offsetParent);
    } else {
      // Handle other cases based on DOM element used as boundaries
      var boundariesNode = void 0;
      if (boundariesElement === 'scrollParent') {
        boundariesNode = getScrollParent(getParentNode(reference));
        if (boundariesNode.nodeName === 'BODY') {
          boundariesNode = popper.ownerDocument.documentElement;
        }
      } else if (boundariesElement === 'window') {
        boundariesNode = popper.ownerDocument.documentElement;
      } else {
        boundariesNode = boundariesElement;
      }

      var offsets = getOffsetRectRelativeToArbitraryNode(boundariesNode, offsetParent);

      // In case of HTML, we need a different computation
      if (boundariesNode.nodeName === 'HTML' && !isFixed(offsetParent)) {
        var _getWindowSizes = getWindowSizes(),
            height = _getWindowSizes.height,
            width = _getWindowSizes.width;

        boundaries.top += offsets.top - offsets.marginTop;
        boundaries.bottom = height + offsets.top;
        boundaries.left += offsets.left - offsets.marginLeft;
        boundaries.right = width + offsets.left;
      } else {
        // for all the other DOM elements, this one is good
        boundaries = offsets;
      }
    }

    // Add paddings
    boundaries.left += padding;
    boundaries.top += padding;
    boundaries.right -= padding;
    boundaries.bottom -= padding;

    return boundaries;
  }

  function getArea(_ref) {
    var width = _ref.width,
        height = _ref.height;

    return width * height;
  }

  /**
   * Utility used to transform the `auto` placement to the placement with more
   * available space.
   * @method
   * @memberof Popper.Utils
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeAutoPlacement(placement, refRect, popper, reference, boundariesElement) {
    var padding = arguments.length > 5 && arguments[5] !== undefined ? arguments[5] : 0;

    if (placement.indexOf('auto') === -1) {
      return placement;
    }

    var boundaries = getBoundaries(popper, reference, padding, boundariesElement);

    var rects = {
      top: {
        width: boundaries.width,
        height: refRect.top - boundaries.top
      },
      right: {
        width: boundaries.right - refRect.right,
        height: boundaries.height
      },
      bottom: {
        width: boundaries.width,
        height: boundaries.bottom - refRect.bottom
      },
      left: {
        width: refRect.left - boundaries.left,
        height: boundaries.height
      }
    };

    var sortedAreas = Object.keys(rects).map(function (key) {
      return _extends({
        key: key
      }, rects[key], {
        area: getArea(rects[key])
      });
    }).sort(function (a, b) {
      return b.area - a.area;
    });

    var filteredAreas = sortedAreas.filter(function (_ref2) {
      var width = _ref2.width,
          height = _ref2.height;
      return width >= popper.clientWidth && height >= popper.clientHeight;
    });

    var computedPlacement = filteredAreas.length > 0 ? filteredAreas[0].key : sortedAreas[0].key;

    var variation = placement.split('-')[1];

    return computedPlacement + (variation ? '-' + variation : '');
  }

  /**
   * Get offsets to the reference element
   * @method
   * @memberof Popper.Utils
   * @param {Object} state
   * @param {Element} popper - the popper element
   * @param {Element} reference - the reference element (the popper will be relative to this)
   * @returns {Object} An object containing the offsets which will be applied to the popper
   */
  function getReferenceOffsets(state, popper, reference) {
    var commonOffsetParent = findCommonOffsetParent(popper, reference);
    return getOffsetRectRelativeToArbitraryNode(reference, commonOffsetParent);
  }

  /**
   * Get the outer sizes of the given element (offset size + margins)
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element
   * @returns {Object} object containing width and height properties
   */
  function getOuterSizes(element) {
    var styles = getComputedStyle(element);
    var x = parseFloat(styles.marginTop) + parseFloat(styles.marginBottom);
    var y = parseFloat(styles.marginLeft) + parseFloat(styles.marginRight);
    var result = {
      width: element.offsetWidth + y,
      height: element.offsetHeight + x
    };
    return result;
  }

  /**
   * Get the opposite placement of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement
   * @returns {String} flipped placement
   */
  function getOppositePlacement(placement) {
    var hash = { left: 'right', right: 'left', bottom: 'top', top: 'bottom' };
    return placement.replace(/left|right|bottom|top/g, function (matched) {
      return hash[matched];
    });
  }

  /**
   * Get offsets to the popper
   * @method
   * @memberof Popper.Utils
   * @param {Object} position - CSS position the Popper will get applied
   * @param {HTMLElement} popper - the popper element
   * @param {Object} referenceOffsets - the reference offsets (the popper will be relative to this)
   * @param {String} placement - one of the valid placement options
   * @returns {Object} popperOffsets - An object containing the offsets which will be applied to the popper
   */
  function getPopperOffsets(popper, referenceOffsets, placement) {
    placement = placement.split('-')[0];

    // Get popper node sizes
    var popperRect = getOuterSizes(popper);

    // Add position, width and height to our offsets object
    var popperOffsets = {
      width: popperRect.width,
      height: popperRect.height
    };

    // depending by the popper placement we have to compute its offsets slightly differently
    var isHoriz = ['right', 'left'].indexOf(placement) !== -1;
    var mainSide = isHoriz ? 'top' : 'left';
    var secondarySide = isHoriz ? 'left' : 'top';
    var measurement = isHoriz ? 'height' : 'width';
    var secondaryMeasurement = !isHoriz ? 'height' : 'width';

    popperOffsets[mainSide] = referenceOffsets[mainSide] + referenceOffsets[measurement] / 2 - popperRect[measurement] / 2;
    if (placement === secondarySide) {
      popperOffsets[secondarySide] = referenceOffsets[secondarySide] - popperRect[secondaryMeasurement];
    } else {
      popperOffsets[secondarySide] = referenceOffsets[getOppositePlacement(secondarySide)];
    }

    return popperOffsets;
  }

  /**
   * Mimics the `find` method of Array
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function find$1(arr, check) {
    // use native find if supported
    if (Array.prototype.find) {
      return arr.find(check);
    }

    // use `filter` to obtain the same behavior of `find`
    return arr.filter(check)[0];
  }

  /**
   * Return the index of the matching object
   * @method
   * @memberof Popper.Utils
   * @argument {Array} arr
   * @argument prop
   * @argument value
   * @returns index or -1
   */
  function findIndex$1(arr, prop, value) {
    // use native findIndex if supported
    if (Array.prototype.findIndex) {
      return arr.findIndex(function (cur) {
        return cur[prop] === value;
      });
    }

    // use `find` + `indexOf` if `findIndex` isn't supported
    var match = find$1(arr, function (obj) {
      return obj[prop] === value;
    });
    return arr.indexOf(match);
  }

  /**
   * Loop trough the list of modifiers and run them in order,
   * each of them will then edit the data object.
   * @method
   * @memberof Popper.Utils
   * @param {dataObject} data
   * @param {Array} modifiers
   * @param {String} ends - Optional modifier name used as stopper
   * @returns {dataObject}
   */
  function runModifiers(modifiers, data, ends) {
    var modifiersToRun = ends === undefined ? modifiers : modifiers.slice(0, findIndex$1(modifiers, 'name', ends));

    modifiersToRun.forEach(function (modifier) {
      if (modifier['function']) {
        // eslint-disable-line dot-notation
        console.warn('`modifier.function` is deprecated, use `modifier.fn`!');
      }
      var fn = modifier['function'] || modifier.fn; // eslint-disable-line dot-notation
      if (modifier.enabled && isFunction(fn)) {
        // Add properties to offsets to make them a complete clientRect object
        // we do this before each modifier to make sure the previous one doesn't
        // mess with these values
        data.offsets.popper = getClientRect(data.offsets.popper);
        data.offsets.reference = getClientRect(data.offsets.reference);

        data = fn(data, modifier);
      }
    });

    return data;
  }

  /**
   * Updates the position of the popper, computing the new offsets and applying
   * the new style.<br />
   * Prefer `scheduleUpdate` over `update` because of performance reasons.
   * @method
   * @memberof Popper
   */
  function update() {
    // if popper is destroyed, don't perform any further update
    if (this.state.isDestroyed) {
      return;
    }

    var data = {
      instance: this,
      styles: {},
      arrowStyles: {},
      attributes: {},
      flipped: false,
      offsets: {}
    };

    // compute reference element offsets
    data.offsets.reference = getReferenceOffsets(this.state, this.popper, this.reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    data.placement = computeAutoPlacement(this.options.placement, data.offsets.reference, this.popper, this.reference, this.options.modifiers.flip.boundariesElement, this.options.modifiers.flip.padding);

    // store the computed placement inside `originalPlacement`
    data.originalPlacement = data.placement;

    // compute the popper offsets
    data.offsets.popper = getPopperOffsets(this.popper, data.offsets.reference, data.placement);
    data.offsets.popper.position = 'absolute';

    // run the modifiers
    data = runModifiers(this.modifiers, data);

    // the first `update` will call `onCreate` callback
    // the other ones will call `onUpdate` callback
    if (!this.state.isCreated) {
      this.state.isCreated = true;
      this.options.onCreate(data);
    } else {
      this.options.onUpdate(data);
    }
  }

  /**
   * Helper used to know if the given modifier is enabled.
   * @method
   * @memberof Popper.Utils
   * @returns {Boolean}
   */
  function isModifierEnabled(modifiers, modifierName) {
    return modifiers.some(function (_ref) {
      var name = _ref.name,
          enabled = _ref.enabled;
      return enabled && name === modifierName;
    });
  }

  /**
   * Get the prefixed supported property name
   * @method
   * @memberof Popper.Utils
   * @argument {String} property (camelCase)
   * @returns {String} prefixed property (camelCase or PascalCase, depending on the vendor prefix)
   */
  function getSupportedPropertyName(property) {
    var prefixes = [false, 'ms', 'Webkit', 'Moz', 'O'];
    var upperProp = property.charAt(0).toUpperCase() + property.slice(1);

    for (var i = 0; i < prefixes.length - 1; i++) {
      var prefix = prefixes[i];
      var toCheck = prefix ? '' + prefix + upperProp : property;
      if (typeof document.body.style[toCheck] !== 'undefined') {
        return toCheck;
      }
    }
    return null;
  }

  /**
   * Destroy the popper
   * @method
   * @memberof Popper
   */
  function destroy() {
    this.state.isDestroyed = true;

    // touch DOM only if `applyStyle` modifier is enabled
    if (isModifierEnabled(this.modifiers, 'applyStyle')) {
      this.popper.removeAttribute('x-placement');
      this.popper.style.left = '';
      this.popper.style.position = '';
      this.popper.style.top = '';
      this.popper.style[getSupportedPropertyName('transform')] = '';
    }

    this.disableEventListeners();

    // remove the popper if user explicity asked for the deletion on destroy
    // do not use `remove` because IE11 doesn't support it
    if (this.options.removeOnDestroy) {
      this.popper.parentNode.removeChild(this.popper);
    }
    return this;
  }

  /**
   * Get the window associated with the element
   * @argument {Element} element
   * @returns {Window}
   */
  function getWindow(element) {
    var ownerDocument = element.ownerDocument;
    return ownerDocument ? ownerDocument.defaultView : window;
  }

  function attachToScrollParents(scrollParent, event, callback, scrollParents) {
    var isBody = scrollParent.nodeName === 'BODY';
    var target = isBody ? scrollParent.ownerDocument.defaultView : scrollParent;
    target.addEventListener(event, callback, { passive: true });

    if (!isBody) {
      attachToScrollParents(getScrollParent(target.parentNode), event, callback, scrollParents);
    }
    scrollParents.push(target);
  }

  /**
   * Setup needed event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function setupEventListeners(reference, options, state, updateBound) {
    // Resize event listener on window
    state.updateBound = updateBound;
    getWindow(reference).addEventListener('resize', state.updateBound, { passive: true });

    // Scroll event listener on scroll parents
    var scrollElement = getScrollParent(reference);
    attachToScrollParents(scrollElement, 'scroll', state.updateBound, state.scrollParents);
    state.scrollElement = scrollElement;
    state.eventsEnabled = true;

    return state;
  }

  /**
   * It will add resize/scroll events and start recalculating
   * position of the popper element when they are triggered.
   * @method
   * @memberof Popper
   */
  function enableEventListeners() {
    if (!this.state.eventsEnabled) {
      this.state = setupEventListeners(this.reference, this.options, this.state, this.scheduleUpdate);
    }
  }

  /**
   * Remove event listeners used to update the popper position
   * @method
   * @memberof Popper.Utils
   * @private
   */
  function removeEventListeners(reference, state) {
    // Remove resize event listener on window
    getWindow(reference).removeEventListener('resize', state.updateBound);

    // Remove scroll event listener on scroll parents
    state.scrollParents.forEach(function (target) {
      target.removeEventListener('scroll', state.updateBound);
    });

    // Reset state
    state.updateBound = null;
    state.scrollParents = [];
    state.scrollElement = null;
    state.eventsEnabled = false;
    return state;
  }

  /**
   * It will remove resize/scroll events and won't recalculate popper position
   * when they are triggered. It also won't trigger onUpdate callback anymore,
   * unless you call `update` method manually.
   * @method
   * @memberof Popper
   */
  function disableEventListeners() {
    if (this.state.eventsEnabled) {
      cancelAnimationFrame(this.scheduleUpdate);
      this.state = removeEventListeners(this.reference, this.state);
    }
  }

  /**
   * Tells if a given input is a number
   * @method
   * @memberof Popper.Utils
   * @param {*} input to check
   * @return {Boolean}
   */
  function isNumeric(n) {
    return n !== '' && !isNaN(parseFloat(n)) && isFinite(n);
  }

  /**
   * Set the style to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the style to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setStyles(element, styles) {
    Object.keys(styles).forEach(function (prop) {
      var unit = '';
      // add unit if the value is numeric and is one of the following
      if (['width', 'height', 'top', 'right', 'bottom', 'left'].indexOf(prop) !== -1 && isNumeric(styles[prop])) {
        unit = 'px';
      }
      element.style[prop] = styles[prop] + unit;
    });
  }

  /**
   * Set the attributes to the given popper
   * @method
   * @memberof Popper.Utils
   * @argument {Element} element - Element to apply the attributes to
   * @argument {Object} styles
   * Object with a list of properties and values which will be applied to the element
   */
  function setAttributes(element, attributes) {
    Object.keys(attributes).forEach(function (prop) {
      var value = attributes[prop];
      if (value !== false) {
        element.setAttribute(prop, attributes[prop]);
      } else {
        element.removeAttribute(prop);
      }
    });
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} data.styles - List of style properties - values to apply to popper element
   * @argument {Object} data.attributes - List of attribute properties - values to apply to popper element
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The same data object
   */
  function applyStyle(data) {
    // any property present in `data.styles` will be applied to the popper,
    // in this way we can make the 3rd party modifiers add custom styles to it
    // Be aware, modifiers could override the properties defined in the previous
    // lines of this modifier!
    setStyles(data.instance.popper, data.styles);

    // any property present in `data.attributes` will be applied to the popper,
    // they will be set as HTML attributes of the element
    setAttributes(data.instance.popper, data.attributes);

    // if arrowElement is defined and arrowStyles has some properties
    if (data.arrowElement && Object.keys(data.arrowStyles).length) {
      setStyles(data.arrowElement, data.arrowStyles);
    }

    return data;
  }

  /**
   * Set the x-placement attribute before everything else because it could be used
   * to add margins to the popper margins needs to be calculated to get the
   * correct popper offsets.
   * @method
   * @memberof Popper.modifiers
   * @param {HTMLElement} reference - The reference element used to position the popper
   * @param {HTMLElement} popper - The HTML element used as popper.
   * @param {Object} options - Popper.js options
   */
  function applyStyleOnLoad(reference, popper, options, modifierOptions, state) {
    // compute reference element offsets
    var referenceOffsets = getReferenceOffsets(state, popper, reference);

    // compute auto placement, store placement inside the data object,
    // modifiers will be able to edit `placement` if needed
    // and refer to originalPlacement to know the original value
    var placement = computeAutoPlacement(options.placement, referenceOffsets, popper, reference, options.modifiers.flip.boundariesElement, options.modifiers.flip.padding);

    popper.setAttribute('x-placement', placement);

    // Apply `position` to popper before anything else because
    // without the position applied we can't guarantee correct computations
    setStyles(popper, { position: 'absolute' });

    return options;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function computeStyle(data, options) {
    var x = options.x,
        y = options.y;
    var popper = data.offsets.popper;

    // Remove this legacy support in Popper.js v2

    var legacyGpuAccelerationOption = find$1(data.instance.modifiers, function (modifier) {
      return modifier.name === 'applyStyle';
    }).gpuAcceleration;
    if (legacyGpuAccelerationOption !== undefined) {
      console.warn('WARNING: `gpuAcceleration` option moved to `computeStyle` modifier and will not be supported in future versions of Popper.js!');
    }
    var gpuAcceleration = legacyGpuAccelerationOption !== undefined ? legacyGpuAccelerationOption : options.gpuAcceleration;

    var offsetParent = getOffsetParent(data.instance.popper);
    var offsetParentRect = getBoundingClientRect(offsetParent);

    // Styles
    var styles = {
      position: popper.position
    };

    // floor sides to avoid blurry text
    var offsets = {
      left: Math.floor(popper.left),
      top: Math.floor(popper.top),
      bottom: Math.floor(popper.bottom),
      right: Math.floor(popper.right)
    };

    var sideA = x === 'bottom' ? 'top' : 'bottom';
    var sideB = y === 'right' ? 'left' : 'right';

    // if gpuAcceleration is set to `true` and transform is supported,
    //  we use `translate3d` to apply the position to the popper we
    // automatically use the supported prefixed version if needed
    var prefixedProperty = getSupportedPropertyName('transform');

    // now, let's make a step back and look at this code closely (wtf?)
    // If the content of the popper grows once it's been positioned, it
    // may happen that the popper gets misplaced because of the new content
    // overflowing its reference element
    // To avoid this problem, we provide two options (x and y), which allow
    // the consumer to define the offset origin.
    // If we position a popper on top of a reference element, we can set
    // `x` to `top` to make the popper grow towards its top instead of
    // its bottom.
    var left = void 0,
        top = void 0;
    if (sideA === 'bottom') {
      top = -offsetParentRect.height + offsets.bottom;
    } else {
      top = offsets.top;
    }
    if (sideB === 'right') {
      left = -offsetParentRect.width + offsets.right;
    } else {
      left = offsets.left;
    }
    if (gpuAcceleration && prefixedProperty) {
      styles[prefixedProperty] = 'translate3d(' + left + 'px, ' + top + 'px, 0)';
      styles[sideA] = 0;
      styles[sideB] = 0;
      styles.willChange = 'transform';
    } else {
      // othwerise, we use the standard `top`, `left`, `bottom` and `right` properties
      var invertTop = sideA === 'bottom' ? -1 : 1;
      var invertLeft = sideB === 'right' ? -1 : 1;
      styles[sideA] = top * invertTop;
      styles[sideB] = left * invertLeft;
      styles.willChange = sideA + ', ' + sideB;
    }

    // Attributes
    var attributes = {
      'x-placement': data.placement
    };

    // Update `data` attributes, styles and arrowStyles
    data.attributes = _extends({}, attributes, data.attributes);
    data.styles = _extends({}, styles, data.styles);
    data.arrowStyles = _extends({}, data.offsets.arrow, data.arrowStyles);

    return data;
  }

  /**
   * Helper used to know if the given modifier depends from another one.<br />
   * It checks if the needed modifier is listed and enabled.
   * @method
   * @memberof Popper.Utils
   * @param {Array} modifiers - list of modifiers
   * @param {String} requestingName - name of requesting modifier
   * @param {String} requestedName - name of requested modifier
   * @returns {Boolean}
   */
  function isModifierRequired(modifiers, requestingName, requestedName) {
    var requesting = find$1(modifiers, function (_ref) {
      var name = _ref.name;
      return name === requestingName;
    });

    var isRequired = !!requesting && modifiers.some(function (modifier) {
      return modifier.name === requestedName && modifier.enabled && modifier.order < requesting.order;
    });

    if (!isRequired) {
      var _requesting = '`' + requestingName + '`';
      var requested = '`' + requestedName + '`';
      console.warn(requested + ' modifier is required by ' + _requesting + ' modifier in order to work, be sure to include it before ' + _requesting + '!');
    }
    return isRequired;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function arrow(data, options) {
    var _data$offsets$arrow;

    // arrow depends on keepTogether in order to work
    if (!isModifierRequired(data.instance.modifiers, 'arrow', 'keepTogether')) {
      return data;
    }

    var arrowElement = options.element;

    // if arrowElement is a string, suppose it's a CSS selector
    if (typeof arrowElement === 'string') {
      arrowElement = data.instance.popper.querySelector(arrowElement);

      // if arrowElement is not found, don't run the modifier
      if (!arrowElement) {
        return data;
      }
    } else {
      // if the arrowElement isn't a query selector we must check that the
      // provided DOM node is child of its popper node
      if (!data.instance.popper.contains(arrowElement)) {
        console.warn('WARNING: `arrow.element` must be child of its popper element!');
        return data;
      }
    }

    var placement = data.placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isVertical = ['left', 'right'].indexOf(placement) !== -1;

    var len = isVertical ? 'height' : 'width';
    var sideCapitalized = isVertical ? 'Top' : 'Left';
    var side = sideCapitalized.toLowerCase();
    var altSide = isVertical ? 'left' : 'top';
    var opSide = isVertical ? 'bottom' : 'right';
    var arrowElementSize = getOuterSizes(arrowElement)[len];

    //
    // extends keepTogether behavior making sure the popper and its
    // reference have enough pixels in conjuction
    //

    // top/left side
    if (reference[opSide] - arrowElementSize < popper[side]) {
      data.offsets.popper[side] -= popper[side] - (reference[opSide] - arrowElementSize);
    }
    // bottom/right side
    if (reference[side] + arrowElementSize > popper[opSide]) {
      data.offsets.popper[side] += reference[side] + arrowElementSize - popper[opSide];
    }
    data.offsets.popper = getClientRect(data.offsets.popper);

    // compute center of the popper
    var center = reference[side] + reference[len] / 2 - arrowElementSize / 2;

    // Compute the sideValue using the updated popper offsets
    // take popper margin in account because we don't have this info available
    var css = getStyleComputedProperty(data.instance.popper);
    var popperMarginSide = parseFloat(css['margin' + sideCapitalized], 10);
    var popperBorderSide = parseFloat(css['border' + sideCapitalized + 'Width'], 10);
    var sideValue = center - data.offsets.popper[side] - popperMarginSide - popperBorderSide;

    // prevent arrowElement from being placed not contiguously to its popper
    sideValue = Math.max(Math.min(popper[len] - arrowElementSize, sideValue), 0);

    data.arrowElement = arrowElement;
    data.offsets.arrow = (_data$offsets$arrow = {}, defineProperty(_data$offsets$arrow, side, Math.round(sideValue)), defineProperty(_data$offsets$arrow, altSide, ''), _data$offsets$arrow);

    return data;
  }

  /**
   * Get the opposite placement variation of the given one
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement variation
   * @returns {String} flipped placement variation
   */
  function getOppositeVariation(variation) {
    if (variation === 'end') {
      return 'start';
    } else if (variation === 'start') {
      return 'end';
    }
    return variation;
  }

  /**
   * List of accepted placements to use as values of the `placement` option.<br />
   * Valid placements are:
   * - `auto`
   * - `top`
   * - `right`
   * - `bottom`
   * - `left`
   *
   * Each placement can have a variation from this list:
   * - `-start`
   * - `-end`
   *
   * Variations are interpreted easily if you think of them as the left to right
   * written languages. Horizontally (`top` and `bottom`), `start` is left and `end`
   * is right.<br />
   * Vertically (`left` and `right`), `start` is top and `end` is bottom.
   *
   * Some valid examples are:
   * - `top-end` (on top of reference, right aligned)
   * - `right-start` (on right of reference, top aligned)
   * - `bottom` (on bottom, centered)
   * - `auto-right` (on the side with more space available, alignment depends by placement)
   *
   * @static
   * @type {Array}
   * @enum {String}
   * @readonly
   * @method placements
   * @memberof Popper
   */
  var placements = ['auto-start', 'auto', 'auto-end', 'top-start', 'top', 'top-end', 'right-start', 'right', 'right-end', 'bottom-end', 'bottom', 'bottom-start', 'left-end', 'left', 'left-start'];

  // Get rid of `auto` `auto-start` and `auto-end`
  var validPlacements = placements.slice(3);

  /**
   * Given an initial placement, returns all the subsequent placements
   * clockwise (or counter-clockwise).
   *
   * @method
   * @memberof Popper.Utils
   * @argument {String} placement - A valid placement (it accepts variations)
   * @argument {Boolean} counter - Set to true to walk the placements counterclockwise
   * @returns {Array} placements including their variations
   */
  function clockwise(placement) {
    var counter = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;

    var index = validPlacements.indexOf(placement);
    var arr = validPlacements.slice(index + 1).concat(validPlacements.slice(0, index));
    return counter ? arr.reverse() : arr;
  }

  var BEHAVIORS = {
    FLIP: 'flip',
    CLOCKWISE: 'clockwise',
    COUNTERCLOCKWISE: 'counterclockwise'
  };

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function flip(data, options) {
    // if `inner` modifier is enabled, we can't use the `flip` modifier
    if (isModifierEnabled(data.instance.modifiers, 'inner')) {
      return data;
    }

    if (data.flipped && data.placement === data.originalPlacement) {
      // seems like flip is trying to loop, probably there's not enough space on any of the flippable sides
      return data;
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, options.boundariesElement);

    var placement = data.placement.split('-')[0];
    var placementOpposite = getOppositePlacement(placement);
    var variation = data.placement.split('-')[1] || '';

    var flipOrder = [];

    switch (options.behavior) {
      case BEHAVIORS.FLIP:
        flipOrder = [placement, placementOpposite];
        break;
      case BEHAVIORS.CLOCKWISE:
        flipOrder = clockwise(placement);
        break;
      case BEHAVIORS.COUNTERCLOCKWISE:
        flipOrder = clockwise(placement, true);
        break;
      default:
        flipOrder = options.behavior;
    }

    flipOrder.forEach(function (step, index) {
      if (placement !== step || flipOrder.length === index + 1) {
        return data;
      }

      placement = data.placement.split('-')[0];
      placementOpposite = getOppositePlacement(placement);

      var popperOffsets = data.offsets.popper;
      var refOffsets = data.offsets.reference;

      // using floor because the reference offsets may contain decimals we are not going to consider here
      var floor = Math.floor;
      var overlapsRef = placement === 'left' && floor(popperOffsets.right) > floor(refOffsets.left) || placement === 'right' && floor(popperOffsets.left) < floor(refOffsets.right) || placement === 'top' && floor(popperOffsets.bottom) > floor(refOffsets.top) || placement === 'bottom' && floor(popperOffsets.top) < floor(refOffsets.bottom);

      var overflowsLeft = floor(popperOffsets.left) < floor(boundaries.left);
      var overflowsRight = floor(popperOffsets.right) > floor(boundaries.right);
      var overflowsTop = floor(popperOffsets.top) < floor(boundaries.top);
      var overflowsBottom = floor(popperOffsets.bottom) > floor(boundaries.bottom);

      var overflowsBoundaries = placement === 'left' && overflowsLeft || placement === 'right' && overflowsRight || placement === 'top' && overflowsTop || placement === 'bottom' && overflowsBottom;

      // flip the variation if required
      var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
      var flippedVariation = !!options.flipVariations && (isVertical && variation === 'start' && overflowsLeft || isVertical && variation === 'end' && overflowsRight || !isVertical && variation === 'start' && overflowsTop || !isVertical && variation === 'end' && overflowsBottom);

      if (overlapsRef || overflowsBoundaries || flippedVariation) {
        // this boolean to detect any flip loop
        data.flipped = true;

        if (overlapsRef || overflowsBoundaries) {
          placement = flipOrder[index + 1];
        }

        if (flippedVariation) {
          variation = getOppositeVariation(variation);
        }

        data.placement = placement + (variation ? '-' + variation : '');

        // this object contains `position`, we want to preserve it along with
        // any additional property we may add in the future
        data.offsets.popper = _extends({}, data.offsets.popper, getPopperOffsets(data.instance.popper, data.offsets.reference, data.placement));

        data = runModifiers(data.instance.modifiers, data, 'flip');
      }
    });
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function keepTogether(data) {
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var placement = data.placement.split('-')[0];
    var floor = Math.floor;
    var isVertical = ['top', 'bottom'].indexOf(placement) !== -1;
    var side = isVertical ? 'right' : 'bottom';
    var opSide = isVertical ? 'left' : 'top';
    var measurement = isVertical ? 'width' : 'height';

    if (popper[side] < floor(reference[opSide])) {
      data.offsets.popper[opSide] = floor(reference[opSide]) - popper[measurement];
    }
    if (popper[opSide] > floor(reference[side])) {
      data.offsets.popper[opSide] = floor(reference[side]);
    }

    return data;
  }

  /**
   * Converts a string containing value + unit into a px value number
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} str - Value + unit string
   * @argument {String} measurement - `height` or `width`
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @returns {Number|String}
   * Value in pixels, or original string if no values were extracted
   */
  function toValue(str, measurement, popperOffsets, referenceOffsets) {
    // separate value from unit
    var split = str.match(/((?:\-|\+)?\d*\.?\d*)(.*)/);
    var value = +split[1];
    var unit = split[2];

    // If it's not a number it's an operator, I guess
    if (!value) {
      return str;
    }

    if (unit.indexOf('%') === 0) {
      var element = void 0;
      switch (unit) {
        case '%p':
          element = popperOffsets;
          break;
        case '%':
        case '%r':
        default:
          element = referenceOffsets;
      }

      var rect = getClientRect(element);
      return rect[measurement] / 100 * value;
    } else if (unit === 'vh' || unit === 'vw') {
      // if is a vh or vw, we calculate the size based on the viewport
      var size = void 0;
      if (unit === 'vh') {
        size = Math.max(document.documentElement.clientHeight, window.innerHeight || 0);
      } else {
        size = Math.max(document.documentElement.clientWidth, window.innerWidth || 0);
      }
      return size / 100 * value;
    } else {
      // if is an explicit pixel unit, we get rid of the unit and keep the value
      // if is an implicit unit, it's px, and we return just the value
      return value;
    }
  }

  /**
   * Parse an `offset` string to extrapolate `x` and `y` numeric offsets.
   * @function
   * @memberof {modifiers~offset}
   * @private
   * @argument {String} offset
   * @argument {Object} popperOffsets
   * @argument {Object} referenceOffsets
   * @argument {String} basePlacement
   * @returns {Array} a two cells array with x and y offsets in numbers
   */
  function parseOffset(offset, popperOffsets, referenceOffsets, basePlacement) {
    var offsets = [0, 0];

    // Use height if placement is left or right and index is 0 otherwise use width
    // in this way the first offset will use an axis and the second one
    // will use the other one
    var useHeight = ['right', 'left'].indexOf(basePlacement) !== -1;

    // Split the offset string to obtain a list of values and operands
    // The regex addresses values with the plus or minus sign in front (+10, -20, etc)
    var fragments = offset.split(/(\+|\-)/).map(function (frag) {
      return frag.trim();
    });

    // Detect if the offset string contains a pair of values or a single one
    // they could be separated by comma or space
    var divider = fragments.indexOf(find$1(fragments, function (frag) {
      return frag.search(/,|\s/) !== -1;
    }));

    if (fragments[divider] && fragments[divider].indexOf(',') === -1) {
      console.warn('Offsets separated by white space(s) are deprecated, use a comma (,) instead.');
    }

    // If divider is found, we divide the list of values and operands to divide
    // them by ofset X and Y.
    var splitRegex = /\s*,\s*|\s+/;
    var ops = divider !== -1 ? [fragments.slice(0, divider).concat([fragments[divider].split(splitRegex)[0]]), [fragments[divider].split(splitRegex)[1]].concat(fragments.slice(divider + 1))] : [fragments];

    // Convert the values with units to absolute pixels to allow our computations
    ops = ops.map(function (op, index) {
      // Most of the units rely on the orientation of the popper
      var measurement = (index === 1 ? !useHeight : useHeight) ? 'height' : 'width';
      var mergeWithPrevious = false;
      return op
      // This aggregates any `+` or `-` sign that aren't considered operators
      // e.g.: 10 + +5 => [10, +, +5]
      .reduce(function (a, b) {
        if (a[a.length - 1] === '' && ['+', '-'].indexOf(b) !== -1) {
          a[a.length - 1] = b;
          mergeWithPrevious = true;
          return a;
        } else if (mergeWithPrevious) {
          a[a.length - 1] += b;
          mergeWithPrevious = false;
          return a;
        } else {
          return a.concat(b);
        }
      }, [])
      // Here we convert the string values into number values (in px)
      .map(function (str) {
        return toValue(str, measurement, popperOffsets, referenceOffsets);
      });
    });

    // Loop trough the offsets arrays and execute the operations
    ops.forEach(function (op, index) {
      op.forEach(function (frag, index2) {
        if (isNumeric(frag)) {
          offsets[index] += frag * (op[index2 - 1] === '-' ? -1 : 1);
        }
      });
    });
    return offsets;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @argument {Number|String} options.offset=0
   * The offset value as described in the modifier description
   * @returns {Object} The data object, properly modified
   */
  function offset(data, _ref) {
    var offset = _ref.offset;
    var placement = data.placement,
        _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var basePlacement = placement.split('-')[0];

    var offsets = void 0;
    if (isNumeric(+offset)) {
      offsets = [+offset, 0];
    } else {
      offsets = parseOffset(offset, popper, reference, basePlacement);
    }

    if (basePlacement === 'left') {
      popper.top += offsets[0];
      popper.left -= offsets[1];
    } else if (basePlacement === 'right') {
      popper.top += offsets[0];
      popper.left += offsets[1];
    } else if (basePlacement === 'top') {
      popper.left += offsets[0];
      popper.top -= offsets[1];
    } else if (basePlacement === 'bottom') {
      popper.left += offsets[0];
      popper.top += offsets[1];
    }

    data.popper = popper;
    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function preventOverflow(data, options) {
    var boundariesElement = options.boundariesElement || getOffsetParent(data.instance.popper);

    // If offsetParent is the reference element, we really want to
    // go one step up and use the next offsetParent as reference to
    // avoid to make this modifier completely useless and look like broken
    if (data.instance.reference === boundariesElement) {
      boundariesElement = getOffsetParent(boundariesElement);
    }

    var boundaries = getBoundaries(data.instance.popper, data.instance.reference, options.padding, boundariesElement);
    options.boundaries = boundaries;

    var order = options.priority;
    var popper = data.offsets.popper;

    var check = {
      primary: function primary(placement) {
        var value = popper[placement];
        if (popper[placement] < boundaries[placement] && !options.escapeWithReference) {
          value = Math.max(popper[placement], boundaries[placement]);
        }
        return defineProperty({}, placement, value);
      },
      secondary: function secondary(placement) {
        var mainSide = placement === 'right' ? 'left' : 'top';
        var value = popper[mainSide];
        if (popper[placement] > boundaries[placement] && !options.escapeWithReference) {
          value = Math.min(popper[mainSide], boundaries[placement] - (placement === 'right' ? popper.width : popper.height));
        }
        return defineProperty({}, mainSide, value);
      }
    };

    order.forEach(function (placement) {
      var side = ['left', 'top'].indexOf(placement) !== -1 ? 'primary' : 'secondary';
      popper = _extends({}, popper, check[side](placement));
    });

    data.offsets.popper = popper;

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function shift(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var shiftvariation = placement.split('-')[1];

    // if shift shiftvariation is specified, run the modifier
    if (shiftvariation) {
      var _data$offsets = data.offsets,
          reference = _data$offsets.reference,
          popper = _data$offsets.popper;

      var isVertical = ['bottom', 'top'].indexOf(basePlacement) !== -1;
      var side = isVertical ? 'left' : 'top';
      var measurement = isVertical ? 'width' : 'height';

      var shiftOffsets = {
        start: defineProperty({}, side, reference[side]),
        end: defineProperty({}, side, reference[side] + reference[measurement] - popper[measurement])
      };

      data.offsets.popper = _extends({}, popper, shiftOffsets[shiftvariation]);
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by update method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function hide(data) {
    if (!isModifierRequired(data.instance.modifiers, 'hide', 'preventOverflow')) {
      return data;
    }

    var refRect = data.offsets.reference;
    var bound = find$1(data.instance.modifiers, function (modifier) {
      return modifier.name === 'preventOverflow';
    }).boundaries;

    if (refRect.bottom < bound.top || refRect.left > bound.right || refRect.top > bound.bottom || refRect.right < bound.left) {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === true) {
        return data;
      }

      data.hide = true;
      data.attributes['x-out-of-boundaries'] = '';
    } else {
      // Avoid unnecessary DOM access if visibility hasn't changed
      if (data.hide === false) {
        return data;
      }

      data.hide = false;
      data.attributes['x-out-of-boundaries'] = false;
    }

    return data;
  }

  /**
   * @function
   * @memberof Modifiers
   * @argument {Object} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {Object} The data object, properly modified
   */
  function inner(data) {
    var placement = data.placement;
    var basePlacement = placement.split('-')[0];
    var _data$offsets = data.offsets,
        popper = _data$offsets.popper,
        reference = _data$offsets.reference;

    var isHoriz = ['left', 'right'].indexOf(basePlacement) !== -1;

    var subtractLength = ['top', 'left'].indexOf(basePlacement) === -1;

    popper[isHoriz ? 'left' : 'top'] = reference[basePlacement] - (subtractLength ? popper[isHoriz ? 'width' : 'height'] : 0);

    data.placement = getOppositePlacement(placement);
    data.offsets.popper = getClientRect(popper);

    return data;
  }

  /**
   * Modifier function, each modifier can have a function of this type assigned
   * to its `fn` property.<br />
   * These functions will be called on each update, this means that you must
   * make sure they are performant enough to avoid performance bottlenecks.
   *
   * @function ModifierFn
   * @argument {dataObject} data - The data object generated by `update` method
   * @argument {Object} options - Modifiers configuration and options
   * @returns {dataObject} The data object, properly modified
   */

  /**
   * Modifiers are plugins used to alter the behavior of your poppers.<br />
   * Popper.js uses a set of 9 modifiers to provide all the basic functionalities
   * needed by the library.
   *
   * Usually you don't want to override the `order`, `fn` and `onLoad` props.
   * All the other properties are configurations that could be tweaked.
   * @namespace modifiers
   */
  var modifiers = {
    /**
     * Modifier used to shift the popper on the start or end of its reference
     * element.<br />
     * It will read the variation of the `placement` property.<br />
     * It can be one either `-end` or `-start`.
     * @memberof modifiers
     * @inner
     */
    shift: {
      /** @prop {number} order=100 - Index used to define the order of execution */
      order: 100,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: shift
    },

    /**
     * The `offset` modifier can shift your popper on both its axis.
     *
     * It accepts the following units:
     * - `px` or unitless, interpreted as pixels
     * - `%` or `%r`, percentage relative to the length of the reference element
     * - `%p`, percentage relative to the length of the popper element
     * - `vw`, CSS viewport width unit
     * - `vh`, CSS viewport height unit
     *
     * For length is intended the main axis relative to the placement of the popper.<br />
     * This means that if the placement is `top` or `bottom`, the length will be the
     * `width`. In case of `left` or `right`, it will be the height.
     *
     * You can provide a single value (as `Number` or `String`), or a pair of values
     * as `String` divided by a comma or one (or more) white spaces.<br />
     * The latter is a deprecated method because it leads to confusion and will be
     * removed in v2.<br />
     * Additionally, it accepts additions and subtractions between different units.
     * Note that multiplications and divisions aren't supported.
     *
     * Valid examples are:
     * ```
     * 10
     * '10%'
     * '10, 10'
     * '10%, 10'
     * '10 + 10%'
     * '10 - 5vh + 3%'
     * '-10px + 5vh, 5px - 6%'
     * ```
     * > **NB**: If you desire to apply offsets to your poppers in a way that may make them overlap
     * > with their reference element, unfortunately, you will have to disable the `flip` modifier.
     * > More on this [reading this issue](https://github.com/FezVrasta/popper.js/issues/373)
     *
     * @memberof modifiers
     * @inner
     */
    offset: {
      /** @prop {number} order=200 - Index used to define the order of execution */
      order: 200,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: offset,
      /** @prop {Number|String} offset=0
       * The offset value as described in the modifier description
       */
      offset: 0
    },

    /**
     * Modifier used to prevent the popper from being positioned outside the boundary.
     *
     * An scenario exists where the reference itself is not within the boundaries.<br />
     * We can say it has "escaped the boundaries"  or just "escaped".<br />
     * In this case we need to decide whether the popper should either:
     *
     * - detach from the reference and remain "trapped" in the boundaries, or
     * - if it should ignore the boundary and "escape with its reference"
     *
     * When `escapeWithReference` is set to`true` and reference is completely
     * outside its boundaries, the popper will overflow (or completely leave)
     * the boundaries in order to remain attached to the edge of the reference.
     *
     * @memberof modifiers
     * @inner
     */
    preventOverflow: {
      /** @prop {number} order=300 - Index used to define the order of execution */
      order: 300,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: preventOverflow,
      /**
       * @prop {Array} [priority=['left','right','top','bottom']]
       * Popper will try to prevent overflow following these priorities by default,
       * then, it could overflow on the left and on top of the `boundariesElement`
       */
      priority: ['left', 'right', 'top', 'bottom'],
      /**
       * @prop {number} padding=5
       * Amount of pixel used to define a minimum distance between the boundaries
       * and the popper this makes sure the popper has always a little padding
       * between the edges of its container
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='scrollParent'
       * Boundaries used by the modifier, can be `scrollParent`, `window`,
       * `viewport` or any DOM element.
       */
      boundariesElement: 'scrollParent'
    },

    /**
     * Modifier used to make sure the reference and its popper stay near eachothers
     * without leaving any gap between the two. Expecially useful when the arrow is
     * enabled and you want to assure it to point to its reference element.
     * It cares only about the first axis, you can still have poppers with margin
     * between the popper and its reference element.
     * @memberof modifiers
     * @inner
     */
    keepTogether: {
      /** @prop {number} order=400 - Index used to define the order of execution */
      order: 400,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: keepTogether
    },

    /**
     * This modifier is used to move the `arrowElement` of the popper to make
     * sure it is positioned between the reference element and its popper element.
     * It will read the outer size of the `arrowElement` node to detect how many
     * pixels of conjuction are needed.
     *
     * It has no effect if no `arrowElement` is provided.
     * @memberof modifiers
     * @inner
     */
    arrow: {
      /** @prop {number} order=500 - Index used to define the order of execution */
      order: 500,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: arrow,
      /** @prop {String|HTMLElement} element='[x-arrow]' - Selector or node used as arrow */
      element: '[x-arrow]'
    },

    /**
     * Modifier used to flip the popper's placement when it starts to overlap its
     * reference element.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     *
     * **NOTE:** this modifier will interrupt the current update cycle and will
     * restart it if it detects the need to flip the placement.
     * @memberof modifiers
     * @inner
     */
    flip: {
      /** @prop {number} order=600 - Index used to define the order of execution */
      order: 600,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: flip,
      /**
       * @prop {String|Array} behavior='flip'
       * The behavior used to change the popper's placement. It can be one of
       * `flip`, `clockwise`, `counterclockwise` or an array with a list of valid
       * placements (with optional variations).
       */
      behavior: 'flip',
      /**
       * @prop {number} padding=5
       * The popper will flip if it hits the edges of the `boundariesElement`
       */
      padding: 5,
      /**
       * @prop {String|HTMLElement} boundariesElement='viewport'
       * The element which will define the boundaries of the popper position,
       * the popper will never be placed outside of the defined boundaries
       * (except if keepTogether is enabled)
       */
      boundariesElement: 'viewport'
    },

    /**
     * Modifier used to make the popper flow toward the inner of the reference element.
     * By default, when this modifier is disabled, the popper will be placed outside
     * the reference element.
     * @memberof modifiers
     * @inner
     */
    inner: {
      /** @prop {number} order=700 - Index used to define the order of execution */
      order: 700,
      /** @prop {Boolean} enabled=false - Whether the modifier is enabled or not */
      enabled: false,
      /** @prop {ModifierFn} */
      fn: inner
    },

    /**
     * Modifier used to hide the popper when its reference element is outside of the
     * popper boundaries. It will set a `x-out-of-boundaries` attribute which can
     * be used to hide with a CSS selector the popper when its reference is
     * out of boundaries.
     *
     * Requires the `preventOverflow` modifier before it in order to work.
     * @memberof modifiers
     * @inner
     */
    hide: {
      /** @prop {number} order=800 - Index used to define the order of execution */
      order: 800,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: hide
    },

    /**
     * Computes the style that will be applied to the popper element to gets
     * properly positioned.
     *
     * Note that this modifier will not touch the DOM, it just prepares the styles
     * so that `applyStyle` modifier can apply it. This separation is useful
     * in case you need to replace `applyStyle` with a custom implementation.
     *
     * This modifier has `850` as `order` value to maintain backward compatibility
     * with previous versions of Popper.js. Expect the modifiers ordering method
     * to change in future major versions of the library.
     *
     * @memberof modifiers
     * @inner
     */
    computeStyle: {
      /** @prop {number} order=850 - Index used to define the order of execution */
      order: 850,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: computeStyle,
      /**
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: true,
      /**
       * @prop {string} [x='bottom']
       * Where to anchor the X axis (`bottom` or `top`). AKA X offset origin.
       * Change this if your popper should grow in a direction different from `bottom`
       */
      x: 'bottom',
      /**
       * @prop {string} [x='left']
       * Where to anchor the Y axis (`left` or `right`). AKA Y offset origin.
       * Change this if your popper should grow in a direction different from `right`
       */
      y: 'right'
    },

    /**
     * Applies the computed styles to the popper element.
     *
     * All the DOM manipulations are limited to this modifier. This is useful in case
     * you want to integrate Popper.js inside a framework or view library and you
     * want to delegate all the DOM manipulations to it.
     *
     * Note that if you disable this modifier, you must make sure the popper element
     * has its position set to `absolute` before Popper.js can do its work!
     *
     * Just disable this modifier and define you own to achieve the desired effect.
     *
     * @memberof modifiers
     * @inner
     */
    applyStyle: {
      /** @prop {number} order=900 - Index used to define the order of execution */
      order: 900,
      /** @prop {Boolean} enabled=true - Whether the modifier is enabled or not */
      enabled: true,
      /** @prop {ModifierFn} */
      fn: applyStyle,
      /** @prop {Function} */
      onLoad: applyStyleOnLoad,
      /**
       * @deprecated since version 1.10.0, the property moved to `computeStyle` modifier
       * @prop {Boolean} gpuAcceleration=true
       * If true, it uses the CSS 3d transformation to position the popper.
       * Otherwise, it will use the `top` and `left` properties.
       */
      gpuAcceleration: undefined
    }
  };

  /**
   * The `dataObject` is an object containing all the informations used by Popper.js
   * this object get passed to modifiers and to the `onCreate` and `onUpdate` callbacks.
   * @name dataObject
   * @property {Object} data.instance The Popper.js instance
   * @property {String} data.placement Placement applied to popper
   * @property {String} data.originalPlacement Placement originally defined on init
   * @property {Boolean} data.flipped True if popper has been flipped by flip modifier
   * @property {Boolean} data.hide True if the reference element is out of boundaries, useful to know when to hide the popper.
   * @property {HTMLElement} data.arrowElement Node used as arrow by arrow modifier
   * @property {Object} data.styles Any CSS property defined here will be applied to the popper, it expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.arrowStyles Any CSS property defined here will be applied to the popper arrow, it expects the JavaScript nomenclature (eg. `marginBottom`)
   * @property {Object} data.boundaries Offsets of the popper boundaries
   * @property {Object} data.offsets The measurements of popper, reference and arrow elements.
   * @property {Object} data.offsets.popper `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.reference `top`, `left`, `width`, `height` values
   * @property {Object} data.offsets.arrow] `top` and `left` offsets, only one of them will be different from 0
   */

  /**
   * Default options provided to Popper.js constructor.<br />
   * These can be overriden using the `options` argument of Popper.js.<br />
   * To override an option, simply pass as 3rd argument an object with the same
   * structure of this object, example:
   * ```
   * new Popper(ref, pop, {
   *   modifiers: {
   *     preventOverflow: { enabled: false }
   *   }
   * })
   * ```
   * @type {Object}
   * @static
   * @memberof Popper
   */
  var Defaults$1 = {
    /**
     * Popper's placement
     * @prop {Popper.placements} placement='bottom'
     */
    placement: 'bottom',

    /**
     * Whether events (resize, scroll) are initially enabled
     * @prop {Boolean} eventsEnabled=true
     */
    eventsEnabled: true,

    /**
     * Set to true if you want to automatically remove the popper when
     * you call the `destroy` method.
     * @prop {Boolean} removeOnDestroy=false
     */
    removeOnDestroy: false,

    /**
     * Callback called when the popper is created.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onCreate}
     */
    onCreate: function onCreate() {},

    /**
     * Callback called when the popper is updated, this callback is not called
     * on the initialization/creation of the popper, but only on subsequent
     * updates.<br />
     * By default, is set to no-op.<br />
     * Access Popper.js instance with `data.instance`.
     * @prop {onUpdate}
     */
    onUpdate: function onUpdate() {},

    /**
     * List of modifiers used to modify the offsets before they are applied to the popper.
     * They provide most of the functionalities of Popper.js
     * @prop {modifiers}
     */
    modifiers: modifiers
  };

  /**
   * @callback onCreate
   * @param {dataObject} data
   */

  /**
   * @callback onUpdate
   * @param {dataObject} data
   */

  // Utils
  // Methods
  var Popper = function () {
    /**
     * Create a new Popper.js instance
     * @class Popper
     * @param {HTMLElement|referenceObject} reference - The reference element used to position the popper
     * @param {HTMLElement} popper - The HTML element used as popper.
     * @param {Object} options - Your custom options to override the ones defined in [Defaults](#defaults)
     * @return {Object} instance - The generated Popper.js instance
     */
    function Popper(reference, popper) {
      var _this = this;

      var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
      classCallCheck(this, Popper);

      this.scheduleUpdate = function () {
        return requestAnimationFrame(_this.update);
      };

      // make update() debounced, so that it only runs at most once-per-tick
      this.update = debounce(this.update.bind(this));

      // with {} we create a new object with the options inside it
      this.options = _extends({}, Popper.Defaults, options);

      // init state
      this.state = {
        isDestroyed: false,
        isCreated: false,
        scrollParents: []
      };

      // get reference and popper elements (allow jQuery wrappers)
      this.reference = reference && reference.jquery ? reference[0] : reference;
      this.popper = popper && popper.jquery ? popper[0] : popper;

      // Deep merge modifiers options
      this.options.modifiers = {};
      Object.keys(_extends({}, Popper.Defaults.modifiers, options.modifiers)).forEach(function (name) {
        _this.options.modifiers[name] = _extends({}, Popper.Defaults.modifiers[name] || {}, options.modifiers ? options.modifiers[name] : {});
      });

      // Refactoring modifiers' list (Object => Array)
      this.modifiers = Object.keys(this.options.modifiers).map(function (name) {
        return _extends({
          name: name
        }, _this.options.modifiers[name]);
      })
      // sort the modifiers by order
      .sort(function (a, b) {
        return a.order - b.order;
      });

      // modifiers have the ability to execute arbitrary code when Popper.js get inited
      // such code is executed in the same order of its modifier
      // they could add new properties to their options configuration
      // BE AWARE: don't add options to `options.modifiers.name` but to `modifierOptions`!
      this.modifiers.forEach(function (modifierOptions) {
        if (modifierOptions.enabled && isFunction(modifierOptions.onLoad)) {
          modifierOptions.onLoad(_this.reference, _this.popper, _this.options, modifierOptions, _this.state);
        }
      });

      // fire the first update to position the popper in the right place
      this.update();

      var eventsEnabled = this.options.eventsEnabled;
      if (eventsEnabled) {
        // setup event listeners, they will take care of update the position in specific situations
        this.enableEventListeners();
      }

      this.state.eventsEnabled = eventsEnabled;
    }

    // We can't use class properties because they don't get listed in the
    // class prototype and break stuff like Sinon stubs


    createClass(Popper, [{
      key: 'update',
      value: function update$$1() {
        return update.call(this);
      }
    }, {
      key: 'destroy',
      value: function destroy$$1() {
        return destroy.call(this);
      }
    }, {
      key: 'enableEventListeners',
      value: function enableEventListeners$$1() {
        return enableEventListeners.call(this);
      }
    }, {
      key: 'disableEventListeners',
      value: function disableEventListeners$$1() {
        return disableEventListeners.call(this);
      }

      /**
       * Schedule an update, it will run on the next UI update available
       * @method scheduleUpdate
       * @memberof Popper
       */

      /**
       * Collection of utilities useful when writing custom modifiers.
       * Starting from version 1.7, this method is available only if you
       * include `popper-utils.js` before `popper.js`.
       *
       * **DEPRECATION**: This way to access PopperUtils is deprecated
       * and will be removed in v2! Use the PopperUtils module directly instead.
       * Due to the high instability of the methods contained in Utils, we can't
       * guarantee them to follow semver. Use them at your own risk!
       * @static
       * @private
       * @type {Object}
       * @deprecated since version 1.8
       * @member Utils
       * @memberof Popper
       */

    }]);
    return Popper;
  }();

  /**
   * The `referenceObject` is an object that provides an interface compatible with Popper.js
   * and lets you use it as replacement of a real DOM node.<br />
   * You can use this method to position a popper relatively to a set of coordinates
   * in case you don't have a DOM node to use as reference.
   *
   * ```
   * new Popper(referenceObject, popperNode);
   * ```
   *
   * NB: This feature isn't supported in Internet Explorer 10
   * @name referenceObject
   * @property {Function} data.getBoundingClientRect
   * A function that returns a set of coordinates compatible with the native `getBoundingClientRect` method.
   * @property {number} data.clientWidth
   * An ES6 getter that will return the width of the virtual reference element.
   * @property {number} data.clientHeight
   * An ES6 getter that will return the height of the virtual reference element.
   */

  Popper.Utils = (typeof window !== 'undefined' ? window : global).PopperUtils;
  Popper.placements = placements;
  Popper.Defaults = Defaults$1;

  /**
  * Returns the distance taking into account the default distance due to
  * the transform: translate setting in CSS
  * @param {Number} distance
  * @return {String}
  */
  function getOffsetDistanceInPx(distance) {
    return -(distance - Defaults.distance) + 'px';
  }

  var classCallCheck$1 = function classCallCheck$1(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass$1 = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends$1 = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  /**
  * Creates a new popper instance
  * @param {Object} data
  * @return {Object} - the popper instance
  */
  function createPopperInstance(data) {
    var el = data.el,
        popper = data.popper,
        _data$settings = data.settings,
        position = _data$settings.position,
        popperOptions = _data$settings.popperOptions,
        offset = _data$settings.offset,
        distance = _data$settings.distance,
        flipDuration = _data$settings.flipDuration;

    var _getInnerElements = getInnerElements(popper),
        tooltip = _getInnerElements.tooltip;

    var config = _extends$1({
      placement: position
    }, popperOptions || {}, {
      modifiers: _extends$1({}, popperOptions ? popperOptions.modifiers : {}, {
        flip: _extends$1({
          padding: distance + 5 /* 5px from viewport boundary */
        }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.flip : {}),
        offset: _extends$1({
          offset: offset
        }, popperOptions && popperOptions.modifiers ? popperOptions.modifiers.offset : {})
      }),
      onUpdate: function onUpdate() {
        var styles = tooltip.style;
        styles.top = '';
        styles.bottom = '';
        styles.left = '';
        styles.right = '';
        styles[getCorePlacement(popper.getAttribute('x-placement'))] = getOffsetDistanceInPx(distance);
      }
    });

    // Update the popper's position whenever its content changes
    // Not supported in IE10 unless polyfilled
    if (window.MutationObserver) {
      var styles = popper.style;

      var observer = new MutationObserver(function () {
        styles[prefix('transitionDuration')] = '0ms';
        data.popperInstance.update();
        defer(function () {
          styles[prefix('transitionDuration')] = flipDuration + 'ms';
        });
      });

      observer.observe(popper, {
        childList: true,
        subtree: true,
        characterData: true
      });

      data._mutationObservers.push(observer);
    }

    return new Popper(el, popper, config);
  }

  /**
  * Appends the popper and creates a popper instance if one does not exist
  * Also updates its position if need be and enables event listeners
  * @param {Object} data -  the element/popper reference data
  */
  function mountPopper(data) {
    var el = data.el,
        popper = data.popper,
        _data$settings = data.settings,
        appendTo = _data$settings.appendTo,
        followCursor = _data$settings.followCursor;

    // Already on the DOM

    if (appendTo.contains(popper)) return;

    appendTo.appendChild(popper);

    if (!data.popperInstance) {
      data.popperInstance = createPopperInstance(data);
    } else {
      data.popperInstance.update();
      if (!followCursor || Browser.touch) {
        data.popperInstance.enableEventListeners();
      }
    }

    // Since touch is determined dynamically, followCursor is set on mount
    if (followCursor && !Browser.touch) {
      el.addEventListener('mousemove', followCursorHandler);
      data.popperInstance.disableEventListeners();
    }
  }

  /**
  * Updates a popper's position on each animation frame to make it stick to a moving element
  * @param {Object} refData
  */
  function makeSticky(refData) {
    var popper = refData.popper,
        popperInstance = refData.popperInstance,
        stickyDuration = refData.settings.stickyDuration;

    var applyTransitionDuration = function applyTransitionDuration() {
      return popper.style[prefix('transitionDuration')] = stickyDuration + 'ms';
    };

    var removeTransitionDuration = function removeTransitionDuration() {
      return popper.style[prefix('transitionDuration')] = '';
    };

    var updatePosition = function updatePosition() {
      popperInstance && popperInstance.scheduleUpdate();

      applyTransitionDuration();

      isVisible(popper) ? window.requestAnimationFrame(updatePosition) : removeTransitionDuration();
    };

    // Wait until Popper's position has been updated initially
    defer(updatePosition);
  }

  /**
  * Returns an object of settings to override global settings
  * @param {Element} el - the tooltipped element
  * @param {Object} instanceSettings
  * @return {Object} - individual settings
  */
  function getIndividualSettings(el, instanceSettings) {
    var settings = DefaultsKeys.reduce(function (acc, key) {
      var val = el.getAttribute('data-' + key.toLowerCase()) || instanceSettings[key];

      // Convert strings to booleans
      if (val === 'false') val = false;
      if (val === 'true') val = true;

      // Convert number strings to true numbers
      if (isFinite(val) && !isNaN(parseFloat(val))) {
        val = parseFloat(val);
      }

      // Convert array strings to actual arrays
      if (typeof val === 'string' && val.trim().charAt(0) === '[') {
        val = JSON.parse(val);
      }

      acc[key] = val;

      return acc;
    }, {});

    return _extends$1({}, instanceSettings, settings);
  }

  /**
  * Creates a popper element then returns it
  * @param {Number} id - the popper id
  * @param {String} title - the tooltip's `title` attribute
  * @param {Object} settings - individual settings
  * @return {Element} - the popper element
  */
  function createPopperElement(id, title, settings) {
    var position = settings.position,
        distance = settings.distance,
        arrow = settings.arrow,
        animateFill = settings.animateFill,
        inertia = settings.inertia,
        animation = settings.animation,
        arrowSize = settings.arrowSize,
        size = settings.size,
        theme = settings.theme,
        html = settings.html,
        zIndex = settings.zIndex,
        interactive = settings.interactive;

    var popper = document.createElement('div');
    popper.setAttribute('class', 'tippy-popper');
    popper.setAttribute('role', 'tooltip');
    popper.setAttribute('aria-hidden', 'true');
    popper.setAttribute('id', 'tippy-tooltip-' + id);
    popper.style.zIndex = zIndex;

    var tooltip = document.createElement('div');
    tooltip.setAttribute('class', 'tippy-tooltip tippy-tooltip--' + size + ' leave');
    tooltip.setAttribute('data-animation', animation);

    theme.split(' ').forEach(function (t) {
      tooltip.classList.add(t + '-theme');
    });

    if (arrow) {
      // Add an arrow
      var _arrow = document.createElement('div');
      _arrow.setAttribute('class', 'arrow-' + arrowSize);
      _arrow.setAttribute('x-arrow', '');
      tooltip.appendChild(_arrow);
    }

    if (animateFill) {
      // Create animateFill circle element for animation
      tooltip.setAttribute('data-animatefill', '');
      var circle = document.createElement('div');
      circle.setAttribute('class', 'leave');
      circle.setAttribute('x-circle', '');
      tooltip.appendChild(circle);
    }

    if (inertia) {
      // Change transition timing function cubic bezier
      tooltip.setAttribute('data-inertia', '');
    }

    if (interactive) {
      tooltip.setAttribute('data-interactive', '');
    }

    // Tooltip content (text or HTML)
    var content = document.createElement('div');
    content.setAttribute('class', 'tippy-tooltip-content');

    if (html) {
      var templateId = void 0;

      if (html instanceof Element) {
        content.appendChild(html);
        templateId = '#' + html.id || 'tippy-html-template';
      } else {
        content.innerHTML = document.getElementById(html.replace('#', '')).innerHTML;
        templateId = html;
      }

      popper.classList.add('html-template');
      interactive && popper.setAttribute('tabindex', '-1');
      tooltip.setAttribute('data-template-id', templateId);
    } else {
      content.innerHTML = title;
    }

    // Init distance. Further updates are made in the popper instance's `onUpdate()` method
    tooltip.style[getCorePlacement(position)] = getOffsetDistanceInPx(distance);

    tooltip.appendChild(content);
    popper.appendChild(tooltip);

    return popper;
  }

  /**
  * Creates a trigger
  * @param {Object} event - the custom event specified in the `trigger` setting
  * @param {Element} el - tooltipped element
  * @param {Object} handlers - the handlers for each listener
  * @param {Boolean} touchHold
  * @return {Array} - array of listener objects
  */
  function createTrigger(event, el, handlers, touchHold) {
    var listeners = [];

    if (event === 'manual') return listeners;

    // Enter
    el.addEventListener(event, handlers.handleTrigger);
    listeners.push({
      event: event,
      handler: handlers.handleTrigger
    });

    // Leave
    if (event === 'mouseenter') {
      if (Browser.SUPPORTS_TOUCH && touchHold) {
        el.addEventListener('touchstart', handlers.handleTrigger);
        listeners.push({
          event: 'touchstart',
          handler: handlers.handleTrigger
        });
        el.addEventListener('touchend', handlers.handleMouseleave);
        listeners.push({
          event: 'touchend',
          handler: handlers.handleMouseleave
        });
      }

      el.addEventListener('mouseleave', handlers.handleMouseleave);
      listeners.push({
        event: 'mouseleave',
        handler: handlers.handleMouseleave
      });
    }

    if (event === 'focus') {
      el.addEventListener('blur', handlers.handleBlur);
      listeners.push({
        event: 'blur',
        handler: handlers.handleBlur
      });
    }

    return listeners;
  }

  /**
  * Determines if the mouse's cursor is outside the interactive border
  * @param {MouseEvent} event
  * @param {Element} popper
  * @param {Object} settings
  * @return {Boolean}
  */
  function cursorIsOutsideInteractiveBorder(event, popper, settings) {
    if (!popper.getAttribute('x-placement')) return true;

    var x = event.clientX,
        y = event.clientY;
    var interactiveBorder = settings.interactiveBorder,
        distance = settings.distance;

    var rect = popper.getBoundingClientRect();
    var corePosition = getCorePlacement(popper.getAttribute('x-placement'));
    var borderWithDistance = interactiveBorder + distance;

    var exceeds = {
      top: rect.top - y > interactiveBorder,
      bottom: y - rect.bottom > interactiveBorder,
      left: rect.left - x > interactiveBorder,
      right: x - rect.right > interactiveBorder
    };

    switch (corePosition) {
      case 'top':
        exceeds.top = rect.top - y > borderWithDistance;
        break;
      case 'bottom':
        exceeds.bottom = y - rect.bottom > borderWithDistance;
        break;
      case 'left':
        exceeds.left = rect.left - x > borderWithDistance;
        break;
      case 'right':
        exceeds.right = x - rect.right > borderWithDistance;
        break;
    }

    return exceeds.top || exceeds.bottom || exceeds.left || exceeds.right;
  }

  /**
  * Returns relevant listener callbacks for each ref
  * @param {Element} el
  * @param {Element} popper
  * @param {Object} settings
  * @return {Object} - relevant listener handlers
  */
  function getEventListenerHandlers(el, popper, settings) {
    var _this = this;

    var position = settings.position,
        delay = settings.delay,
        duration = settings.duration,
        interactive = settings.interactive,
        interactiveBorder = settings.interactiveBorder,
        distance = settings.distance,
        hideOnClick = settings.hideOnClick,
        trigger = settings.trigger,
        touchHold = settings.touchHold,
        touchWait = settings.touchWait;

    var showDelay = void 0,
        hideDelay = void 0;

    var clearTimeouts = function clearTimeouts() {
      clearTimeout(showDelay);
      clearTimeout(hideDelay);
    };

    var _show = function _show() {
      clearTimeouts();

      // Not hidden. For clicking when it also has a `focus` event listener
      if (isVisible(popper)) return;

      var _delay = Array.isArray(delay) ? delay[0] : delay;

      if (delay) {
        showDelay = setTimeout(function () {
          return _this.show(popper);
        }, _delay);
      } else {
        _this.show(popper);
      }
    };

    var show = function show(event) {
      return _this.callbacks.wait ? _this.callbacks.wait.call(popper, _show, event) : _show();
    };

    var hide = function hide() {
      clearTimeouts();

      var _delay = Array.isArray(delay) ? delay[1] : delay;

      if (delay) {
        hideDelay = setTimeout(function () {
          return _this.hide(popper);
        }, _delay);
      } else {
        _this.hide(popper);
      }
    };

    var handleTrigger = function handleTrigger(event) {
      var mouseenterTouch = event.type === 'mouseenter' && Browser.SUPPORTS_TOUCH && Browser.touch;

      if (mouseenterTouch && touchHold) return;

      // Toggle show/hide when clicking click-triggered tooltips
      var isClick = event.type === 'click';
      var isNotPersistent = hideOnClick !== 'persistent';

      isClick && isVisible(popper) && isNotPersistent ? hide() : show(event);

      if (mouseenterTouch && Browser.iOS() && el.click) {
        el.click();
      }
    };

    var handleMouseleave = function handleMouseleave(event) {

      // Don't fire 'mouseleave', use the 'touchend'
      if (event.type === 'mouseleave' && Browser.SUPPORTS_TOUCH && Browser.touch && touchHold) {
        return;
      }

      if (interactive) {
        // Temporarily handle mousemove to check if the mouse left somewhere
        // other than its popper
        var handleMousemove = function handleMousemove(event) {

          var triggerHide = function triggerHide() {
            document.body.removeEventListener('mouseleave', hide);
            document.removeEventListener('mousemove', handleMousemove);
            hide();
          };

          var closestTooltippedEl = closest(event.target, Selectors.TOOLTIPPED_EL);

          var isOverPopper = closest(event.target, Selectors.POPPER) === popper;
          var isOverEl = closestTooltippedEl === el;
          var isClickTriggered = trigger.indexOf('click') !== -1;
          var isOverOtherTooltippedEl = closestTooltippedEl && closestTooltippedEl !== el;

          if (isOverOtherTooltippedEl) {
            return triggerHide();
          }

          if (isOverPopper || isOverEl || isClickTriggered) return;

          if (cursorIsOutsideInteractiveBorder(event, popper, settings)) {
            triggerHide();
          }
        };

        document.body.addEventListener('mouseleave', hide);
        document.addEventListener('mousemove', handleMousemove);

        return;
      }

      // If it's not interactive, just hide it
      hide();
    };

    var handleBlur = function handleBlur(event) {
      // Ignore blur on touch devices, if there is no `relatedTarget`, hide
      // If the related target is a popper, ignore
      if (!event.relatedTarget || Browser.touch) return;
      if (closest(event.relatedTarget, Selectors.POPPER)) return;

      hide();
    };

    return {
      handleTrigger: handleTrigger,
      handleMouseleave: handleMouseleave,
      handleBlur: handleBlur
    };
  }

  /**
  * Evaluates/modifies the settings object for appropriate behavior
  * @param {Object} settings
  * @return {Object} modified/evaluated settings
  */
  function evaluateSettings(settings) {
    // animateFill is disabled if an arrow is true
    if (settings.arrow) {
      settings.animateFill = false;
    }

    // reassign appendTo into the result of evaluating appendTo
    // if it's set as a function instead of Element
    if (settings.appendTo && typeof settings.appendTo === 'function') {
      settings.appendTo = settings.appendTo();
    }

    return settings;
  }

  var idCounter = 1;

  /**
  * Creates tooltips for all el elements that match the instance's selector
  * @param {Element[]} els
  * @return {Object[]} Array of ref data objects
  */
  function createTooltips(els) {
    var _this = this;

    return els.reduce(function (acc, el) {
      var id = idCounter;

      var settings = _extends$1({}, evaluateSettings(_this.settings.performance ? _this.settings : getIndividualSettings(el, _this.settings)));

      if (typeof settings.html === 'function') settings.html = settings.html(el);

      var html = settings.html,
          trigger = settings.trigger,
          touchHold = settings.touchHold,
          dynamicTitle = settings.dynamicTitle;

      var title = el.getAttribute('title');
      if (!title && !html) return acc;

      el.setAttribute('data-tooltipped', '');
      el.setAttribute('aria-describedby', 'tippy-tooltip-' + id);
      removeTitle(el);

      var popper = createPopperElement(id, title, settings);
      var handlers = getEventListenerHandlers.call(_this, el, popper, settings);

      var listeners = [];

      trigger.trim().split(' ').forEach(function (event) {
        return listeners = listeners.concat(createTrigger(event, el, handlers, touchHold));
      });

      // Add a mutation observer to observe the reference element for `title`
      // attribute changes, then automatically update tooltip content
      var observer = void 0;

      if (dynamicTitle && window.MutationObserver) {
        var _getInnerElements = getInnerElements(popper),
            content = _getInnerElements.content;

        observer = new MutationObserver(function () {
          var title = el.getAttribute('title');
          if (title) {
            content.innerHTML = title;
            removeTitle(el);
          }
        });

        observer.observe(el, { attributes: true });
      }

      acc.push({
        id: id,
        el: el,
        popper: popper,
        settings: settings,
        listeners: listeners,
        tippyInstance: _this,
        _mutationObservers: [observer]
      });

      idCounter++;

      return acc;
    }, []);
  }

  /* Utility functions */
  /* Core library functions */
  /**
  * @param {String|Element|Element[]} selector
  * @param {Object} settings (optional) - the object of settings to be applied to the instance
  */

  var Tippy = function () {
    function Tippy(selector) {
      var settings = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
      classCallCheck$1(this, Tippy);

      // Use default browser tooltip on unsupported browsers
      if (!Browser.SUPPORTED) return;

      init();

      this.state = {
        destroyed: false
      };

      this.selector = selector;

      this.settings = _extends$1({}, Defaults, settings);

      if (settings.show || settings.shown || settings.hide || settings.hidden) {
        console.warn('Callbacks without the `on` prefix are deprecated (with the exception of `wait`).' + ' Use onShow, onShown, onHide, and onHidden instead.');
      }

      this.callbacks = {
        wait: settings.wait,
        show: settings.onShow || settings.show || noop,
        shown: settings.onShown || settings.shown || noop,
        hide: settings.onHide || settings.hide || noop,
        hidden: settings.onHidden || settings.hidden || noop
      };

      this.store = createTooltips.call(this, getArrayOfElements(selector));
      Store.push.apply(Store, this.store);
    }

    /**
    * Returns the reference element's popper element
    * @param {Element} el
    * @return {Element}
    */

    createClass$1(Tippy, [{
      key: 'getPopperElement',
      value: function getPopperElement(el) {
        try {
          return find(this.store, function (data) {
            return data.el === el;
          }).popper;
        } catch (e) {
          console.error('[getPopperElement]: Element passed as the argument does not exist in the instance');
        }
      }

      /**
      * Returns a popper's reference element
      * @param {Element} popper
      * @return {Element}
      */

    }, {
      key: 'getReferenceElement',
      value: function getReferenceElement(popper) {
        try {
          return find(this.store, function (data) {
            return data.popper === popper;
          }).el;
        } catch (e) {
          console.error('[getReferenceElement]: Popper passed as the argument does not exist in the instance');
        }
      }

      /**
      * Returns the reference data object from either the reference element or popper element
      * @param {Element} x (reference element or popper)
      * @return {Object}
      */

    }, {
      key: 'getReferenceData',
      value: function getReferenceData(x) {
        return find(this.store, function (data) {
          return data.el === x || data.popper === x;
        });
      }

      /**
      * Shows a popper
      * @param {Element} popper
      * @param {Number} customDuration (optional)
      */

    }, {
      key: 'show',
      value: function show(popper, customDuration) {
        var _this = this;

        if (this.state.destroyed) return;

        var data = find(this.store, function (data) {
          return data.popper === popper;
        });

        var _getInnerElements = getInnerElements(popper),
            tooltip = _getInnerElements.tooltip,
            circle = _getInnerElements.circle,
            content = _getInnerElements.content;

        // Destroy popper if its reference is no longer on the DOM (excluding refObjs)


        if (!this.selector.refObj && !document.body.contains(data.el)) {
          this.destroy(popper);
          return;
        }

        this.callbacks.show.call(popper);

        var el = data.el,
            _data$settings = data.settings,
            appendTo = _data$settings.appendTo,
            sticky = _data$settings.sticky,
            interactive = _data$settings.interactive,
            followCursor = _data$settings.followCursor,
            flipDuration = _data$settings.flipDuration,
            duration = _data$settings.duration;

        var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[0] : duration;

        // Prevent a transition when popper changes position
        applyTransitionDuration([popper, tooltip, circle], 0);

        mountPopper(data);

        popper.style.visibility = 'visible';
        popper.setAttribute('aria-hidden', 'false');

        // Wait for popper's position to update
        defer(function () {
          if (!isVisible(popper)) return;

          // Sometimes the arrow will not be in the correct position, force another update
          if (!followCursor || Browser.touch) {
            data.popperInstance.update();
            applyTransitionDuration([popper], flipDuration);
          }

          // Re-apply transition durations
          applyTransitionDuration([tooltip, circle], _duration);

          // Make content fade out a bit faster than the tooltip if `animateFill`
          if (circle) content.style.opacity = 1;

          // Interactive tooltips receive a class of 'active'
          interactive && el.classList.add('active');

          // Update popper's position on every animation frame
          sticky && makeSticky(data);

          // Repaint/reflow is required for CSS transition when appending
          triggerReflow(tooltip, circle);

          modifyClassList([tooltip, circle], function (list) {
            list.contains('tippy-notransition') && list.remove('tippy-notransition');
            list.remove('leave');
            list.add('enter');
          });

          // Wait for transitions to complete
          onTransitionEnd(data, _duration, function () {
            if (!isVisible(popper) || data._onShownFired) return;

            // Focus interactive tooltips only
            interactive && popper.focus();
            // Remove transitions from tooltip
            tooltip.classList.add('tippy-notransition');
            // Prevents shown() from firing more than once from early transition cancellations
            data._onShownFired = true;

            _this.callbacks.shown.call(popper);
          });
        });
      }

      /**
      * Hides a popper
      * @param {Element} popper
      * @param {Number} customDuration (optional)
      */

    }, {
      key: 'hide',
      value: function hide(popper, customDuration) {
        var _this2 = this;

        if (this.state.destroyed) return;

        this.callbacks.hide.call(popper);

        var data = find(this.store, function (data) {
          return data.popper === popper;
        });

        var _getInnerElements2 = getInnerElements(popper),
            tooltip = _getInnerElements2.tooltip,
            circle = _getInnerElements2.circle,
            content = _getInnerElements2.content;

        var el = data.el,
            _data$settings2 = data.settings,
            appendTo = _data$settings2.appendTo,
            sticky = _data$settings2.sticky,
            interactive = _data$settings2.interactive,
            followCursor = _data$settings2.followCursor,
            html = _data$settings2.html,
            trigger = _data$settings2.trigger,
            duration = _data$settings2.duration;

        var _duration = customDuration !== undefined ? customDuration : Array.isArray(duration) ? duration[1] : duration;

        data._onShownFired = false;
        interactive && el.classList.remove('active');

        popper.style.visibility = 'hidden';
        popper.setAttribute('aria-hidden', 'true');

        applyTransitionDuration([tooltip, circle, circle ? content : null], _duration);

        if (circle) content.style.opacity = 0;

        modifyClassList([tooltip, circle], function (list) {
          list.contains('tippy-tooltip') && list.remove('tippy-notransition');
          list.remove('enter');
          list.add('leave');
        });

        // Re-focus click-triggered html elements
        // and the tooltipped element IS in the viewport (otherwise it causes unsightly scrolling
        // if the tooltip is closed and the element isn't in the viewport anymore)
        if (html && trigger.indexOf('click') !== -1 && elementIsInViewport(el)) {
          el.focus();
        }

        // Wait for transitions to complete
        onTransitionEnd(data, _duration, function () {
          // `isVisible` is not completely reliable to determine if we shouldn't
          // run the hidden callback, we need to check the computed opacity style.
          // This prevents glitchy behavior of the transition when quickly showing
          // and hiding a tooltip.
          if (isVisible(popper) || !appendTo.contains(popper) || getComputedStyle(tooltip).opacity === '1') return;

          el.removeEventListener('mousemove', followCursorHandler);
          data.popperInstance.disableEventListeners();
          appendTo.removeChild(popper);

          _this2.callbacks.hidden.call(popper);
        });
      }

      /**
      * Updates a popper with new content
      * @param {Element} popper
      */

    }, {
      key: 'update',
      value: function update(popper) {
        if (this.state.destroyed) return;

        var data = find(this.store, function (data) {
          return data.popper === popper;
        });

        var _getInnerElements3 = getInnerElements(popper),
            content = _getInnerElements3.content;

        var el = data.el,
            html = data.settings.html;

        if (html instanceof Element) {
          console.warn('Aborted: update() should not be used if `html` is a DOM element');
          return;
        }

        content.innerHTML = html ? document.getElementById(html.replace('#', '')).innerHTML : el.getAttribute('title') || el.getAttribute('data-original-title');

        if (!html) removeTitle(el);
      }

      /**
      * Destroys a popper
      * @param {Element} popper
      * @param {Boolean} _isLast - private param used by destroyAll to optimize
      */

    }, {
      key: 'destroy',
      value: function destroy(popper, _isLast) {
        var _this3 = this;

        if (this.state.destroyed) return;

        var data = find(this.store, function (data) {
          return data.popper === popper;
        });

        var el = data.el,
            popperInstance = data.popperInstance,
            listeners = data.listeners,
            _mutationObservers = data._mutationObservers;

        // Ensure the popper is hidden

        if (isVisible(popper)) {
          this.hide(popper, 0);
        }

        // Remove Tippy-only event listeners from tooltipped element
        listeners.forEach(function (listener) {
          return el.removeEventListener(listener.event, listener.handler);
        });

        // Restore original title
        el.setAttribute('title', el.getAttribute('data-original-title'));

        el.removeAttribute('data-original-title');
        el.removeAttribute('data-tooltipped');
        el.removeAttribute('aria-describedby');

        popperInstance && popperInstance.destroy();

        _mutationObservers.forEach(function (observer) {
          observer && observer.disconnect();
        });

        // Remove from store
        Store.splice(findIndex(Store, function (data) {
          return data.popper === popper;
        }), 1);

        // Ensure filter is called only once
        if (_isLast === undefined || _isLast) {
          this.store = Store.filter(function (data) {
            return data.tippyInstance === _this3;
          });
        }
      }

      /**
      * Destroys all tooltips created by the instance
      */

    }, {
      key: 'destroyAll',
      value: function destroyAll() {
        var _this4 = this;

        if (this.state.destroyed) return;

        var storeLength = this.store.length;

        this.store.forEach(function (_ref, index) {
          var popper = _ref.popper;

          _this4.destroy(popper, index === storeLength - 1);
        });

        this.store = null;
        this.state.destroyed = true;
      }
    }]);
    return Tippy;
  }();

  function tippy$2(selector, settings) {
    // Create a virtual object for custom positioning
    if (isObjectLiteral(selector)) {
      selector = {
        refObj: true,
        attributes: selector.attributes || {},
        getBoundingClientRect: selector.getBoundingClientRect,
        clientWidth: selector.clientWidth,
        clientHeight: selector.clientHeight,
        setAttribute: function setAttribute(key, val) {
          selector.attributes[key] = val;
        },
        getAttribute: function getAttribute(key) {
          return selector.attributes[key];
        },
        removeAttribute: function removeAttribute(key) {
          delete selector.attributes[key];
        },
        addEventListener: function addEventListener() {},
        removeEventListener: function removeEventListener() {},
        classList: {
          classNames: {},
          add: function add(key) {
            selector.classList.classNames[key] = true;
          },
          remove: function remove(key) {
            selector.classList.classNames[key] = false;
            return true;
          },
          contains: function contains(key) {
            return !!selector.classList.classNames[key];
          }
        }
      };
    }

    return new Tippy(selector, settings);
  }

  tippy$2.Browser = Browser;
  tippy$2.Defaults = Defaults;
  tippy$2.disableDynamicInputDetection = function () {
    return Browser.dynamicInputDetection = false;
  };
  tippy$2.enableDynamicInputDetection = function () {
    return Browser.dynamicInputDetection = true;
  };

  return tippy$2;
});
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js")))

/***/ }),

/***/ "./node_modules/vue-awesome/components/Icon.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue")
}
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-afaabd70\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vue-awesome/components/Icon.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-afaabd70", Component.options)
  } else {
    hotAPI.reload("data-v-afaabd70", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vue-awesome/icons/archive.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "archive": { "width": 1792, "height": 1792, "paths": [{ "d": "M1088 832q0-26-19-45t-45-19h-256q-26 0-45 19t-19 45 19 45 45 19h256q26 0 45-19t19-45zM1664 640v960q0 26-19 45t-45 19h-1408q-26 0-45-19t-19-45v-960q0-26 19-45t45-19h1408q26 0 45 19t19 45zM1728 192v256q0 26-19 45t-45 19h-1536q-26 0-45-19t-19-45v-256q0-26 19-45t45-19h1536q26 0 45 19t19 45z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/file-o.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "file-o": { "width": 1536, "height": 1792, "paths": [{ "d": "M1468 380q28 28 48 76t20 88v1152q0 40-28 68t-68 28h-1344q-40 0-68-28t-28-68v-1600q0-40 28-68t68-28h896q40 0 88 20t76 48zM1024 136v376h376q-10-29-22-41l-313-313q-12-12-41-22zM1408 1664v-1024h-416q-40 0-68-28t-28-68v-416h-768v1536h1280z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/file.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "file": { "width": 1536, "height": 1792, "paths": [{ "d": "M1024 512v-472q22 14 36 28l408 408q14 14 28 36h-472zM896 544q0 40 28 68t68 28h544v1056q0 40-28 68t-68 28h-1344q-40 0-68-28t-28-68v-1600q0-40 28-68t68-28h800v544z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/files-o.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "files-o": { "width": 1792, "height": 1792, "paths": [{ "d": "M1696 384q40 0 68 28t28 68v1216q0 40-28 68t-68 28h-960q-40 0-68-28t-28-68v-288h-544q-40 0-68-28t-28-68v-672q0-40 20-88t48-76l408-408q28-28 76-48t88-20h416q40 0 68 28t28 68v328q68-40 128-40h416zM1152 597l-299 299h299v-299zM512 213l-299 299h299v-299zM708 860l316-316v-416h-384v416q0 40-28 68t-68 28h-416v640h512v-256q0-40 20-88t48-76zM1664 1664v-1152h-384v416q0 40-28 68t-68 28h-416v640h896z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/folder.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "folder": { "width": 1664, "height": 1792, "paths": [{ "d": "M1664 608v704q0 92-66 158t-158 66h-1216q-92 0-158-66t-66-158v-960q0-92 66-158t158-66h320q92 0 158 66t66 158v32h672q92 0 158 66t66 158z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/globe.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "globe": { "width": 1536, "height": 1792, "paths": [{ "d": "M768 128q209 0 385.5 103t279.5 279.5 103 385.5-103 385.5-279.5 279.5-385.5 103-385.5-103-279.5-279.5-103-385.5 103-385.5 279.5-279.5 385.5-103zM1042 649q-2 1-9.5 9.5t-13.5 9.5q2 0 4.5-5t5-11 3.5-7q6-7 22-15 14-6 52-12 34-8 51 11-2-2 9.5-13t14.5-12q3-2 15-4.5t15-7.5l2-22q-12 1-17.5-7t-6.5-21q0 2-6 8 0-7-4.5-8t-11.5 1-9 1q-10-3-15-7.5t-8-16.5-4-15q-2-5-9.5-11t-9.5-10q-1-2-2.5-5.5t-3-6.5-4-5.5-5.5-2.5-7 5-7.5 10-4.5 5q-3-2-6-1.5t-4.5 1-4.5 3-5 3.5q-3 2-8.5 3t-8.5 2q15-5-1-11-10-4-16-3 9-4 7.5-12t-8.5-14h5q-1-4-8.5-8.5t-17.5-8.5-13-6q-8-5-34-9.5t-33-0.5q-5 6-4.5 10.5t4 14 3.5 12.5q1 6-5.5 13t-6.5 12q0 7 14 15.5t10 21.5q-3 8-16 16t-16 12q-5 8-1.5 18.5t10.5 16.5q2 2 1.5 4t-3.5 4.5-5.5 4-6.5 3.5l-3 2q-11 5-20.5-6t-13.5-26q-7-25-16-30-23-8-29 1-5-13-41-26-25-9-58-4 6-1 0-15-7-15-19-12 3-6 4-17.5t1-13.5q3-13 12-23 1-1 7-8.5t9.5-13.5 0.5-6q35 4 50-11 5-5 11.5-17t10.5-17q9-6 14-5.5t14.5 5.5 14.5 5q14 1 15.5-11t-7.5-20q12 1 3-17-4-7-8-9-12-4-27 5-8 4 2 8-1-1-9.5 10.5t-16.5 17.5-16-5q-1-1-5.5-13.5t-9.5-13.5q-8 0-16 15 3-8-11-15t-24-8q19-12-8-27-7-4-20.5-5t-19.5 4q-5 7-5.5 11.5t5 8 10.5 5.5 11.5 4 8.5 3q14 10 8 14-2 1-8.5 3.5t-11.5 4.5-6 4q-3 4 0 14t-2 14q-5-5-9-17.5t-7-16.5q7 9-25 6l-10-1q-4 0-16 2t-20.5 1-13.5-8q-4-8 0-20 1-4 4-2-4-3-11-9.5t-10-8.5q-46 15-94 41 6 1 12-1 5-2 13-6.5t10-5.5q34-14 42-7l5-5q14 16 20 25-7-4-30-1-20 6-22 12 7 12 5 18-4-3-11.5-10t-14.5-11-15-5q-16 0-22 1-146 80-235 222 7 7 12 8 4 1 5 9t2.5 11 11.5-3q9 8 3 19 1-1 44 27 19 17 21 21 3 11-10 18-1-2-9-9t-9-4q-3 5 0.5 18.5t10.5 12.5q-7 0-9.5 16t-2.5 35.5-1 23.5l2 1q-3 12 5.5 34.5t21.5 19.5q-13 3 20 43 6 8 8 9 3 2 12 7.5t15 10 10 10.5q4 5 10 22.5t14 23.5q-2 6 9.5 20t10.5 23q-1 0-2.5 1t-2.5 1q3 7 15.5 14t15.5 13q1 3 2 10t3 11 8 2q2-20-24-62-15-25-17-29-3-5-5.5-15.5t-4.5-14.5q2 0 6 1.5t8.5 3.5 7.5 4 2 3q-3 7 2 17.5t12 18.5 17 19 12 13q6 6 14 19.5t0 13.5q9 0 20 10.5t17 19.5q5 8 8 26t5 24q2 7 8.5 13.5t12.5 9.5l16 8t13 7q5 2 18.5 10.5t21.5 11.5q10 4 16 4t14.5-2.5 13.5-3.5q15-2 29 15t21 21q36 19 55 11-2 1 0.5 7.5t8 15.5 9 14.5 5.5 8.5q5 6 18 15t18 15q6-4 7-9-3 8 7 20t18 10q14-3 14-32-31 15-49-18 0-1-2.5-5.5t-4-8.5-2.5-8.5 0-7.5 5-3q9 0 10-3.5t-2-12.5-4-13q-1-8-11-20t-12-15q-5 9-16 8t-16-9q0 1-1.5 5.5t-1.5 6.5q-13 0-15-1 1-3 2.5-17.5t3.5-22.5q1-4 5.5-12t7.5-14.5 4-12.5-4.5-9.5-17.5-2.5q-19 1-26 20-1 3-3 10.5t-5 11.5-9 7q-7 3-24 2t-24-5q-13-8-22.5-29t-9.5-37q0-10 2.5-26.5t3-25-5.5-24.5q3-2 9-9.5t10-10.5q2-1 4.5-1.5t4.5 0 4-1.5 3-6q-1-1-4-3-3-3-4-3 7 3 28.5-1.5t27.5 1.5q15 11 22-2 0-1-2.5-9.5t-0.5-13.5q5 27 29 9 3 3 15.5 5t17.5 5q3 2 7 5.5t5.5 4.5 5-0.5 8.5-6.5q10 14 12 24 11 40 19 44 7 3 11 2t4.5-9.5 0-14-1.5-12.5l-1-8v-18l-1-8q-15-3-18.5-12t1.5-18.5 15-18.5q1-1 8-3.5t15.5-6.5 12.5-8q21-19 15-35 7 0 11-9-1 0-5-3t-7.5-5-4.5-2q9-5 2-16 5-3 7.5-11t7.5-10q9 12 21 2 8-8 1-16 5-7 20.5-10.5t18.5-9.5q7 2 8-2t1-12 3-12q4-5 15-9t13-5l17-11q3-4 0-4 18 2 31-11 10-11-6-20 3-6-3-9.5t-15-5.5q3-1 11.5-0.5t10.5-1.5q15-10-7-16-17-5-43 12zM879 1526q206-36 351-189-3-3-12.5-4.5t-12.5-3.5q-18-7-24-8 1-7-2.5-13t-8-9-12.5-8-11-7q-2-2-7-6t-7-5.5-7.5-4.5-8.5-2-10 1l-3 1q-3 1-5.5 2.5t-5.5 3-4 3 0 2.5q-21-17-36-22-5-1-11-5.5t-10.5-7-10-1.5-11.5 7q-5 5-6 15t-2 13q-7-5 0-17.5t2-18.5q-3-6-10.5-4.5t-12 4.5-11.5 8.5-9 6.5-8.5 5.5-8.5 7.5q-3 4-6 12t-5 11q-2-4-11.5-6.5t-9.5-5.5q2 10 4 35t5 38q7 31-12 48-27 25-29 40-4 22 12 26 0 7-8 20.5t-7 21.5q0 6 2 16z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/keyboard-o.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "keyboard-o": { "width": 1920, "height": 1792, "paths": [{ "d": "M384 1168v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM512 912v96q0 16-16 16h-224q-16 0-16-16v-96q0-16 16-16h224q16 0 16 16zM384 656v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1408 1168v96q0 16-16 16h-864q-16 0-16-16v-96q0-16 16-16h864q16 0 16 16zM768 912v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM640 656v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1024 912v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM896 656v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1280 912v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1664 1168v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1152 656v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1408 656v96q0 16-16 16h-96q-16 0-16-16v-96q0-16 16-16h96q16 0 16 16zM1664 656v352q0 16-16 16h-224q-16 0-16-16v-96q0-16 16-16h112v-240q0-16 16-16h96q16 0 16 16zM1792 1408v-896h-1664v896h1664zM1920 512v896q0 53-37.5 90.5t-90.5 37.5h-1664q-53 0-90.5-37.5t-37.5-90.5v-896q0-53 37.5-90.5t90.5-37.5h1664q53 0 90.5 37.5t37.5 90.5z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/qrcode.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "qrcode": { "width": 1408, "height": 1792, "paths": [{ "d": "M384 1152v128h-128v-128h128zM384 384v128h-128v-128h128zM1152 384v128h-128v-128h128zM128 1407h384v-383h-384v383zM128 640h384v-384h-384v384zM896 640h384v-384h-384v384zM640 896v640h-640v-640h640zM1152 1408v128h-128v-128h128zM1408 1408v128h-128v-128h128zM1408 896v384h-384v-128h-128v384h-128v-640h384v128h128v-128h128zM640 128v640h-640v-640h640zM1408 128v640h-640v-640h640z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/search.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "search": { "width": 1664, "height": 1792, "paths": [{ "d": "M1152 832q0-185-131.5-316.5t-316.5-131.5-316.5 131.5-131.5 316.5 131.5 316.5 316.5 131.5 316.5-131.5 131.5-316.5zM1664 1664q0 52-38 90t-90 38q-54 0-90-38l-343-342q-179 124-399 124-143 0-273.5-55.5t-225-150-150-225-55.5-273.5 55.5-273.5 150-225 225-150 273.5-55.5 273.5 55.5 225 150 150 225 55.5 273.5q0 220-124 399l343 343q37 37 37 90z" }] } });

/***/ }),

/***/ "./node_modules/vue-awesome/icons/trash.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _Icon = __webpack_require__("./node_modules/vue-awesome/components/Icon.vue");

var _Icon2 = _interopRequireDefault(_Icon);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

_Icon2.default.register({ "trash": { "width": 1408, "height": 1792, "paths": [{ "d": "M512 1376v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zM768 1376v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zM1024 1376v-704q0-14-9-23t-23-9h-64q-14 0-23 9t-9 23v704q0 14 9 23t23 9h64q14 0 23-9t9-23zM480 384h448l-48-117q-7-9-17-11h-317q-10 2-17 11zM1408 416v64q0 14-9 23t-23 9h-96v948q0 83-47 143.5t-113 60.5h-832q-66 0-113-58.5t-47-141.5v-952h-96q-14 0-23-9t-9-23v-64q0-14 9-23t23-9h309l70-167q15-37 54-63t79-26h320q40 0 79 26t54 63l70 167h309q14 0 23 9t9 23z" }] } });

/***/ }),

/***/ "./node_modules/vue-clipboard2/vue-clipboard.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Clipboard = __webpack_require__("./node_modules/clipboard/lib/clipboard.js");

var VueClipboard = {
  install: function install(Vue) {
    Vue.prototype.$copyText = function (_text) {
      return new Promise(function (resolve, reject) {
        var fake_el = document.createElement('button');
        var clipboard = new Clipboard(fake_el, {
          text: function text() {
            return _text;
          },
          action: function action() {
            return 'copy';
          }
        });
        clipboard.on('success', function (e) {
          clipboard.destroy();
          resolve(e);
        });
        clipboard.on('error', function (e) {
          clipboard.destroy();
          reject(e);
        });
        fake_el.click();
      });
    };

    Vue.directive('clipboard', {
      bind: function bind(el, binding, vnode) {
        if (binding.arg === 'success') {
          el._v_clipboard_success = binding.value;
        } else if (binding.arg === 'error') {
          el._v_clipboard_error = binding.value;
        } else {
          var clipboard = new Clipboard(el, {
            text: function text() {
              return binding.value;
            },
            action: function action() {
              return binding.arg === 'cut' ? 'cut' : 'copy';
            }
          });
          clipboard.on('success', function (e) {
            var callback = el._v_clipboard_success;
            callback && callback(e);
          });
          clipboard.on('error', function (e) {
            var callback = el._v_clipboard_error;
            callback && callback(e);
          });
          el._v_clipboard = clipboard;
        }
      },
      update: function update(el, binding) {
        if (binding.arg === 'success') {
          el._v_clipboard_success = binding.value;
        } else if (binding.arg === 'error') {
          el._v_clipboard_error = binding.value;
        } else {
          el._v_clipboard.text = function () {
            return binding.value;
          };
          el._v_clipboard.action = function () {
            return binding.arg === 'cut' ? 'cut' : 'copy';
          };
        }
      },
      unbind: function unbind(el, binding) {
        if (binding.arg === 'success') {
          delete el._v_clipboard_success;
        } else if (binding.arg === 'error') {
          delete el._v_clipboard_error;
        } else {
          el._v_clipboard.destroy();
          delete el._v_clipboard;
        }
      }
    });
  }
};

if (( false ? 'undefined' : _typeof(exports)) == "object") {
  module.exports = VueClipboard;
} else if (true) {
  !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
    return VueClipboard;
  }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/component-normalizer.js":
/***/ (function(module, exports) {

/* globals __VUE_SSR_CONTEXT__ */

// IMPORTANT: Do NOT use ES2015 features in this file.
// This module is a runtime utility for cleaner component module output and will
// be included in the final webpack user bundle.

module.exports = function normalizeComponent (
  rawScriptExports,
  compiledTemplate,
  functionalTemplate,
  injectStyles,
  scopeId,
  moduleIdentifier /* server only */
) {
  var esModule
  var scriptExports = rawScriptExports = rawScriptExports || {}

  // ES6 modules interop
  var type = typeof rawScriptExports.default
  if (type === 'object' || type === 'function') {
    esModule = rawScriptExports
    scriptExports = rawScriptExports.default
  }

  // Vue.extend constructor export interop
  var options = typeof scriptExports === 'function'
    ? scriptExports.options
    : scriptExports

  // render functions
  if (compiledTemplate) {
    options.render = compiledTemplate.render
    options.staticRenderFns = compiledTemplate.staticRenderFns
    options._compiled = true
  }

  // functional template
  if (functionalTemplate) {
    options.functional = true
  }

  // scopedId
  if (scopeId) {
    options._scopeId = scopeId
  }

  var hook
  if (moduleIdentifier) { // server build
    hook = function (context) {
      // 2.3 injection
      context =
        context || // cached call
        (this.$vnode && this.$vnode.ssrContext) || // stateful
        (this.parent && this.parent.$vnode && this.parent.$vnode.ssrContext) // functional
      // 2.2 with runInNewContext: true
      if (!context && typeof __VUE_SSR_CONTEXT__ !== 'undefined') {
        context = __VUE_SSR_CONTEXT__
      }
      // inject component styles
      if (injectStyles) {
        injectStyles.call(this, context)
      }
      // register component module identifier for async chunk inferrence
      if (context && context._registeredComponents) {
        context._registeredComponents.add(moduleIdentifier)
      }
    }
    // used by ssr in case component is cached and beforeCreate
    // never gets called
    options._ssrRegister = hook
  } else if (injectStyles) {
    hook = injectStyles
  }

  if (hook) {
    var functional = options.functional
    var existing = functional
      ? options.render
      : options.beforeCreate

    if (!functional) {
      // inject component registration as beforeCreate hook
      options.beforeCreate = existing
        ? [].concat(existing, hook)
        : [hook]
    } else {
      // for template-only hot-reload because in that case the render fn doesn't
      // go through the normalizer
      options._injectStyles = hook
      // register for functioal component in vue file
      options.render = function renderWithStyleInjection (h, context) {
        hook.call(context)
        return existing(h, context)
      }
    }
  }

  return {
    esModule: esModule,
    exports: scriptExports,
    options: options
  }
}


/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-062335d2\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/vendor.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _vm.dirs.length
        ? _c("div", { staticClass: "field is-grouped is-grouped-right" }, [
            _c("div", { staticClass: "control has-icons-left" }, [
              _c("div", { staticClass: "select" }, [
                _c(
                  "select",
                  {
                    directives: [
                      {
                        name: "model",
                        rawName: "v-model",
                        value: _vm.selectedDir,
                        expression: "selectedDir"
                      }
                    ],
                    on: {
                      change: function($event) {
                        var $$selectedVal = Array.prototype.filter
                          .call($event.target.options, function(o) {
                            return o.selected
                          })
                          .map(function(o) {
                            var val = "_value" in o ? o._value : o.value
                            return val
                          })
                        _vm.selectedDir = $event.target.multiple
                          ? $$selectedVal
                          : $$selectedVal[0]
                      }
                    }
                  },
                  [
                    _c("option", { attrs: { value: "", disabled: "" } }, [
                      _vm._v(_vm._s(_vm.trans("select_dir")))
                    ]),
                    _vm._v(" "),
                    _vm._l(_vm.dirs, function(d, i) {
                      return _c("option", { key: i }, [_vm._v(_vm._s(d))])
                    })
                  ],
                  2
                )
              ]),
              _vm._v(" "),
              _c(
                "div",
                { staticClass: "icon is-small is-left" },
                [_c("icon", { attrs: { name: "folder" } })],
                1
              )
            ]),
            _vm._v(" "),
            _vm.selectedDir
              ? _c("div", { staticClass: "control" }, [
                  _c(
                    "button",
                    {
                      staticClass: "button is-danger",
                      on: {
                        click: function($event) {
                          _vm.removeSelectedDir()
                        }
                      }
                    },
                    [
                      _c(
                        "span",
                        { staticClass: "icon" },
                        [_c("icon", { attrs: { name: "trash" } })],
                        1
                      )
                    ]
                  )
                ])
              : _vm._e()
          ])
        : _vm._e(),
      _vm._v(" "),
      _vm.selectedDir ? [_c("shared-content")] : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-062335d2", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-314333c4\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [
    _c("div", { staticClass: "level is-mobile is-marginless" }, [
      _c("div", { staticClass: "level-left" }, [
        _c("div", { staticClass: "level-item" }, [
          _c("div", { staticClass: "field is-grouped is-grouped-left" }, [
            _vm.selectedFile
              ? _c("div", { staticClass: "control" }, [
                  _c("h4", { staticClass: "title is-4" }, [
                    _vm._v('"' + _vm._s(_vm.itemsCount) + '" Item/s')
                  ])
                ])
              : _vm._e()
          ])
        ])
      ]),
      _vm._v(" "),
      _c("div", { staticClass: "level-right" }, [
        _c("div", { staticClass: "level-item" }, [
          _vm.files.length
            ? _c("div", { staticClass: "field is-grouped is-grouped-right" }, [
                _c("div", { staticClass: "control has-icons-left" }, [
                  _c("div", { staticClass: "select" }, [
                    _c(
                      "select",
                      {
                        directives: [
                          {
                            name: "model",
                            rawName: "v-model",
                            value: _vm.selectedFile,
                            expression: "selectedFile"
                          }
                        ],
                        on: {
                          change: function($event) {
                            var $$selectedVal = Array.prototype.filter
                              .call($event.target.options, function(o) {
                                return o.selected
                              })
                              .map(function(o) {
                                var val = "_value" in o ? o._value : o.value
                                return val
                              })
                            _vm.selectedFile = $event.target.multiple
                              ? $$selectedVal
                              : $$selectedVal[0]
                          }
                        }
                      },
                      [
                        _c("option", { attrs: { value: "", disabled: "" } }, [
                          _vm._v(_vm._s(_vm.trans("select_file")))
                        ]),
                        _vm._v(" "),
                        _vm._l(_vm.files, function(f, i) {
                          return _c("option", { key: i }, [_vm._v(_vm._s(f))])
                        })
                      ],
                      2
                    )
                  ]),
                  _vm._v(" "),
                  _c(
                    "div",
                    { staticClass: "icon is-small is-left" },
                    [_c("icon", { attrs: { name: "file" } })],
                    1
                  )
                ]),
                _vm._v(" "),
                _vm.selectedFile
                  ? _c("div", { staticClass: "control" }, [
                      _c(
                        "button",
                        {
                          staticClass: "button is-danger",
                          on: {
                            click: function($event) {
                              _vm.removeSelectedFile()
                            }
                          }
                        },
                        [
                          _c(
                            "span",
                            { staticClass: "icon" },
                            [_c("icon", { attrs: { name: "trash" } })],
                            1
                          )
                        ]
                      )
                    ])
                  : _vm._e()
              ])
            : _vm._e()
        ])
      ])
    ]),
    _vm._v(" "),
    _vm.selectedFile
      ? _c("section", { staticClass: "m-t-50" }, [
          _c(
            "table",
            { staticClass: "table is-fullwidth is-hoverable is-bordered" },
            [
              _c("thead", [
                _c(
                  "tr",
                  { staticClass: "is-unselectable" },
                  [
                    _c(
                      "th",
                      { staticClass: "is-link", attrs: { width: "1%" } },
                      [_vm._v(_vm._s(_vm.trans("key")))]
                    ),
                    _vm._v(" "),
                    _vm._l(_vm.locales, function(l, i) {
                      return _c("th", { key: i, staticClass: "is-link" }, [
                        _c("div", { staticClass: "tags has-addons" }, [
                          _c(
                            "span",
                            { staticClass: "tag is-light is-medium" },
                            [_vm._v(_vm._s(l))]
                          ),
                          _vm._v(" "),
                          _c(
                            "span",
                            {
                              staticClass: "tag is-warning is-medium",
                              on: {
                                click: function($event) {
                                  _vm.removeLocale(l)
                                }
                              }
                            },
                            [_c("icon", { attrs: { name: "trash" } })],
                            1
                          )
                        ])
                      ])
                    }),
                    _vm._v(" "),
                    _c("th", { staticClass: "is-link" }, [
                      _vm._v(_vm._s(_vm.trans("ops")))
                    ])
                  ],
                  2
                )
              ]),
              _vm._v(" "),
              _c(
                "tbody",
                [
                  _vm._l(_vm.selectedFileDataClone, function(
                    mainV,
                    mainK,
                    mainI
                  ) {
                    return _c(
                      "tr",
                      { key: mainI },
                      [
                        _c(
                          "td",
                          {
                            directives: [
                              {
                                name: "tippy",
                                rawName: "v-tippy",
                                value: {
                                  position: "right",
                                  arrow: true,
                                  interactive: true,
                                  trigger: "mouseenter"
                                },
                                expression:
                                  "{ position : 'right', arrow: true, interactive: true, trigger: 'mouseenter'}"
                              }
                            ],
                            class: _vm.nestCheck(mainK),
                            attrs: {
                              nowrap: "",
                              contenteditable: "",
                              dir: "auto",
                              title: _vm.getKey(mainK),
                              "data-html": "#tippyTemplate",
                              "data-main-key": mainK
                            },
                            on: {
                              mouseenter: function($event) {
                                _vm.keyToCopy = _vm.getKey(mainK)
                              },
                              shown: function($event) {
                                _vm.refocus()
                              },
                              keydown: function($event) {
                                if (
                                  !("button" in $event) &&
                                  _vm._k(
                                    $event.keyCode,
                                    "enter",
                                    13,
                                    $event.key
                                  )
                                ) {
                                  return null
                                }
                                $event.preventDefault()
                              },
                              input: function($event) {
                                _vm.newEntry()
                              },
                              focus: function($event) {
                                _vm.getPos($event)
                              },
                              blur: function($event) {
                                _vm.saveNewKey($event)
                              }
                            }
                          },
                          [
                            _vm._v(
                              "\n                        " +
                                _vm._s(mainK) +
                                "\n                    "
                            )
                          ]
                        ),
                        _vm._v(" "),
                        _vm._l(mainV, function(nestV, nestK, nestI) {
                          return _c(
                            "td",
                            {
                              key: nestI,
                              attrs: {
                                contenteditable: "",
                                dir: "auto",
                                "data-main-key": mainK,
                                "data-code": nestK
                              },
                              on: {
                                input: function($event) {
                                  _vm.newEntry()
                                },
                                focus: function($event) {
                                  _vm.getPos($event)
                                },
                                blur: function($event) {
                                  _vm.saveNewValue($event)
                                }
                              }
                            },
                            [
                              _vm._v(
                                "\n                        " +
                                  _vm._s(nestV) +
                                  "\n                    "
                              )
                            ]
                          )
                        }),
                        _vm._v(" "),
                        _c("td", { attrs: { width: "1%" } }, [
                          _c(
                            "button",
                            {
                              staticClass: "button is-danger",
                              on: {
                                click: function($event) {
                                  _vm.removeItem(mainK)
                                }
                              }
                            },
                            [
                              _c(
                                "span",
                                { staticClass: "icon" },
                                [_c("icon", { attrs: { name: "trash" } })],
                                1
                              )
                            ]
                          )
                        ])
                      ],
                      2
                    )
                  }),
                  _vm._v(" "),
                  _vm.dontHaveData()
                    ? _c("tr", [
                        _c(
                          "td",
                          { attrs: { colspan: _vm.locales.length + 2 } },
                          [
                            _vm._v(
                              "\n                        " +
                                _vm._s(_vm.trans("no_data")) +
                                "\n                    "
                            )
                          ]
                        )
                      ])
                    : _vm._e()
                ],
                2
              )
            ]
          ),
          _vm._v(" "),
          _c("div", { staticClass: "level" }, [
            _c("div", { staticClass: "level-right" }, [
              _c("div", { staticClass: "level-item" }, [
                _c(
                  "button",
                  {
                    staticClass: "button is-link",
                    on: {
                      click: function($event) {
                        $event.preventDefault()
                        _vm.addNewItem()
                      }
                    }
                  },
                  [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.trans("add_new")) +
                        "\n                    "
                    )
                  ]
                )
              ])
            ]),
            _vm._v(" "),
            _c("div", { staticClass: "level-left" }, [
              _c("div", { staticClass: "level-item" }, [
                _c(
                  "button",
                  {
                    staticClass: "button is-success",
                    attrs: { disabled: !_vm.dataChanged },
                    on: {
                      click: function($event) {
                        _vm.submitNewData()
                      }
                    }
                  },
                  [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.trans("save")) +
                        "\n                    "
                    )
                  ]
                )
              ]),
              _vm._v(" "),
              _c("div", { staticClass: "level-item" }, [
                _c(
                  "button",
                  {
                    staticClass: "button",
                    attrs: { disabled: !_vm.dataChanged },
                    on: {
                      click: function($event) {
                        _vm.resetData()
                      }
                    }
                  },
                  [
                    _vm._v(
                      "\n                        " +
                        _vm._s(_vm.trans("reset")) +
                        "\n                    "
                    )
                  ]
                )
              ])
            ])
          ]),
          _vm._v(" "),
          _c("div", { attrs: { id: "tippyTemplate" } }, [
            _c("span", { staticClass: "c2c" }, [_vm._v(_vm._s(_vm.keyToCopy))])
          ])
        ])
      : _vm._e()
  ])
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-314333c4", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-64d817c3\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "div",
    [
      _vm.self_show
        ? _c("transition", { attrs: { name: "slide-fade" } }, [
            _c(
              "div",
              { staticClass: "item", class: _vm.classObj(_vm.self_type) },
              [
                _c("button", {
                  staticClass: "delete",
                  on: {
                    click: function($event) {
                      _vm.self_show = false
                    }
                  }
                }),
                _vm._v(" "),
                _c("div", { staticClass: "media" }, [
                  _vm.self_icon
                    ? _c("div", { staticClass: "media-left" }, [
                        _c("figure", { staticClass: "icon is-large" }, [
                          _c("i", { staticClass: "material-icons" }, [
                            _vm._v(_vm._s(_vm.getIcon(_vm.self_type)))
                          ])
                        ])
                      ])
                    : _vm._e(),
                  _vm._v(" "),
                  _c("div", { staticClass: "media-content" }, [
                    _c("h4", { staticClass: "title" }, [
                      _c("strong", [_vm._v(_vm._s(_vm.self_title))])
                    ]),
                    _vm._v(" "),
                    _c("p", { staticClass: "subtitle" }, [
                      _vm._v(_vm._s(_vm.self_body))
                    ])
                  ])
                ])
              ]
            )
          ])
        : _vm._e(),
      _vm._v(" "),
      !_vm.self_title
        ? [
            _vm.checkForGroup()
              ? _c(
                  "span",
                  {
                    staticClass: "tag is-dark is-medium",
                    attrs: { id: "close_all" },
                    on: {
                      click: function($event) {
                        _vm.closeAll()
                      }
                    }
                  },
                  [
                    _vm._v("\n            Close All\n            "),
                    _c("button", { staticClass: "delete" })
                  ]
                )
              : _vm._e(),
            _vm._v(" "),
            _c(
              "transition-group",
              { attrs: { name: "slide-fade", tag: "ul" } },
              _vm._l(_vm.notif_group, function(one, index) {
                return _vm.IsVisible(index)
                  ? _c(
                      "li",
                      {
                        key: index,
                        staticClass: "item",
                        class: _vm.classObj(one.type)
                      },
                      [
                        _c("button", {
                          staticClass: "delete",
                          on: {
                            click: function($event) {
                              _vm.closeNotif(index)
                            }
                          }
                        }),
                        _vm._v(" "),
                        _c("div", { staticClass: "media" }, [
                          one.icon
                            ? _c("div", { staticClass: "media-left" }, [
                                _c("figure", { staticClass: "icon is-large" }, [
                                  _c("i", { staticClass: "material-icons" }, [
                                    _vm._v(_vm._s(_vm.getIcon(one.type)))
                                  ])
                                ])
                              ])
                            : _vm._e(),
                          _vm._v(" "),
                          _c("div", { staticClass: "media-content" }, [
                            _c("h4", { staticClass: "title" }, [
                              _c("strong", [_vm._v(_vm._s(one.title))])
                            ]),
                            _vm._v(" "),
                            _c("p", { staticClass: "subtitle" }, [
                              _vm._v(_vm._s(one.body))
                            ])
                          ])
                        ])
                      ]
                    )
                  : _vm._e()
              })
            )
          ]
        : _vm._e()
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-64d817c3", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-afaabd70\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c(
    "svg",
    {
      class: _vm.klass,
      style: _vm.style,
      attrs: {
        version: "1.1",
        role: _vm.label ? "img" : "presentation",
        "aria-label": _vm.label,
        x: _vm.x,
        y: _vm.y,
        width: _vm.width,
        height: _vm.height,
        viewBox: _vm.box
      }
    },
    [
      _vm._t("default", [
        _vm.icon && _vm.icon.paths
          ? _vm._l(_vm.icon.paths, function(path, i) {
              return _c(
                "path",
                _vm._b({ key: "path-" + i }, "path", path, false)
              )
            })
          : _vm._e(),
        _vm._v(" "),
        _vm.icon && _vm.icon.polygons
          ? _vm._l(_vm.icon.polygons, function(polygon, i) {
              return _c(
                "polygon",
                _vm._b({ key: "polygon-" + i }, "polygon", polygon, false)
              )
            })
          : _vm._e(),
        _vm._v("\b\n    "),
        _vm.icon && _vm.icon.raw
          ? [_c("g", { domProps: { innerHTML: _vm._s(_vm.raw) } })]
          : _vm._e()
      ])
    ],
    2
  )
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-afaabd70", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-f43693fc\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/default.vue":
/***/ (function(module, exports, __webpack_require__) {

var render = function() {
  var _vm = this
  var _h = _vm.$createElement
  var _c = _vm._self._c || _h
  return _c("div", [_c("shared-content")], 1)
}
var staticRenderFns = []
render._withStripped = true
module.exports = { render: render, staticRenderFns: staticRenderFns }
if (false) {
  module.hot.accept()
  if (module.hot.data) {
    require("vue-hot-reload-api")      .rerender("data-v-f43693fc", module.exports)
  }
}

/***/ }),

/***/ "./node_modules/vue-ls/dist/vue-ls.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_FACTORY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

(function (global, factory) {
  ( false ? 'undefined' : _typeof(exports)) === 'object' && typeof module !== 'undefined' ? module.exports = factory() :  true ? !(__WEBPACK_AMD_DEFINE_FACTORY__ = (factory),
				__WEBPACK_AMD_DEFINE_RESULT__ = (typeof __WEBPACK_AMD_DEFINE_FACTORY__ === 'function' ?
				(__WEBPACK_AMD_DEFINE_FACTORY__.call(exports, __webpack_require__, exports, module)) :
				__WEBPACK_AMD_DEFINE_FACTORY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__)) : global['vue-ls'] = factory();
})(undefined, function () {
  'use strict';

  var ls$1 = {};

  var memoryStorage = {
    /**
     * Get item
     *
     * @param {string} name
     * @returns {*}
     */
    getItem: function getItem(name) {
      return name in ls$1 ? ls$1[name] : null;
    },

    /**
     * Set item
     *
     * @param {string} name
     * @param {*} value
     * @returns {boolean}
     */
    setItem: function setItem(name, value) {
      ls$1[name] = value;

      return true;
    },

    /**
     * Remove item
     *
     * @param {string} name
     * @returns {boolean}
     */
    removeItem: function removeItem(name) {
      var found = name in ls$1;

      if (found) {
        return delete ls$1[name];
      }

      return false;
    },

    /**
     * Clear storage
     *
     * @returns {boolean}
     */
    clear: function clear() {
      ls$1 = {};

      return true;
    },

    /**
     * Get item by key
     *
     * @param {number} index
     * @returns {*}
     */
    key: function key(index) {
      var keys = Object.keys(ls$1);

      return typeof keys[index] !== 'undefined' ? keys[index] : null;
    }
  };

  Object.defineProperty(memoryStorage, 'length', {
    /**
     * Define length property
     *
     * @return {number}
     */
    get: function get() {
      return Object.keys(ls$1).length;
    }
  });

  var asyncGenerator = function () {
    function AwaitValue(value) {
      this.value = value;
    }

    function AsyncGenerator(gen) {
      var front, back;

      function send(key, arg) {
        return new Promise(function (resolve, reject) {
          var request = {
            key: key,
            arg: arg,
            resolve: resolve,
            reject: reject,
            next: null
          };

          if (back) {
            back = back.next = request;
          } else {
            front = back = request;
            resume(key, arg);
          }
        });
      }

      function resume(key, arg) {
        try {
          var result = gen[key](arg);
          var value = result.value;

          if (value instanceof AwaitValue) {
            Promise.resolve(value.value).then(function (arg) {
              resume("next", arg);
            }, function (arg) {
              resume("throw", arg);
            });
          } else {
            settle(result.done ? "return" : "normal", result.value);
          }
        } catch (err) {
          settle("throw", err);
        }
      }

      function settle(type, value) {
        switch (type) {
          case "return":
            front.resolve({
              value: value,
              done: true
            });
            break;

          case "throw":
            front.reject(value);
            break;

          default:
            front.resolve({
              value: value,
              done: false
            });
            break;
        }

        front = front.next;

        if (front) {
          resume(front.key, front.arg);
        } else {
          back = null;
        }
      }

      this._invoke = send;

      if (typeof gen.return !== "function") {
        this.return = undefined;
      }
    }

    if (typeof Symbol === "function" && Symbol.asyncIterator) {
      AsyncGenerator.prototype[Symbol.asyncIterator] = function () {
        return this;
      };
    }

    AsyncGenerator.prototype.next = function (arg) {
      return this._invoke("next", arg);
    };

    AsyncGenerator.prototype.throw = function (arg) {
      return this._invoke("throw", arg);
    };

    AsyncGenerator.prototype.return = function (arg) {
      return this._invoke("return", arg);
    };

    return {
      wrap: function wrap(fn) {
        return function () {
          return new AsyncGenerator(fn.apply(this, arguments));
        };
      },
      await: function _await(value) {
        return new AwaitValue(value);
      }
    };
  }();

  var classCallCheck = function classCallCheck(instance, Constructor) {
    if (!(instance instanceof Constructor)) {
      throw new TypeError("Cannot call a class as a function");
    }
  };

  var createClass = function () {
    function defineProperties(target, props) {
      for (var i = 0; i < props.length; i++) {
        var descriptor = props[i];
        descriptor.enumerable = descriptor.enumerable || false;
        descriptor.configurable = true;
        if ("value" in descriptor) descriptor.writable = true;
        Object.defineProperty(target, descriptor.key, descriptor);
      }
    }

    return function (Constructor, protoProps, staticProps) {
      if (protoProps) defineProperties(Constructor.prototype, protoProps);
      if (staticProps) defineProperties(Constructor, staticProps);
      return Constructor;
    };
  }();

  var _extends = Object.assign || function (target) {
    for (var i = 1; i < arguments.length; i++) {
      var source = arguments[i];

      for (var key in source) {
        if (Object.prototype.hasOwnProperty.call(source, key)) {
          target[key] = source[key];
        }
      }
    }

    return target;
  };

  var listeners = {};

  /**
   * Event class
   */

  var _class$1 = function () {
    function _class() {
      classCallCheck(this, _class);
    }

    createClass(_class, null, [{
      key: 'on',

      /**
       * Add storage change event
       *
       * @param {string} name
       * @param {Function} callback
       */
      value: function on(name, callback) {
        if (typeof listeners[name] === 'undefined') {
          listeners[name] = [];
        }

        listeners[name].push(callback);
      }

      /**
       * Remove storage change event
       *
       * @param {string} name
       * @param {Function} callback
       */

    }, {
      key: 'off',
      value: function off(name, callback) {
        if (listeners[name].length) {
          listeners[name].splice(listeners[name].indexOf(callback), 1);
        } else {
          listeners[name] = [];
        }
      }

      /**
       * Emit event
       *
       * @param {Object} event
       */

    }, {
      key: 'emit',
      value: function emit(event) {
        var e = event || window.event;

        var getValue = function getValue(data) {
          try {
            return JSON.parse(data).value;
          } catch (err) {
            return data;
          }
        };

        var fire = function fire(listener) {
          var newValue = getValue(e.newValue);
          var oldValue = getValue(e.oldValue);

          listener(newValue, oldValue, e.url || e.uri);
        };

        if (typeof e === 'undefined' || typeof e.key === 'undefined') {
          return;
        }

        var all = listeners[e.key];

        if (typeof all !== 'undefined') {
          all.forEach(fire);
        }
      }
    }]);
    return _class;
  }();

  /**
   * Storage Bridge
   */

  var _class = function () {
    /**
     * @param {Object} storage
     */
    function _class(storage) {
      classCallCheck(this, _class);

      this.storage = storage;
      this.options = {
        namespace: '',
        events: ['storage']
      };

      Object.defineProperty(this, 'length', {
        /**
         * Define length property
         *
         * @return {number}
         */
        get: function get$$1() {
          return this.storage.length;
        }
      });

      if (typeof window !== 'undefined') {
        for (var i in this.options.events) {
          if (window.addEventListener) {
            window.addEventListener(this.options.events[i], _class$1.emit, false);
          } else if (window.attachEvent) {
            window.attachEvent('on' + this.options.events[i], _class$1.emit);
          } else {
            window['on' + this.options.events[i]] = _class$1.emit;
          }
        }
      }
    }

    /**
     * Set Options
     *
     * @param {Object} options
     */

    createClass(_class, [{
      key: 'setOptions',
      value: function setOptions() {
        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

        this.options = _extends(this.options, options);
      }

      /**
       * Set item
       *
       * @param {string} name
       * @param {*} value
       * @param {number} expire - seconds
       */

    }, {
      key: 'set',
      value: function set$$1(name, value) {
        var expire = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : null;

        var stringifyValue = JSON.stringify({
          value: value,
          expire: expire !== null ? new Date().getTime() + expire : null
        });

        this.storage.setItem(this.options.namespace + name, stringifyValue);
      }

      /**
       * Get item
       *
       * @param {string} name
       * @param {*} def - default value
       * @returns {*}
       */

    }, {
      key: 'get',
      value: function get$$1(name) {
        var def = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

        var item = this.storage.getItem(this.options.namespace + name);

        if (item !== null) {
          try {
            var data = JSON.parse(item);

            if (data.expire === null) {
              return data.value;
            }

            if (data.expire >= new Date().getTime()) {
              return data.value;
            }

            this.remove(name);
          } catch (err) {
            return def;
          }
        }

        return def;
      }

      /**
       * Get item by key
       *
       * @param {number} index
       * @return {*}
       */

    }, {
      key: 'key',
      value: function key(index) {
        return this.storage.key(index);
      }

      /**
       * Remove item
       *
       * @param {string} name
       * @return {boolean}
       */

    }, {
      key: 'remove',
      value: function remove(name) {
        return this.storage.removeItem(this.options.namespace + name);
      }

      /**
       * Clear storage
       */

    }, {
      key: 'clear',
      value: function clear() {
        if (this.length === 0) {
          return;
        }

        var removedKeys = [];

        for (var i = 0; i < this.length; i++) {
          var key = this.storage.key(i);
          var regexp = new RegExp('^' + this.options.namespace + '.+', 'i');

          if (regexp.test(key) === false) {
            continue;
          }

          removedKeys.push(key);
        }

        for (var _key in removedKeys) {
          this.storage.removeItem(removedKeys[_key]);
        }
      }

      /**
       * Add storage change event
       *
       * @param {string} name
       * @param {Function} callback
       */

    }, {
      key: 'on',
      value: function on(name, callback) {
        _class$1.on(this.options.namespace + name, callback);
      }

      /**
       * Remove storage change event
       *
       * @param {string} name
       * @param {Function} callback
       */

    }, {
      key: 'off',
      value: function off(name, callback) {
        _class$1.off(this.options.namespace + name, callback);
      }
    }]);
    return _class;
  }();

  var store = typeof window !== 'undefined' && 'localStorage' in window ? window.localStorage : memoryStorage;
  var ls = new _class(store);

  var VueLocalStorage = {
    /**
     * Install plugin
     *
     * @param {Object} Vue
     * @param {Object} options
     * @returns {Storage}
     */
    install: function install(Vue, options) {
      ls.setOptions(_extends(ls.options, {
        namespace: ''
      }, options || {}));

      Vue.ls = ls; // eslint-disable-line
      Object.defineProperty(Vue.prototype, '$ls', {
        /**
         * Define $ls property
         *
         * @return {Storage}
         */
        get: function get$$1() {
          return ls;
        }
      });
    }
  };

  if (typeof window !== 'undefined') {
    window.VueLocalStorage = VueLocalStorage;
  }

  return VueLocalStorage;
});

/***/ }),

/***/ "./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue")
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=1&bustCache!./node_modules/vue-notif/src/Notification.vue")
}
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-64d817c3\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-64d817c3"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "node_modules/vue-notif/src/Notification.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-64d817c3", Component.options)
  } else {
    hotAPI.reload("data-v-64d817c3", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js")("ef7db746", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../../../../node_modules/css-loader/index.js?sourceMap!../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!../../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./content.vue", function() {
     var newContent = require("!!../../../../../node_modules/css-loader/index.js?sourceMap!../../../../../node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!../../../../../node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./content.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-notif/src/Notification.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js")("50a3d744", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Notification.vue", function() {
     var newContent = require("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":false,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Notification.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=1&bustCache!./node_modules/vue-notif/src/Notification.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=1&bustCache!./node_modules/vue-notif/src/Notification.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js")("805943d0", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=1&bustCache!./Notification.vue", function() {
     var newContent = require("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-64d817c3\",\"scoped\":true,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=1&bustCache!./Notification.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue":
/***/ (function(module, exports, __webpack_require__) {

// style-loader: Adds some css to the DOM by adding a <style> tag

// load the styles
var content = __webpack_require__("./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./node_modules/vue-awesome/components/Icon.vue");
if(typeof content === 'string') content = [[module.i, content, '']];
if(content.locals) module.exports = content.locals;
// add the styles to the DOM
var update = __webpack_require__("./node_modules/vue-style-loader/lib/addStylesClient.js")("7b468da4", content, false);
// Hot Module Replacement
if(false) {
 // When the styles change, update the <style> tags
 if(!content.locals) {
   module.hot.accept("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Icon.vue", function() {
     var newContent = require("!!../../css-loader/index.js?sourceMap!../../vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-afaabd70\",\"scoped\":false,\"hasInlineConfig\":true}!../../vue-loader/lib/selector.js?type=styles&index=0&bustCache!./Icon.vue");
     if(typeof newContent === 'string') newContent = [[module.id, newContent, '']];
     update(newContent);
   });
 }
 // When the module is disposed, remove the <style> tags
 module.hot.dispose(function() { update(); });
}

/***/ }),

/***/ "./node_modules/vue-style-loader/lib/addStylesClient.js":
/***/ (function(module, exports, __webpack_require__) {

/*
  MIT License http://www.opensource.org/licenses/mit-license.php
  Author Tobias Koppers @sokra
  Modified by Evan You @yyx990803
*/

var hasDocument = typeof document !== 'undefined'

if (typeof DEBUG !== 'undefined' && DEBUG) {
  if (!hasDocument) {
    throw new Error(
    'vue-style-loader cannot be used in a non-browser environment. ' +
    "Use { target: 'node' } in your Webpack config to indicate a server-rendering environment."
  ) }
}

var listToStyles = __webpack_require__("./node_modules/vue-style-loader/lib/listToStyles.js")

/*
type StyleObject = {
  id: number;
  parts: Array<StyleObjectPart>
}

type StyleObjectPart = {
  css: string;
  media: string;
  sourceMap: ?string
}
*/

var stylesInDom = {/*
  [id: number]: {
    id: number,
    refs: number,
    parts: Array<(obj?: StyleObjectPart) => void>
  }
*/}

var head = hasDocument && (document.head || document.getElementsByTagName('head')[0])
var singletonElement = null
var singletonCounter = 0
var isProduction = false
var noop = function () {}

// Force single-tag solution on IE6-9, which has a hard limit on the # of <style>
// tags it will allow on a page
var isOldIE = typeof navigator !== 'undefined' && /msie [6-9]\b/.test(navigator.userAgent.toLowerCase())

module.exports = function (parentId, list, _isProduction) {
  isProduction = _isProduction

  var styles = listToStyles(parentId, list)
  addStylesToDom(styles)

  return function update (newList) {
    var mayRemove = []
    for (var i = 0; i < styles.length; i++) {
      var item = styles[i]
      var domStyle = stylesInDom[item.id]
      domStyle.refs--
      mayRemove.push(domStyle)
    }
    if (newList) {
      styles = listToStyles(parentId, newList)
      addStylesToDom(styles)
    } else {
      styles = []
    }
    for (var i = 0; i < mayRemove.length; i++) {
      var domStyle = mayRemove[i]
      if (domStyle.refs === 0) {
        for (var j = 0; j < domStyle.parts.length; j++) {
          domStyle.parts[j]()
        }
        delete stylesInDom[domStyle.id]
      }
    }
  }
}

function addStylesToDom (styles /* Array<StyleObject> */) {
  for (var i = 0; i < styles.length; i++) {
    var item = styles[i]
    var domStyle = stylesInDom[item.id]
    if (domStyle) {
      domStyle.refs++
      for (var j = 0; j < domStyle.parts.length; j++) {
        domStyle.parts[j](item.parts[j])
      }
      for (; j < item.parts.length; j++) {
        domStyle.parts.push(addStyle(item.parts[j]))
      }
      if (domStyle.parts.length > item.parts.length) {
        domStyle.parts.length = item.parts.length
      }
    } else {
      var parts = []
      for (var j = 0; j < item.parts.length; j++) {
        parts.push(addStyle(item.parts[j]))
      }
      stylesInDom[item.id] = { id: item.id, refs: 1, parts: parts }
    }
  }
}

function createStyleElement () {
  var styleElement = document.createElement('style')
  styleElement.type = 'text/css'
  head.appendChild(styleElement)
  return styleElement
}

function addStyle (obj /* StyleObjectPart */) {
  var update, remove
  var styleElement = document.querySelector('style[data-vue-ssr-id~="' + obj.id + '"]')

  if (styleElement) {
    if (isProduction) {
      // has SSR styles and in production mode.
      // simply do nothing.
      return noop
    } else {
      // has SSR styles but in dev mode.
      // for some reason Chrome can't handle source map in server-rendered
      // style tags - source maps in <style> only works if the style tag is
      // created and inserted dynamically. So we remove the server rendered
      // styles and inject new ones.
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  if (isOldIE) {
    // use singleton mode for IE9.
    var styleIndex = singletonCounter++
    styleElement = singletonElement || (singletonElement = createStyleElement())
    update = applyToSingletonTag.bind(null, styleElement, styleIndex, false)
    remove = applyToSingletonTag.bind(null, styleElement, styleIndex, true)
  } else {
    // use multi-style-tag mode in all other cases
    styleElement = createStyleElement()
    update = applyToTag.bind(null, styleElement)
    remove = function () {
      styleElement.parentNode.removeChild(styleElement)
    }
  }

  update(obj)

  return function updateStyle (newObj /* StyleObjectPart */) {
    if (newObj) {
      if (newObj.css === obj.css &&
          newObj.media === obj.media &&
          newObj.sourceMap === obj.sourceMap) {
        return
      }
      update(obj = newObj)
    } else {
      remove()
    }
  }
}

var replaceText = (function () {
  var textStore = []

  return function (index, replacement) {
    textStore[index] = replacement
    return textStore.filter(Boolean).join('\n')
  }
})()

function applyToSingletonTag (styleElement, index, remove, obj) {
  var css = remove ? '' : obj.css

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = replaceText(index, css)
  } else {
    var cssNode = document.createTextNode(css)
    var childNodes = styleElement.childNodes
    if (childNodes[index]) styleElement.removeChild(childNodes[index])
    if (childNodes.length) {
      styleElement.insertBefore(cssNode, childNodes[index])
    } else {
      styleElement.appendChild(cssNode)
    }
  }
}

function applyToTag (styleElement, obj) {
  var css = obj.css
  var media = obj.media
  var sourceMap = obj.sourceMap

  if (media) {
    styleElement.setAttribute('media', media)
  }

  if (sourceMap) {
    // https://developer.chrome.com/devtools/docs/javascript-debugging
    // this makes source maps inside style tags work properly in Chrome
    css += '\n/*# sourceURL=' + sourceMap.sources[0] + ' */'
    // http://stackoverflow.com/a/26603875
    css += '\n/*# sourceMappingURL=data:application/json;base64,' + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + ' */'
  }

  if (styleElement.styleSheet) {
    styleElement.styleSheet.cssText = css
  } else {
    while (styleElement.firstChild) {
      styleElement.removeChild(styleElement.firstChild)
    }
    styleElement.appendChild(document.createTextNode(css))
  }
}


/***/ }),

/***/ "./node_modules/vue-style-loader/lib/listToStyles.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


/**
 * Translates the list format produced by css-loader into something
 * easier to manipulate.
 */
module.exports = function listToStyles(parentId, list) {
  var styles = [];
  var newStyles = {};
  for (var i = 0; i < list.length; i++) {
    var item = list[i];
    var id = item[0];
    var css = item[1];
    var media = item[2];
    var sourceMap = item[3];
    var part = {
      id: parentId + ':' + i,
      css: css,
      media: media,
      sourceMap: sourceMap
    };
    if (!newStyles[id]) {
      styles.push(newStyles[id] = { id: id, parts: [part] });
    } else {
      newStyles[id].parts.push(part);
    }
  }
  return styles;
};

/***/ }),

/***/ "./node_modules/vue-tippy/vue-tippy.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
var __WEBPACK_AMD_DEFINE_ARRAY__, __WEBPACK_AMD_DEFINE_RESULT__;

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var Tippy = __webpack_require__("./node_modules/tippy.js/dist/tippy.js");
var css = __webpack_require__("./node_modules/tippy.js/dist/tippy.css");

if (!Array.prototype.some) {
    Array.prototype.some = function (fun /*, thisArg*/) {
        'use strict';

        if (this == null) {
            throw new TypeError('Array.prototype.some called on null or undefined');
        }

        if (typeof fun !== 'function') {
            throw new TypeError();
        }

        var t = Object(this);
        var len = t.length >>> 0;

        var thisArg = arguments.length >= 2 ? arguments[1] : void 0;
        for (var i = 0; i < len; i++) {
            if (i in t && fun.call(thisArg, t[i], i, t)) {
                return true;
            }
        }

        return false;
    };
}
var VueTippy = {
    install: function install(Vue, options) {
        Vue.$tippyInstances = [];
        Vue.$tippyComponents = [];
        Vue.prototype.$tippy = {

            getInstance: function getInstance(el) {
                return Vue.$tippyInstances.find(function ($instance) {
                    return $instance.el === el;
                });
            },
            getTippyPopper: function getTippyPopper(tippy) {
                return tippy.getPopperElement(tippy.selector);
            },
            showPopper: function showPopper(el) {
                var tippy = this.getTippy(el);
                tippy.show(this.getTippyPopper(tippy));
            },
            hidePopper: function hidePopper(el) {
                var tippy = this.getTippy(el);
                tippy.hide(this.getTippyPopper(tippy));
            },
            destroyTippy: function destroyTippy(el) {
                var i = this.getInstance(el);
                var t = this.getTippy(el);
                t.destroy(this.getTippyPopper(t));
                var index = Vue.$tippyInstances.indexOf(i);
                if (index > -1) Vue.$tippyInstances.splice(index, 1);
            },
            getTippy: function getTippy(el) {
                return this.getInstance(el).tippy;
            },
            update: function update(el) {

                this.instance = this.getInstance(el);

                if (this.instance) {
                    this.instance.tippy.update(this.instance.tippy.getPopperElement(this.instance.tippy.selector));
                }
            },
            forceUpdateHtml: function forceUpdateHtml() {
                Vue.$tippyInstances.forEach(function (instance) {

                    if (instance.tippy && instance.tippy && instance.tippy.store) {
                        instance.tippy.store.forEach(function (s) {

                            if (s && s && s.settings && !s.settings.html) {
                                Vue.nextTick(function () {
                                    s.tippyInstance.update(s.popper);
                                });
                            }
                        });
                    }
                });
            }

        };

        Vue.directive('tippy', {
            inserted: function inserted(el, binding, vnode, oldVnode) {

                var handlers = vnode.data && vnode.data.on || vnode.componentOptions && vnode.componentOptions.listeners;

                var opts = binding.value || {};

                Object.assign(opts, {}, options);

                opts.onShow = function () {

                    if (handlers && handlers["show"]) {
                        handlers["show"].fns();
                    }
                };
                opts.onShown = function () {

                    if (handlers && handlers["shown"]) {
                        handlers["shown"].fns();
                    }
                };
                opts.onHidden = function () {
                    if (handlers && handlers["hidden"]) {
                        handlers["hidden"].fns();
                    }
                };
                opts.onHide = function () {
                    if (handlers && handlers["hide"]) {
                        handlers["hide"].fns();
                    }
                };

                if (el.getAttribute('data-html')) {

                    vnode.context.$children.forEach(function ($vm) {
                        if (!Vue.$tippyComponents.some(function (x) {
                            return x._uid === $vm._uid;
                        })) {
                            if ($vm.$options.updated === undefined) {
                                $vm.$options.updated = [];
                            }

                            $vm.$options.updated.push(function () {
                                $vm.$tippy.forceUpdateHtml();
                            });

                            Vue.$tippyComponents.push($vm);
                        }
                    });
                } else if (opts.html) {
                    opts.html = document.querySelector(opts.html);
                }

                // if (opts.show && !opts.trigger) {
                //     opts.trigger = 'manual';
                // }

                el.tippy = new Tippy(el, opts);

                Vue.$tippyInstances.push({
                    el: el,
                    tippy: el.tippy
                });

                if (opts.showOnLoad) {
                    vnode.context.$tippy.showPopper(el);
                }
            },
            unbind: function unbind(el, binding, vnode) {
                vnode.context.$tippy.destroyTippy(el);
            },
            componentUpdated: function componentUpdated(el, binding, vnode) {

                var opts = binding.value || {};
                var oldValue = binding.oldValue || {};

                if (opts.html) return;

                if (el.tippy && JSON.stringify(opts) !== JSON.stringify(oldValue)) {

                    var handlers = vnode.data && vnode.data.on || vnode.componentOptions && vnode.componentOptions.listeners;

                    vnode.context.$tippy.destroyTippy(el);

                    opts.onShow = function () {

                        if (handlers && handlers["show"]) {
                            handlers["show"].fns();
                        }
                    };
                    opts.onShown = function () {

                        if (handlers && handlers["shown"]) {
                            handlers["shown"].fns();
                        }
                    };
                    opts.onHidden = function () {
                        if (handlers && handlers["hidden"]) {
                            handlers["hidden"].fns();
                        }
                    };
                    opts.onHide = function () {
                        if (handlers && handlers["hide"]) {
                            handlers["hide"].fns();
                        }
                    };

                    el.tippy = new Tippy(el, opts);

                    Vue.$tippyInstances.push({
                        el: el,
                        tippy: el.tippy

                    });
                } else if (el.tippy && (el.getAttribute('title') || el.getAttribute('data-html'))) {

                    vnode.context.$nextTick(function () {
                        el.tippy.store.forEach(function (s) {

                            var popper = s.popper;

                            var tip = s.tippyInstance;

                            tip.update(popper);
                        });
                    });
                }

                if (el.tippy && opts.show) {
                    vnode.context.$tippy.showPopper(el);
                } else if (el.tippy && !opts.show && opts.trigger === 'manual') {
                    vnode.context.$tippy.hidePopper(el);
                }
            }

        });
    }
};

if (( false ? 'undefined' : _typeof(exports)) == "object") {
    module.exports = VueTippy;
} else if (true) {
    !(__WEBPACK_AMD_DEFINE_ARRAY__ = [], __WEBPACK_AMD_DEFINE_RESULT__ = (function () {
        return VueTippy;
    }).apply(exports, __WEBPACK_AMD_DEFINE_ARRAY__),
				__WEBPACK_AMD_DEFINE_RESULT__ !== undefined && (module.exports = __WEBPACK_AMD_DEFINE_RESULT__));
}

/***/ }),

/***/ "./node_modules/vue/dist/vue.common.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";
/* WEBPACK VAR INJECTION */(function(global, setImmediate) {/*!
 * Vue.js v2.5.9
 * (c) 2014-2017 Evan You
 * Released under the MIT License.
 */


/*  */

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var emptyObject = Object.freeze({});

// these helpers produces better vm code in JS engines due to their
// explicitness and function inlining
function isUndef(v) {
  return v === undefined || v === null;
}

function isDef(v) {
  return v !== undefined && v !== null;
}

function isTrue(v) {
  return v === true;
}

function isFalse(v) {
  return v === false;
}

/**
 * Check if value is primitive
 */
function isPrimitive(value) {
  return typeof value === 'string' || typeof value === 'number' || typeof value === 'boolean';
}

/**
 * Quick object check - this is primarily used to tell
 * Objects from primitive values when we know the value
 * is a JSON-compliant type.
 */
function isObject(obj) {
  return obj !== null && (typeof obj === 'undefined' ? 'undefined' : _typeof(obj)) === 'object';
}

/**
 * Get the raw type string of a value e.g. [object Object]
 */
var _toString = Object.prototype.toString;

function toRawType(value) {
  return _toString.call(value).slice(8, -1);
}

/**
 * Strict object type check. Only returns true
 * for plain JavaScript objects.
 */
function isPlainObject(obj) {
  return _toString.call(obj) === '[object Object]';
}

function isRegExp(v) {
  return _toString.call(v) === '[object RegExp]';
}

/**
 * Check if val is a valid array index.
 */
function isValidArrayIndex(val) {
  var n = parseFloat(String(val));
  return n >= 0 && Math.floor(n) === n && isFinite(val);
}

/**
 * Convert a value to a string that is actually rendered.
 */
function toString(val) {
  return val == null ? '' : (typeof val === 'undefined' ? 'undefined' : _typeof(val)) === 'object' ? JSON.stringify(val, null, 2) : String(val);
}

/**
 * Convert a input value to a number for persistence.
 * If the conversion fails, return original string.
 */
function toNumber(val) {
  var n = parseFloat(val);
  return isNaN(n) ? val : n;
}

/**
 * Make a map and return a function for checking if a key
 * is in that map.
 */
function makeMap(str, expectsLowerCase) {
  var map = Object.create(null);
  var list = str.split(',');
  for (var i = 0; i < list.length; i++) {
    map[list[i]] = true;
  }
  return expectsLowerCase ? function (val) {
    return map[val.toLowerCase()];
  } : function (val) {
    return map[val];
  };
}

/**
 * Check if a tag is a built-in tag.
 */
var isBuiltInTag = makeMap('slot,component', true);

/**
 * Check if a attribute is a reserved attribute.
 */
var isReservedAttribute = makeMap('key,ref,slot,slot-scope,is');

/**
 * Remove an item from an array
 */
function remove(arr, item) {
  if (arr.length) {
    var index = arr.indexOf(item);
    if (index > -1) {
      return arr.splice(index, 1);
    }
  }
}

/**
 * Check whether the object has the property.
 */
var hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return hasOwnProperty.call(obj, key);
}

/**
 * Create a cached version of a pure function.
 */
function cached(fn) {
  var cache = Object.create(null);
  return function cachedFn(str) {
    var hit = cache[str];
    return hit || (cache[str] = fn(str));
  };
}

/**
 * Camelize a hyphen-delimited string.
 */
var camelizeRE = /-(\w)/g;
var camelize = cached(function (str) {
  return str.replace(camelizeRE, function (_, c) {
    return c ? c.toUpperCase() : '';
  });
});

/**
 * Capitalize a string.
 */
var capitalize = cached(function (str) {
  return str.charAt(0).toUpperCase() + str.slice(1);
});

/**
 * Hyphenate a camelCase string.
 */
var hyphenateRE = /\B([A-Z])/g;
var hyphenate = cached(function (str) {
  return str.replace(hyphenateRE, '-$1').toLowerCase();
});

/**
 * Simple bind, faster than native
 */
function bind(fn, ctx) {
  function boundFn(a) {
    var l = arguments.length;
    return l ? l > 1 ? fn.apply(ctx, arguments) : fn.call(ctx, a) : fn.call(ctx);
  }
  // record original fn length
  boundFn._length = fn.length;
  return boundFn;
}

/**
 * Convert an Array-like object to a real Array.
 */
function toArray(list, start) {
  start = start || 0;
  var i = list.length - start;
  var ret = new Array(i);
  while (i--) {
    ret[i] = list[i + start];
  }
  return ret;
}

/**
 * Mix properties into target object.
 */
function extend(to, _from) {
  for (var key in _from) {
    to[key] = _from[key];
  }
  return to;
}

/**
 * Merge an Array of Objects into a single Object.
 */
function toObject(arr) {
  var res = {};
  for (var i = 0; i < arr.length; i++) {
    if (arr[i]) {
      extend(res, arr[i]);
    }
  }
  return res;
}

/**
 * Perform no operation.
 * Stubbing args to make Flow happy without leaving useless transpiled code
 * with ...rest (https://flow.org/blog/2017/05/07/Strict-Function-Call-Arity/)
 */
function noop(a, b, c) {}

/**
 * Always return false.
 */
var no = function no(a, b, c) {
  return false;
};

/**
 * Return same value
 */
var identity = function identity(_) {
  return _;
};

/**
 * Generate a static keys string from compiler modules.
 */
function genStaticKeys(modules) {
  return modules.reduce(function (keys, m) {
    return keys.concat(m.staticKeys || []);
  }, []).join(',');
}

/**
 * Check if two values are loosely equal - that is,
 * if they are plain objects, do they have the same shape?
 */
function looseEqual(a, b) {
  if (a === b) {
    return true;
  }
  var isObjectA = isObject(a);
  var isObjectB = isObject(b);
  if (isObjectA && isObjectB) {
    try {
      var isArrayA = Array.isArray(a);
      var isArrayB = Array.isArray(b);
      if (isArrayA && isArrayB) {
        return a.length === b.length && a.every(function (e, i) {
          return looseEqual(e, b[i]);
        });
      } else if (!isArrayA && !isArrayB) {
        var keysA = Object.keys(a);
        var keysB = Object.keys(b);
        return keysA.length === keysB.length && keysA.every(function (key) {
          return looseEqual(a[key], b[key]);
        });
      } else {
        /* istanbul ignore next */
        return false;
      }
    } catch (e) {
      /* istanbul ignore next */
      return false;
    }
  } else if (!isObjectA && !isObjectB) {
    return String(a) === String(b);
  } else {
    return false;
  }
}

function looseIndexOf(arr, val) {
  for (var i = 0; i < arr.length; i++) {
    if (looseEqual(arr[i], val)) {
      return i;
    }
  }
  return -1;
}

/**
 * Ensure a function is called only once.
 */
function once(fn) {
  var called = false;
  return function () {
    if (!called) {
      called = true;
      fn.apply(this, arguments);
    }
  };
}

var SSR_ATTR = 'data-server-rendered';

var ASSET_TYPES = ['component', 'directive', 'filter'];

var LIFECYCLE_HOOKS = ['beforeCreate', 'created', 'beforeMount', 'mounted', 'beforeUpdate', 'updated', 'beforeDestroy', 'destroyed', 'activated', 'deactivated', 'errorCaptured'];

/*  */

var config = {
  /**
   * Option merge strategies (used in core/util/options)
   */
  optionMergeStrategies: Object.create(null),

  /**
   * Whether to suppress warnings.
   */
  silent: false,

  /**
   * Show production mode tip message on boot?
   */
  productionTip: "development" !== 'production',

  /**
   * Whether to enable devtools
   */
  devtools: "development" !== 'production',

  /**
   * Whether to record perf
   */
  performance: false,

  /**
   * Error handler for watcher errors
   */
  errorHandler: null,

  /**
   * Warn handler for watcher warns
   */
  warnHandler: null,

  /**
   * Ignore certain custom elements
   */
  ignoredElements: [],

  /**
   * Custom user key aliases for v-on
   */
  keyCodes: Object.create(null),

  /**
   * Check if a tag is reserved so that it cannot be registered as a
   * component. This is platform-dependent and may be overwritten.
   */
  isReservedTag: no,

  /**
   * Check if an attribute is reserved so that it cannot be used as a component
   * prop. This is platform-dependent and may be overwritten.
   */
  isReservedAttr: no,

  /**
   * Check if a tag is an unknown element.
   * Platform-dependent.
   */
  isUnknownElement: no,

  /**
   * Get the namespace of an element
   */
  getTagNamespace: noop,

  /**
   * Parse the real tag name for the specific platform.
   */
  parsePlatformTagName: identity,

  /**
   * Check if an attribute must be bound using property, e.g. value
   * Platform-dependent.
   */
  mustUseProp: no,

  /**
   * Exposed for legacy reasons
   */
  _lifecycleHooks: LIFECYCLE_HOOKS
};

/*  */

/**
 * Check if a string starts with $ or _
 */
function isReserved(str) {
  var c = (str + '').charCodeAt(0);
  return c === 0x24 || c === 0x5F;
}

/**
 * Define a property.
 */
function def(obj, key, val, enumerable) {
  Object.defineProperty(obj, key, {
    value: val,
    enumerable: !!enumerable,
    writable: true,
    configurable: true
  });
}

/**
 * Parse simple path.
 */
var bailRE = /[^\w.$]/;
function parsePath(path) {
  if (bailRE.test(path)) {
    return;
  }
  var segments = path.split('.');
  return function (obj) {
    for (var i = 0; i < segments.length; i++) {
      if (!obj) {
        return;
      }
      obj = obj[segments[i]];
    }
    return obj;
  };
}

/*  */

// can we use __proto__?
var hasProto = '__proto__' in {};

// Browser environment sniffing
var inBrowser = typeof window !== 'undefined';
var inWeex = typeof WXEnvironment !== 'undefined' && !!WXEnvironment.platform;
var weexPlatform = inWeex && WXEnvironment.platform.toLowerCase();
var UA = inBrowser && window.navigator.userAgent.toLowerCase();
var isIE = UA && /msie|trident/.test(UA);
var isIE9 = UA && UA.indexOf('msie 9.0') > 0;
var isEdge = UA && UA.indexOf('edge/') > 0;
var isAndroid = UA && UA.indexOf('android') > 0 || weexPlatform === 'android';
var isIOS = UA && /iphone|ipad|ipod|ios/.test(UA) || weexPlatform === 'ios';
var isChrome = UA && /chrome\/\d+/.test(UA) && !isEdge;

// Firefox has a "watch" function on Object.prototype...
var nativeWatch = {}.watch;

var supportsPassive = false;
if (inBrowser) {
  try {
    var opts = {};
    Object.defineProperty(opts, 'passive', {
      get: function get() {
        /* istanbul ignore next */
        supportsPassive = true;
      }
    }); // https://github.com/facebook/flow/issues/285
    window.addEventListener('test-passive', null, opts);
  } catch (e) {}
}

// this needs to be lazy-evaled because vue may be required before
// vue-server-renderer can set VUE_ENV
var _isServer;
var isServerRendering = function isServerRendering() {
  if (_isServer === undefined) {
    /* istanbul ignore if */
    if (!inBrowser && typeof global !== 'undefined') {
      // detect presence of vue-server-renderer and avoid
      // Webpack shimming the process
      _isServer = global['process'].env.VUE_ENV === 'server';
    } else {
      _isServer = false;
    }
  }
  return _isServer;
};

// detect devtools
var devtools = inBrowser && window.__VUE_DEVTOOLS_GLOBAL_HOOK__;

/* istanbul ignore next */
function isNative(Ctor) {
  return typeof Ctor === 'function' && /native code/.test(Ctor.toString());
}

var hasSymbol = typeof Symbol !== 'undefined' && isNative(Symbol) && typeof Reflect !== 'undefined' && isNative(Reflect.ownKeys);

var _Set;
/* istanbul ignore if */ // $flow-disable-line
if (typeof Set !== 'undefined' && isNative(Set)) {
  // use native Set when available.
  _Set = Set;
} else {
  // a non-standard Set polyfill that only works with primitive keys.
  _Set = function () {
    function Set() {
      this.set = Object.create(null);
    }
    Set.prototype.has = function has(key) {
      return this.set[key] === true;
    };
    Set.prototype.add = function add(key) {
      this.set[key] = true;
    };
    Set.prototype.clear = function clear() {
      this.set = Object.create(null);
    };

    return Set;
  }();
}

/*  */

var warn = noop;
var tip = noop;
var generateComponentTrace = noop; // work around flow check
var formatComponentName = noop;

if (true) {
  var hasConsole = typeof console !== 'undefined';
  var classifyRE = /(?:^|[-_])(\w)/g;
  var classify = function classify(str) {
    return str.replace(classifyRE, function (c) {
      return c.toUpperCase();
    }).replace(/[-_]/g, '');
  };

  warn = function warn(msg, vm) {
    var trace = vm ? generateComponentTrace(vm) : '';

    if (config.warnHandler) {
      config.warnHandler.call(null, msg, vm, trace);
    } else if (hasConsole && !config.silent) {
      console.error("[Vue warn]: " + msg + trace);
    }
  };

  tip = function tip(msg, vm) {
    if (hasConsole && !config.silent) {
      console.warn("[Vue tip]: " + msg + (vm ? generateComponentTrace(vm) : ''));
    }
  };

  formatComponentName = function formatComponentName(vm, includeFile) {
    if (vm.$root === vm) {
      return '<Root>';
    }
    var options = typeof vm === 'function' && vm.cid != null ? vm.options : vm._isVue ? vm.$options || vm.constructor.options : vm || {};
    var name = options.name || options._componentTag;
    var file = options.__file;
    if (!name && file) {
      var match = file.match(/([^/\\]+)\.vue$/);
      name = match && match[1];
    }

    return (name ? "<" + classify(name) + ">" : "<Anonymous>") + (file && includeFile !== false ? " at " + file : '');
  };

  var repeat = function repeat(str, n) {
    var res = '';
    while (n) {
      if (n % 2 === 1) {
        res += str;
      }
      if (n > 1) {
        str += str;
      }
      n >>= 1;
    }
    return res;
  };

  generateComponentTrace = function generateComponentTrace(vm) {
    if (vm._isVue && vm.$parent) {
      var tree = [];
      var currentRecursiveSequence = 0;
      while (vm) {
        if (tree.length > 0) {
          var last = tree[tree.length - 1];
          if (last.constructor === vm.constructor) {
            currentRecursiveSequence++;
            vm = vm.$parent;
            continue;
          } else if (currentRecursiveSequence > 0) {
            tree[tree.length - 1] = [last, currentRecursiveSequence];
            currentRecursiveSequence = 0;
          }
        }
        tree.push(vm);
        vm = vm.$parent;
      }
      return '\n\nfound in\n\n' + tree.map(function (vm, i) {
        return "" + (i === 0 ? '---> ' : repeat(' ', 5 + i * 2)) + (Array.isArray(vm) ? formatComponentName(vm[0]) + "... (" + vm[1] + " recursive calls)" : formatComponentName(vm));
      }).join('\n');
    } else {
      return "\n\n(found in " + formatComponentName(vm) + ")";
    }
  };
}

/*  */

var uid = 0;

/**
 * A dep is an observable that can have multiple
 * directives subscribing to it.
 */
var Dep = function Dep() {
  this.id = uid++;
  this.subs = [];
};

Dep.prototype.addSub = function addSub(sub) {
  this.subs.push(sub);
};

Dep.prototype.removeSub = function removeSub(sub) {
  remove(this.subs, sub);
};

Dep.prototype.depend = function depend() {
  if (Dep.target) {
    Dep.target.addDep(this);
  }
};

Dep.prototype.notify = function notify() {
  // stabilize the subscriber list first
  var subs = this.subs.slice();
  for (var i = 0, l = subs.length; i < l; i++) {
    subs[i].update();
  }
};

// the current target watcher being evaluated.
// this is globally unique because there could be only one
// watcher being evaluated at any time.
Dep.target = null;
var targetStack = [];

function pushTarget(_target) {
  if (Dep.target) {
    targetStack.push(Dep.target);
  }
  Dep.target = _target;
}

function popTarget() {
  Dep.target = targetStack.pop();
}

/*  */

var VNode = function VNode(tag, data, children, text, elm, context, componentOptions, asyncFactory) {
  this.tag = tag;
  this.data = data;
  this.children = children;
  this.text = text;
  this.elm = elm;
  this.ns = undefined;
  this.context = context;
  this.fnContext = undefined;
  this.fnOptions = undefined;
  this.fnScopeId = undefined;
  this.key = data && data.key;
  this.componentOptions = componentOptions;
  this.componentInstance = undefined;
  this.parent = undefined;
  this.raw = false;
  this.isStatic = false;
  this.isRootInsert = true;
  this.isComment = false;
  this.isCloned = false;
  this.isOnce = false;
  this.asyncFactory = asyncFactory;
  this.asyncMeta = undefined;
  this.isAsyncPlaceholder = false;
};

var prototypeAccessors = { child: { configurable: true } };

// DEPRECATED: alias for componentInstance for backwards compat.
/* istanbul ignore next */
prototypeAccessors.child.get = function () {
  return this.componentInstance;
};

Object.defineProperties(VNode.prototype, prototypeAccessors);

var createEmptyVNode = function createEmptyVNode(text) {
  if (text === void 0) text = '';

  var node = new VNode();
  node.text = text;
  node.isComment = true;
  return node;
};

function createTextVNode(val) {
  return new VNode(undefined, undefined, undefined, String(val));
}

// optimized shallow clone
// used for static nodes and slot nodes because they may be reused across
// multiple renders, cloning them avoids errors when DOM manipulations rely
// on their elm reference.
function cloneVNode(vnode, deep) {
  var componentOptions = vnode.componentOptions;
  var cloned = new VNode(vnode.tag, vnode.data, vnode.children, vnode.text, vnode.elm, vnode.context, componentOptions, vnode.asyncFactory);
  cloned.ns = vnode.ns;
  cloned.isStatic = vnode.isStatic;
  cloned.key = vnode.key;
  cloned.isComment = vnode.isComment;
  cloned.fnContext = vnode.fnContext;
  cloned.fnOptions = vnode.fnOptions;
  cloned.fnScopeId = vnode.fnScopeId;
  cloned.isCloned = true;
  if (deep) {
    if (vnode.children) {
      cloned.children = cloneVNodes(vnode.children, true);
    }
    if (componentOptions && componentOptions.children) {
      componentOptions.children = cloneVNodes(componentOptions.children, true);
    }
  }
  return cloned;
}

function cloneVNodes(vnodes, deep) {
  var len = vnodes.length;
  var res = new Array(len);
  for (var i = 0; i < len; i++) {
    res[i] = cloneVNode(vnodes[i], deep);
  }
  return res;
}

/*
 * not type checking this file because flow doesn't play well with
 * dynamically accessing methods on Array prototype
 */

var arrayProto = Array.prototype;
var arrayMethods = Object.create(arrayProto);['push', 'pop', 'shift', 'unshift', 'splice', 'sort', 'reverse'].forEach(function (method) {
  // cache original method
  var original = arrayProto[method];
  def(arrayMethods, method, function mutator() {
    var args = [],
        len = arguments.length;
    while (len--) {
      args[len] = arguments[len];
    }var result = original.apply(this, args);
    var ob = this.__ob__;
    var inserted;
    switch (method) {
      case 'push':
      case 'unshift':
        inserted = args;
        break;
      case 'splice':
        inserted = args.slice(2);
        break;
    }
    if (inserted) {
      ob.observeArray(inserted);
    }
    // notify change
    ob.dep.notify();
    return result;
  });
});

/*  */

var arrayKeys = Object.getOwnPropertyNames(arrayMethods);

/**
 * By default, when a reactive property is set, the new value is
 * also converted to become reactive. However when passing down props,
 * we don't want to force conversion because the value may be a nested value
 * under a frozen data structure. Converting it would defeat the optimization.
 */
var observerState = {
  shouldConvert: true
};

/**
 * Observer class that are attached to each observed
 * object. Once attached, the observer converts target
 * object's property keys into getter/setters that
 * collect dependencies and dispatches updates.
 */
var Observer = function Observer(value) {
  this.value = value;
  this.dep = new Dep();
  this.vmCount = 0;
  def(value, '__ob__', this);
  if (Array.isArray(value)) {
    var augment = hasProto ? protoAugment : copyAugment;
    augment(value, arrayMethods, arrayKeys);
    this.observeArray(value);
  } else {
    this.walk(value);
  }
};

/**
 * Walk through each property and convert them into
 * getter/setters. This method should only be called when
 * value type is Object.
 */
Observer.prototype.walk = function walk(obj) {
  var keys = Object.keys(obj);
  for (var i = 0; i < keys.length; i++) {
    defineReactive(obj, keys[i], obj[keys[i]]);
  }
};

/**
 * Observe a list of Array items.
 */
Observer.prototype.observeArray = function observeArray(items) {
  for (var i = 0, l = items.length; i < l; i++) {
    observe(items[i]);
  }
};

// helpers

/**
 * Augment an target Object or Array by intercepting
 * the prototype chain using __proto__
 */
function protoAugment(target, src, keys) {
  /* eslint-disable no-proto */
  target.__proto__ = src;
  /* eslint-enable no-proto */
}

/**
 * Augment an target Object or Array by defining
 * hidden properties.
 */
/* istanbul ignore next */
function copyAugment(target, src, keys) {
  for (var i = 0, l = keys.length; i < l; i++) {
    var key = keys[i];
    def(target, key, src[key]);
  }
}

/**
 * Attempt to create an observer instance for a value,
 * returns the new observer if successfully observed,
 * or the existing observer if the value already has one.
 */
function observe(value, asRootData) {
  if (!isObject(value) || value instanceof VNode) {
    return;
  }
  var ob;
  if (hasOwn(value, '__ob__') && value.__ob__ instanceof Observer) {
    ob = value.__ob__;
  } else if (observerState.shouldConvert && !isServerRendering() && (Array.isArray(value) || isPlainObject(value)) && Object.isExtensible(value) && !value._isVue) {
    ob = new Observer(value);
  }
  if (asRootData && ob) {
    ob.vmCount++;
  }
  return ob;
}

/**
 * Define a reactive property on an Object.
 */
function defineReactive(obj, key, val, customSetter, shallow) {
  var dep = new Dep();

  var property = Object.getOwnPropertyDescriptor(obj, key);
  if (property && property.configurable === false) {
    return;
  }

  // cater for pre-defined getter/setters
  var getter = property && property.get;
  var setter = property && property.set;

  var childOb = !shallow && observe(val);
  Object.defineProperty(obj, key, {
    enumerable: true,
    configurable: true,
    get: function reactiveGetter() {
      var value = getter ? getter.call(obj) : val;
      if (Dep.target) {
        dep.depend();
        if (childOb) {
          childOb.dep.depend();
          if (Array.isArray(value)) {
            dependArray(value);
          }
        }
      }
      return value;
    },
    set: function reactiveSetter(newVal) {
      var value = getter ? getter.call(obj) : val;
      /* eslint-disable no-self-compare */
      if (newVal === value || newVal !== newVal && value !== value) {
        return;
      }
      /* eslint-enable no-self-compare */
      if ("development" !== 'production' && customSetter) {
        customSetter();
      }
      if (setter) {
        setter.call(obj, newVal);
      } else {
        val = newVal;
      }
      childOb = !shallow && observe(newVal);
      dep.notify();
    }
  });
}

/**
 * Set a property on an object. Adds the new property and
 * triggers change notification if the property doesn't
 * already exist.
 */
function set(target, key, val) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.length = Math.max(target.length, key);
    target.splice(key, 1, val);
    return val;
  }
  if (key in target && !(key in Object.prototype)) {
    target[key] = val;
    return val;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid adding reactive properties to a Vue instance or its root $data ' + 'at runtime - declare it upfront in the data option.');
    return val;
  }
  if (!ob) {
    target[key] = val;
    return val;
  }
  defineReactive(ob.value, key, val);
  ob.dep.notify();
  return val;
}

/**
 * Delete a property and trigger change if necessary.
 */
function del(target, key) {
  if (Array.isArray(target) && isValidArrayIndex(key)) {
    target.splice(key, 1);
    return;
  }
  var ob = target.__ob__;
  if (target._isVue || ob && ob.vmCount) {
    "development" !== 'production' && warn('Avoid deleting properties on a Vue instance or its root $data ' + '- just set it to null.');
    return;
  }
  if (!hasOwn(target, key)) {
    return;
  }
  delete target[key];
  if (!ob) {
    return;
  }
  ob.dep.notify();
}

/**
 * Collect dependencies on array elements when the array is touched, since
 * we cannot intercept array element access like property getters.
 */
function dependArray(value) {
  for (var e = void 0, i = 0, l = value.length; i < l; i++) {
    e = value[i];
    e && e.__ob__ && e.__ob__.dep.depend();
    if (Array.isArray(e)) {
      dependArray(e);
    }
  }
}

/*  */

/**
 * Option overwriting strategies are functions that handle
 * how to merge a parent option value and a child option
 * value into the final value.
 */
var strats = config.optionMergeStrategies;

/**
 * Options with restrictions
 */
if (true) {
  strats.el = strats.propsData = function (parent, child, vm, key) {
    if (!vm) {
      warn("option \"" + key + "\" can only be used during instance " + 'creation with the `new` keyword.');
    }
    return defaultStrat(parent, child);
  };
}

/**
 * Helper that recursively merges two data objects together.
 */
function mergeData(to, from) {
  if (!from) {
    return to;
  }
  var key, toVal, fromVal;
  var keys = Object.keys(from);
  for (var i = 0; i < keys.length; i++) {
    key = keys[i];
    toVal = to[key];
    fromVal = from[key];
    if (!hasOwn(to, key)) {
      set(to, key, fromVal);
    } else if (isPlainObject(toVal) && isPlainObject(fromVal)) {
      mergeData(toVal, fromVal);
    }
  }
  return to;
}

/**
 * Data
 */
function mergeDataOrFn(parentVal, childVal, vm) {
  if (!vm) {
    // in a Vue.extend merge, both should be functions
    if (!childVal) {
      return parentVal;
    }
    if (!parentVal) {
      return childVal;
    }
    // when parentVal & childVal are both present,
    // we need to return a function that returns the
    // merged result of both functions... no need to
    // check if parentVal is a function here because
    // it has to be a function to pass previous merges.
    return function mergedDataFn() {
      return mergeData(typeof childVal === 'function' ? childVal.call(this) : childVal, typeof parentVal === 'function' ? parentVal.call(this) : parentVal);
    };
  } else {
    return function mergedInstanceDataFn() {
      // instance merge
      var instanceData = typeof childVal === 'function' ? childVal.call(vm) : childVal;
      var defaultData = typeof parentVal === 'function' ? parentVal.call(vm) : parentVal;
      if (instanceData) {
        return mergeData(instanceData, defaultData);
      } else {
        return defaultData;
      }
    };
  }
}

strats.data = function (parentVal, childVal, vm) {
  if (!vm) {
    if (childVal && typeof childVal !== 'function') {
      "development" !== 'production' && warn('The "data" option should be a function ' + 'that returns a per-instance value in component ' + 'definitions.', vm);

      return parentVal;
    }
    return mergeDataOrFn(parentVal, childVal);
  }

  return mergeDataOrFn(parentVal, childVal, vm);
};

/**
 * Hooks and props are merged as arrays.
 */
function mergeHook(parentVal, childVal) {
  return childVal ? parentVal ? parentVal.concat(childVal) : Array.isArray(childVal) ? childVal : [childVal] : parentVal;
}

LIFECYCLE_HOOKS.forEach(function (hook) {
  strats[hook] = mergeHook;
});

/**
 * Assets
 *
 * When a vm is present (instance creation), we need to do
 * a three-way merge between constructor options, instance
 * options and parent options.
 */
function mergeAssets(parentVal, childVal, vm, key) {
  var res = Object.create(parentVal || null);
  if (childVal) {
    "development" !== 'production' && assertObjectType(key, childVal, vm);
    return extend(res, childVal);
  } else {
    return res;
  }
}

ASSET_TYPES.forEach(function (type) {
  strats[type + 's'] = mergeAssets;
});

/**
 * Watchers.
 *
 * Watchers hashes should not overwrite one
 * another, so we merge them as arrays.
 */
strats.watch = function (parentVal, childVal, vm, key) {
  // work around Firefox's Object.prototype.watch...
  if (parentVal === nativeWatch) {
    parentVal = undefined;
  }
  if (childVal === nativeWatch) {
    childVal = undefined;
  }
  /* istanbul ignore if */
  if (!childVal) {
    return Object.create(parentVal || null);
  }
  if (true) {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = {};
  extend(ret, parentVal);
  for (var key$1 in childVal) {
    var parent = ret[key$1];
    var child = childVal[key$1];
    if (parent && !Array.isArray(parent)) {
      parent = [parent];
    }
    ret[key$1] = parent ? parent.concat(child) : Array.isArray(child) ? child : [child];
  }
  return ret;
};

/**
 * Other object hashes.
 */
strats.props = strats.methods = strats.inject = strats.computed = function (parentVal, childVal, vm, key) {
  if (childVal && "development" !== 'production') {
    assertObjectType(key, childVal, vm);
  }
  if (!parentVal) {
    return childVal;
  }
  var ret = Object.create(null);
  extend(ret, parentVal);
  if (childVal) {
    extend(ret, childVal);
  }
  return ret;
};
strats.provide = mergeDataOrFn;

/**
 * Default strategy.
 */
var defaultStrat = function defaultStrat(parentVal, childVal) {
  return childVal === undefined ? parentVal : childVal;
};

/**
 * Validate component names
 */
function checkComponents(options) {
  for (var key in options.components) {
    var lower = key.toLowerCase();
    if (isBuiltInTag(lower) || config.isReservedTag(lower)) {
      warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + key);
    }
  }
}

/**
 * Ensure all props option syntax are normalized into the
 * Object-based format.
 */
function normalizeProps(options, vm) {
  var props = options.props;
  if (!props) {
    return;
  }
  var res = {};
  var i, val, name;
  if (Array.isArray(props)) {
    i = props.length;
    while (i--) {
      val = props[i];
      if (typeof val === 'string') {
        name = camelize(val);
        res[name] = { type: null };
      } else if (true) {
        warn('props must be strings when using array syntax.');
      }
    }
  } else if (isPlainObject(props)) {
    for (var key in props) {
      val = props[key];
      name = camelize(key);
      res[name] = isPlainObject(val) ? val : { type: val };
    }
  } else if (true) {
    warn("Invalid value for option \"props\": expected an Array or an Object, " + "but got " + toRawType(props) + ".", vm);
  }
  options.props = res;
}

/**
 * Normalize all injections into Object-based format
 */
function normalizeInject(options, vm) {
  var inject = options.inject;
  var normalized = options.inject = {};
  if (Array.isArray(inject)) {
    for (var i = 0; i < inject.length; i++) {
      normalized[inject[i]] = { from: inject[i] };
    }
  } else if (isPlainObject(inject)) {
    for (var key in inject) {
      var val = inject[key];
      normalized[key] = isPlainObject(val) ? extend({ from: key }, val) : { from: val };
    }
  } else if ("development" !== 'production' && inject) {
    warn("Invalid value for option \"inject\": expected an Array or an Object, " + "but got " + toRawType(inject) + ".", vm);
  }
}

/**
 * Normalize raw function directives into object format.
 */
function normalizeDirectives(options) {
  var dirs = options.directives;
  if (dirs) {
    for (var key in dirs) {
      var def = dirs[key];
      if (typeof def === 'function') {
        dirs[key] = { bind: def, update: def };
      }
    }
  }
}

function assertObjectType(name, value, vm) {
  if (!isPlainObject(value)) {
    warn("Invalid value for option \"" + name + "\": expected an Object, " + "but got " + toRawType(value) + ".", vm);
  }
}

/**
 * Merge two option objects into a new one.
 * Core utility used in both instantiation and inheritance.
 */
function mergeOptions(parent, child, vm) {
  if (true) {
    checkComponents(child);
  }

  if (typeof child === 'function') {
    child = child.options;
  }

  normalizeProps(child, vm);
  normalizeInject(child, vm);
  normalizeDirectives(child);
  var extendsFrom = child.extends;
  if (extendsFrom) {
    parent = mergeOptions(parent, extendsFrom, vm);
  }
  if (child.mixins) {
    for (var i = 0, l = child.mixins.length; i < l; i++) {
      parent = mergeOptions(parent, child.mixins[i], vm);
    }
  }
  var options = {};
  var key;
  for (key in parent) {
    mergeField(key);
  }
  for (key in child) {
    if (!hasOwn(parent, key)) {
      mergeField(key);
    }
  }
  function mergeField(key) {
    var strat = strats[key] || defaultStrat;
    options[key] = strat(parent[key], child[key], vm, key);
  }
  return options;
}

/**
 * Resolve an asset.
 * This function is used because child instances need access
 * to assets defined in its ancestor chain.
 */
function resolveAsset(options, type, id, warnMissing) {
  /* istanbul ignore if */
  if (typeof id !== 'string') {
    return;
  }
  var assets = options[type];
  // check local registration variations first
  if (hasOwn(assets, id)) {
    return assets[id];
  }
  var camelizedId = camelize(id);
  if (hasOwn(assets, camelizedId)) {
    return assets[camelizedId];
  }
  var PascalCaseId = capitalize(camelizedId);
  if (hasOwn(assets, PascalCaseId)) {
    return assets[PascalCaseId];
  }
  // fallback to prototype chain
  var res = assets[id] || assets[camelizedId] || assets[PascalCaseId];
  if ("development" !== 'production' && warnMissing && !res) {
    warn('Failed to resolve ' + type.slice(0, -1) + ': ' + id, options);
  }
  return res;
}

/*  */

function validateProp(key, propOptions, propsData, vm) {
  var prop = propOptions[key];
  var absent = !hasOwn(propsData, key);
  var value = propsData[key];
  // handle boolean props
  if (isType(Boolean, prop.type)) {
    if (absent && !hasOwn(prop, 'default')) {
      value = false;
    } else if (!isType(String, prop.type) && (value === '' || value === hyphenate(key))) {
      value = true;
    }
  }
  // check default value
  if (value === undefined) {
    value = getPropDefaultValue(vm, prop, key);
    // since the default value is a fresh copy,
    // make sure to observe it.
    var prevShouldConvert = observerState.shouldConvert;
    observerState.shouldConvert = true;
    observe(value);
    observerState.shouldConvert = prevShouldConvert;
  }
  if (true) {
    assertProp(prop, key, value, vm, absent);
  }
  return value;
}

/**
 * Get the default value of a prop.
 */
function getPropDefaultValue(vm, prop, key) {
  // no default, return undefined
  if (!hasOwn(prop, 'default')) {
    return undefined;
  }
  var def = prop.default;
  // warn against non-factory defaults for Object & Array
  if ("development" !== 'production' && isObject(def)) {
    warn('Invalid default value for prop "' + key + '": ' + 'Props with type Object/Array must use a factory function ' + 'to return the default value.', vm);
  }
  // the raw prop value was also undefined from previous render,
  // return previous default value to avoid unnecessary watcher trigger
  if (vm && vm.$options.propsData && vm.$options.propsData[key] === undefined && vm._props[key] !== undefined) {
    return vm._props[key];
  }
  // call factory function for non-Function types
  // a value is Function if its prototype is function even across different execution context
  return typeof def === 'function' && getType(prop.type) !== 'Function' ? def.call(vm) : def;
}

/**
 * Assert whether a prop is valid.
 */
function assertProp(prop, name, value, vm, absent) {
  if (prop.required && absent) {
    warn('Missing required prop: "' + name + '"', vm);
    return;
  }
  if (value == null && !prop.required) {
    return;
  }
  var type = prop.type;
  var valid = !type || type === true;
  var expectedTypes = [];
  if (type) {
    if (!Array.isArray(type)) {
      type = [type];
    }
    for (var i = 0; i < type.length && !valid; i++) {
      var assertedType = assertType(value, type[i]);
      expectedTypes.push(assertedType.expectedType || '');
      valid = assertedType.valid;
    }
  }
  if (!valid) {
    warn("Invalid prop: type check failed for prop \"" + name + "\"." + " Expected " + expectedTypes.map(capitalize).join(', ') + ", got " + toRawType(value) + ".", vm);
    return;
  }
  var validator = prop.validator;
  if (validator) {
    if (!validator(value)) {
      warn('Invalid prop: custom validator check failed for prop "' + name + '".', vm);
    }
  }
}

var simpleCheckRE = /^(String|Number|Boolean|Function|Symbol)$/;

function assertType(value, type) {
  var valid;
  var expectedType = getType(type);
  if (simpleCheckRE.test(expectedType)) {
    var t = typeof value === 'undefined' ? 'undefined' : _typeof(value);
    valid = t === expectedType.toLowerCase();
    // for primitive wrapper objects
    if (!valid && t === 'object') {
      valid = value instanceof type;
    }
  } else if (expectedType === 'Object') {
    valid = isPlainObject(value);
  } else if (expectedType === 'Array') {
    valid = Array.isArray(value);
  } else {
    valid = value instanceof type;
  }
  return {
    valid: valid,
    expectedType: expectedType
  };
}

/**
 * Use function string name to check built-in types,
 * because a simple equality check will fail when running
 * across different vms / iframes.
 */
function getType(fn) {
  var match = fn && fn.toString().match(/^\s*function (\w+)/);
  return match ? match[1] : '';
}

function isType(type, fn) {
  if (!Array.isArray(fn)) {
    return getType(fn) === getType(type);
  }
  for (var i = 0, len = fn.length; i < len; i++) {
    if (getType(fn[i]) === getType(type)) {
      return true;
    }
  }
  /* istanbul ignore next */
  return false;
}

/*  */

function handleError(err, vm, info) {
  if (vm) {
    var cur = vm;
    while (cur = cur.$parent) {
      var hooks = cur.$options.errorCaptured;
      if (hooks) {
        for (var i = 0; i < hooks.length; i++) {
          try {
            var capture = hooks[i].call(cur, err, vm, info) === false;
            if (capture) {
              return;
            }
          } catch (e) {
            globalHandleError(e, cur, 'errorCaptured hook');
          }
        }
      }
    }
  }
  globalHandleError(err, vm, info);
}

function globalHandleError(err, vm, info) {
  if (config.errorHandler) {
    try {
      return config.errorHandler.call(null, err, vm, info);
    } catch (e) {
      logError(e, null, 'config.errorHandler');
    }
  }
  logError(err, vm, info);
}

function logError(err, vm, info) {
  if (true) {
    warn("Error in " + info + ": \"" + err.toString() + "\"", vm);
  }
  /* istanbul ignore else */
  if ((inBrowser || inWeex) && typeof console !== 'undefined') {
    console.error(err);
  } else {
    throw err;
  }
}

/*  */
/* globals MessageChannel */

var callbacks = [];
var pending = false;

function flushCallbacks() {
  pending = false;
  var copies = callbacks.slice(0);
  callbacks.length = 0;
  for (var i = 0; i < copies.length; i++) {
    copies[i]();
  }
}

// Here we have async deferring wrappers using both micro and macro tasks.
// In < 2.4 we used micro tasks everywhere, but there are some scenarios where
// micro tasks have too high a priority and fires in between supposedly
// sequential events (e.g. #4521, #6690) or even between bubbling of the same
// event (#6566). However, using macro tasks everywhere also has subtle problems
// when state is changed right before repaint (e.g. #6813, out-in transitions).
// Here we use micro task by default, but expose a way to force macro task when
// needed (e.g. in event handlers attached by v-on).
var microTimerFunc;
var macroTimerFunc;
var useMacroTask = false;

// Determine (macro) Task defer implementation.
// Technically setImmediate should be the ideal choice, but it's only available
// in IE. The only polyfill that consistently queues the callback after all DOM
// events triggered in the same loop is by using MessageChannel.
/* istanbul ignore if */
if (typeof setImmediate !== 'undefined' && isNative(setImmediate)) {
  macroTimerFunc = function macroTimerFunc() {
    setImmediate(flushCallbacks);
  };
} else if (typeof MessageChannel !== 'undefined' && (isNative(MessageChannel) ||
// PhantomJS
MessageChannel.toString() === '[object MessageChannelConstructor]')) {
  var channel = new MessageChannel();
  var port = channel.port2;
  channel.port1.onmessage = flushCallbacks;
  macroTimerFunc = function macroTimerFunc() {
    port.postMessage(1);
  };
} else {
  /* istanbul ignore next */
  macroTimerFunc = function macroTimerFunc() {
    setTimeout(flushCallbacks, 0);
  };
}

// Determine MicroTask defer implementation.
/* istanbul ignore next, $flow-disable-line */
if (typeof Promise !== 'undefined' && isNative(Promise)) {
  var p = Promise.resolve();
  microTimerFunc = function microTimerFunc() {
    p.then(flushCallbacks);
    // in problematic UIWebViews, Promise.then doesn't completely break, but
    // it can get stuck in a weird state where callbacks are pushed into the
    // microtask queue but the queue isn't being flushed, until the browser
    // needs to do some other work, e.g. handle a timer. Therefore we can
    // "force" the microtask queue to be flushed by adding an empty timer.
    if (isIOS) {
      setTimeout(noop);
    }
  };
} else {
  // fallback to macro
  microTimerFunc = macroTimerFunc;
}

/**
 * Wrap a function so that if any code inside triggers state change,
 * the changes are queued using a Task instead of a MicroTask.
 */
function withMacroTask(fn) {
  return fn._withTask || (fn._withTask = function () {
    useMacroTask = true;
    var res = fn.apply(null, arguments);
    useMacroTask = false;
    return res;
  });
}

function nextTick(cb, ctx) {
  var _resolve;
  callbacks.push(function () {
    if (cb) {
      try {
        cb.call(ctx);
      } catch (e) {
        handleError(e, ctx, 'nextTick');
      }
    } else if (_resolve) {
      _resolve(ctx);
    }
  });
  if (!pending) {
    pending = true;
    if (useMacroTask) {
      macroTimerFunc();
    } else {
      microTimerFunc();
    }
  }
  // $flow-disable-line
  if (!cb && typeof Promise !== 'undefined') {
    return new Promise(function (resolve) {
      _resolve = resolve;
    });
  }
}

/*  */

var mark;
var measure;

if (true) {
  var perf = inBrowser && window.performance;
  /* istanbul ignore if */
  if (perf && perf.mark && perf.measure && perf.clearMarks && perf.clearMeasures) {
    mark = function mark(tag) {
      return perf.mark(tag);
    };
    measure = function measure(name, startTag, endTag) {
      perf.measure(name, startTag, endTag);
      perf.clearMarks(startTag);
      perf.clearMarks(endTag);
      perf.clearMeasures(name);
    };
  }
}

/* not type checking this file because flow doesn't play well with Proxy */

var initProxy;

if (true) {
  var allowedGlobals = makeMap('Infinity,undefined,NaN,isFinite,isNaN,' + 'parseFloat,parseInt,decodeURI,decodeURIComponent,encodeURI,encodeURIComponent,' + 'Math,Number,Date,Array,Object,Boolean,String,RegExp,Map,Set,JSON,Intl,' + 'require' // for Webpack/Browserify
  );

  var warnNonPresent = function warnNonPresent(target, key) {
    warn("Property or method \"" + key + "\" is not defined on the instance but " + 'referenced during render. Make sure that this property is reactive, ' + 'either in the data option, or for class-based components, by ' + 'initializing the property. ' + 'See: https://vuejs.org/v2/guide/reactivity.html#Declaring-Reactive-Properties.', target);
  };

  var hasProxy = typeof Proxy !== 'undefined' && Proxy.toString().match(/native code/);

  if (hasProxy) {
    var isBuiltInModifier = makeMap('stop,prevent,self,ctrl,shift,alt,meta,exact');
    config.keyCodes = new Proxy(config.keyCodes, {
      set: function set(target, key, value) {
        if (isBuiltInModifier(key)) {
          warn("Avoid overwriting built-in modifier in config.keyCodes: ." + key);
          return false;
        } else {
          target[key] = value;
          return true;
        }
      }
    });
  }

  var hasHandler = {
    has: function has(target, key) {
      var has = key in target;
      var isAllowed = allowedGlobals(key) || key.charAt(0) === '_';
      if (!has && !isAllowed) {
        warnNonPresent(target, key);
      }
      return has || !isAllowed;
    }
  };

  var getHandler = {
    get: function get(target, key) {
      if (typeof key === 'string' && !(key in target)) {
        warnNonPresent(target, key);
      }
      return target[key];
    }
  };

  initProxy = function initProxy(vm) {
    if (hasProxy) {
      // determine which proxy handler to use
      var options = vm.$options;
      var handlers = options.render && options.render._withStripped ? getHandler : hasHandler;
      vm._renderProxy = new Proxy(vm, handlers);
    } else {
      vm._renderProxy = vm;
    }
  };
}

/*  */

var seenObjects = new _Set();

/**
 * Recursively traverse an object to evoke all converted
 * getters, so that every nested property inside the object
 * is collected as a "deep" dependency.
 */
function traverse(val) {
  _traverse(val, seenObjects);
  seenObjects.clear();
}

function _traverse(val, seen) {
  var i, keys;
  var isA = Array.isArray(val);
  if (!isA && !isObject(val) || Object.isFrozen(val)) {
    return;
  }
  if (val.__ob__) {
    var depId = val.__ob__.dep.id;
    if (seen.has(depId)) {
      return;
    }
    seen.add(depId);
  }
  if (isA) {
    i = val.length;
    while (i--) {
      _traverse(val[i], seen);
    }
  } else {
    keys = Object.keys(val);
    i = keys.length;
    while (i--) {
      _traverse(val[keys[i]], seen);
    }
  }
}

/*  */

var normalizeEvent = cached(function (name) {
  var passive = name.charAt(0) === '&';
  name = passive ? name.slice(1) : name;
  var once$$1 = name.charAt(0) === '~'; // Prefixed last, checked first
  name = once$$1 ? name.slice(1) : name;
  var capture = name.charAt(0) === '!';
  name = capture ? name.slice(1) : name;
  return {
    name: name,
    once: once$$1,
    capture: capture,
    passive: passive
  };
});

function createFnInvoker(fns) {
  function invoker() {
    var arguments$1 = arguments;

    var fns = invoker.fns;
    if (Array.isArray(fns)) {
      var cloned = fns.slice();
      for (var i = 0; i < cloned.length; i++) {
        cloned[i].apply(null, arguments$1);
      }
    } else {
      // return handler return value for single handlers
      return fns.apply(null, arguments);
    }
  }
  invoker.fns = fns;
  return invoker;
}

function updateListeners(on, oldOn, add, remove$$1, vm) {
  var name, cur, old, event;
  for (name in on) {
    cur = on[name];
    old = oldOn[name];
    event = normalizeEvent(name);
    if (isUndef(cur)) {
      "development" !== 'production' && warn("Invalid handler for event \"" + event.name + "\": got " + String(cur), vm);
    } else if (isUndef(old)) {
      if (isUndef(cur.fns)) {
        cur = on[name] = createFnInvoker(cur);
      }
      add(event.name, cur, event.once, event.capture, event.passive);
    } else if (cur !== old) {
      old.fns = cur;
      on[name] = old;
    }
  }
  for (name in oldOn) {
    if (isUndef(on[name])) {
      event = normalizeEvent(name);
      remove$$1(event.name, oldOn[name], event.capture);
    }
  }
}

/*  */

function mergeVNodeHook(def, hookKey, hook) {
  if (def instanceof VNode) {
    def = def.data.hook || (def.data.hook = {});
  }
  var invoker;
  var oldHook = def[hookKey];

  function wrappedHook() {
    hook.apply(this, arguments);
    // important: remove merged hook to ensure it's called only once
    // and prevent memory leak
    remove(invoker.fns, wrappedHook);
  }

  if (isUndef(oldHook)) {
    // no existing hook
    invoker = createFnInvoker([wrappedHook]);
  } else {
    /* istanbul ignore if */
    if (isDef(oldHook.fns) && isTrue(oldHook.merged)) {
      // already a merged invoker
      invoker = oldHook;
      invoker.fns.push(wrappedHook);
    } else {
      // existing plain hook
      invoker = createFnInvoker([oldHook, wrappedHook]);
    }
  }

  invoker.merged = true;
  def[hookKey] = invoker;
}

/*  */

function extractPropsFromVNodeData(data, Ctor, tag) {
  // we are only extracting raw values here.
  // validation and default values are handled in the child
  // component itself.
  var propOptions = Ctor.options.props;
  if (isUndef(propOptions)) {
    return;
  }
  var res = {};
  var attrs = data.attrs;
  var props = data.props;
  if (isDef(attrs) || isDef(props)) {
    for (var key in propOptions) {
      var altKey = hyphenate(key);
      if (true) {
        var keyInLowerCase = key.toLowerCase();
        if (key !== keyInLowerCase && attrs && hasOwn(attrs, keyInLowerCase)) {
          tip("Prop \"" + keyInLowerCase + "\" is passed to component " + formatComponentName(tag || Ctor) + ", but the declared prop name is" + " \"" + key + "\". " + "Note that HTML attributes are case-insensitive and camelCased " + "props need to use their kebab-case equivalents when using in-DOM " + "templates. You should probably use \"" + altKey + "\" instead of \"" + key + "\".");
        }
      }
      checkProp(res, props, key, altKey, true) || checkProp(res, attrs, key, altKey, false);
    }
  }
  return res;
}

function checkProp(res, hash, key, altKey, preserve) {
  if (isDef(hash)) {
    if (hasOwn(hash, key)) {
      res[key] = hash[key];
      if (!preserve) {
        delete hash[key];
      }
      return true;
    } else if (hasOwn(hash, altKey)) {
      res[key] = hash[altKey];
      if (!preserve) {
        delete hash[altKey];
      }
      return true;
    }
  }
  return false;
}

/*  */

// The template compiler attempts to minimize the need for normalization by
// statically analyzing the template at compile time.
//
// For plain HTML markup, normalization can be completely skipped because the
// generated render function is guaranteed to return Array<VNode>. There are
// two cases where extra normalization is needed:

// 1. When the children contains components - because a functional component
// may return an Array instead of a single root. In this case, just a simple
// normalization is needed - if any child is an Array, we flatten the whole
// thing with Array.prototype.concat. It is guaranteed to be only 1-level deep
// because functional components already normalize their own children.
function simpleNormalizeChildren(children) {
  for (var i = 0; i < children.length; i++) {
    if (Array.isArray(children[i])) {
      return Array.prototype.concat.apply([], children);
    }
  }
  return children;
}

// 2. When the children contains constructs that always generated nested Arrays,
// e.g. <template>, <slot>, v-for, or when the children is provided by user
// with hand-written render functions / JSX. In such cases a full normalization
// is needed to cater to all possible types of children values.
function normalizeChildren(children) {
  return isPrimitive(children) ? [createTextVNode(children)] : Array.isArray(children) ? normalizeArrayChildren(children) : undefined;
}

function isTextNode(node) {
  return isDef(node) && isDef(node.text) && isFalse(node.isComment);
}

function normalizeArrayChildren(children, nestedIndex) {
  var res = [];
  var i, c, lastIndex, last;
  for (i = 0; i < children.length; i++) {
    c = children[i];
    if (isUndef(c) || typeof c === 'boolean') {
      continue;
    }
    lastIndex = res.length - 1;
    last = res[lastIndex];
    //  nested
    if (Array.isArray(c)) {
      if (c.length > 0) {
        c = normalizeArrayChildren(c, (nestedIndex || '') + "_" + i);
        // merge adjacent text nodes
        if (isTextNode(c[0]) && isTextNode(last)) {
          res[lastIndex] = createTextVNode(last.text + c[0].text);
          c.shift();
        }
        res.push.apply(res, c);
      }
    } else if (isPrimitive(c)) {
      if (isTextNode(last)) {
        // merge adjacent text nodes
        // this is necessary for SSR hydration because text nodes are
        // essentially merged when rendered to HTML strings
        res[lastIndex] = createTextVNode(last.text + c);
      } else if (c !== '') {
        // convert primitive to vnode
        res.push(createTextVNode(c));
      }
    } else {
      if (isTextNode(c) && isTextNode(last)) {
        // merge adjacent text nodes
        res[lastIndex] = createTextVNode(last.text + c.text);
      } else {
        // default key for nested array children (likely generated by v-for)
        if (isTrue(children._isVList) && isDef(c.tag) && isUndef(c.key) && isDef(nestedIndex)) {
          c.key = "__vlist" + nestedIndex + "_" + i + "__";
        }
        res.push(c);
      }
    }
  }
  return res;
}

/*  */

function ensureCtor(comp, base) {
  if (comp.__esModule || hasSymbol && comp[Symbol.toStringTag] === 'Module') {
    comp = comp.default;
  }
  return isObject(comp) ? base.extend(comp) : comp;
}

function createAsyncPlaceholder(factory, data, context, children, tag) {
  var node = createEmptyVNode();
  node.asyncFactory = factory;
  node.asyncMeta = { data: data, context: context, children: children, tag: tag };
  return node;
}

function resolveAsyncComponent(factory, baseCtor, context) {
  if (isTrue(factory.error) && isDef(factory.errorComp)) {
    return factory.errorComp;
  }

  if (isDef(factory.resolved)) {
    return factory.resolved;
  }

  if (isTrue(factory.loading) && isDef(factory.loadingComp)) {
    return factory.loadingComp;
  }

  if (isDef(factory.contexts)) {
    // already pending
    factory.contexts.push(context);
  } else {
    var contexts = factory.contexts = [context];
    var sync = true;

    var forceRender = function forceRender() {
      for (var i = 0, l = contexts.length; i < l; i++) {
        contexts[i].$forceUpdate();
      }
    };

    var resolve = once(function (res) {
      // cache resolved
      factory.resolved = ensureCtor(res, baseCtor);
      // invoke callbacks only if this is not a synchronous resolve
      // (async resolves are shimmed as synchronous during SSR)
      if (!sync) {
        forceRender();
      }
    });

    var reject = once(function (reason) {
      "development" !== 'production' && warn("Failed to resolve async component: " + String(factory) + (reason ? "\nReason: " + reason : ''));
      if (isDef(factory.errorComp)) {
        factory.error = true;
        forceRender();
      }
    });

    var res = factory(resolve, reject);

    if (isObject(res)) {
      if (typeof res.then === 'function') {
        // () => Promise
        if (isUndef(factory.resolved)) {
          res.then(resolve, reject);
        }
      } else if (isDef(res.component) && typeof res.component.then === 'function') {
        res.component.then(resolve, reject);

        if (isDef(res.error)) {
          factory.errorComp = ensureCtor(res.error, baseCtor);
        }

        if (isDef(res.loading)) {
          factory.loadingComp = ensureCtor(res.loading, baseCtor);
          if (res.delay === 0) {
            factory.loading = true;
          } else {
            setTimeout(function () {
              if (isUndef(factory.resolved) && isUndef(factory.error)) {
                factory.loading = true;
                forceRender();
              }
            }, res.delay || 200);
          }
        }

        if (isDef(res.timeout)) {
          setTimeout(function () {
            if (isUndef(factory.resolved)) {
              reject( true ? "timeout (" + res.timeout + "ms)" : null);
            }
          }, res.timeout);
        }
      }
    }

    sync = false;
    // return in case resolved synchronously
    return factory.loading ? factory.loadingComp : factory.resolved;
  }
}

/*  */

function isAsyncPlaceholder(node) {
  return node.isComment && node.asyncFactory;
}

/*  */

function getFirstComponentChild(children) {
  if (Array.isArray(children)) {
    for (var i = 0; i < children.length; i++) {
      var c = children[i];
      if (isDef(c) && (isDef(c.componentOptions) || isAsyncPlaceholder(c))) {
        return c;
      }
    }
  }
}

/*  */

/*  */

function initEvents(vm) {
  vm._events = Object.create(null);
  vm._hasHookEvent = false;
  // init parent attached events
  var listeners = vm.$options._parentListeners;
  if (listeners) {
    updateComponentListeners(vm, listeners);
  }
}

var target;

function add(event, fn, once) {
  if (once) {
    target.$once(event, fn);
  } else {
    target.$on(event, fn);
  }
}

function remove$1(event, fn) {
  target.$off(event, fn);
}

function updateComponentListeners(vm, listeners, oldListeners) {
  target = vm;
  updateListeners(listeners, oldListeners || {}, add, remove$1, vm);
  target = undefined;
}

function eventsMixin(Vue) {
  var hookRE = /^hook:/;
  Vue.prototype.$on = function (event, fn) {
    var this$1 = this;

    var vm = this;
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$on(event[i], fn);
      }
    } else {
      (vm._events[event] || (vm._events[event] = [])).push(fn);
      // optimize hook:event cost by using a boolean flag marked at registration
      // instead of a hash lookup
      if (hookRE.test(event)) {
        vm._hasHookEvent = true;
      }
    }
    return vm;
  };

  Vue.prototype.$once = function (event, fn) {
    var vm = this;
    function on() {
      vm.$off(event, on);
      fn.apply(vm, arguments);
    }
    on.fn = fn;
    vm.$on(event, on);
    return vm;
  };

  Vue.prototype.$off = function (event, fn) {
    var this$1 = this;

    var vm = this;
    // all
    if (!arguments.length) {
      vm._events = Object.create(null);
      return vm;
    }
    // array of events
    if (Array.isArray(event)) {
      for (var i = 0, l = event.length; i < l; i++) {
        this$1.$off(event[i], fn);
      }
      return vm;
    }
    // specific event
    var cbs = vm._events[event];
    if (!cbs) {
      return vm;
    }
    if (!fn) {
      vm._events[event] = null;
      return vm;
    }
    if (fn) {
      // specific handler
      var cb;
      var i$1 = cbs.length;
      while (i$1--) {
        cb = cbs[i$1];
        if (cb === fn || cb.fn === fn) {
          cbs.splice(i$1, 1);
          break;
        }
      }
    }
    return vm;
  };

  Vue.prototype.$emit = function (event) {
    var vm = this;
    if (true) {
      var lowerCaseEvent = event.toLowerCase();
      if (lowerCaseEvent !== event && vm._events[lowerCaseEvent]) {
        tip("Event \"" + lowerCaseEvent + "\" is emitted in component " + formatComponentName(vm) + " but the handler is registered for \"" + event + "\". " + "Note that HTML attributes are case-insensitive and you cannot use " + "v-on to listen to camelCase events when using in-DOM templates. " + "You should probably use \"" + hyphenate(event) + "\" instead of \"" + event + "\".");
      }
    }
    var cbs = vm._events[event];
    if (cbs) {
      cbs = cbs.length > 1 ? toArray(cbs) : cbs;
      var args = toArray(arguments, 1);
      for (var i = 0, l = cbs.length; i < l; i++) {
        try {
          cbs[i].apply(vm, args);
        } catch (e) {
          handleError(e, vm, "event handler for \"" + event + "\"");
        }
      }
    }
    return vm;
  };
}

/*  */

/**
 * Runtime helper for resolving raw children VNodes into a slot object.
 */
function resolveSlots(children, context) {
  var slots = {};
  if (!children) {
    return slots;
  }
  for (var i = 0, l = children.length; i < l; i++) {
    var child = children[i];
    var data = child.data;
    // remove slot attribute if the node is resolved as a Vue slot node
    if (data && data.attrs && data.attrs.slot) {
      delete data.attrs.slot;
    }
    // named slots should only be respected if the vnode was rendered in the
    // same context.
    if ((child.context === context || child.fnContext === context) && data && data.slot != null) {
      var name = child.data.slot;
      var slot = slots[name] || (slots[name] = []);
      if (child.tag === 'template') {
        slot.push.apply(slot, child.children);
      } else {
        slot.push(child);
      }
    } else {
      (slots.default || (slots.default = [])).push(child);
    }
  }
  // ignore slots that contains only whitespace
  for (var name$1 in slots) {
    if (slots[name$1].every(isWhitespace)) {
      delete slots[name$1];
    }
  }
  return slots;
}

function isWhitespace(node) {
  return node.isComment && !node.asyncFactory || node.text === ' ';
}

function resolveScopedSlots(fns, // see flow/vnode
res) {
  res = res || {};
  for (var i = 0; i < fns.length; i++) {
    if (Array.isArray(fns[i])) {
      resolveScopedSlots(fns[i], res);
    } else {
      res[fns[i].key] = fns[i].fn;
    }
  }
  return res;
}

/*  */

var activeInstance = null;
var isUpdatingChildComponent = false;

function initLifecycle(vm) {
  var options = vm.$options;

  // locate first non-abstract parent
  var parent = options.parent;
  if (parent && !options.abstract) {
    while (parent.$options.abstract && parent.$parent) {
      parent = parent.$parent;
    }
    parent.$children.push(vm);
  }

  vm.$parent = parent;
  vm.$root = parent ? parent.$root : vm;

  vm.$children = [];
  vm.$refs = {};

  vm._watcher = null;
  vm._inactive = null;
  vm._directInactive = false;
  vm._isMounted = false;
  vm._isDestroyed = false;
  vm._isBeingDestroyed = false;
}

function lifecycleMixin(Vue) {
  Vue.prototype._update = function (vnode, hydrating) {
    var vm = this;
    if (vm._isMounted) {
      callHook(vm, 'beforeUpdate');
    }
    var prevEl = vm.$el;
    var prevVnode = vm._vnode;
    var prevActiveInstance = activeInstance;
    activeInstance = vm;
    vm._vnode = vnode;
    // Vue.prototype.__patch__ is injected in entry points
    // based on the rendering backend used.
    if (!prevVnode) {
      // initial render
      vm.$el = vm.__patch__(vm.$el, vnode, hydrating, false /* removeOnly */
      , vm.$options._parentElm, vm.$options._refElm);
      // no need for the ref nodes after initial patch
      // this prevents keeping a detached DOM tree in memory (#5851)
      vm.$options._parentElm = vm.$options._refElm = null;
    } else {
      // updates
      vm.$el = vm.__patch__(prevVnode, vnode);
    }
    activeInstance = prevActiveInstance;
    // update __vue__ reference
    if (prevEl) {
      prevEl.__vue__ = null;
    }
    if (vm.$el) {
      vm.$el.__vue__ = vm;
    }
    // if parent is an HOC, update its $el as well
    if (vm.$vnode && vm.$parent && vm.$vnode === vm.$parent._vnode) {
      vm.$parent.$el = vm.$el;
    }
    // updated hook is called by the scheduler to ensure that children are
    // updated in a parent's updated hook.
  };

  Vue.prototype.$forceUpdate = function () {
    var vm = this;
    if (vm._watcher) {
      vm._watcher.update();
    }
  };

  Vue.prototype.$destroy = function () {
    var vm = this;
    if (vm._isBeingDestroyed) {
      return;
    }
    callHook(vm, 'beforeDestroy');
    vm._isBeingDestroyed = true;
    // remove self from parent
    var parent = vm.$parent;
    if (parent && !parent._isBeingDestroyed && !vm.$options.abstract) {
      remove(parent.$children, vm);
    }
    // teardown watchers
    if (vm._watcher) {
      vm._watcher.teardown();
    }
    var i = vm._watchers.length;
    while (i--) {
      vm._watchers[i].teardown();
    }
    // remove reference from data ob
    // frozen object may not have observer.
    if (vm._data.__ob__) {
      vm._data.__ob__.vmCount--;
    }
    // call the last hook...
    vm._isDestroyed = true;
    // invoke destroy hooks on current rendered tree
    vm.__patch__(vm._vnode, null);
    // fire destroyed hook
    callHook(vm, 'destroyed');
    // turn off all instance listeners.
    vm.$off();
    // remove __vue__ reference
    if (vm.$el) {
      vm.$el.__vue__ = null;
    }
    // release circular reference (#6759)
    if (vm.$vnode) {
      vm.$vnode.parent = null;
    }
  };
}

function mountComponent(vm, el, hydrating) {
  vm.$el = el;
  if (!vm.$options.render) {
    vm.$options.render = createEmptyVNode;
    if (true) {
      /* istanbul ignore if */
      if (vm.$options.template && vm.$options.template.charAt(0) !== '#' || vm.$options.el || el) {
        warn('You are using the runtime-only build of Vue where the template ' + 'compiler is not available. Either pre-compile the templates into ' + 'render functions, or use the compiler-included build.', vm);
      } else {
        warn('Failed to mount component: template or render function not defined.', vm);
      }
    }
  }
  callHook(vm, 'beforeMount');

  var updateComponent;
  /* istanbul ignore if */
  if ("development" !== 'production' && config.performance && mark) {
    updateComponent = function updateComponent() {
      var name = vm._name;
      var id = vm._uid;
      var startTag = "vue-perf-start:" + id;
      var endTag = "vue-perf-end:" + id;

      mark(startTag);
      var vnode = vm._render();
      mark(endTag);
      measure("vue " + name + " render", startTag, endTag);

      mark(startTag);
      vm._update(vnode, hydrating);
      mark(endTag);
      measure("vue " + name + " patch", startTag, endTag);
    };
  } else {
    updateComponent = function updateComponent() {
      vm._update(vm._render(), hydrating);
    };
  }

  // we set this to vm._watcher inside the watcher's constructor
  // since the watcher's initial patch may call $forceUpdate (e.g. inside child
  // component's mounted hook), which relies on vm._watcher being already defined
  new Watcher(vm, updateComponent, noop, null, true /* isRenderWatcher */);
  hydrating = false;

  // manually mounted instance, call mounted on self
  // mounted is called for render-created child components in its inserted hook
  if (vm.$vnode == null) {
    vm._isMounted = true;
    callHook(vm, 'mounted');
  }
  return vm;
}

function updateChildComponent(vm, propsData, listeners, parentVnode, renderChildren) {
  if (true) {
    isUpdatingChildComponent = true;
  }

  // determine whether component has slot children
  // we need to do this before overwriting $options._renderChildren
  var hasChildren = !!(renderChildren || // has new static slots
  vm.$options._renderChildren || // has old static slots
  parentVnode.data.scopedSlots || // has new scoped slots
  vm.$scopedSlots !== emptyObject // has old scoped slots
  );

  vm.$options._parentVnode = parentVnode;
  vm.$vnode = parentVnode; // update vm's placeholder node without re-render

  if (vm._vnode) {
    // update child tree's parent
    vm._vnode.parent = parentVnode;
  }
  vm.$options._renderChildren = renderChildren;

  // update $attrs and $listeners hash
  // these are also reactive so they may trigger child update if the child
  // used them during render
  vm.$attrs = parentVnode.data && parentVnode.data.attrs || emptyObject;
  vm.$listeners = listeners || emptyObject;

  // update props
  if (propsData && vm.$options.props) {
    observerState.shouldConvert = false;
    var props = vm._props;
    var propKeys = vm.$options._propKeys || [];
    for (var i = 0; i < propKeys.length; i++) {
      var key = propKeys[i];
      props[key] = validateProp(key, vm.$options.props, propsData, vm);
    }
    observerState.shouldConvert = true;
    // keep a copy of raw propsData
    vm.$options.propsData = propsData;
  }

  // update listeners
  if (listeners) {
    var oldListeners = vm.$options._parentListeners;
    vm.$options._parentListeners = listeners;
    updateComponentListeners(vm, listeners, oldListeners);
  }
  // resolve slots + force update if has children
  if (hasChildren) {
    vm.$slots = resolveSlots(renderChildren, parentVnode.context);
    vm.$forceUpdate();
  }

  if (true) {
    isUpdatingChildComponent = false;
  }
}

function isInInactiveTree(vm) {
  while (vm && (vm = vm.$parent)) {
    if (vm._inactive) {
      return true;
    }
  }
  return false;
}

function activateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = false;
    if (isInInactiveTree(vm)) {
      return;
    }
  } else if (vm._directInactive) {
    return;
  }
  if (vm._inactive || vm._inactive === null) {
    vm._inactive = false;
    for (var i = 0; i < vm.$children.length; i++) {
      activateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'activated');
  }
}

function deactivateChildComponent(vm, direct) {
  if (direct) {
    vm._directInactive = true;
    if (isInInactiveTree(vm)) {
      return;
    }
  }
  if (!vm._inactive) {
    vm._inactive = true;
    for (var i = 0; i < vm.$children.length; i++) {
      deactivateChildComponent(vm.$children[i]);
    }
    callHook(vm, 'deactivated');
  }
}

function callHook(vm, hook) {
  var handlers = vm.$options[hook];
  if (handlers) {
    for (var i = 0, j = handlers.length; i < j; i++) {
      try {
        handlers[i].call(vm);
      } catch (e) {
        handleError(e, vm, hook + " hook");
      }
    }
  }
  if (vm._hasHookEvent) {
    vm.$emit('hook:' + hook);
  }
}

/*  */

var MAX_UPDATE_COUNT = 100;

var queue = [];
var activatedChildren = [];
var has = {};
var circular = {};
var waiting = false;
var flushing = false;
var index = 0;

/**
 * Reset the scheduler's state.
 */
function resetSchedulerState() {
  index = queue.length = activatedChildren.length = 0;
  has = {};
  if (true) {
    circular = {};
  }
  waiting = flushing = false;
}

/**
 * Flush both queues and run the watchers.
 */
function flushSchedulerQueue() {
  flushing = true;
  var watcher, id;

  // Sort queue before flush.
  // This ensures that:
  // 1. Components are updated from parent to child. (because parent is always
  //    created before the child)
  // 2. A component's user watchers are run before its render watcher (because
  //    user watchers are created before the render watcher)
  // 3. If a component is destroyed during a parent component's watcher run,
  //    its watchers can be skipped.
  queue.sort(function (a, b) {
    return a.id - b.id;
  });

  // do not cache length because more watchers might be pushed
  // as we run existing watchers
  for (index = 0; index < queue.length; index++) {
    watcher = queue[index];
    id = watcher.id;
    has[id] = null;
    watcher.run();
    // in dev build, check and stop circular updates.
    if ("development" !== 'production' && has[id] != null) {
      circular[id] = (circular[id] || 0) + 1;
      if (circular[id] > MAX_UPDATE_COUNT) {
        warn('You may have an infinite update loop ' + (watcher.user ? "in watcher with expression \"" + watcher.expression + "\"" : "in a component render function."), watcher.vm);
        break;
      }
    }
  }

  // keep copies of post queues before resetting state
  var activatedQueue = activatedChildren.slice();
  var updatedQueue = queue.slice();

  resetSchedulerState();

  // call component updated and activated hooks
  callActivatedHooks(activatedQueue);
  callUpdatedHooks(updatedQueue);

  // devtool hook
  /* istanbul ignore if */
  if (devtools && config.devtools) {
    devtools.emit('flush');
  }
}

function callUpdatedHooks(queue) {
  var i = queue.length;
  while (i--) {
    var watcher = queue[i];
    var vm = watcher.vm;
    if (vm._watcher === watcher && vm._isMounted) {
      callHook(vm, 'updated');
    }
  }
}

/**
 * Queue a kept-alive component that was activated during patch.
 * The queue will be processed after the entire tree has been patched.
 */
function queueActivatedComponent(vm) {
  // setting _inactive to false here so that a render function can
  // rely on checking whether it's in an inactive tree (e.g. router-view)
  vm._inactive = false;
  activatedChildren.push(vm);
}

function callActivatedHooks(queue) {
  for (var i = 0; i < queue.length; i++) {
    queue[i]._inactive = true;
    activateChildComponent(queue[i], true /* true */);
  }
}

/**
 * Push a watcher into the watcher queue.
 * Jobs with duplicate IDs will be skipped unless it's
 * pushed when the queue is being flushed.
 */
function queueWatcher(watcher) {
  var id = watcher.id;
  if (has[id] == null) {
    has[id] = true;
    if (!flushing) {
      queue.push(watcher);
    } else {
      // if already flushing, splice the watcher based on its id
      // if already past its id, it will be run next immediately.
      var i = queue.length - 1;
      while (i > index && queue[i].id > watcher.id) {
        i--;
      }
      queue.splice(i + 1, 0, watcher);
    }
    // queue the flush
    if (!waiting) {
      waiting = true;
      nextTick(flushSchedulerQueue);
    }
  }
}

/*  */

var uid$2 = 0;

/**
 * A watcher parses an expression, collects dependencies,
 * and fires callback when the expression value changes.
 * This is used for both the $watch() api and directives.
 */
var Watcher = function Watcher(vm, expOrFn, cb, options, isRenderWatcher) {
  this.vm = vm;
  if (isRenderWatcher) {
    vm._watcher = this;
  }
  vm._watchers.push(this);
  // options
  if (options) {
    this.deep = !!options.deep;
    this.user = !!options.user;
    this.lazy = !!options.lazy;
    this.sync = !!options.sync;
  } else {
    this.deep = this.user = this.lazy = this.sync = false;
  }
  this.cb = cb;
  this.id = ++uid$2; // uid for batching
  this.active = true;
  this.dirty = this.lazy; // for lazy watchers
  this.deps = [];
  this.newDeps = [];
  this.depIds = new _Set();
  this.newDepIds = new _Set();
  this.expression =  true ? expOrFn.toString() : '';
  // parse expression for getter
  if (typeof expOrFn === 'function') {
    this.getter = expOrFn;
  } else {
    this.getter = parsePath(expOrFn);
    if (!this.getter) {
      this.getter = function () {};
      "development" !== 'production' && warn("Failed watching path: \"" + expOrFn + "\" " + 'Watcher only accepts simple dot-delimited paths. ' + 'For full control, use a function instead.', vm);
    }
  }
  this.value = this.lazy ? undefined : this.get();
};

/**
 * Evaluate the getter, and re-collect dependencies.
 */
Watcher.prototype.get = function get() {
  pushTarget(this);
  var value;
  var vm = this.vm;
  try {
    value = this.getter.call(vm, vm);
  } catch (e) {
    if (this.user) {
      handleError(e, vm, "getter for watcher \"" + this.expression + "\"");
    } else {
      throw e;
    }
  } finally {
    // "touch" every property so they are all tracked as
    // dependencies for deep watching
    if (this.deep) {
      traverse(value);
    }
    popTarget();
    this.cleanupDeps();
  }
  return value;
};

/**
 * Add a dependency to this directive.
 */
Watcher.prototype.addDep = function addDep(dep) {
  var id = dep.id;
  if (!this.newDepIds.has(id)) {
    this.newDepIds.add(id);
    this.newDeps.push(dep);
    if (!this.depIds.has(id)) {
      dep.addSub(this);
    }
  }
};

/**
 * Clean up for dependency collection.
 */
Watcher.prototype.cleanupDeps = function cleanupDeps() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    var dep = this$1.deps[i];
    if (!this$1.newDepIds.has(dep.id)) {
      dep.removeSub(this$1);
    }
  }
  var tmp = this.depIds;
  this.depIds = this.newDepIds;
  this.newDepIds = tmp;
  this.newDepIds.clear();
  tmp = this.deps;
  this.deps = this.newDeps;
  this.newDeps = tmp;
  this.newDeps.length = 0;
};

/**
 * Subscriber interface.
 * Will be called when a dependency changes.
 */
Watcher.prototype.update = function update() {
  /* istanbul ignore else */
  if (this.lazy) {
    this.dirty = true;
  } else if (this.sync) {
    this.run();
  } else {
    queueWatcher(this);
  }
};

/**
 * Scheduler job interface.
 * Will be called by the scheduler.
 */
Watcher.prototype.run = function run() {
  if (this.active) {
    var value = this.get();
    if (value !== this.value ||
    // Deep watchers and watchers on Object/Arrays should fire even
    // when the value is the same, because the value may
    // have mutated.
    isObject(value) || this.deep) {
      // set new value
      var oldValue = this.value;
      this.value = value;
      if (this.user) {
        try {
          this.cb.call(this.vm, value, oldValue);
        } catch (e) {
          handleError(e, this.vm, "callback for watcher \"" + this.expression + "\"");
        }
      } else {
        this.cb.call(this.vm, value, oldValue);
      }
    }
  }
};

/**
 * Evaluate the value of the watcher.
 * This only gets called for lazy watchers.
 */
Watcher.prototype.evaluate = function evaluate() {
  this.value = this.get();
  this.dirty = false;
};

/**
 * Depend on all deps collected by this watcher.
 */
Watcher.prototype.depend = function depend() {
  var this$1 = this;

  var i = this.deps.length;
  while (i--) {
    this$1.deps[i].depend();
  }
};

/**
 * Remove self from all dependencies' subscriber list.
 */
Watcher.prototype.teardown = function teardown() {
  var this$1 = this;

  if (this.active) {
    // remove self from vm's watcher list
    // this is a somewhat expensive operation so we skip it
    // if the vm is being destroyed.
    if (!this.vm._isBeingDestroyed) {
      remove(this.vm._watchers, this);
    }
    var i = this.deps.length;
    while (i--) {
      this$1.deps[i].removeSub(this$1);
    }
    this.active = false;
  }
};

/*  */

var sharedPropertyDefinition = {
  enumerable: true,
  configurable: true,
  get: noop,
  set: noop
};

function proxy(target, sourceKey, key) {
  sharedPropertyDefinition.get = function proxyGetter() {
    return this[sourceKey][key];
  };
  sharedPropertyDefinition.set = function proxySetter(val) {
    this[sourceKey][key] = val;
  };
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function initState(vm) {
  vm._watchers = [];
  var opts = vm.$options;
  if (opts.props) {
    initProps(vm, opts.props);
  }
  if (opts.methods) {
    initMethods(vm, opts.methods);
  }
  if (opts.data) {
    initData(vm);
  } else {
    observe(vm._data = {}, true /* asRootData */);
  }
  if (opts.computed) {
    initComputed(vm, opts.computed);
  }
  if (opts.watch && opts.watch !== nativeWatch) {
    initWatch(vm, opts.watch);
  }
}

function initProps(vm, propsOptions) {
  var propsData = vm.$options.propsData || {};
  var props = vm._props = {};
  // cache prop keys so that future props updates can iterate using Array
  // instead of dynamic object key enumeration.
  var keys = vm.$options._propKeys = [];
  var isRoot = !vm.$parent;
  // root instance props should be converted
  observerState.shouldConvert = isRoot;
  var loop = function loop(key) {
    keys.push(key);
    var value = validateProp(key, propsOptions, propsData, vm);
    /* istanbul ignore else */
    if (true) {
      var hyphenatedKey = hyphenate(key);
      if (isReservedAttribute(hyphenatedKey) || config.isReservedAttr(hyphenatedKey)) {
        warn("\"" + hyphenatedKey + "\" is a reserved attribute and cannot be used as component prop.", vm);
      }
      defineReactive(props, key, value, function () {
        if (vm.$parent && !isUpdatingChildComponent) {
          warn("Avoid mutating a prop directly since the value will be " + "overwritten whenever the parent component re-renders. " + "Instead, use a data or computed property based on the prop's " + "value. Prop being mutated: \"" + key + "\"", vm);
        }
      });
    } else {
      defineReactive(props, key, value);
    }
    // static props are already proxied on the component's prototype
    // during Vue.extend(). We only need to proxy props defined at
    // instantiation here.
    if (!(key in vm)) {
      proxy(vm, "_props", key);
    }
  };

  for (var key in propsOptions) {
    loop(key);
  }observerState.shouldConvert = true;
}

function initData(vm) {
  var data = vm.$options.data;
  data = vm._data = typeof data === 'function' ? getData(data, vm) : data || {};
  if (!isPlainObject(data)) {
    data = {};
    "development" !== 'production' && warn('data functions should return an object:\n' + 'https://vuejs.org/v2/guide/components.html#data-Must-Be-a-Function', vm);
  }
  // proxy data on instance
  var keys = Object.keys(data);
  var props = vm.$options.props;
  var methods = vm.$options.methods;
  var i = keys.length;
  while (i--) {
    var key = keys[i];
    if (true) {
      if (methods && hasOwn(methods, key)) {
        warn("Method \"" + key + "\" has already been defined as a data property.", vm);
      }
    }
    if (props && hasOwn(props, key)) {
      "development" !== 'production' && warn("The data property \"" + key + "\" is already declared as a prop. " + "Use prop default value instead.", vm);
    } else if (!isReserved(key)) {
      proxy(vm, "_data", key);
    }
  }
  // observe data
  observe(data, true /* asRootData */);
}

function getData(data, vm) {
  try {
    return data.call(vm, vm);
  } catch (e) {
    handleError(e, vm, "data()");
    return {};
  }
}

var computedWatcherOptions = { lazy: true };

function initComputed(vm, computed) {
  var watchers = vm._computedWatchers = Object.create(null);
  // computed properties are just getters during SSR
  var isSSR = isServerRendering();

  for (var key in computed) {
    var userDef = computed[key];
    var getter = typeof userDef === 'function' ? userDef : userDef.get;
    if ("development" !== 'production' && getter == null) {
      warn("Getter is missing for computed property \"" + key + "\".", vm);
    }

    if (!isSSR) {
      // create internal watcher for the computed property.
      watchers[key] = new Watcher(vm, getter || noop, noop, computedWatcherOptions);
    }

    // component-defined computed properties are already defined on the
    // component prototype. We only need to define computed properties defined
    // at instantiation here.
    if (!(key in vm)) {
      defineComputed(vm, key, userDef);
    } else if (true) {
      if (key in vm.$data) {
        warn("The computed property \"" + key + "\" is already defined in data.", vm);
      } else if (vm.$options.props && key in vm.$options.props) {
        warn("The computed property \"" + key + "\" is already defined as a prop.", vm);
      }
    }
  }
}

function defineComputed(target, key, userDef) {
  var shouldCache = !isServerRendering();
  if (typeof userDef === 'function') {
    sharedPropertyDefinition.get = shouldCache ? createComputedGetter(key) : userDef;
    sharedPropertyDefinition.set = noop;
  } else {
    sharedPropertyDefinition.get = userDef.get ? shouldCache && userDef.cache !== false ? createComputedGetter(key) : userDef.get : noop;
    sharedPropertyDefinition.set = userDef.set ? userDef.set : noop;
  }
  if ("development" !== 'production' && sharedPropertyDefinition.set === noop) {
    sharedPropertyDefinition.set = function () {
      warn("Computed property \"" + key + "\" was assigned to but it has no setter.", this);
    };
  }
  Object.defineProperty(target, key, sharedPropertyDefinition);
}

function createComputedGetter(key) {
  return function computedGetter() {
    var watcher = this._computedWatchers && this._computedWatchers[key];
    if (watcher) {
      if (watcher.dirty) {
        watcher.evaluate();
      }
      if (Dep.target) {
        watcher.depend();
      }
      return watcher.value;
    }
  };
}

function initMethods(vm, methods) {
  var props = vm.$options.props;
  for (var key in methods) {
    if (true) {
      if (methods[key] == null) {
        warn("Method \"" + key + "\" has an undefined value in the component definition. " + "Did you reference the function correctly?", vm);
      }
      if (props && hasOwn(props, key)) {
        warn("Method \"" + key + "\" has already been defined as a prop.", vm);
      }
      if (key in vm && isReserved(key)) {
        warn("Method \"" + key + "\" conflicts with an existing Vue instance method. " + "Avoid defining component methods that start with _ or $.");
      }
    }
    vm[key] = methods[key] == null ? noop : bind(methods[key], vm);
  }
}

function initWatch(vm, watch) {
  for (var key in watch) {
    var handler = watch[key];
    if (Array.isArray(handler)) {
      for (var i = 0; i < handler.length; i++) {
        createWatcher(vm, key, handler[i]);
      }
    } else {
      createWatcher(vm, key, handler);
    }
  }
}

function createWatcher(vm, keyOrFn, handler, options) {
  if (isPlainObject(handler)) {
    options = handler;
    handler = handler.handler;
  }
  if (typeof handler === 'string') {
    handler = vm[handler];
  }
  return vm.$watch(keyOrFn, handler, options);
}

function stateMixin(Vue) {
  // flow somehow has problems with directly declared definition object
  // when using Object.defineProperty, so we have to procedurally build up
  // the object here.
  var dataDef = {};
  dataDef.get = function () {
    return this._data;
  };
  var propsDef = {};
  propsDef.get = function () {
    return this._props;
  };
  if (true) {
    dataDef.set = function (newData) {
      warn('Avoid replacing instance root $data. ' + 'Use nested data properties instead.', this);
    };
    propsDef.set = function () {
      warn("$props is readonly.", this);
    };
  }
  Object.defineProperty(Vue.prototype, '$data', dataDef);
  Object.defineProperty(Vue.prototype, '$props', propsDef);

  Vue.prototype.$set = set;
  Vue.prototype.$delete = del;

  Vue.prototype.$watch = function (expOrFn, cb, options) {
    var vm = this;
    if (isPlainObject(cb)) {
      return createWatcher(vm, expOrFn, cb, options);
    }
    options = options || {};
    options.user = true;
    var watcher = new Watcher(vm, expOrFn, cb, options);
    if (options.immediate) {
      cb.call(vm, watcher.value);
    }
    return function unwatchFn() {
      watcher.teardown();
    };
  };
}

/*  */

function initProvide(vm) {
  var provide = vm.$options.provide;
  if (provide) {
    vm._provided = typeof provide === 'function' ? provide.call(vm) : provide;
  }
}

function initInjections(vm) {
  var result = resolveInject(vm.$options.inject, vm);
  if (result) {
    observerState.shouldConvert = false;
    Object.keys(result).forEach(function (key) {
      /* istanbul ignore else */
      if (true) {
        defineReactive(vm, key, result[key], function () {
          warn("Avoid mutating an injected value directly since the changes will be " + "overwritten whenever the provided component re-renders. " + "injection being mutated: \"" + key + "\"", vm);
        });
      } else {
        defineReactive(vm, key, result[key]);
      }
    });
    observerState.shouldConvert = true;
  }
}

function resolveInject(inject, vm) {
  if (inject) {
    // inject is :any because flow is not smart enough to figure out cached
    var result = Object.create(null);
    var keys = hasSymbol ? Reflect.ownKeys(inject).filter(function (key) {
      /* istanbul ignore next */
      return Object.getOwnPropertyDescriptor(inject, key).enumerable;
    }) : Object.keys(inject);

    for (var i = 0; i < keys.length; i++) {
      var key = keys[i];
      var provideKey = inject[key].from;
      var source = vm;
      while (source) {
        if (source._provided && provideKey in source._provided) {
          result[key] = source._provided[provideKey];
          break;
        }
        source = source.$parent;
      }
      if (!source) {
        if ('default' in inject[key]) {
          var provideDefault = inject[key].default;
          result[key] = typeof provideDefault === 'function' ? provideDefault.call(vm) : provideDefault;
        } else if (true) {
          warn("Injection \"" + key + "\" not found", vm);
        }
      }
    }
    return result;
  }
}

/*  */

/**
 * Runtime helper for rendering v-for lists.
 */
function renderList(val, render) {
  var ret, i, l, keys, key;
  if (Array.isArray(val) || typeof val === 'string') {
    ret = new Array(val.length);
    for (i = 0, l = val.length; i < l; i++) {
      ret[i] = render(val[i], i);
    }
  } else if (typeof val === 'number') {
    ret = new Array(val);
    for (i = 0; i < val; i++) {
      ret[i] = render(i + 1, i);
    }
  } else if (isObject(val)) {
    keys = Object.keys(val);
    ret = new Array(keys.length);
    for (i = 0, l = keys.length; i < l; i++) {
      key = keys[i];
      ret[i] = render(val[key], key, i);
    }
  }
  if (isDef(ret)) {
    ret._isVList = true;
  }
  return ret;
}

/*  */

/**
 * Runtime helper for rendering <slot>
 */
function renderSlot(name, fallback, props, bindObject) {
  var scopedSlotFn = this.$scopedSlots[name];
  var nodes;
  if (scopedSlotFn) {
    // scoped slot
    props = props || {};
    if (bindObject) {
      if ("development" !== 'production' && !isObject(bindObject)) {
        warn('slot v-bind without argument expects an Object', this);
      }
      props = extend(extend({}, bindObject), props);
    }
    nodes = scopedSlotFn(props) || fallback;
  } else {
    var slotNodes = this.$slots[name];
    // warn duplicate slot usage
    if (slotNodes) {
      if ("development" !== 'production' && slotNodes._rendered) {
        warn("Duplicate presence of slot \"" + name + "\" found in the same render tree " + "- this will likely cause render errors.", this);
      }
      slotNodes._rendered = true;
    }
    nodes = slotNodes || fallback;
  }

  var target = props && props.slot;
  if (target) {
    return this.$createElement('template', { slot: target }, nodes);
  } else {
    return nodes;
  }
}

/*  */

/**
 * Runtime helper for resolving filters
 */
function resolveFilter(id) {
  return resolveAsset(this.$options, 'filters', id, true) || identity;
}

/*  */

/**
 * Runtime helper for checking keyCodes from config.
 * exposed as Vue.prototype._k
 * passing in eventKeyName as last argument separately for backwards compat
 */
function checkKeyCodes(eventKeyCode, key, builtInAlias, eventKeyName) {
  var keyCodes = config.keyCodes[key] || builtInAlias;
  if (keyCodes) {
    if (Array.isArray(keyCodes)) {
      return keyCodes.indexOf(eventKeyCode) === -1;
    } else {
      return keyCodes !== eventKeyCode;
    }
  } else if (eventKeyName) {
    return hyphenate(eventKeyName) !== key;
  }
}

/*  */

/**
 * Runtime helper for merging v-bind="object" into a VNode's data.
 */
function bindObjectProps(data, tag, value, asProp, isSync) {
  if (value) {
    if (!isObject(value)) {
      "development" !== 'production' && warn('v-bind without argument expects an Object or Array value', this);
    } else {
      if (Array.isArray(value)) {
        value = toObject(value);
      }
      var hash;
      var loop = function loop(key) {
        if (key === 'class' || key === 'style' || isReservedAttribute(key)) {
          hash = data;
        } else {
          var type = data.attrs && data.attrs.type;
          hash = asProp || config.mustUseProp(tag, type, key) ? data.domProps || (data.domProps = {}) : data.attrs || (data.attrs = {});
        }
        if (!(key in hash)) {
          hash[key] = value[key];

          if (isSync) {
            var on = data.on || (data.on = {});
            on["update:" + key] = function ($event) {
              value[key] = $event;
            };
          }
        }
      };

      for (var key in value) {
        loop(key);
      }
    }
  }
  return data;
}

/*  */

/**
 * Runtime helper for rendering static trees.
 */
function renderStatic(index, isInFor, isOnce) {
  // render fns generated by compiler < 2.5.4 does not provide v-once
  // information to runtime so be conservative
  var isOldVersion = arguments.length < 3;
  // if a static tree is generated by v-once, it is cached on the instance;
  // otherwise it is purely static and can be cached on the shared options
  // across all instances.
  var renderFns = this.$options.staticRenderFns;
  var cached = isOldVersion || isOnce ? this._staticTrees || (this._staticTrees = []) : renderFns.cached || (renderFns.cached = []);
  var tree = cached[index];
  // if has already-rendered static tree and not inside v-for,
  // we can reuse the same tree by doing a shallow clone.
  if (tree && !isInFor) {
    return Array.isArray(tree) ? cloneVNodes(tree) : cloneVNode(tree);
  }
  // otherwise, render a fresh tree.
  tree = cached[index] = renderFns[index].call(this._renderProxy, null, this);
  markStatic(tree, "__static__" + index, false);
  return tree;
}

/**
 * Runtime helper for v-once.
 * Effectively it means marking the node as static with a unique key.
 */
function markOnce(tree, index, key) {
  markStatic(tree, "__once__" + index + (key ? "_" + key : ""), true);
  return tree;
}

function markStatic(tree, key, isOnce) {
  if (Array.isArray(tree)) {
    for (var i = 0; i < tree.length; i++) {
      if (tree[i] && typeof tree[i] !== 'string') {
        markStaticNode(tree[i], key + "_" + i, isOnce);
      }
    }
  } else {
    markStaticNode(tree, key, isOnce);
  }
}

function markStaticNode(node, key, isOnce) {
  node.isStatic = true;
  node.key = key;
  node.isOnce = isOnce;
}

/*  */

function bindObjectListeners(data, value) {
  if (value) {
    if (!isPlainObject(value)) {
      "development" !== 'production' && warn('v-on without argument expects an Object value', this);
    } else {
      var on = data.on = data.on ? extend({}, data.on) : {};
      for (var key in value) {
        var existing = on[key];
        var ours = value[key];
        on[key] = existing ? [].concat(existing, ours) : ours;
      }
    }
  }
  return data;
}

/*  */

function installRenderHelpers(target) {
  target._o = markOnce;
  target._n = toNumber;
  target._s = toString;
  target._l = renderList;
  target._t = renderSlot;
  target._q = looseEqual;
  target._i = looseIndexOf;
  target._m = renderStatic;
  target._f = resolveFilter;
  target._k = checkKeyCodes;
  target._b = bindObjectProps;
  target._v = createTextVNode;
  target._e = createEmptyVNode;
  target._u = resolveScopedSlots;
  target._g = bindObjectListeners;
}

/*  */

function FunctionalRenderContext(data, props, children, parent, Ctor) {
  var options = Ctor.options;
  this.data = data;
  this.props = props;
  this.children = children;
  this.parent = parent;
  this.listeners = data.on || emptyObject;
  this.injections = resolveInject(options.inject, parent);
  this.slots = function () {
    return resolveSlots(children, parent);
  };

  // ensure the createElement function in functional components
  // gets a unique context - this is necessary for correct named slot check
  var contextVm = Object.create(parent);
  var isCompiled = isTrue(options._compiled);
  var needNormalization = !isCompiled;

  // support for compiled functional template
  if (isCompiled) {
    // exposing $options for renderStatic()
    this.$options = options;
    // pre-resolve slots for renderSlot()
    this.$slots = this.slots();
    this.$scopedSlots = data.scopedSlots || emptyObject;
  }

  if (options._scopeId) {
    this._c = function (a, b, c, d) {
      var vnode = createElement(contextVm, a, b, c, d, needNormalization);
      if (vnode) {
        vnode.fnScopeId = options._scopeId;
        vnode.fnContext = parent;
      }
      return vnode;
    };
  } else {
    this._c = function (a, b, c, d) {
      return createElement(contextVm, a, b, c, d, needNormalization);
    };
  }
}

installRenderHelpers(FunctionalRenderContext.prototype);

function createFunctionalComponent(Ctor, propsData, data, contextVm, children) {
  var options = Ctor.options;
  var props = {};
  var propOptions = options.props;
  if (isDef(propOptions)) {
    for (var key in propOptions) {
      props[key] = validateProp(key, propOptions, propsData || emptyObject);
    }
  } else {
    if (isDef(data.attrs)) {
      mergeProps(props, data.attrs);
    }
    if (isDef(data.props)) {
      mergeProps(props, data.props);
    }
  }

  var renderContext = new FunctionalRenderContext(data, props, children, contextVm, Ctor);

  var vnode = options.render.call(null, renderContext._c, renderContext);

  if (vnode instanceof VNode) {
    vnode.fnContext = contextVm;
    vnode.fnOptions = options;
    if (data.slot) {
      (vnode.data || (vnode.data = {})).slot = data.slot;
    }
  }

  return vnode;
}

function mergeProps(to, from) {
  for (var key in from) {
    to[camelize(key)] = from[key];
  }
}

/*  */

// hooks to be invoked on component VNodes during patch
var componentVNodeHooks = {
  init: function init(vnode, hydrating, parentElm, refElm) {
    if (!vnode.componentInstance || vnode.componentInstance._isDestroyed) {
      var child = vnode.componentInstance = createComponentInstanceForVnode(vnode, activeInstance, parentElm, refElm);
      child.$mount(hydrating ? vnode.elm : undefined, hydrating);
    } else if (vnode.data.keepAlive) {
      // kept-alive components, treat as a patch
      var mountedNode = vnode; // work around flow
      componentVNodeHooks.prepatch(mountedNode, mountedNode);
    }
  },

  prepatch: function prepatch(oldVnode, vnode) {
    var options = vnode.componentOptions;
    var child = vnode.componentInstance = oldVnode.componentInstance;
    updateChildComponent(child, options.propsData, // updated props
    options.listeners, // updated listeners
    vnode, // new parent vnode
    options.children // new children
    );
  },

  insert: function insert(vnode) {
    var context = vnode.context;
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isMounted) {
      componentInstance._isMounted = true;
      callHook(componentInstance, 'mounted');
    }
    if (vnode.data.keepAlive) {
      if (context._isMounted) {
        // vue-router#1212
        // During updates, a kept-alive component's child components may
        // change, so directly walking the tree here may call activated hooks
        // on incorrect children. Instead we push them into a queue which will
        // be processed after the whole patch process ended.
        queueActivatedComponent(componentInstance);
      } else {
        activateChildComponent(componentInstance, true /* direct */);
      }
    }
  },

  destroy: function destroy(vnode) {
    var componentInstance = vnode.componentInstance;
    if (!componentInstance._isDestroyed) {
      if (!vnode.data.keepAlive) {
        componentInstance.$destroy();
      } else {
        deactivateChildComponent(componentInstance, true /* direct */);
      }
    }
  }
};

var hooksToMerge = Object.keys(componentVNodeHooks);

function createComponent(Ctor, data, context, children, tag) {
  if (isUndef(Ctor)) {
    return;
  }

  var baseCtor = context.$options._base;

  // plain options object: turn it into a constructor
  if (isObject(Ctor)) {
    Ctor = baseCtor.extend(Ctor);
  }

  // if at this stage it's not a constructor or an async component factory,
  // reject.
  if (typeof Ctor !== 'function') {
    if (true) {
      warn("Invalid Component definition: " + String(Ctor), context);
    }
    return;
  }

  // async component
  var asyncFactory;
  if (isUndef(Ctor.cid)) {
    asyncFactory = Ctor;
    Ctor = resolveAsyncComponent(asyncFactory, baseCtor, context);
    if (Ctor === undefined) {
      // return a placeholder node for async component, which is rendered
      // as a comment node but preserves all the raw information for the node.
      // the information will be used for async server-rendering and hydration.
      return createAsyncPlaceholder(asyncFactory, data, context, children, tag);
    }
  }

  data = data || {};

  // resolve constructor options in case global mixins are applied after
  // component constructor creation
  resolveConstructorOptions(Ctor);

  // transform component v-model data into props & events
  if (isDef(data.model)) {
    transformModel(Ctor.options, data);
  }

  // extract props
  var propsData = extractPropsFromVNodeData(data, Ctor, tag);

  // functional component
  if (isTrue(Ctor.options.functional)) {
    return createFunctionalComponent(Ctor, propsData, data, context, children);
  }

  // extract listeners, since these needs to be treated as
  // child component listeners instead of DOM listeners
  var listeners = data.on;
  // replace with listeners with .native modifier
  // so it gets processed during parent component patch.
  data.on = data.nativeOn;

  if (isTrue(Ctor.options.abstract)) {
    // abstract components do not keep anything
    // other than props & listeners & slot

    // work around flow
    var slot = data.slot;
    data = {};
    if (slot) {
      data.slot = slot;
    }
  }

  // merge component management hooks onto the placeholder node
  mergeHooks(data);

  // return a placeholder vnode
  var name = Ctor.options.name || tag;
  var vnode = new VNode("vue-component-" + Ctor.cid + (name ? "-" + name : ''), data, undefined, undefined, undefined, context, { Ctor: Ctor, propsData: propsData, listeners: listeners, tag: tag, children: children }, asyncFactory);
  return vnode;
}

function createComponentInstanceForVnode(vnode, // we know it's MountedComponentVNode but flow doesn't
parent, // activeInstance in lifecycle state
parentElm, refElm) {
  var vnodeComponentOptions = vnode.componentOptions;
  var options = {
    _isComponent: true,
    parent: parent,
    propsData: vnodeComponentOptions.propsData,
    _componentTag: vnodeComponentOptions.tag,
    _parentVnode: vnode,
    _parentListeners: vnodeComponentOptions.listeners,
    _renderChildren: vnodeComponentOptions.children,
    _parentElm: parentElm || null,
    _refElm: refElm || null
  };
  // check inline-template render functions
  var inlineTemplate = vnode.data.inlineTemplate;
  if (isDef(inlineTemplate)) {
    options.render = inlineTemplate.render;
    options.staticRenderFns = inlineTemplate.staticRenderFns;
  }
  return new vnodeComponentOptions.Ctor(options);
}

function mergeHooks(data) {
  if (!data.hook) {
    data.hook = {};
  }
  for (var i = 0; i < hooksToMerge.length; i++) {
    var key = hooksToMerge[i];
    var fromParent = data.hook[key];
    var ours = componentVNodeHooks[key];
    data.hook[key] = fromParent ? mergeHook$1(ours, fromParent) : ours;
  }
}

function mergeHook$1(one, two) {
  return function (a, b, c, d) {
    one(a, b, c, d);
    two(a, b, c, d);
  };
}

// transform component v-model info (value and callback) into
// prop and event handler respectively.
function transformModel(options, data) {
  var prop = options.model && options.model.prop || 'value';
  var event = options.model && options.model.event || 'input';(data.props || (data.props = {}))[prop] = data.model.value;
  var on = data.on || (data.on = {});
  if (isDef(on[event])) {
    on[event] = [data.model.callback].concat(on[event]);
  } else {
    on[event] = data.model.callback;
  }
}

/*  */

var SIMPLE_NORMALIZE = 1;
var ALWAYS_NORMALIZE = 2;

// wrapper function for providing a more flexible interface
// without getting yelled at by flow
function createElement(context, tag, data, children, normalizationType, alwaysNormalize) {
  if (Array.isArray(data) || isPrimitive(data)) {
    normalizationType = children;
    children = data;
    data = undefined;
  }
  if (isTrue(alwaysNormalize)) {
    normalizationType = ALWAYS_NORMALIZE;
  }
  return _createElement(context, tag, data, children, normalizationType);
}

function _createElement(context, tag, data, children, normalizationType) {
  if (isDef(data) && isDef(data.__ob__)) {
    "development" !== 'production' && warn("Avoid using observed data object as vnode data: " + JSON.stringify(data) + "\n" + 'Always create fresh vnode data objects in each render!', context);
    return createEmptyVNode();
  }
  // object syntax in v-bind
  if (isDef(data) && isDef(data.is)) {
    tag = data.is;
  }
  if (!tag) {
    // in case of component :is set to falsy value
    return createEmptyVNode();
  }
  // warn against non-primitive key
  if ("development" !== 'production' && isDef(data) && isDef(data.key) && !isPrimitive(data.key)) {
    warn('Avoid using non-primitive value as key, ' + 'use string/number value instead.', context);
  }
  // support single function children as default scoped slot
  if (Array.isArray(children) && typeof children[0] === 'function') {
    data = data || {};
    data.scopedSlots = { default: children[0] };
    children.length = 0;
  }
  if (normalizationType === ALWAYS_NORMALIZE) {
    children = normalizeChildren(children);
  } else if (normalizationType === SIMPLE_NORMALIZE) {
    children = simpleNormalizeChildren(children);
  }
  var vnode, ns;
  if (typeof tag === 'string') {
    var Ctor;
    ns = context.$vnode && context.$vnode.ns || config.getTagNamespace(tag);
    if (config.isReservedTag(tag)) {
      // platform built-in elements
      vnode = new VNode(config.parsePlatformTagName(tag), data, children, undefined, undefined, context);
    } else if (isDef(Ctor = resolveAsset(context.$options, 'components', tag))) {
      // component
      vnode = createComponent(Ctor, data, context, children, tag);
    } else {
      // unknown or unlisted namespaced elements
      // check at runtime because it may get assigned a namespace when its
      // parent normalizes children
      vnode = new VNode(tag, data, children, undefined, undefined, context);
    }
  } else {
    // direct component options / constructor
    vnode = createComponent(tag, data, context, children);
  }
  if (isDef(vnode)) {
    if (ns) {
      applyNS(vnode, ns);
    }
    return vnode;
  } else {
    return createEmptyVNode();
  }
}

function applyNS(vnode, ns, force) {
  vnode.ns = ns;
  if (vnode.tag === 'foreignObject') {
    // use default namespace inside foreignObject
    ns = undefined;
    force = true;
  }
  if (isDef(vnode.children)) {
    for (var i = 0, l = vnode.children.length; i < l; i++) {
      var child = vnode.children[i];
      if (isDef(child.tag) && (isUndef(child.ns) || isTrue(force))) {
        applyNS(child, ns, force);
      }
    }
  }
}

/*  */

function initRender(vm) {
  vm._vnode = null; // the root of the child tree
  vm._staticTrees = null; // v-once cached trees
  var options = vm.$options;
  var parentVnode = vm.$vnode = options._parentVnode; // the placeholder node in parent tree
  var renderContext = parentVnode && parentVnode.context;
  vm.$slots = resolveSlots(options._renderChildren, renderContext);
  vm.$scopedSlots = emptyObject;
  // bind the createElement fn to this instance
  // so that we get proper render context inside it.
  // args order: tag, data, children, normalizationType, alwaysNormalize
  // internal version is used by render functions compiled from templates
  vm._c = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, false);
  };
  // normalization is always applied for the public version, used in
  // user-written render functions.
  vm.$createElement = function (a, b, c, d) {
    return createElement(vm, a, b, c, d, true);
  };

  // $attrs & $listeners are exposed for easier HOC creation.
  // they need to be reactive so that HOCs using them are always updated
  var parentData = parentVnode && parentVnode.data;

  /* istanbul ignore else */
  if (true) {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, function () {
      !isUpdatingChildComponent && warn("$attrs is readonly.", vm);
    }, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, function () {
      !isUpdatingChildComponent && warn("$listeners is readonly.", vm);
    }, true);
  } else {
    defineReactive(vm, '$attrs', parentData && parentData.attrs || emptyObject, null, true);
    defineReactive(vm, '$listeners', options._parentListeners || emptyObject, null, true);
  }
}

function renderMixin(Vue) {
  // install runtime convenience helpers
  installRenderHelpers(Vue.prototype);

  Vue.prototype.$nextTick = function (fn) {
    return nextTick(fn, this);
  };

  Vue.prototype._render = function () {
    var vm = this;
    var ref = vm.$options;
    var render = ref.render;
    var _parentVnode = ref._parentVnode;

    if (vm._isMounted) {
      // if the parent didn't update, the slot nodes will be the ones from
      // last render. They need to be cloned to ensure "freshness" for this render.
      for (var key in vm.$slots) {
        var slot = vm.$slots[key];
        // _rendered is a flag added by renderSlot, but may not be present
        // if the slot is passed from manually written render functions
        if (slot._rendered || slot[0] && slot[0].elm) {
          vm.$slots[key] = cloneVNodes(slot, true /* deep */);
        }
      }
    }

    vm.$scopedSlots = _parentVnode && _parentVnode.data.scopedSlots || emptyObject;

    // set parent vnode. this allows render functions to have access
    // to the data on the placeholder node.
    vm.$vnode = _parentVnode;
    // render self
    var vnode;
    try {
      vnode = render.call(vm._renderProxy, vm.$createElement);
    } catch (e) {
      handleError(e, vm, "render");
      // return error render result,
      // or previous vnode to prevent render error causing blank component
      /* istanbul ignore else */
      if (true) {
        if (vm.$options.renderError) {
          try {
            vnode = vm.$options.renderError.call(vm._renderProxy, vm.$createElement, e);
          } catch (e) {
            handleError(e, vm, "renderError");
            vnode = vm._vnode;
          }
        } else {
          vnode = vm._vnode;
        }
      } else {
        vnode = vm._vnode;
      }
    }
    // return empty vnode in case the render function errored out
    if (!(vnode instanceof VNode)) {
      if ("development" !== 'production' && Array.isArray(vnode)) {
        warn('Multiple root nodes returned from render function. Render function ' + 'should return a single root node.', vm);
      }
      vnode = createEmptyVNode();
    }
    // set parent
    vnode.parent = _parentVnode;
    return vnode;
  };
}

/*  */

var uid$1 = 0;

function initMixin(Vue) {
  Vue.prototype._init = function (options) {
    var vm = this;
    // a uid
    vm._uid = uid$1++;

    var startTag, endTag;
    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      startTag = "vue-perf-start:" + vm._uid;
      endTag = "vue-perf-end:" + vm._uid;
      mark(startTag);
    }

    // a flag to avoid this being observed
    vm._isVue = true;
    // merge options
    if (options && options._isComponent) {
      // optimize internal component instantiation
      // since dynamic options merging is pretty slow, and none of the
      // internal component options needs special treatment.
      initInternalComponent(vm, options);
    } else {
      vm.$options = mergeOptions(resolveConstructorOptions(vm.constructor), options || {}, vm);
    }
    /* istanbul ignore else */
    if (true) {
      initProxy(vm);
    } else {
      vm._renderProxy = vm;
    }
    // expose real self
    vm._self = vm;
    initLifecycle(vm);
    initEvents(vm);
    initRender(vm);
    callHook(vm, 'beforeCreate');
    initInjections(vm); // resolve injections before data/props
    initState(vm);
    initProvide(vm); // resolve provide after data/props
    callHook(vm, 'created');

    /* istanbul ignore if */
    if ("development" !== 'production' && config.performance && mark) {
      vm._name = formatComponentName(vm, false);
      mark(endTag);
      measure("vue " + vm._name + " init", startTag, endTag);
    }

    if (vm.$options.el) {
      vm.$mount(vm.$options.el);
    }
  };
}

function initInternalComponent(vm, options) {
  var opts = vm.$options = Object.create(vm.constructor.options);
  // doing this because it's faster than dynamic enumeration.
  opts.parent = options.parent;
  opts.propsData = options.propsData;
  opts._parentVnode = options._parentVnode;
  opts._parentListeners = options._parentListeners;
  opts._renderChildren = options._renderChildren;
  opts._componentTag = options._componentTag;
  opts._parentElm = options._parentElm;
  opts._refElm = options._refElm;
  if (options.render) {
    opts.render = options.render;
    opts.staticRenderFns = options.staticRenderFns;
  }
}

function resolveConstructorOptions(Ctor) {
  var options = Ctor.options;
  if (Ctor.super) {
    var superOptions = resolveConstructorOptions(Ctor.super);
    var cachedSuperOptions = Ctor.superOptions;
    if (superOptions !== cachedSuperOptions) {
      // super option changed,
      // need to resolve new options.
      Ctor.superOptions = superOptions;
      // check if there are any late-modified/attached options (#4976)
      var modifiedOptions = resolveModifiedOptions(Ctor);
      // update base extend options
      if (modifiedOptions) {
        extend(Ctor.extendOptions, modifiedOptions);
      }
      options = Ctor.options = mergeOptions(superOptions, Ctor.extendOptions);
      if (options.name) {
        options.components[options.name] = Ctor;
      }
    }
  }
  return options;
}

function resolveModifiedOptions(Ctor) {
  var modified;
  var latest = Ctor.options;
  var extended = Ctor.extendOptions;
  var sealed = Ctor.sealedOptions;
  for (var key in latest) {
    if (latest[key] !== sealed[key]) {
      if (!modified) {
        modified = {};
      }
      modified[key] = dedupe(latest[key], extended[key], sealed[key]);
    }
  }
  return modified;
}

function dedupe(latest, extended, sealed) {
  // compare latest and sealed to ensure lifecycle hooks won't be duplicated
  // between merges
  if (Array.isArray(latest)) {
    var res = [];
    sealed = Array.isArray(sealed) ? sealed : [sealed];
    extended = Array.isArray(extended) ? extended : [extended];
    for (var i = 0; i < latest.length; i++) {
      // push original options and not sealed options to exclude duplicated options
      if (extended.indexOf(latest[i]) >= 0 || sealed.indexOf(latest[i]) < 0) {
        res.push(latest[i]);
      }
    }
    return res;
  } else {
    return latest;
  }
}

function Vue$3(options) {
  if ("development" !== 'production' && !(this instanceof Vue$3)) {
    warn('Vue is a constructor and should be called with the `new` keyword');
  }
  this._init(options);
}

initMixin(Vue$3);
stateMixin(Vue$3);
eventsMixin(Vue$3);
lifecycleMixin(Vue$3);
renderMixin(Vue$3);

/*  */

function initUse(Vue) {
  Vue.use = function (plugin) {
    var installedPlugins = this._installedPlugins || (this._installedPlugins = []);
    if (installedPlugins.indexOf(plugin) > -1) {
      return this;
    }

    // additional parameters
    var args = toArray(arguments, 1);
    args.unshift(this);
    if (typeof plugin.install === 'function') {
      plugin.install.apply(plugin, args);
    } else if (typeof plugin === 'function') {
      plugin.apply(null, args);
    }
    installedPlugins.push(plugin);
    return this;
  };
}

/*  */

function initMixin$1(Vue) {
  Vue.mixin = function (mixin) {
    this.options = mergeOptions(this.options, mixin);
    return this;
  };
}

/*  */

function initExtend(Vue) {
  /**
   * Each instance constructor, including Vue, has a unique
   * cid. This enables us to create wrapped "child
   * constructors" for prototypal inheritance and cache them.
   */
  Vue.cid = 0;
  var cid = 1;

  /**
   * Class inheritance
   */
  Vue.extend = function (extendOptions) {
    extendOptions = extendOptions || {};
    var Super = this;
    var SuperId = Super.cid;
    var cachedCtors = extendOptions._Ctor || (extendOptions._Ctor = {});
    if (cachedCtors[SuperId]) {
      return cachedCtors[SuperId];
    }

    var name = extendOptions.name || Super.options.name;
    if (true) {
      if (!/^[a-zA-Z][\w-]*$/.test(name)) {
        warn('Invalid component name: "' + name + '". Component names ' + 'can only contain alphanumeric characters and the hyphen, ' + 'and must start with a letter.');
      }
    }

    var Sub = function VueComponent(options) {
      this._init(options);
    };
    Sub.prototype = Object.create(Super.prototype);
    Sub.prototype.constructor = Sub;
    Sub.cid = cid++;
    Sub.options = mergeOptions(Super.options, extendOptions);
    Sub['super'] = Super;

    // For props and computed properties, we define the proxy getters on
    // the Vue instances at extension time, on the extended prototype. This
    // avoids Object.defineProperty calls for each instance created.
    if (Sub.options.props) {
      initProps$1(Sub);
    }
    if (Sub.options.computed) {
      initComputed$1(Sub);
    }

    // allow further extension/mixin/plugin usage
    Sub.extend = Super.extend;
    Sub.mixin = Super.mixin;
    Sub.use = Super.use;

    // create asset registers, so extended classes
    // can have their private assets too.
    ASSET_TYPES.forEach(function (type) {
      Sub[type] = Super[type];
    });
    // enable recursive self-lookup
    if (name) {
      Sub.options.components[name] = Sub;
    }

    // keep a reference to the super options at extension time.
    // later at instantiation we can check if Super's options have
    // been updated.
    Sub.superOptions = Super.options;
    Sub.extendOptions = extendOptions;
    Sub.sealedOptions = extend({}, Sub.options);

    // cache constructor
    cachedCtors[SuperId] = Sub;
    return Sub;
  };
}

function initProps$1(Comp) {
  var props = Comp.options.props;
  for (var key in props) {
    proxy(Comp.prototype, "_props", key);
  }
}

function initComputed$1(Comp) {
  var computed = Comp.options.computed;
  for (var key in computed) {
    defineComputed(Comp.prototype, key, computed[key]);
  }
}

/*  */

function initAssetRegisters(Vue) {
  /**
   * Create asset registration methods.
   */
  ASSET_TYPES.forEach(function (type) {
    Vue[type] = function (id, definition) {
      if (!definition) {
        return this.options[type + 's'][id];
      } else {
        /* istanbul ignore if */
        if (true) {
          if (type === 'component' && config.isReservedTag(id)) {
            warn('Do not use built-in or reserved HTML elements as component ' + 'id: ' + id);
          }
        }
        if (type === 'component' && isPlainObject(definition)) {
          definition.name = definition.name || id;
          definition = this.options._base.extend(definition);
        }
        if (type === 'directive' && typeof definition === 'function') {
          definition = { bind: definition, update: definition };
        }
        this.options[type + 's'][id] = definition;
        return definition;
      }
    };
  });
}

/*  */

function getComponentName(opts) {
  return opts && (opts.Ctor.options.name || opts.tag);
}

function matches(pattern, name) {
  if (Array.isArray(pattern)) {
    return pattern.indexOf(name) > -1;
  } else if (typeof pattern === 'string') {
    return pattern.split(',').indexOf(name) > -1;
  } else if (isRegExp(pattern)) {
    return pattern.test(name);
  }
  /* istanbul ignore next */
  return false;
}

function pruneCache(keepAliveInstance, filter) {
  var cache = keepAliveInstance.cache;
  var keys = keepAliveInstance.keys;
  var _vnode = keepAliveInstance._vnode;
  for (var key in cache) {
    var cachedNode = cache[key];
    if (cachedNode) {
      var name = getComponentName(cachedNode.componentOptions);
      if (name && !filter(name)) {
        pruneCacheEntry(cache, key, keys, _vnode);
      }
    }
  }
}

function pruneCacheEntry(cache, key, keys, current) {
  var cached$$1 = cache[key];
  if (cached$$1 && (!current || cached$$1.tag !== current.tag)) {
    cached$$1.componentInstance.$destroy();
  }
  cache[key] = null;
  remove(keys, key);
}

var patternTypes = [String, RegExp, Array];

var KeepAlive = {
  name: 'keep-alive',
  abstract: true,

  props: {
    include: patternTypes,
    exclude: patternTypes,
    max: [String, Number]
  },

  created: function created() {
    this.cache = Object.create(null);
    this.keys = [];
  },

  destroyed: function destroyed() {
    var this$1 = this;

    for (var key in this$1.cache) {
      pruneCacheEntry(this$1.cache, key, this$1.keys);
    }
  },

  watch: {
    include: function include(val) {
      pruneCache(this, function (name) {
        return matches(val, name);
      });
    },
    exclude: function exclude(val) {
      pruneCache(this, function (name) {
        return !matches(val, name);
      });
    }
  },

  render: function render() {
    var slot = this.$slots.default;
    var vnode = getFirstComponentChild(slot);
    var componentOptions = vnode && vnode.componentOptions;
    if (componentOptions) {
      // check pattern
      var name = getComponentName(componentOptions);
      var ref = this;
      var include = ref.include;
      var exclude = ref.exclude;
      if (
      // not included
      include && (!name || !matches(include, name)) ||
      // excluded
      exclude && name && matches(exclude, name)) {
        return vnode;
      }

      var ref$1 = this;
      var cache = ref$1.cache;
      var keys = ref$1.keys;
      var key = vnode.key == null
      // same constructor may get registered as different local components
      // so cid alone is not enough (#3269)
      ? componentOptions.Ctor.cid + (componentOptions.tag ? "::" + componentOptions.tag : '') : vnode.key;
      if (cache[key]) {
        vnode.componentInstance = cache[key].componentInstance;
        // make current key freshest
        remove(keys, key);
        keys.push(key);
      } else {
        cache[key] = vnode;
        keys.push(key);
        // prune oldest entry
        if (this.max && keys.length > parseInt(this.max)) {
          pruneCacheEntry(cache, keys[0], keys, this._vnode);
        }
      }

      vnode.data.keepAlive = true;
    }
    return vnode || slot && slot[0];
  }
};

var builtInComponents = {
  KeepAlive: KeepAlive
};

/*  */

function initGlobalAPI(Vue) {
  // config
  var configDef = {};
  configDef.get = function () {
    return config;
  };
  if (true) {
    configDef.set = function () {
      warn('Do not replace the Vue.config object, set individual fields instead.');
    };
  }
  Object.defineProperty(Vue, 'config', configDef);

  // exposed util methods.
  // NOTE: these are not considered part of the public API - avoid relying on
  // them unless you are aware of the risk.
  Vue.util = {
    warn: warn,
    extend: extend,
    mergeOptions: mergeOptions,
    defineReactive: defineReactive
  };

  Vue.set = set;
  Vue.delete = del;
  Vue.nextTick = nextTick;

  Vue.options = Object.create(null);
  ASSET_TYPES.forEach(function (type) {
    Vue.options[type + 's'] = Object.create(null);
  });

  // this is used to identify the "base" constructor to extend all plain-object
  // components with in Weex's multi-instance scenarios.
  Vue.options._base = Vue;

  extend(Vue.options.components, builtInComponents);

  initUse(Vue);
  initMixin$1(Vue);
  initExtend(Vue);
  initAssetRegisters(Vue);
}

initGlobalAPI(Vue$3);

Object.defineProperty(Vue$3.prototype, '$isServer', {
  get: isServerRendering
});

Object.defineProperty(Vue$3.prototype, '$ssrContext', {
  get: function get() {
    /* istanbul ignore next */
    return this.$vnode && this.$vnode.ssrContext;
  }
});

Vue$3.version = '2.5.9';

/*  */

// these are reserved for web because they are directly compiled away
// during template compilation
var isReservedAttr = makeMap('style,class');

// attributes that should be using props for binding
var acceptValue = makeMap('input,textarea,option,select,progress');
var mustUseProp = function mustUseProp(tag, type, attr) {
  return attr === 'value' && acceptValue(tag) && type !== 'button' || attr === 'selected' && tag === 'option' || attr === 'checked' && tag === 'input' || attr === 'muted' && tag === 'video';
};

var isEnumeratedAttr = makeMap('contenteditable,draggable,spellcheck');

var isBooleanAttr = makeMap('allowfullscreen,async,autofocus,autoplay,checked,compact,controls,declare,' + 'default,defaultchecked,defaultmuted,defaultselected,defer,disabled,' + 'enabled,formnovalidate,hidden,indeterminate,inert,ismap,itemscope,loop,multiple,' + 'muted,nohref,noresize,noshade,novalidate,nowrap,open,pauseonexit,readonly,' + 'required,reversed,scoped,seamless,selected,sortable,translate,' + 'truespeed,typemustmatch,visible');

var xlinkNS = 'http://www.w3.org/1999/xlink';

var isXlink = function isXlink(name) {
  return name.charAt(5) === ':' && name.slice(0, 5) === 'xlink';
};

var getXlinkProp = function getXlinkProp(name) {
  return isXlink(name) ? name.slice(6, name.length) : '';
};

var isFalsyAttrValue = function isFalsyAttrValue(val) {
  return val == null || val === false;
};

/*  */

function genClassForVnode(vnode) {
  var data = vnode.data;
  var parentNode = vnode;
  var childNode = vnode;
  while (isDef(childNode.componentInstance)) {
    childNode = childNode.componentInstance._vnode;
    if (childNode.data) {
      data = mergeClassData(childNode.data, data);
    }
  }
  while (isDef(parentNode = parentNode.parent)) {
    if (parentNode.data) {
      data = mergeClassData(data, parentNode.data);
    }
  }
  return renderClass(data.staticClass, data.class);
}

function mergeClassData(child, parent) {
  return {
    staticClass: concat(child.staticClass, parent.staticClass),
    class: isDef(child.class) ? [child.class, parent.class] : parent.class
  };
}

function renderClass(staticClass, dynamicClass) {
  if (isDef(staticClass) || isDef(dynamicClass)) {
    return concat(staticClass, stringifyClass(dynamicClass));
  }
  /* istanbul ignore next */
  return '';
}

function concat(a, b) {
  return a ? b ? a + ' ' + b : a : b || '';
}

function stringifyClass(value) {
  if (Array.isArray(value)) {
    return stringifyArray(value);
  }
  if (isObject(value)) {
    return stringifyObject(value);
  }
  if (typeof value === 'string') {
    return value;
  }
  /* istanbul ignore next */
  return '';
}

function stringifyArray(value) {
  var res = '';
  var stringified;
  for (var i = 0, l = value.length; i < l; i++) {
    if (isDef(stringified = stringifyClass(value[i])) && stringified !== '') {
      if (res) {
        res += ' ';
      }
      res += stringified;
    }
  }
  return res;
}

function stringifyObject(value) {
  var res = '';
  for (var key in value) {
    if (value[key]) {
      if (res) {
        res += ' ';
      }
      res += key;
    }
  }
  return res;
}

/*  */

var namespaceMap = {
  svg: 'http://www.w3.org/2000/svg',
  math: 'http://www.w3.org/1998/Math/MathML'
};

var isHTMLTag = makeMap('html,body,base,head,link,meta,style,title,' + 'address,article,aside,footer,header,h1,h2,h3,h4,h5,h6,hgroup,nav,section,' + 'div,dd,dl,dt,figcaption,figure,picture,hr,img,li,main,ol,p,pre,ul,' + 'a,b,abbr,bdi,bdo,br,cite,code,data,dfn,em,i,kbd,mark,q,rp,rt,rtc,ruby,' + 's,samp,small,span,strong,sub,sup,time,u,var,wbr,area,audio,map,track,video,' + 'embed,object,param,source,canvas,script,noscript,del,ins,' + 'caption,col,colgroup,table,thead,tbody,td,th,tr,' + 'button,datalist,fieldset,form,input,label,legend,meter,optgroup,option,' + 'output,progress,select,textarea,' + 'details,dialog,menu,menuitem,summary,' + 'content,element,shadow,template,blockquote,iframe,tfoot');

// this map is intentionally selective, only covering SVG elements that may
// contain child elements.
var isSVG = makeMap('svg,animate,circle,clippath,cursor,defs,desc,ellipse,filter,font-face,' + 'foreignObject,g,glyph,image,line,marker,mask,missing-glyph,path,pattern,' + 'polygon,polyline,rect,switch,symbol,text,textpath,tspan,use,view', true);

var isPreTag = function isPreTag(tag) {
  return tag === 'pre';
};

var isReservedTag = function isReservedTag(tag) {
  return isHTMLTag(tag) || isSVG(tag);
};

function getTagNamespace(tag) {
  if (isSVG(tag)) {
    return 'svg';
  }
  // basic support for MathML
  // note it doesn't support other MathML elements being component roots
  if (tag === 'math') {
    return 'math';
  }
}

var unknownElementCache = Object.create(null);
function isUnknownElement(tag) {
  /* istanbul ignore if */
  if (!inBrowser) {
    return true;
  }
  if (isReservedTag(tag)) {
    return false;
  }
  tag = tag.toLowerCase();
  /* istanbul ignore if */
  if (unknownElementCache[tag] != null) {
    return unknownElementCache[tag];
  }
  var el = document.createElement(tag);
  if (tag.indexOf('-') > -1) {
    // http://stackoverflow.com/a/28210364/1070244
    return unknownElementCache[tag] = el.constructor === window.HTMLUnknownElement || el.constructor === window.HTMLElement;
  } else {
    return unknownElementCache[tag] = /HTMLUnknownElement/.test(el.toString());
  }
}

var isTextInputType = makeMap('text,number,password,search,email,tel,url');

/*  */

/**
 * Query an element selector if it's not an element already.
 */
function query(el) {
  if (typeof el === 'string') {
    var selected = document.querySelector(el);
    if (!selected) {
      "development" !== 'production' && warn('Cannot find element: ' + el);
      return document.createElement('div');
    }
    return selected;
  } else {
    return el;
  }
}

/*  */

function createElement$1(tagName, vnode) {
  var elm = document.createElement(tagName);
  if (tagName !== 'select') {
    return elm;
  }
  // false or null will remove the attribute but undefined will not
  if (vnode.data && vnode.data.attrs && vnode.data.attrs.multiple !== undefined) {
    elm.setAttribute('multiple', 'multiple');
  }
  return elm;
}

function createElementNS(namespace, tagName) {
  return document.createElementNS(namespaceMap[namespace], tagName);
}

function createTextNode(text) {
  return document.createTextNode(text);
}

function createComment(text) {
  return document.createComment(text);
}

function insertBefore(parentNode, newNode, referenceNode) {
  parentNode.insertBefore(newNode, referenceNode);
}

function removeChild(node, child) {
  node.removeChild(child);
}

function appendChild(node, child) {
  node.appendChild(child);
}

function parentNode(node) {
  return node.parentNode;
}

function nextSibling(node) {
  return node.nextSibling;
}

function tagName(node) {
  return node.tagName;
}

function setTextContent(node, text) {
  node.textContent = text;
}

function setAttribute(node, key, val) {
  node.setAttribute(key, val);
}

var nodeOps = Object.freeze({
  createElement: createElement$1,
  createElementNS: createElementNS,
  createTextNode: createTextNode,
  createComment: createComment,
  insertBefore: insertBefore,
  removeChild: removeChild,
  appendChild: appendChild,
  parentNode: parentNode,
  nextSibling: nextSibling,
  tagName: tagName,
  setTextContent: setTextContent,
  setAttribute: setAttribute
});

/*  */

var ref = {
  create: function create(_, vnode) {
    registerRef(vnode);
  },
  update: function update(oldVnode, vnode) {
    if (oldVnode.data.ref !== vnode.data.ref) {
      registerRef(oldVnode, true);
      registerRef(vnode);
    }
  },
  destroy: function destroy(vnode) {
    registerRef(vnode, true);
  }
};

function registerRef(vnode, isRemoval) {
  var key = vnode.data.ref;
  if (!key) {
    return;
  }

  var vm = vnode.context;
  var ref = vnode.componentInstance || vnode.elm;
  var refs = vm.$refs;
  if (isRemoval) {
    if (Array.isArray(refs[key])) {
      remove(refs[key], ref);
    } else if (refs[key] === ref) {
      refs[key] = undefined;
    }
  } else {
    if (vnode.data.refInFor) {
      if (!Array.isArray(refs[key])) {
        refs[key] = [ref];
      } else if (refs[key].indexOf(ref) < 0) {
        // $flow-disable-line
        refs[key].push(ref);
      }
    } else {
      refs[key] = ref;
    }
  }
}

/**
 * Virtual DOM patching algorithm based on Snabbdom by
 * Simon Friis Vindum (@paldepind)
 * Licensed under the MIT License
 * https://github.com/paldepind/snabbdom/blob/master/LICENSE
 *
 * modified by Evan You (@yyx990803)
 *
 * Not type-checking this because this file is perf-critical and the cost
 * of making flow understand it is not worth it.
 */

var emptyNode = new VNode('', {}, []);

var hooks = ['create', 'activate', 'update', 'remove', 'destroy'];

function sameVnode(a, b) {
  return a.key === b.key && (a.tag === b.tag && a.isComment === b.isComment && isDef(a.data) === isDef(b.data) && sameInputType(a, b) || isTrue(a.isAsyncPlaceholder) && a.asyncFactory === b.asyncFactory && isUndef(b.asyncFactory.error));
}

function sameInputType(a, b) {
  if (a.tag !== 'input') {
    return true;
  }
  var i;
  var typeA = isDef(i = a.data) && isDef(i = i.attrs) && i.type;
  var typeB = isDef(i = b.data) && isDef(i = i.attrs) && i.type;
  return typeA === typeB || isTextInputType(typeA) && isTextInputType(typeB);
}

function createKeyToOldIdx(children, beginIdx, endIdx) {
  var i, key;
  var map = {};
  for (i = beginIdx; i <= endIdx; ++i) {
    key = children[i].key;
    if (isDef(key)) {
      map[key] = i;
    }
  }
  return map;
}

function createPatchFunction(backend) {
  var i, j;
  var cbs = {};

  var modules = backend.modules;
  var nodeOps = backend.nodeOps;

  for (i = 0; i < hooks.length; ++i) {
    cbs[hooks[i]] = [];
    for (j = 0; j < modules.length; ++j) {
      if (isDef(modules[j][hooks[i]])) {
        cbs[hooks[i]].push(modules[j][hooks[i]]);
      }
    }
  }

  function emptyNodeAt(elm) {
    return new VNode(nodeOps.tagName(elm).toLowerCase(), {}, [], undefined, elm);
  }

  function createRmCb(childElm, listeners) {
    function remove() {
      if (--remove.listeners === 0) {
        removeNode(childElm);
      }
    }
    remove.listeners = listeners;
    return remove;
  }

  function removeNode(el) {
    var parent = nodeOps.parentNode(el);
    // element may have already been removed due to v-html / v-text
    if (isDef(parent)) {
      nodeOps.removeChild(parent, el);
    }
  }

  function isUnknownElement$$1(vnode, inVPre) {
    return !inVPre && !vnode.ns && !(config.ignoredElements.length && config.ignoredElements.some(function (ignore) {
      return isRegExp(ignore) ? ignore.test(vnode.tag) : ignore === vnode.tag;
    })) && config.isUnknownElement(vnode.tag);
  }

  var creatingElmInVPre = 0;
  function createElm(vnode, insertedVnodeQueue, parentElm, refElm, nested) {
    vnode.isRootInsert = !nested; // for transition enter check
    if (createComponent(vnode, insertedVnodeQueue, parentElm, refElm)) {
      return;
    }

    var data = vnode.data;
    var children = vnode.children;
    var tag = vnode.tag;
    if (isDef(tag)) {
      if (true) {
        if (data && data.pre) {
          creatingElmInVPre++;
        }
        if (isUnknownElement$$1(vnode, creatingElmInVPre)) {
          warn('Unknown custom element: <' + tag + '> - did you ' + 'register the component correctly? For recursive components, ' + 'make sure to provide the "name" option.', vnode.context);
        }
      }
      vnode.elm = vnode.ns ? nodeOps.createElementNS(vnode.ns, tag) : nodeOps.createElement(tag, vnode);
      setScope(vnode);

      /* istanbul ignore if */
      {
        createChildren(vnode, children, insertedVnodeQueue);
        if (isDef(data)) {
          invokeCreateHooks(vnode, insertedVnodeQueue);
        }
        insert(parentElm, vnode.elm, refElm);
      }

      if ("development" !== 'production' && data && data.pre) {
        creatingElmInVPre--;
      }
    } else if (isTrue(vnode.isComment)) {
      vnode.elm = nodeOps.createComment(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    } else {
      vnode.elm = nodeOps.createTextNode(vnode.text);
      insert(parentElm, vnode.elm, refElm);
    }
  }

  function createComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i = vnode.data;
    if (isDef(i)) {
      var isReactivated = isDef(vnode.componentInstance) && i.keepAlive;
      if (isDef(i = i.hook) && isDef(i = i.init)) {
        i(vnode, false /* hydrating */, parentElm, refElm);
      }
      // after calling the init hook, if the vnode is a child component
      // it should've created a child instance and mounted it. the child
      // component also has set the placeholder vnode's elm.
      // in that case we can just return the element and be done.
      if (isDef(vnode.componentInstance)) {
        initComponent(vnode, insertedVnodeQueue);
        if (isTrue(isReactivated)) {
          reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm);
        }
        return true;
      }
    }
  }

  function initComponent(vnode, insertedVnodeQueue) {
    if (isDef(vnode.data.pendingInsert)) {
      insertedVnodeQueue.push.apply(insertedVnodeQueue, vnode.data.pendingInsert);
      vnode.data.pendingInsert = null;
    }
    vnode.elm = vnode.componentInstance.$el;
    if (isPatchable(vnode)) {
      invokeCreateHooks(vnode, insertedVnodeQueue);
      setScope(vnode);
    } else {
      // empty component root.
      // skip all element-related modules except for ref (#3455)
      registerRef(vnode);
      // make sure to invoke the insert hook
      insertedVnodeQueue.push(vnode);
    }
  }

  function reactivateComponent(vnode, insertedVnodeQueue, parentElm, refElm) {
    var i;
    // hack for #4339: a reactivated component with inner transition
    // does not trigger because the inner node's created hooks are not called
    // again. It's not ideal to involve module-specific logic in here but
    // there doesn't seem to be a better way to do it.
    var innerNode = vnode;
    while (innerNode.componentInstance) {
      innerNode = innerNode.componentInstance._vnode;
      if (isDef(i = innerNode.data) && isDef(i = i.transition)) {
        for (i = 0; i < cbs.activate.length; ++i) {
          cbs.activate[i](emptyNode, innerNode);
        }
        insertedVnodeQueue.push(innerNode);
        break;
      }
    }
    // unlike a newly created component,
    // a reactivated keep-alive component doesn't insert itself
    insert(parentElm, vnode.elm, refElm);
  }

  function insert(parent, elm, ref$$1) {
    if (isDef(parent)) {
      if (isDef(ref$$1)) {
        if (ref$$1.parentNode === parent) {
          nodeOps.insertBefore(parent, elm, ref$$1);
        }
      } else {
        nodeOps.appendChild(parent, elm);
      }
    }
  }

  function createChildren(vnode, children, insertedVnodeQueue) {
    if (Array.isArray(children)) {
      for (var i = 0; i < children.length; ++i) {
        createElm(children[i], insertedVnodeQueue, vnode.elm, null, true);
      }
    } else if (isPrimitive(vnode.text)) {
      nodeOps.appendChild(vnode.elm, nodeOps.createTextNode(vnode.text));
    }
  }

  function isPatchable(vnode) {
    while (vnode.componentInstance) {
      vnode = vnode.componentInstance._vnode;
    }
    return isDef(vnode.tag);
  }

  function invokeCreateHooks(vnode, insertedVnodeQueue) {
    for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
      cbs.create[i$1](emptyNode, vnode);
    }
    i = vnode.data.hook; // Reuse variable
    if (isDef(i)) {
      if (isDef(i.create)) {
        i.create(emptyNode, vnode);
      }
      if (isDef(i.insert)) {
        insertedVnodeQueue.push(vnode);
      }
    }
  }

  // set scope id attribute for scoped CSS.
  // this is implemented as a special case to avoid the overhead
  // of going through the normal attribute patching process.
  function setScope(vnode) {
    var i;
    if (isDef(i = vnode.fnScopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    } else {
      var ancestor = vnode;
      while (ancestor) {
        if (isDef(i = ancestor.context) && isDef(i = i.$options._scopeId)) {
          nodeOps.setAttribute(vnode.elm, i, '');
        }
        ancestor = ancestor.parent;
      }
    }
    // for slot content they should also get the scopeId from the host instance.
    if (isDef(i = activeInstance) && i !== vnode.context && i !== vnode.fnContext && isDef(i = i.$options._scopeId)) {
      nodeOps.setAttribute(vnode.elm, i, '');
    }
  }

  function addVnodes(parentElm, refElm, vnodes, startIdx, endIdx, insertedVnodeQueue) {
    for (; startIdx <= endIdx; ++startIdx) {
      createElm(vnodes[startIdx], insertedVnodeQueue, parentElm, refElm);
    }
  }

  function invokeDestroyHook(vnode) {
    var i, j;
    var data = vnode.data;
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.destroy)) {
        i(vnode);
      }
      for (i = 0; i < cbs.destroy.length; ++i) {
        cbs.destroy[i](vnode);
      }
    }
    if (isDef(i = vnode.children)) {
      for (j = 0; j < vnode.children.length; ++j) {
        invokeDestroyHook(vnode.children[j]);
      }
    }
  }

  function removeVnodes(parentElm, vnodes, startIdx, endIdx) {
    for (; startIdx <= endIdx; ++startIdx) {
      var ch = vnodes[startIdx];
      if (isDef(ch)) {
        if (isDef(ch.tag)) {
          removeAndInvokeRemoveHook(ch);
          invokeDestroyHook(ch);
        } else {
          // Text node
          removeNode(ch.elm);
        }
      }
    }
  }

  function removeAndInvokeRemoveHook(vnode, rm) {
    if (isDef(rm) || isDef(vnode.data)) {
      var i;
      var listeners = cbs.remove.length + 1;
      if (isDef(rm)) {
        // we have a recursively passed down rm callback
        // increase the listeners count
        rm.listeners += listeners;
      } else {
        // directly removing
        rm = createRmCb(vnode.elm, listeners);
      }
      // recursively invoke hooks on child component root node
      if (isDef(i = vnode.componentInstance) && isDef(i = i._vnode) && isDef(i.data)) {
        removeAndInvokeRemoveHook(i, rm);
      }
      for (i = 0; i < cbs.remove.length; ++i) {
        cbs.remove[i](vnode, rm);
      }
      if (isDef(i = vnode.data.hook) && isDef(i = i.remove)) {
        i(vnode, rm);
      } else {
        rm();
      }
    } else {
      removeNode(vnode.elm);
    }
  }

  function updateChildren(parentElm, oldCh, newCh, insertedVnodeQueue, removeOnly) {
    var oldStartIdx = 0;
    var newStartIdx = 0;
    var oldEndIdx = oldCh.length - 1;
    var oldStartVnode = oldCh[0];
    var oldEndVnode = oldCh[oldEndIdx];
    var newEndIdx = newCh.length - 1;
    var newStartVnode = newCh[0];
    var newEndVnode = newCh[newEndIdx];
    var oldKeyToIdx, idxInOld, vnodeToMove, refElm;

    // removeOnly is a special flag used only by <transition-group>
    // to ensure removed elements stay in correct relative positions
    // during leaving transitions
    var canMove = !removeOnly;

    while (oldStartIdx <= oldEndIdx && newStartIdx <= newEndIdx) {
      if (isUndef(oldStartVnode)) {
        oldStartVnode = oldCh[++oldStartIdx]; // Vnode has been moved left
      } else if (isUndef(oldEndVnode)) {
        oldEndVnode = oldCh[--oldEndIdx];
      } else if (sameVnode(oldStartVnode, newStartVnode)) {
        patchVnode(oldStartVnode, newStartVnode, insertedVnodeQueue);
        oldStartVnode = oldCh[++oldStartIdx];
        newStartVnode = newCh[++newStartIdx];
      } else if (sameVnode(oldEndVnode, newEndVnode)) {
        patchVnode(oldEndVnode, newEndVnode, insertedVnodeQueue);
        oldEndVnode = oldCh[--oldEndIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldStartVnode, newEndVnode)) {
        // Vnode moved right
        patchVnode(oldStartVnode, newEndVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldStartVnode.elm, nodeOps.nextSibling(oldEndVnode.elm));
        oldStartVnode = oldCh[++oldStartIdx];
        newEndVnode = newCh[--newEndIdx];
      } else if (sameVnode(oldEndVnode, newStartVnode)) {
        // Vnode moved left
        patchVnode(oldEndVnode, newStartVnode, insertedVnodeQueue);
        canMove && nodeOps.insertBefore(parentElm, oldEndVnode.elm, oldStartVnode.elm);
        oldEndVnode = oldCh[--oldEndIdx];
        newStartVnode = newCh[++newStartIdx];
      } else {
        if (isUndef(oldKeyToIdx)) {
          oldKeyToIdx = createKeyToOldIdx(oldCh, oldStartIdx, oldEndIdx);
        }
        idxInOld = isDef(newStartVnode.key) ? oldKeyToIdx[newStartVnode.key] : findIdxInOld(newStartVnode, oldCh, oldStartIdx, oldEndIdx);
        if (isUndef(idxInOld)) {
          // New element
          createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
        } else {
          vnodeToMove = oldCh[idxInOld];
          /* istanbul ignore if */
          if ("development" !== 'production' && !vnodeToMove) {
            warn('It seems there are duplicate keys that is causing an update error. ' + 'Make sure each v-for item has a unique key.');
          }
          if (sameVnode(vnodeToMove, newStartVnode)) {
            patchVnode(vnodeToMove, newStartVnode, insertedVnodeQueue);
            oldCh[idxInOld] = undefined;
            canMove && nodeOps.insertBefore(parentElm, vnodeToMove.elm, oldStartVnode.elm);
          } else {
            // same key but different element. treat as new element
            createElm(newStartVnode, insertedVnodeQueue, parentElm, oldStartVnode.elm);
          }
        }
        newStartVnode = newCh[++newStartIdx];
      }
    }
    if (oldStartIdx > oldEndIdx) {
      refElm = isUndef(newCh[newEndIdx + 1]) ? null : newCh[newEndIdx + 1].elm;
      addVnodes(parentElm, refElm, newCh, newStartIdx, newEndIdx, insertedVnodeQueue);
    } else if (newStartIdx > newEndIdx) {
      removeVnodes(parentElm, oldCh, oldStartIdx, oldEndIdx);
    }
  }

  function findIdxInOld(node, oldCh, start, end) {
    for (var i = start; i < end; i++) {
      var c = oldCh[i];
      if (isDef(c) && sameVnode(node, c)) {
        return i;
      }
    }
  }

  function patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly) {
    if (oldVnode === vnode) {
      return;
    }

    var elm = vnode.elm = oldVnode.elm;

    if (isTrue(oldVnode.isAsyncPlaceholder)) {
      if (isDef(vnode.asyncFactory.resolved)) {
        hydrate(oldVnode.elm, vnode, insertedVnodeQueue);
      } else {
        vnode.isAsyncPlaceholder = true;
      }
      return;
    }

    // reuse element for static trees.
    // note we only do this if the vnode is cloned -
    // if the new node is not cloned it means the render functions have been
    // reset by the hot-reload-api and we need to do a proper re-render.
    if (isTrue(vnode.isStatic) && isTrue(oldVnode.isStatic) && vnode.key === oldVnode.key && (isTrue(vnode.isCloned) || isTrue(vnode.isOnce))) {
      vnode.componentInstance = oldVnode.componentInstance;
      return;
    }

    var i;
    var data = vnode.data;
    if (isDef(data) && isDef(i = data.hook) && isDef(i = i.prepatch)) {
      i(oldVnode, vnode);
    }

    var oldCh = oldVnode.children;
    var ch = vnode.children;
    if (isDef(data) && isPatchable(vnode)) {
      for (i = 0; i < cbs.update.length; ++i) {
        cbs.update[i](oldVnode, vnode);
      }
      if (isDef(i = data.hook) && isDef(i = i.update)) {
        i(oldVnode, vnode);
      }
    }
    if (isUndef(vnode.text)) {
      if (isDef(oldCh) && isDef(ch)) {
        if (oldCh !== ch) {
          updateChildren(elm, oldCh, ch, insertedVnodeQueue, removeOnly);
        }
      } else if (isDef(ch)) {
        if (isDef(oldVnode.text)) {
          nodeOps.setTextContent(elm, '');
        }
        addVnodes(elm, null, ch, 0, ch.length - 1, insertedVnodeQueue);
      } else if (isDef(oldCh)) {
        removeVnodes(elm, oldCh, 0, oldCh.length - 1);
      } else if (isDef(oldVnode.text)) {
        nodeOps.setTextContent(elm, '');
      }
    } else if (oldVnode.text !== vnode.text) {
      nodeOps.setTextContent(elm, vnode.text);
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.postpatch)) {
        i(oldVnode, vnode);
      }
    }
  }

  function invokeInsertHook(vnode, queue, initial) {
    // delay insert hooks for component root nodes, invoke them after the
    // element is really inserted
    if (isTrue(initial) && isDef(vnode.parent)) {
      vnode.parent.data.pendingInsert = queue;
    } else {
      for (var i = 0; i < queue.length; ++i) {
        queue[i].data.hook.insert(queue[i]);
      }
    }
  }

  var hydrationBailed = false;
  // list of modules that can skip create hook during hydration because they
  // are already rendered on the client or has no need for initialization
  // Note: style is excluded because it relies on initial clone for future
  // deep updates (#7063).
  var isRenderedModule = makeMap('attrs,class,staticClass,staticStyle,key');

  // Note: this is a browser-only function so we can assume elms are DOM nodes.
  function hydrate(elm, vnode, insertedVnodeQueue, inVPre) {
    var i;
    var tag = vnode.tag;
    var data = vnode.data;
    var children = vnode.children;
    inVPre = inVPre || data && data.pre;
    vnode.elm = elm;

    if (isTrue(vnode.isComment) && isDef(vnode.asyncFactory)) {
      vnode.isAsyncPlaceholder = true;
      return true;
    }
    // assert node match
    if (true) {
      if (!assertNodeMatch(elm, vnode, inVPre)) {
        return false;
      }
    }
    if (isDef(data)) {
      if (isDef(i = data.hook) && isDef(i = i.init)) {
        i(vnode, true /* hydrating */);
      }
      if (isDef(i = vnode.componentInstance)) {
        // child component. it should have hydrated its own tree.
        initComponent(vnode, insertedVnodeQueue);
        return true;
      }
    }
    if (isDef(tag)) {
      if (isDef(children)) {
        // empty element, allow client to pick up and populate children
        if (!elm.hasChildNodes()) {
          createChildren(vnode, children, insertedVnodeQueue);
        } else {
          // v-html and domProps: innerHTML
          if (isDef(i = data) && isDef(i = i.domProps) && isDef(i = i.innerHTML)) {
            if (i !== elm.innerHTML) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('server innerHTML: ', i);
                console.warn('client innerHTML: ', elm.innerHTML);
              }
              return false;
            }
          } else {
            // iterate and compare children lists
            var childrenMatch = true;
            var childNode = elm.firstChild;
            for (var i$1 = 0; i$1 < children.length; i$1++) {
              if (!childNode || !hydrate(childNode, children[i$1], insertedVnodeQueue, inVPre)) {
                childrenMatch = false;
                break;
              }
              childNode = childNode.nextSibling;
            }
            // if childNode is not null, it means the actual childNodes list is
            // longer than the virtual children list.
            if (!childrenMatch || childNode) {
              /* istanbul ignore if */
              if ("development" !== 'production' && typeof console !== 'undefined' && !hydrationBailed) {
                hydrationBailed = true;
                console.warn('Parent: ', elm);
                console.warn('Mismatching childNodes vs. VNodes: ', elm.childNodes, children);
              }
              return false;
            }
          }
        }
      }
      if (isDef(data)) {
        var fullInvoke = false;
        for (var key in data) {
          if (!isRenderedModule(key)) {
            fullInvoke = true;
            invokeCreateHooks(vnode, insertedVnodeQueue);
            break;
          }
        }
        if (!fullInvoke && data['class']) {
          // ensure collecting deps for deep class bindings for future updates
          traverse(data['class']);
        }
      }
    } else if (elm.data !== vnode.text) {
      elm.data = vnode.text;
    }
    return true;
  }

  function assertNodeMatch(node, vnode, inVPre) {
    if (isDef(vnode.tag)) {
      return vnode.tag.indexOf('vue-component') === 0 || !isUnknownElement$$1(vnode, inVPre) && vnode.tag.toLowerCase() === (node.tagName && node.tagName.toLowerCase());
    } else {
      return node.nodeType === (vnode.isComment ? 8 : 3);
    }
  }

  return function patch(oldVnode, vnode, hydrating, removeOnly, parentElm, refElm) {
    if (isUndef(vnode)) {
      if (isDef(oldVnode)) {
        invokeDestroyHook(oldVnode);
      }
      return;
    }

    var isInitialPatch = false;
    var insertedVnodeQueue = [];

    if (isUndef(oldVnode)) {
      // empty mount (likely as component), create new root element
      isInitialPatch = true;
      createElm(vnode, insertedVnodeQueue, parentElm, refElm);
    } else {
      var isRealElement = isDef(oldVnode.nodeType);
      if (!isRealElement && sameVnode(oldVnode, vnode)) {
        // patch existing root node
        patchVnode(oldVnode, vnode, insertedVnodeQueue, removeOnly);
      } else {
        if (isRealElement) {
          // mounting to a real element
          // check if this is server-rendered content and if we can perform
          // a successful hydration.
          if (oldVnode.nodeType === 1 && oldVnode.hasAttribute(SSR_ATTR)) {
            oldVnode.removeAttribute(SSR_ATTR);
            hydrating = true;
          }
          if (isTrue(hydrating)) {
            if (hydrate(oldVnode, vnode, insertedVnodeQueue)) {
              invokeInsertHook(vnode, insertedVnodeQueue, true);
              return oldVnode;
            } else if (true) {
              warn('The client-side rendered virtual DOM tree is not matching ' + 'server-rendered content. This is likely caused by incorrect ' + 'HTML markup, for example nesting block-level elements inside ' + '<p>, or missing <tbody>. Bailing hydration and performing ' + 'full client-side render.');
            }
          }
          // either not server-rendered, or hydration failed.
          // create an empty node and replace it
          oldVnode = emptyNodeAt(oldVnode);
        }

        // replacing existing element
        var oldElm = oldVnode.elm;
        var parentElm$1 = nodeOps.parentNode(oldElm);

        // create new node
        createElm(vnode, insertedVnodeQueue,
        // extremely rare edge case: do not insert if old element is in a
        // leaving transition. Only happens when combining transition +
        // keep-alive + HOCs. (#4590)
        oldElm._leaveCb ? null : parentElm$1, nodeOps.nextSibling(oldElm));

        // update parent placeholder node element, recursively
        if (isDef(vnode.parent)) {
          var ancestor = vnode.parent;
          var patchable = isPatchable(vnode);
          while (ancestor) {
            for (var i = 0; i < cbs.destroy.length; ++i) {
              cbs.destroy[i](ancestor);
            }
            ancestor.elm = vnode.elm;
            if (patchable) {
              for (var i$1 = 0; i$1 < cbs.create.length; ++i$1) {
                cbs.create[i$1](emptyNode, ancestor);
              }
              // #6513
              // invoke insert hooks that may have been merged by create hooks.
              // e.g. for directives that uses the "inserted" hook.
              var insert = ancestor.data.hook.insert;
              if (insert.merged) {
                // start at index 1 to avoid re-invoking component mounted hook
                for (var i$2 = 1; i$2 < insert.fns.length; i$2++) {
                  insert.fns[i$2]();
                }
              }
            } else {
              registerRef(ancestor);
            }
            ancestor = ancestor.parent;
          }
        }

        // destroy old node
        if (isDef(parentElm$1)) {
          removeVnodes(parentElm$1, [oldVnode], 0, 0);
        } else if (isDef(oldVnode.tag)) {
          invokeDestroyHook(oldVnode);
        }
      }
    }

    invokeInsertHook(vnode, insertedVnodeQueue, isInitialPatch);
    return vnode.elm;
  };
}

/*  */

var directives = {
  create: updateDirectives,
  update: updateDirectives,
  destroy: function unbindDirectives(vnode) {
    updateDirectives(vnode, emptyNode);
  }
};

function updateDirectives(oldVnode, vnode) {
  if (oldVnode.data.directives || vnode.data.directives) {
    _update(oldVnode, vnode);
  }
}

function _update(oldVnode, vnode) {
  var isCreate = oldVnode === emptyNode;
  var isDestroy = vnode === emptyNode;
  var oldDirs = normalizeDirectives$1(oldVnode.data.directives, oldVnode.context);
  var newDirs = normalizeDirectives$1(vnode.data.directives, vnode.context);

  var dirsWithInsert = [];
  var dirsWithPostpatch = [];

  var key, oldDir, dir;
  for (key in newDirs) {
    oldDir = oldDirs[key];
    dir = newDirs[key];
    if (!oldDir) {
      // new directive, bind
      callHook$1(dir, 'bind', vnode, oldVnode);
      if (dir.def && dir.def.inserted) {
        dirsWithInsert.push(dir);
      }
    } else {
      // existing directive, update
      dir.oldValue = oldDir.value;
      callHook$1(dir, 'update', vnode, oldVnode);
      if (dir.def && dir.def.componentUpdated) {
        dirsWithPostpatch.push(dir);
      }
    }
  }

  if (dirsWithInsert.length) {
    var callInsert = function callInsert() {
      for (var i = 0; i < dirsWithInsert.length; i++) {
        callHook$1(dirsWithInsert[i], 'inserted', vnode, oldVnode);
      }
    };
    if (isCreate) {
      mergeVNodeHook(vnode, 'insert', callInsert);
    } else {
      callInsert();
    }
  }

  if (dirsWithPostpatch.length) {
    mergeVNodeHook(vnode, 'postpatch', function () {
      for (var i = 0; i < dirsWithPostpatch.length; i++) {
        callHook$1(dirsWithPostpatch[i], 'componentUpdated', vnode, oldVnode);
      }
    });
  }

  if (!isCreate) {
    for (key in oldDirs) {
      if (!newDirs[key]) {
        // no longer present, unbind
        callHook$1(oldDirs[key], 'unbind', oldVnode, oldVnode, isDestroy);
      }
    }
  }
}

var emptyModifiers = Object.create(null);

function normalizeDirectives$1(dirs, vm) {
  var res = Object.create(null);
  if (!dirs) {
    return res;
  }
  var i, dir;
  for (i = 0; i < dirs.length; i++) {
    dir = dirs[i];
    if (!dir.modifiers) {
      dir.modifiers = emptyModifiers;
    }
    res[getRawDirName(dir)] = dir;
    dir.def = resolveAsset(vm.$options, 'directives', dir.name, true);
  }
  return res;
}

function getRawDirName(dir) {
  return dir.rawName || dir.name + "." + Object.keys(dir.modifiers || {}).join('.');
}

function callHook$1(dir, hook, vnode, oldVnode, isDestroy) {
  var fn = dir.def && dir.def[hook];
  if (fn) {
    try {
      fn(vnode.elm, dir, vnode, oldVnode, isDestroy);
    } catch (e) {
      handleError(e, vnode.context, "directive " + dir.name + " " + hook + " hook");
    }
  }
}

var baseModules = [ref, directives];

/*  */

function updateAttrs(oldVnode, vnode) {
  var opts = vnode.componentOptions;
  if (isDef(opts) && opts.Ctor.options.inheritAttrs === false) {
    return;
  }
  if (isUndef(oldVnode.data.attrs) && isUndef(vnode.data.attrs)) {
    return;
  }
  var key, cur, old;
  var elm = vnode.elm;
  var oldAttrs = oldVnode.data.attrs || {};
  var attrs = vnode.data.attrs || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(attrs.__ob__)) {
    attrs = vnode.data.attrs = extend({}, attrs);
  }

  for (key in attrs) {
    cur = attrs[key];
    old = oldAttrs[key];
    if (old !== cur) {
      setAttr(elm, key, cur);
    }
  }
  // #4391: in IE9, setting type can reset value for input[type=radio]
  // #6666: IE/Edge forces progress value down to 1 before setting a max
  /* istanbul ignore if */
  if ((isIE || isEdge) && attrs.value !== oldAttrs.value) {
    setAttr(elm, 'value', attrs.value);
  }
  for (key in oldAttrs) {
    if (isUndef(attrs[key])) {
      if (isXlink(key)) {
        elm.removeAttributeNS(xlinkNS, getXlinkProp(key));
      } else if (!isEnumeratedAttr(key)) {
        elm.removeAttribute(key);
      }
    }
  }
}

function setAttr(el, key, value) {
  if (isBooleanAttr(key)) {
    // set attribute for blank value
    // e.g. <option disabled>Select one</option>
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // technically allowfullscreen is a boolean attribute for <iframe>,
      // but Flash expects a value of "true" when used on <embed> tag
      value = key === 'allowfullscreen' && el.tagName === 'EMBED' ? 'true' : key;
      el.setAttribute(key, value);
    }
  } else if (isEnumeratedAttr(key)) {
    el.setAttribute(key, isFalsyAttrValue(value) || value === 'false' ? 'false' : 'true');
  } else if (isXlink(key)) {
    if (isFalsyAttrValue(value)) {
      el.removeAttributeNS(xlinkNS, getXlinkProp(key));
    } else {
      el.setAttributeNS(xlinkNS, key, value);
    }
  } else {
    if (isFalsyAttrValue(value)) {
      el.removeAttribute(key);
    } else {
      // #7138: IE10 & 11 fires input event when setting placeholder on
      // <textarea>... block the first input event and remove the blocker
      // immediately.
      /* istanbul ignore if */
      if (isIE && !isIE9 && el.tagName === 'TEXTAREA' && key === 'placeholder' && !el.__ieph) {
        var blocker = function blocker(e) {
          e.stopImmediatePropagation();
          el.removeEventListener('input', blocker);
        };
        el.addEventListener('input', blocker);
        // $flow-disable-line
        el.__ieph = true; /* IE placeholder patched */
      }
      el.setAttribute(key, value);
    }
  }
}

var attrs = {
  create: updateAttrs,
  update: updateAttrs
};

/*  */

function updateClass(oldVnode, vnode) {
  var el = vnode.elm;
  var data = vnode.data;
  var oldData = oldVnode.data;
  if (isUndef(data.staticClass) && isUndef(data.class) && (isUndef(oldData) || isUndef(oldData.staticClass) && isUndef(oldData.class))) {
    return;
  }

  var cls = genClassForVnode(vnode);

  // handle transition classes
  var transitionClass = el._transitionClasses;
  if (isDef(transitionClass)) {
    cls = concat(cls, stringifyClass(transitionClass));
  }

  // set the class
  if (cls !== el._prevClass) {
    el.setAttribute('class', cls);
    el._prevClass = cls;
  }
}

var klass = {
  create: updateClass,
  update: updateClass
};

/*  */

var validDivisionCharRE = /[\w).+\-_$\]]/;

function parseFilters(exp) {
  var inSingle = false;
  var inDouble = false;
  var inTemplateString = false;
  var inRegex = false;
  var curly = 0;
  var square = 0;
  var paren = 0;
  var lastFilterIndex = 0;
  var c, prev, i, expression, filters;

  for (i = 0; i < exp.length; i++) {
    prev = c;
    c = exp.charCodeAt(i);
    if (inSingle) {
      if (c === 0x27 && prev !== 0x5C) {
        inSingle = false;
      }
    } else if (inDouble) {
      if (c === 0x22 && prev !== 0x5C) {
        inDouble = false;
      }
    } else if (inTemplateString) {
      if (c === 0x60 && prev !== 0x5C) {
        inTemplateString = false;
      }
    } else if (inRegex) {
      if (c === 0x2f && prev !== 0x5C) {
        inRegex = false;
      }
    } else if (c === 0x7C && // pipe
    exp.charCodeAt(i + 1) !== 0x7C && exp.charCodeAt(i - 1) !== 0x7C && !curly && !square && !paren) {
      if (expression === undefined) {
        // first filter, end of expression
        lastFilterIndex = i + 1;
        expression = exp.slice(0, i).trim();
      } else {
        pushFilter();
      }
    } else {
      switch (c) {
        case 0x22:
          inDouble = true;break; // "
        case 0x27:
          inSingle = true;break; // '
        case 0x60:
          inTemplateString = true;break; // `
        case 0x28:
          paren++;break; // (
        case 0x29:
          paren--;break; // )
        case 0x5B:
          square++;break; // [
        case 0x5D:
          square--;break; // ]
        case 0x7B:
          curly++;break; // {
        case 0x7D:
          curly--;break; // }
      }
      if (c === 0x2f) {
        // /
        var j = i - 1;
        var p = void 0;
        // find first non-whitespace prev char
        for (; j >= 0; j--) {
          p = exp.charAt(j);
          if (p !== ' ') {
            break;
          }
        }
        if (!p || !validDivisionCharRE.test(p)) {
          inRegex = true;
        }
      }
    }
  }

  if (expression === undefined) {
    expression = exp.slice(0, i).trim();
  } else if (lastFilterIndex !== 0) {
    pushFilter();
  }

  function pushFilter() {
    (filters || (filters = [])).push(exp.slice(lastFilterIndex, i).trim());
    lastFilterIndex = i + 1;
  }

  if (filters) {
    for (i = 0; i < filters.length; i++) {
      expression = wrapFilter(expression, filters[i]);
    }
  }

  return expression;
}

function wrapFilter(exp, filter) {
  var i = filter.indexOf('(');
  if (i < 0) {
    // _f: resolveFilter
    return "_f(\"" + filter + "\")(" + exp + ")";
  } else {
    var name = filter.slice(0, i);
    var args = filter.slice(i + 1);
    return "_f(\"" + name + "\")(" + exp + "," + args;
  }
}

/*  */

function baseWarn(msg) {
  console.error("[Vue compiler]: " + msg);
}

function pluckModuleFunction(modules, key) {
  return modules ? modules.map(function (m) {
    return m[key];
  }).filter(function (_) {
    return _;
  }) : [];
}

function addProp(el, name, value) {
  (el.props || (el.props = [])).push({ name: name, value: value });
}

function addAttr(el, name, value) {
  (el.attrs || (el.attrs = [])).push({ name: name, value: value });
}

function addDirective(el, name, rawName, value, arg, modifiers) {
  (el.directives || (el.directives = [])).push({ name: name, rawName: rawName, value: value, arg: arg, modifiers: modifiers });
}

function addHandler(el, name, value, modifiers, important, warn) {
  modifiers = modifiers || emptyObject;
  // warn prevent and passive modifier
  /* istanbul ignore if */
  if ("development" !== 'production' && warn && modifiers.prevent && modifiers.passive) {
    warn('passive and prevent can\'t be used together. ' + 'Passive handler can\'t prevent default event.');
  }

  // check capture modifier
  if (modifiers.capture) {
    delete modifiers.capture;
    name = '!' + name; // mark the event as captured
  }
  if (modifiers.once) {
    delete modifiers.once;
    name = '~' + name; // mark the event as once
  }
  /* istanbul ignore if */
  if (modifiers.passive) {
    delete modifiers.passive;
    name = '&' + name; // mark the event as passive
  }

  // normalize click.right and click.middle since they don't actually fire
  // this is technically browser-specific, but at least for now browsers are
  // the only target envs that have right/middle clicks.
  if (name === 'click') {
    if (modifiers.right) {
      name = 'contextmenu';
      delete modifiers.right;
    } else if (modifiers.middle) {
      name = 'mouseup';
    }
  }

  var events;
  if (modifiers.native) {
    delete modifiers.native;
    events = el.nativeEvents || (el.nativeEvents = {});
  } else {
    events = el.events || (el.events = {});
  }

  var newHandler = { value: value };
  if (modifiers !== emptyObject) {
    newHandler.modifiers = modifiers;
  }

  var handlers = events[name];
  /* istanbul ignore if */
  if (Array.isArray(handlers)) {
    important ? handlers.unshift(newHandler) : handlers.push(newHandler);
  } else if (handlers) {
    events[name] = important ? [newHandler, handlers] : [handlers, newHandler];
  } else {
    events[name] = newHandler;
  }
}

function getBindingAttr(el, name, getStatic) {
  var dynamicValue = getAndRemoveAttr(el, ':' + name) || getAndRemoveAttr(el, 'v-bind:' + name);
  if (dynamicValue != null) {
    return parseFilters(dynamicValue);
  } else if (getStatic !== false) {
    var staticValue = getAndRemoveAttr(el, name);
    if (staticValue != null) {
      return JSON.stringify(staticValue);
    }
  }
}

// note: this only removes the attr from the Array (attrsList) so that it
// doesn't get processed by processAttrs.
// By default it does NOT remove it from the map (attrsMap) because the map is
// needed during codegen.
function getAndRemoveAttr(el, name, removeFromMap) {
  var val;
  if ((val = el.attrsMap[name]) != null) {
    var list = el.attrsList;
    for (var i = 0, l = list.length; i < l; i++) {
      if (list[i].name === name) {
        list.splice(i, 1);
        break;
      }
    }
  }
  if (removeFromMap) {
    delete el.attrsMap[name];
  }
  return val;
}

/*  */

/**
 * Cross-platform code generation for component v-model
 */
function genComponentModel(el, value, modifiers) {
  var ref = modifiers || {};
  var number = ref.number;
  var trim = ref.trim;

  var baseValueExpression = '$$v';
  var valueExpression = baseValueExpression;
  if (trim) {
    valueExpression = "(typeof " + baseValueExpression + " === 'string'" + "? " + baseValueExpression + ".trim()" + ": " + baseValueExpression + ")";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }
  var assignment = genAssignmentCode(value, valueExpression);

  el.model = {
    value: "(" + value + ")",
    expression: "\"" + value + "\"",
    callback: "function (" + baseValueExpression + ") {" + assignment + "}"
  };
}

/**
 * Cross-platform codegen helper for generating v-model value assignment code.
 */
function genAssignmentCode(value, assignment) {
  var res = parseModel(value);
  if (res.key === null) {
    return value + "=" + assignment;
  } else {
    return "$set(" + res.exp + ", " + res.key + ", " + assignment + ")";
  }
}

/**
 * Parse a v-model expression into a base path and a final key segment.
 * Handles both dot-path and possible square brackets.
 *
 * Possible cases:
 *
 * - test
 * - test[key]
 * - test[test1[key]]
 * - test["a"][key]
 * - xxx.test[a[a].test1[key]]
 * - test.xxx.a["asa"][test1[key]]
 *
 */

var len;
var str;
var chr;
var index$1;
var expressionPos;
var expressionEndPos;

function parseModel(val) {
  len = val.length;

  if (val.indexOf('[') < 0 || val.lastIndexOf(']') < len - 1) {
    index$1 = val.lastIndexOf('.');
    if (index$1 > -1) {
      return {
        exp: val.slice(0, index$1),
        key: '"' + val.slice(index$1 + 1) + '"'
      };
    } else {
      return {
        exp: val,
        key: null
      };
    }
  }

  str = val;
  index$1 = expressionPos = expressionEndPos = 0;

  while (!eof()) {
    chr = next();
    /* istanbul ignore if */
    if (isStringStart(chr)) {
      parseString(chr);
    } else if (chr === 0x5B) {
      parseBracket(chr);
    }
  }

  return {
    exp: val.slice(0, expressionPos),
    key: val.slice(expressionPos + 1, expressionEndPos)
  };
}

function next() {
  return str.charCodeAt(++index$1);
}

function eof() {
  return index$1 >= len;
}

function isStringStart(chr) {
  return chr === 0x22 || chr === 0x27;
}

function parseBracket(chr) {
  var inBracket = 1;
  expressionPos = index$1;
  while (!eof()) {
    chr = next();
    if (isStringStart(chr)) {
      parseString(chr);
      continue;
    }
    if (chr === 0x5B) {
      inBracket++;
    }
    if (chr === 0x5D) {
      inBracket--;
    }
    if (inBracket === 0) {
      expressionEndPos = index$1;
      break;
    }
  }
}

function parseString(chr) {
  var stringQuote = chr;
  while (!eof()) {
    chr = next();
    if (chr === stringQuote) {
      break;
    }
  }
}

/*  */

var warn$1;

// in some cases, the event used has to be determined at runtime
// so we used some reserved tokens during compile.
var RANGE_TOKEN = '__r';
var CHECKBOX_RADIO_TOKEN = '__c';

function model(el, dir, _warn) {
  warn$1 = _warn;
  var value = dir.value;
  var modifiers = dir.modifiers;
  var tag = el.tag;
  var type = el.attrsMap.type;

  if (true) {
    // inputs with type="file" are read only and setting the input's
    // value will throw an error.
    if (tag === 'input' && type === 'file') {
      warn$1("<" + el.tag + " v-model=\"" + value + "\" type=\"file\">:\n" + "File inputs are read only. Use a v-on:change listener instead.");
    }
  }

  if (el.component) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (tag === 'select') {
    genSelect(el, value, modifiers);
  } else if (tag === 'input' && type === 'checkbox') {
    genCheckboxModel(el, value, modifiers);
  } else if (tag === 'input' && type === 'radio') {
    genRadioModel(el, value, modifiers);
  } else if (tag === 'input' || tag === 'textarea') {
    genDefaultModel(el, value, modifiers);
  } else if (!config.isReservedTag(tag)) {
    genComponentModel(el, value, modifiers);
    // component v-model doesn't need extra runtime
    return false;
  } else if (true) {
    warn$1("<" + el.tag + " v-model=\"" + value + "\">: " + "v-model is not supported on this element type. " + 'If you are working with contenteditable, it\'s recommended to ' + 'wrap a library dedicated for that purpose inside a custom component.');
  }

  // ensure runtime directive metadata
  return true;
}

function genCheckboxModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  var trueValueBinding = getBindingAttr(el, 'true-value') || 'true';
  var falseValueBinding = getBindingAttr(el, 'false-value') || 'false';
  addProp(el, 'checked', "Array.isArray(" + value + ")" + "?_i(" + value + "," + valueBinding + ")>-1" + (trueValueBinding === 'true' ? ":(" + value + ")" : ":_q(" + value + "," + trueValueBinding + ")"));
  addHandler(el, 'change', "var $$a=" + value + "," + '$$el=$event.target,' + "$$c=$$el.checked?(" + trueValueBinding + "):(" + falseValueBinding + ");" + 'if(Array.isArray($$a)){' + "var $$v=" + (number ? '_n(' + valueBinding + ')' : valueBinding) + "," + '$$i=_i($$a,$$v);' + "if($$el.checked){$$i<0&&(" + value + "=$$a.concat([$$v]))}" + "else{$$i>-1&&(" + value + "=$$a.slice(0,$$i).concat($$a.slice($$i+1)))}" + "}else{" + genAssignmentCode(value, '$$c') + "}", null, true);
}

function genRadioModel(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var valueBinding = getBindingAttr(el, 'value') || 'null';
  valueBinding = number ? "_n(" + valueBinding + ")" : valueBinding;
  addProp(el, 'checked', "_q(" + value + "," + valueBinding + ")");
  addHandler(el, 'change', genAssignmentCode(value, valueBinding), null, true);
}

function genSelect(el, value, modifiers) {
  var number = modifiers && modifiers.number;
  var selectedVal = "Array.prototype.filter" + ".call($event.target.options,function(o){return o.selected})" + ".map(function(o){var val = \"_value\" in o ? o._value : o.value;" + "return " + (number ? '_n(val)' : 'val') + "})";

  var assignment = '$event.target.multiple ? $$selectedVal : $$selectedVal[0]';
  var code = "var $$selectedVal = " + selectedVal + ";";
  code = code + " " + genAssignmentCode(value, assignment);
  addHandler(el, 'change', code, null, true);
}

function genDefaultModel(el, value, modifiers) {
  var type = el.attrsMap.type;

  // warn if v-bind:value conflicts with v-model
  if (true) {
    var value$1 = el.attrsMap['v-bind:value'] || el.attrsMap[':value'];
    if (value$1) {
      var binding = el.attrsMap['v-bind:value'] ? 'v-bind:value' : ':value';
      warn$1(binding + "=\"" + value$1 + "\" conflicts with v-model on the same element " + 'because the latter already expands to a value binding internally');
    }
  }

  var ref = modifiers || {};
  var lazy = ref.lazy;
  var number = ref.number;
  var trim = ref.trim;
  var needCompositionGuard = !lazy && type !== 'range';
  var event = lazy ? 'change' : type === 'range' ? RANGE_TOKEN : 'input';

  var valueExpression = '$event.target.value';
  if (trim) {
    valueExpression = "$event.target.value.trim()";
  }
  if (number) {
    valueExpression = "_n(" + valueExpression + ")";
  }

  var code = genAssignmentCode(value, valueExpression);
  if (needCompositionGuard) {
    code = "if($event.target.composing)return;" + code;
  }

  addProp(el, 'value', "(" + value + ")");
  addHandler(el, event, code, null, true);
  if (trim || number) {
    addHandler(el, 'blur', '$forceUpdate()');
  }
}

/*  */

// normalize v-model event tokens that can only be determined at runtime.
// it's important to place the event as the first in the array because
// the whole point is ensuring the v-model callback gets called before
// user-attached handlers.
function normalizeEvents(on) {
  /* istanbul ignore if */
  if (isDef(on[RANGE_TOKEN])) {
    // IE input[type=range] only supports `change` event
    var event = isIE ? 'change' : 'input';
    on[event] = [].concat(on[RANGE_TOKEN], on[event] || []);
    delete on[RANGE_TOKEN];
  }
  // This was originally intended to fix #4521 but no longer necessary
  // after 2.5. Keeping it for backwards compat with generated code from < 2.4
  /* istanbul ignore if */
  if (isDef(on[CHECKBOX_RADIO_TOKEN])) {
    on.change = [].concat(on[CHECKBOX_RADIO_TOKEN], on.change || []);
    delete on[CHECKBOX_RADIO_TOKEN];
  }
}

var target$1;

function createOnceHandler(handler, event, capture) {
  var _target = target$1; // save current target element in closure
  return function onceHandler() {
    var res = handler.apply(null, arguments);
    if (res !== null) {
      remove$2(event, onceHandler, capture, _target);
    }
  };
}

function add$1(event, handler, once$$1, capture, passive) {
  handler = withMacroTask(handler);
  if (once$$1) {
    handler = createOnceHandler(handler, event, capture);
  }
  target$1.addEventListener(event, handler, supportsPassive ? { capture: capture, passive: passive } : capture);
}

function remove$2(event, handler, capture, _target) {
  (_target || target$1).removeEventListener(event, handler._withTask || handler, capture);
}

function updateDOMListeners(oldVnode, vnode) {
  if (isUndef(oldVnode.data.on) && isUndef(vnode.data.on)) {
    return;
  }
  var on = vnode.data.on || {};
  var oldOn = oldVnode.data.on || {};
  target$1 = vnode.elm;
  normalizeEvents(on);
  updateListeners(on, oldOn, add$1, remove$2, vnode.context);
  target$1 = undefined;
}

var events = {
  create: updateDOMListeners,
  update: updateDOMListeners
};

/*  */

function updateDOMProps(oldVnode, vnode) {
  if (isUndef(oldVnode.data.domProps) && isUndef(vnode.data.domProps)) {
    return;
  }
  var key, cur;
  var elm = vnode.elm;
  var oldProps = oldVnode.data.domProps || {};
  var props = vnode.data.domProps || {};
  // clone observed objects, as the user probably wants to mutate it
  if (isDef(props.__ob__)) {
    props = vnode.data.domProps = extend({}, props);
  }

  for (key in oldProps) {
    if (isUndef(props[key])) {
      elm[key] = '';
    }
  }
  for (key in props) {
    cur = props[key];
    // ignore children if the node has textContent or innerHTML,
    // as these will throw away existing DOM nodes and cause removal errors
    // on subsequent patches (#3360)
    if (key === 'textContent' || key === 'innerHTML') {
      if (vnode.children) {
        vnode.children.length = 0;
      }
      if (cur === oldProps[key]) {
        continue;
      }
      // #6601 work around Chrome version <= 55 bug where single textNode
      // replaced by innerHTML/textContent retains its parentNode property
      if (elm.childNodes.length === 1) {
        elm.removeChild(elm.childNodes[0]);
      }
    }

    if (key === 'value') {
      // store value as _value as well since
      // non-string values will be stringified
      elm._value = cur;
      // avoid resetting cursor position when value is the same
      var strCur = isUndef(cur) ? '' : String(cur);
      if (shouldUpdateValue(elm, strCur)) {
        elm.value = strCur;
      }
    } else {
      elm[key] = cur;
    }
  }
}

// check platforms/web/util/attrs.js acceptValue


function shouldUpdateValue(elm, checkVal) {
  return !elm.composing && (elm.tagName === 'OPTION' || isDirty(elm, checkVal) || isInputChanged(elm, checkVal));
}

function isDirty(elm, checkVal) {
  // return true when textbox (.number and .trim) loses focus and its value is
  // not equal to the updated value
  var notInFocus = true;
  // #6157
  // work around IE bug when accessing document.activeElement in an iframe
  try {
    notInFocus = document.activeElement !== elm;
  } catch (e) {}
  return notInFocus && elm.value !== checkVal;
}

function isInputChanged(elm, newVal) {
  var value = elm.value;
  var modifiers = elm._vModifiers; // injected by v-model runtime
  if (isDef(modifiers) && modifiers.number) {
    return toNumber(value) !== toNumber(newVal);
  }
  if (isDef(modifiers) && modifiers.trim) {
    return value.trim() !== newVal.trim();
  }
  return value !== newVal;
}

var domProps = {
  create: updateDOMProps,
  update: updateDOMProps
};

/*  */

var parseStyleText = cached(function (cssText) {
  var res = {};
  var listDelimiter = /;(?![^(]*\))/g;
  var propertyDelimiter = /:(.+)/;
  cssText.split(listDelimiter).forEach(function (item) {
    if (item) {
      var tmp = item.split(propertyDelimiter);
      tmp.length > 1 && (res[tmp[0].trim()] = tmp[1].trim());
    }
  });
  return res;
});

// merge static and dynamic style data on the same vnode
function normalizeStyleData(data) {
  var style = normalizeStyleBinding(data.style);
  // static style is pre-processed into an object during compilation
  // and is always a fresh object, so it's safe to merge into it
  return data.staticStyle ? extend(data.staticStyle, style) : style;
}

// normalize possible array / string values into Object
function normalizeStyleBinding(bindingStyle) {
  if (Array.isArray(bindingStyle)) {
    return toObject(bindingStyle);
  }
  if (typeof bindingStyle === 'string') {
    return parseStyleText(bindingStyle);
  }
  return bindingStyle;
}

/**
 * parent component style should be after child's
 * so that parent component's style could override it
 */
function getStyle(vnode, checkChild) {
  var res = {};
  var styleData;

  if (checkChild) {
    var childNode = vnode;
    while (childNode.componentInstance) {
      childNode = childNode.componentInstance._vnode;
      if (childNode.data && (styleData = normalizeStyleData(childNode.data))) {
        extend(res, styleData);
      }
    }
  }

  if (styleData = normalizeStyleData(vnode.data)) {
    extend(res, styleData);
  }

  var parentNode = vnode;
  while (parentNode = parentNode.parent) {
    if (parentNode.data && (styleData = normalizeStyleData(parentNode.data))) {
      extend(res, styleData);
    }
  }
  return res;
}

/*  */

var cssVarRE = /^--/;
var importantRE = /\s*!important$/;
var setProp = function setProp(el, name, val) {
  /* istanbul ignore if */
  if (cssVarRE.test(name)) {
    el.style.setProperty(name, val);
  } else if (importantRE.test(val)) {
    el.style.setProperty(name, val.replace(importantRE, ''), 'important');
  } else {
    var normalizedName = normalize(name);
    if (Array.isArray(val)) {
      // Support values array created by autoprefixer, e.g.
      // {display: ["-webkit-box", "-ms-flexbox", "flex"]}
      // Set them one by one, and the browser will only set those it can recognize
      for (var i = 0, len = val.length; i < len; i++) {
        el.style[normalizedName] = val[i];
      }
    } else {
      el.style[normalizedName] = val;
    }
  }
};

var vendorNames = ['Webkit', 'Moz', 'ms'];

var emptyStyle;
var normalize = cached(function (prop) {
  emptyStyle = emptyStyle || document.createElement('div').style;
  prop = camelize(prop);
  if (prop !== 'filter' && prop in emptyStyle) {
    return prop;
  }
  var capName = prop.charAt(0).toUpperCase() + prop.slice(1);
  for (var i = 0; i < vendorNames.length; i++) {
    var name = vendorNames[i] + capName;
    if (name in emptyStyle) {
      return name;
    }
  }
});

function updateStyle(oldVnode, vnode) {
  var data = vnode.data;
  var oldData = oldVnode.data;

  if (isUndef(data.staticStyle) && isUndef(data.style) && isUndef(oldData.staticStyle) && isUndef(oldData.style)) {
    return;
  }

  var cur, name;
  var el = vnode.elm;
  var oldStaticStyle = oldData.staticStyle;
  var oldStyleBinding = oldData.normalizedStyle || oldData.style || {};

  // if static style exists, stylebinding already merged into it when doing normalizeStyleData
  var oldStyle = oldStaticStyle || oldStyleBinding;

  var style = normalizeStyleBinding(vnode.data.style) || {};

  // store normalized style under a different key for next diff
  // make sure to clone it if it's reactive, since the user likely wants
  // to mutate it.
  vnode.data.normalizedStyle = isDef(style.__ob__) ? extend({}, style) : style;

  var newStyle = getStyle(vnode, true);

  for (name in oldStyle) {
    if (isUndef(newStyle[name])) {
      setProp(el, name, '');
    }
  }
  for (name in newStyle) {
    cur = newStyle[name];
    if (cur !== oldStyle[name]) {
      // ie9 setting to null has no effect, must use empty string
      setProp(el, name, cur == null ? '' : cur);
    }
  }
}

var style = {
  create: updateStyle,
  update: updateStyle
};

/*  */

/**
 * Add class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function addClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.add(c);
      });
    } else {
      el.classList.add(cls);
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    if (cur.indexOf(' ' + cls + ' ') < 0) {
      el.setAttribute('class', (cur + cls).trim());
    }
  }
}

/**
 * Remove class with compatibility for SVG since classList is not supported on
 * SVG elements in IE
 */
function removeClass(el, cls) {
  /* istanbul ignore if */
  if (!cls || !(cls = cls.trim())) {
    return;
  }

  /* istanbul ignore else */
  if (el.classList) {
    if (cls.indexOf(' ') > -1) {
      cls.split(/\s+/).forEach(function (c) {
        return el.classList.remove(c);
      });
    } else {
      el.classList.remove(cls);
    }
    if (!el.classList.length) {
      el.removeAttribute('class');
    }
  } else {
    var cur = " " + (el.getAttribute('class') || '') + " ";
    var tar = ' ' + cls + ' ';
    while (cur.indexOf(tar) >= 0) {
      cur = cur.replace(tar, ' ');
    }
    cur = cur.trim();
    if (cur) {
      el.setAttribute('class', cur);
    } else {
      el.removeAttribute('class');
    }
  }
}

/*  */

function resolveTransition(def) {
  if (!def) {
    return;
  }
  /* istanbul ignore else */
  if ((typeof def === 'undefined' ? 'undefined' : _typeof(def)) === 'object') {
    var res = {};
    if (def.css !== false) {
      extend(res, autoCssTransition(def.name || 'v'));
    }
    extend(res, def);
    return res;
  } else if (typeof def === 'string') {
    return autoCssTransition(def);
  }
}

var autoCssTransition = cached(function (name) {
  return {
    enterClass: name + "-enter",
    enterToClass: name + "-enter-to",
    enterActiveClass: name + "-enter-active",
    leaveClass: name + "-leave",
    leaveToClass: name + "-leave-to",
    leaveActiveClass: name + "-leave-active"
  };
});

var hasTransition = inBrowser && !isIE9;
var TRANSITION = 'transition';
var ANIMATION = 'animation';

// Transition property/event sniffing
var transitionProp = 'transition';
var transitionEndEvent = 'transitionend';
var animationProp = 'animation';
var animationEndEvent = 'animationend';
if (hasTransition) {
  /* istanbul ignore if */
  if (window.ontransitionend === undefined && window.onwebkittransitionend !== undefined) {
    transitionProp = 'WebkitTransition';
    transitionEndEvent = 'webkitTransitionEnd';
  }
  if (window.onanimationend === undefined && window.onwebkitanimationend !== undefined) {
    animationProp = 'WebkitAnimation';
    animationEndEvent = 'webkitAnimationEnd';
  }
}

// binding to window is necessary to make hot reload work in IE in strict mode
var raf = inBrowser ? window.requestAnimationFrame ? window.requestAnimationFrame.bind(window) : setTimeout : /* istanbul ignore next */function (fn) {
  return fn();
};

function nextFrame(fn) {
  raf(function () {
    raf(fn);
  });
}

function addTransitionClass(el, cls) {
  var transitionClasses = el._transitionClasses || (el._transitionClasses = []);
  if (transitionClasses.indexOf(cls) < 0) {
    transitionClasses.push(cls);
    addClass(el, cls);
  }
}

function removeTransitionClass(el, cls) {
  if (el._transitionClasses) {
    remove(el._transitionClasses, cls);
  }
  removeClass(el, cls);
}

function whenTransitionEnds(el, expectedType, cb) {
  var ref = getTransitionInfo(el, expectedType);
  var type = ref.type;
  var timeout = ref.timeout;
  var propCount = ref.propCount;
  if (!type) {
    return cb();
  }
  var event = type === TRANSITION ? transitionEndEvent : animationEndEvent;
  var ended = 0;
  var end = function end() {
    el.removeEventListener(event, onEnd);
    cb();
  };
  var onEnd = function onEnd(e) {
    if (e.target === el) {
      if (++ended >= propCount) {
        end();
      }
    }
  };
  setTimeout(function () {
    if (ended < propCount) {
      end();
    }
  }, timeout + 1);
  el.addEventListener(event, onEnd);
}

var transformRE = /\b(transform|all)(,|$)/;

function getTransitionInfo(el, expectedType) {
  var styles = window.getComputedStyle(el);
  var transitionDelays = styles[transitionProp + 'Delay'].split(', ');
  var transitionDurations = styles[transitionProp + 'Duration'].split(', ');
  var transitionTimeout = getTimeout(transitionDelays, transitionDurations);
  var animationDelays = styles[animationProp + 'Delay'].split(', ');
  var animationDurations = styles[animationProp + 'Duration'].split(', ');
  var animationTimeout = getTimeout(animationDelays, animationDurations);

  var type;
  var timeout = 0;
  var propCount = 0;
  /* istanbul ignore if */
  if (expectedType === TRANSITION) {
    if (transitionTimeout > 0) {
      type = TRANSITION;
      timeout = transitionTimeout;
      propCount = transitionDurations.length;
    }
  } else if (expectedType === ANIMATION) {
    if (animationTimeout > 0) {
      type = ANIMATION;
      timeout = animationTimeout;
      propCount = animationDurations.length;
    }
  } else {
    timeout = Math.max(transitionTimeout, animationTimeout);
    type = timeout > 0 ? transitionTimeout > animationTimeout ? TRANSITION : ANIMATION : null;
    propCount = type ? type === TRANSITION ? transitionDurations.length : animationDurations.length : 0;
  }
  var hasTransform = type === TRANSITION && transformRE.test(styles[transitionProp + 'Property']);
  return {
    type: type,
    timeout: timeout,
    propCount: propCount,
    hasTransform: hasTransform
  };
}

function getTimeout(delays, durations) {
  /* istanbul ignore next */
  while (delays.length < durations.length) {
    delays = delays.concat(delays);
  }

  return Math.max.apply(null, durations.map(function (d, i) {
    return toMs(d) + toMs(delays[i]);
  }));
}

function toMs(s) {
  return Number(s.slice(0, -1)) * 1000;
}

/*  */

function enter(vnode, toggleDisplay) {
  var el = vnode.elm;

  // call leave callback now
  if (isDef(el._leaveCb)) {
    el._leaveCb.cancelled = true;
    el._leaveCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data)) {
    return;
  }

  /* istanbul ignore if */
  if (isDef(el._enterCb) || el.nodeType !== 1) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var enterClass = data.enterClass;
  var enterToClass = data.enterToClass;
  var enterActiveClass = data.enterActiveClass;
  var appearClass = data.appearClass;
  var appearToClass = data.appearToClass;
  var appearActiveClass = data.appearActiveClass;
  var beforeEnter = data.beforeEnter;
  var enter = data.enter;
  var afterEnter = data.afterEnter;
  var enterCancelled = data.enterCancelled;
  var beforeAppear = data.beforeAppear;
  var appear = data.appear;
  var afterAppear = data.afterAppear;
  var appearCancelled = data.appearCancelled;
  var duration = data.duration;

  // activeInstance will always be the <transition> component managing this
  // transition. One edge case to check is when the <transition> is placed
  // as the root node of a child component. In that case we need to check
  // <transition>'s parent for appear check.
  var context = activeInstance;
  var transitionNode = activeInstance.$vnode;
  while (transitionNode && transitionNode.parent) {
    transitionNode = transitionNode.parent;
    context = transitionNode.context;
  }

  var isAppear = !context._isMounted || !vnode.isRootInsert;

  if (isAppear && !appear && appear !== '') {
    return;
  }

  var startClass = isAppear && appearClass ? appearClass : enterClass;
  var activeClass = isAppear && appearActiveClass ? appearActiveClass : enterActiveClass;
  var toClass = isAppear && appearToClass ? appearToClass : enterToClass;

  var beforeEnterHook = isAppear ? beforeAppear || beforeEnter : beforeEnter;
  var enterHook = isAppear ? typeof appear === 'function' ? appear : enter : enter;
  var afterEnterHook = isAppear ? afterAppear || afterEnter : afterEnter;
  var enterCancelledHook = isAppear ? appearCancelled || enterCancelled : enterCancelled;

  var explicitEnterDuration = toNumber(isObject(duration) ? duration.enter : duration);

  if ("development" !== 'production' && explicitEnterDuration != null) {
    checkDuration(explicitEnterDuration, 'enter', vnode);
  }

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(enterHook);

  var cb = el._enterCb = once(function () {
    if (expectsCSS) {
      removeTransitionClass(el, toClass);
      removeTransitionClass(el, activeClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, startClass);
      }
      enterCancelledHook && enterCancelledHook(el);
    } else {
      afterEnterHook && afterEnterHook(el);
    }
    el._enterCb = null;
  });

  if (!vnode.data.show) {
    // remove pending leave element on enter by injecting an insert hook
    mergeVNodeHook(vnode, 'insert', function () {
      var parent = el.parentNode;
      var pendingNode = parent && parent._pending && parent._pending[vnode.key];
      if (pendingNode && pendingNode.tag === vnode.tag && pendingNode.elm._leaveCb) {
        pendingNode.elm._leaveCb();
      }
      enterHook && enterHook(el, cb);
    });
  }

  // start enter transition
  beforeEnterHook && beforeEnterHook(el);
  if (expectsCSS) {
    addTransitionClass(el, startClass);
    addTransitionClass(el, activeClass);
    nextFrame(function () {
      addTransitionClass(el, toClass);
      removeTransitionClass(el, startClass);
      if (!cb.cancelled && !userWantsControl) {
        if (isValidDuration(explicitEnterDuration)) {
          setTimeout(cb, explicitEnterDuration);
        } else {
          whenTransitionEnds(el, type, cb);
        }
      }
    });
  }

  if (vnode.data.show) {
    toggleDisplay && toggleDisplay();
    enterHook && enterHook(el, cb);
  }

  if (!expectsCSS && !userWantsControl) {
    cb();
  }
}

function leave(vnode, rm) {
  var el = vnode.elm;

  // call enter callback now
  if (isDef(el._enterCb)) {
    el._enterCb.cancelled = true;
    el._enterCb();
  }

  var data = resolveTransition(vnode.data.transition);
  if (isUndef(data) || el.nodeType !== 1) {
    return rm();
  }

  /* istanbul ignore if */
  if (isDef(el._leaveCb)) {
    return;
  }

  var css = data.css;
  var type = data.type;
  var leaveClass = data.leaveClass;
  var leaveToClass = data.leaveToClass;
  var leaveActiveClass = data.leaveActiveClass;
  var beforeLeave = data.beforeLeave;
  var leave = data.leave;
  var afterLeave = data.afterLeave;
  var leaveCancelled = data.leaveCancelled;
  var delayLeave = data.delayLeave;
  var duration = data.duration;

  var expectsCSS = css !== false && !isIE9;
  var userWantsControl = getHookArgumentsLength(leave);

  var explicitLeaveDuration = toNumber(isObject(duration) ? duration.leave : duration);

  if ("development" !== 'production' && isDef(explicitLeaveDuration)) {
    checkDuration(explicitLeaveDuration, 'leave', vnode);
  }

  var cb = el._leaveCb = once(function () {
    if (el.parentNode && el.parentNode._pending) {
      el.parentNode._pending[vnode.key] = null;
    }
    if (expectsCSS) {
      removeTransitionClass(el, leaveToClass);
      removeTransitionClass(el, leaveActiveClass);
    }
    if (cb.cancelled) {
      if (expectsCSS) {
        removeTransitionClass(el, leaveClass);
      }
      leaveCancelled && leaveCancelled(el);
    } else {
      rm();
      afterLeave && afterLeave(el);
    }
    el._leaveCb = null;
  });

  if (delayLeave) {
    delayLeave(performLeave);
  } else {
    performLeave();
  }

  function performLeave() {
    // the delayed leave may have already been cancelled
    if (cb.cancelled) {
      return;
    }
    // record leaving element
    if (!vnode.data.show) {
      (el.parentNode._pending || (el.parentNode._pending = {}))[vnode.key] = vnode;
    }
    beforeLeave && beforeLeave(el);
    if (expectsCSS) {
      addTransitionClass(el, leaveClass);
      addTransitionClass(el, leaveActiveClass);
      nextFrame(function () {
        addTransitionClass(el, leaveToClass);
        removeTransitionClass(el, leaveClass);
        if (!cb.cancelled && !userWantsControl) {
          if (isValidDuration(explicitLeaveDuration)) {
            setTimeout(cb, explicitLeaveDuration);
          } else {
            whenTransitionEnds(el, type, cb);
          }
        }
      });
    }
    leave && leave(el, cb);
    if (!expectsCSS && !userWantsControl) {
      cb();
    }
  }
}

// only used in dev mode
function checkDuration(val, name, vnode) {
  if (typeof val !== 'number') {
    warn("<transition> explicit " + name + " duration is not a valid number - " + "got " + JSON.stringify(val) + ".", vnode.context);
  } else if (isNaN(val)) {
    warn("<transition> explicit " + name + " duration is NaN - " + 'the duration expression might be incorrect.', vnode.context);
  }
}

function isValidDuration(val) {
  return typeof val === 'number' && !isNaN(val);
}

/**
 * Normalize a transition hook's argument length. The hook may be:
 * - a merged hook (invoker) with the original in .fns
 * - a wrapped component method (check ._length)
 * - a plain function (.length)
 */
function getHookArgumentsLength(fn) {
  if (isUndef(fn)) {
    return false;
  }
  var invokerFns = fn.fns;
  if (isDef(invokerFns)) {
    // invoker
    return getHookArgumentsLength(Array.isArray(invokerFns) ? invokerFns[0] : invokerFns);
  } else {
    return (fn._length || fn.length) > 1;
  }
}

function _enter(_, vnode) {
  if (vnode.data.show !== true) {
    enter(vnode);
  }
}

var transition = inBrowser ? {
  create: _enter,
  activate: _enter,
  remove: function remove$$1(vnode, rm) {
    /* istanbul ignore else */
    if (vnode.data.show !== true) {
      leave(vnode, rm);
    } else {
      rm();
    }
  }
} : {};

var platformModules = [attrs, klass, events, domProps, style, transition];

/*  */

// the directive module should be applied last, after all
// built-in modules have been applied.
var modules = platformModules.concat(baseModules);

var patch = createPatchFunction({ nodeOps: nodeOps, modules: modules });

/**
 * Not type checking this file because flow doesn't like attaching
 * properties to Elements.
 */

/* istanbul ignore if */
if (isIE9) {
  // http://www.matts411.com/post/internet-explorer-9-oninput/
  document.addEventListener('selectionchange', function () {
    var el = document.activeElement;
    if (el && el.vmodel) {
      trigger(el, 'input');
    }
  });
}

var directive = {
  inserted: function inserted(el, binding, vnode, oldVnode) {
    if (vnode.tag === 'select') {
      // #6903
      if (oldVnode.elm && !oldVnode.elm._vOptions) {
        mergeVNodeHook(vnode, 'postpatch', function () {
          directive.componentUpdated(el, binding, vnode);
        });
      } else {
        setSelected(el, binding, vnode.context);
      }
      el._vOptions = [].map.call(el.options, getValue);
    } else if (vnode.tag === 'textarea' || isTextInputType(el.type)) {
      el._vModifiers = binding.modifiers;
      if (!binding.modifiers.lazy) {
        // Safari < 10.2 & UIWebView doesn't fire compositionend when
        // switching focus before confirming composition choice
        // this also fixes the issue where some browsers e.g. iOS Chrome
        // fires "change" instead of "input" on autocomplete.
        el.addEventListener('change', onCompositionEnd);
        if (!isAndroid) {
          el.addEventListener('compositionstart', onCompositionStart);
          el.addEventListener('compositionend', onCompositionEnd);
        }
        /* istanbul ignore if */
        if (isIE9) {
          el.vmodel = true;
        }
      }
    }
  },

  componentUpdated: function componentUpdated(el, binding, vnode) {
    if (vnode.tag === 'select') {
      setSelected(el, binding, vnode.context);
      // in case the options rendered by v-for have changed,
      // it's possible that the value is out-of-sync with the rendered options.
      // detect such cases and filter out values that no longer has a matching
      // option in the DOM.
      var prevOptions = el._vOptions;
      var curOptions = el._vOptions = [].map.call(el.options, getValue);
      if (curOptions.some(function (o, i) {
        return !looseEqual(o, prevOptions[i]);
      })) {
        // trigger change event if
        // no matching option found for at least one value
        var needReset = el.multiple ? binding.value.some(function (v) {
          return hasNoMatchingOption(v, curOptions);
        }) : binding.value !== binding.oldValue && hasNoMatchingOption(binding.value, curOptions);
        if (needReset) {
          trigger(el, 'change');
        }
      }
    }
  }
};

function setSelected(el, binding, vm) {
  actuallySetSelected(el, binding, vm);
  /* istanbul ignore if */
  if (isIE || isEdge) {
    setTimeout(function () {
      actuallySetSelected(el, binding, vm);
    }, 0);
  }
}

function actuallySetSelected(el, binding, vm) {
  var value = binding.value;
  var isMultiple = el.multiple;
  if (isMultiple && !Array.isArray(value)) {
    "development" !== 'production' && warn("<select multiple v-model=\"" + binding.expression + "\"> " + "expects an Array value for its binding, but got " + Object.prototype.toString.call(value).slice(8, -1), vm);
    return;
  }
  var selected, option;
  for (var i = 0, l = el.options.length; i < l; i++) {
    option = el.options[i];
    if (isMultiple) {
      selected = looseIndexOf(value, getValue(option)) > -1;
      if (option.selected !== selected) {
        option.selected = selected;
      }
    } else {
      if (looseEqual(getValue(option), value)) {
        if (el.selectedIndex !== i) {
          el.selectedIndex = i;
        }
        return;
      }
    }
  }
  if (!isMultiple) {
    el.selectedIndex = -1;
  }
}

function hasNoMatchingOption(value, options) {
  return options.every(function (o) {
    return !looseEqual(o, value);
  });
}

function getValue(option) {
  return '_value' in option ? option._value : option.value;
}

function onCompositionStart(e) {
  e.target.composing = true;
}

function onCompositionEnd(e) {
  // prevent triggering an input event for no reason
  if (!e.target.composing) {
    return;
  }
  e.target.composing = false;
  trigger(e.target, 'input');
}

function trigger(el, type) {
  var e = document.createEvent('HTMLEvents');
  e.initEvent(type, true, true);
  el.dispatchEvent(e);
}

/*  */

// recursively search for possible transition defined inside the component root
function locateNode(vnode) {
  return vnode.componentInstance && (!vnode.data || !vnode.data.transition) ? locateNode(vnode.componentInstance._vnode) : vnode;
}

var show = {
  bind: function bind(el, ref, vnode) {
    var value = ref.value;

    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    var originalDisplay = el.__vOriginalDisplay = el.style.display === 'none' ? '' : el.style.display;
    if (value && transition$$1) {
      vnode.data.show = true;
      enter(vnode, function () {
        el.style.display = originalDisplay;
      });
    } else {
      el.style.display = value ? originalDisplay : 'none';
    }
  },

  update: function update(el, ref, vnode) {
    var value = ref.value;
    var oldValue = ref.oldValue;

    /* istanbul ignore if */
    if (value === oldValue) {
      return;
    }
    vnode = locateNode(vnode);
    var transition$$1 = vnode.data && vnode.data.transition;
    if (transition$$1) {
      vnode.data.show = true;
      if (value) {
        enter(vnode, function () {
          el.style.display = el.__vOriginalDisplay;
        });
      } else {
        leave(vnode, function () {
          el.style.display = 'none';
        });
      }
    } else {
      el.style.display = value ? el.__vOriginalDisplay : 'none';
    }
  },

  unbind: function unbind(el, binding, vnode, oldVnode, isDestroy) {
    if (!isDestroy) {
      el.style.display = el.__vOriginalDisplay;
    }
  }
};

var platformDirectives = {
  model: directive,
  show: show
};

/*  */

// Provides transition support for a single element/component.
// supports transition mode (out-in / in-out)

var transitionProps = {
  name: String,
  appear: Boolean,
  css: Boolean,
  mode: String,
  type: String,
  enterClass: String,
  leaveClass: String,
  enterToClass: String,
  leaveToClass: String,
  enterActiveClass: String,
  leaveActiveClass: String,
  appearClass: String,
  appearActiveClass: String,
  appearToClass: String,
  duration: [Number, String, Object]
};

// in case the child is also an abstract component, e.g. <keep-alive>
// we want to recursively retrieve the real component to be rendered
function getRealChild(vnode) {
  var compOptions = vnode && vnode.componentOptions;
  if (compOptions && compOptions.Ctor.options.abstract) {
    return getRealChild(getFirstComponentChild(compOptions.children));
  } else {
    return vnode;
  }
}

function extractTransitionData(comp) {
  var data = {};
  var options = comp.$options;
  // props
  for (var key in options.propsData) {
    data[key] = comp[key];
  }
  // events.
  // extract listeners and pass them directly to the transition methods
  var listeners = options._parentListeners;
  for (var key$1 in listeners) {
    data[camelize(key$1)] = listeners[key$1];
  }
  return data;
}

function placeholder(h, rawChild) {
  if (/\d-keep-alive$/.test(rawChild.tag)) {
    return h('keep-alive', {
      props: rawChild.componentOptions.propsData
    });
  }
}

function hasParentTransition(vnode) {
  while (vnode = vnode.parent) {
    if (vnode.data.transition) {
      return true;
    }
  }
}

function isSameChild(child, oldChild) {
  return oldChild.key === child.key && oldChild.tag === child.tag;
}

var Transition = {
  name: 'transition',
  props: transitionProps,
  abstract: true,

  render: function render(h) {
    var this$1 = this;

    var children = this.$slots.default;
    if (!children) {
      return;
    }

    // filter out text nodes (possible whitespaces)
    children = children.filter(function (c) {
      return c.tag || isAsyncPlaceholder(c);
    });
    /* istanbul ignore if */
    if (!children.length) {
      return;
    }

    // warn multiple elements
    if ("development" !== 'production' && children.length > 1) {
      warn('<transition> can only be used on a single element. Use ' + '<transition-group> for lists.', this.$parent);
    }

    var mode = this.mode;

    // warn invalid mode
    if ("development" !== 'production' && mode && mode !== 'in-out' && mode !== 'out-in') {
      warn('invalid <transition> mode: ' + mode, this.$parent);
    }

    var rawChild = children[0];

    // if this is a component root node and the component's
    // parent container node also has transition, skip.
    if (hasParentTransition(this.$vnode)) {
      return rawChild;
    }

    // apply transition data to child
    // use getRealChild() to ignore abstract components e.g. keep-alive
    var child = getRealChild(rawChild);
    /* istanbul ignore if */
    if (!child) {
      return rawChild;
    }

    if (this._leaving) {
      return placeholder(h, rawChild);
    }

    // ensure a key that is unique to the vnode type and to this transition
    // component instance. This key will be used to remove pending leaving nodes
    // during entering.
    var id = "__transition-" + this._uid + "-";
    child.key = child.key == null ? child.isComment ? id + 'comment' : id + child.tag : isPrimitive(child.key) ? String(child.key).indexOf(id) === 0 ? child.key : id + child.key : child.key;

    var data = (child.data || (child.data = {})).transition = extractTransitionData(this);
    var oldRawChild = this._vnode;
    var oldChild = getRealChild(oldRawChild);

    // mark v-show
    // so that the transition module can hand over the control to the directive
    if (child.data.directives && child.data.directives.some(function (d) {
      return d.name === 'show';
    })) {
      child.data.show = true;
    }

    if (oldChild && oldChild.data && !isSameChild(child, oldChild) && !isAsyncPlaceholder(oldChild) &&
    // #6687 component root is a comment node
    !(oldChild.componentInstance && oldChild.componentInstance._vnode.isComment)) {
      // replace old child transition data with fresh one
      // important for dynamic transitions!
      var oldData = oldChild.data.transition = extend({}, data);
      // handle transition mode
      if (mode === 'out-in') {
        // return placeholder node and queue update when leave finishes
        this._leaving = true;
        mergeVNodeHook(oldData, 'afterLeave', function () {
          this$1._leaving = false;
          this$1.$forceUpdate();
        });
        return placeholder(h, rawChild);
      } else if (mode === 'in-out') {
        if (isAsyncPlaceholder(child)) {
          return oldRawChild;
        }
        var delayedLeave;
        var performLeave = function performLeave() {
          delayedLeave();
        };
        mergeVNodeHook(data, 'afterEnter', performLeave);
        mergeVNodeHook(data, 'enterCancelled', performLeave);
        mergeVNodeHook(oldData, 'delayLeave', function (leave) {
          delayedLeave = leave;
        });
      }
    }

    return rawChild;
  }
};

/*  */

// Provides transition support for list items.
// supports move transitions using the FLIP technique.

// Because the vdom's children update algorithm is "unstable" - i.e.
// it doesn't guarantee the relative positioning of removed elements,
// we force transition-group to update its children into two passes:
// in the first pass, we remove all nodes that need to be removed,
// triggering their leaving transition; in the second pass, we insert/move
// into the final desired state. This way in the second pass removed
// nodes will remain where they should be.

var props = extend({
  tag: String,
  moveClass: String
}, transitionProps);

delete props.mode;

var TransitionGroup = {
  props: props,

  render: function render(h) {
    var tag = this.tag || this.$vnode.data.tag || 'span';
    var map = Object.create(null);
    var prevChildren = this.prevChildren = this.children;
    var rawChildren = this.$slots.default || [];
    var children = this.children = [];
    var transitionData = extractTransitionData(this);

    for (var i = 0; i < rawChildren.length; i++) {
      var c = rawChildren[i];
      if (c.tag) {
        if (c.key != null && String(c.key).indexOf('__vlist') !== 0) {
          children.push(c);
          map[c.key] = c;(c.data || (c.data = {})).transition = transitionData;
        } else if (true) {
          var opts = c.componentOptions;
          var name = opts ? opts.Ctor.options.name || opts.tag || '' : c.tag;
          warn("<transition-group> children must be keyed: <" + name + ">");
        }
      }
    }

    if (prevChildren) {
      var kept = [];
      var removed = [];
      for (var i$1 = 0; i$1 < prevChildren.length; i$1++) {
        var c$1 = prevChildren[i$1];
        c$1.data.transition = transitionData;
        c$1.data.pos = c$1.elm.getBoundingClientRect();
        if (map[c$1.key]) {
          kept.push(c$1);
        } else {
          removed.push(c$1);
        }
      }
      this.kept = h(tag, null, kept);
      this.removed = removed;
    }

    return h(tag, null, children);
  },

  beforeUpdate: function beforeUpdate() {
    // force removing pass
    this.__patch__(this._vnode, this.kept, false, // hydrating
    true // removeOnly (!important, avoids unnecessary moves)
    );
    this._vnode = this.kept;
  },

  updated: function updated() {
    var children = this.prevChildren;
    var moveClass = this.moveClass || (this.name || 'v') + '-move';
    if (!children.length || !this.hasMove(children[0].elm, moveClass)) {
      return;
    }

    // we divide the work into three loops to avoid mixing DOM reads and writes
    // in each iteration - which helps prevent layout thrashing.
    children.forEach(callPendingCbs);
    children.forEach(recordPosition);
    children.forEach(applyTranslation);

    // force reflow to put everything in position
    // assign to this to avoid being removed in tree-shaking
    // $flow-disable-line
    this._reflow = document.body.offsetHeight;

    children.forEach(function (c) {
      if (c.data.moved) {
        var el = c.elm;
        var s = el.style;
        addTransitionClass(el, moveClass);
        s.transform = s.WebkitTransform = s.transitionDuration = '';
        el.addEventListener(transitionEndEvent, el._moveCb = function cb(e) {
          if (!e || /transform$/.test(e.propertyName)) {
            el.removeEventListener(transitionEndEvent, cb);
            el._moveCb = null;
            removeTransitionClass(el, moveClass);
          }
        });
      }
    });
  },

  methods: {
    hasMove: function hasMove(el, moveClass) {
      /* istanbul ignore if */
      if (!hasTransition) {
        return false;
      }
      /* istanbul ignore if */
      if (this._hasMove) {
        return this._hasMove;
      }
      // Detect whether an element with the move class applied has
      // CSS transitions. Since the element may be inside an entering
      // transition at this very moment, we make a clone of it and remove
      // all other transition classes applied to ensure only the move class
      // is applied.
      var clone = el.cloneNode();
      if (el._transitionClasses) {
        el._transitionClasses.forEach(function (cls) {
          removeClass(clone, cls);
        });
      }
      addClass(clone, moveClass);
      clone.style.display = 'none';
      this.$el.appendChild(clone);
      var info = getTransitionInfo(clone);
      this.$el.removeChild(clone);
      return this._hasMove = info.hasTransform;
    }
  }
};

function callPendingCbs(c) {
  /* istanbul ignore if */
  if (c.elm._moveCb) {
    c.elm._moveCb();
  }
  /* istanbul ignore if */
  if (c.elm._enterCb) {
    c.elm._enterCb();
  }
}

function recordPosition(c) {
  c.data.newPos = c.elm.getBoundingClientRect();
}

function applyTranslation(c) {
  var oldPos = c.data.pos;
  var newPos = c.data.newPos;
  var dx = oldPos.left - newPos.left;
  var dy = oldPos.top - newPos.top;
  if (dx || dy) {
    c.data.moved = true;
    var s = c.elm.style;
    s.transform = s.WebkitTransform = "translate(" + dx + "px," + dy + "px)";
    s.transitionDuration = '0s';
  }
}

var platformComponents = {
  Transition: Transition,
  TransitionGroup: TransitionGroup
};

/*  */

// install platform specific utils
Vue$3.config.mustUseProp = mustUseProp;
Vue$3.config.isReservedTag = isReservedTag;
Vue$3.config.isReservedAttr = isReservedAttr;
Vue$3.config.getTagNamespace = getTagNamespace;
Vue$3.config.isUnknownElement = isUnknownElement;

// install platform runtime directives & components
extend(Vue$3.options.directives, platformDirectives);
extend(Vue$3.options.components, platformComponents);

// install platform patch function
Vue$3.prototype.__patch__ = inBrowser ? patch : noop;

// public mount method
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && inBrowser ? query(el) : undefined;
  return mountComponent(this, el, hydrating);
};

// devtools global hook
/* istanbul ignore next */
Vue$3.nextTick(function () {
  if (config.devtools) {
    if (devtools) {
      devtools.emit('init', Vue$3);
    } else if ("development" !== 'production' && isChrome) {
      console[console.info ? 'info' : 'log']('Download the Vue Devtools extension for a better development experience:\n' + 'https://github.com/vuejs/vue-devtools');
    }
  }
  if ("development" !== 'production' && config.productionTip !== false && inBrowser && typeof console !== 'undefined') {
    console[console.info ? 'info' : 'log']("You are running Vue in development mode.\n" + "Make sure to turn on production mode when deploying for production.\n" + "See more tips at https://vuejs.org/guide/deployment.html");
  }
}, 0);

/*  */

var defaultTagRE = /\{\{((?:.|\n)+?)\}\}/g;
var regexEscapeRE = /[-.*+?^${}()|[\]\/\\]/g;

var buildRegex = cached(function (delimiters) {
  var open = delimiters[0].replace(regexEscapeRE, '\\$&');
  var close = delimiters[1].replace(regexEscapeRE, '\\$&');
  return new RegExp(open + '((?:.|\\n)+?)' + close, 'g');
});

function parseText(text, delimiters) {
  var tagRE = delimiters ? buildRegex(delimiters) : defaultTagRE;
  if (!tagRE.test(text)) {
    return;
  }
  var tokens = [];
  var lastIndex = tagRE.lastIndex = 0;
  var match, index;
  while (match = tagRE.exec(text)) {
    index = match.index;
    // push text token
    if (index > lastIndex) {
      tokens.push(JSON.stringify(text.slice(lastIndex, index)));
    }
    // tag token
    var exp = parseFilters(match[1].trim());
    tokens.push("_s(" + exp + ")");
    lastIndex = index + match[0].length;
  }
  if (lastIndex < text.length) {
    tokens.push(JSON.stringify(text.slice(lastIndex)));
  }
  return tokens.join('+');
}

/*  */

function transformNode(el, options) {
  var warn = options.warn || baseWarn;
  var staticClass = getAndRemoveAttr(el, 'class');
  if ("development" !== 'production' && staticClass) {
    var expression = parseText(staticClass, options.delimiters);
    if (expression) {
      warn("class=\"" + staticClass + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div class="{{ val }}">, use <div :class="val">.');
    }
  }
  if (staticClass) {
    el.staticClass = JSON.stringify(staticClass);
  }
  var classBinding = getBindingAttr(el, 'class', false /* getStatic */);
  if (classBinding) {
    el.classBinding = classBinding;
  }
}

function genData(el) {
  var data = '';
  if (el.staticClass) {
    data += "staticClass:" + el.staticClass + ",";
  }
  if (el.classBinding) {
    data += "class:" + el.classBinding + ",";
  }
  return data;
}

var klass$1 = {
  staticKeys: ['staticClass'],
  transformNode: transformNode,
  genData: genData
};

/*  */

function transformNode$1(el, options) {
  var warn = options.warn || baseWarn;
  var staticStyle = getAndRemoveAttr(el, 'style');
  if (staticStyle) {
    /* istanbul ignore if */
    if (true) {
      var expression = parseText(staticStyle, options.delimiters);
      if (expression) {
        warn("style=\"" + staticStyle + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div style="{{ val }}">, use <div :style="val">.');
      }
    }
    el.staticStyle = JSON.stringify(parseStyleText(staticStyle));
  }

  var styleBinding = getBindingAttr(el, 'style', false /* getStatic */);
  if (styleBinding) {
    el.styleBinding = styleBinding;
  }
}

function genData$1(el) {
  var data = '';
  if (el.staticStyle) {
    data += "staticStyle:" + el.staticStyle + ",";
  }
  if (el.styleBinding) {
    data += "style:(" + el.styleBinding + "),";
  }
  return data;
}

var style$1 = {
  staticKeys: ['staticStyle'],
  transformNode: transformNode$1,
  genData: genData$1
};

/*  */

var decoder;

var he = {
  decode: function decode(html) {
    decoder = decoder || document.createElement('div');
    decoder.innerHTML = html;
    return decoder.textContent;
  }
};

/*  */

var isUnaryTag = makeMap('area,base,br,col,embed,frame,hr,img,input,isindex,keygen,' + 'link,meta,param,source,track,wbr');

// Elements that you can, intentionally, leave open
// (and which close themselves)
var canBeLeftOpenTag = makeMap('colgroup,dd,dt,li,options,p,td,tfoot,th,thead,tr,source');

// HTML5 tags https://html.spec.whatwg.org/multipage/indices.html#elements-3
// Phrasing Content https://html.spec.whatwg.org/multipage/dom.html#phrasing-content
var isNonPhrasingTag = makeMap('address,article,aside,base,blockquote,body,caption,col,colgroup,dd,' + 'details,dialog,div,dl,dt,fieldset,figcaption,figure,footer,form,' + 'h1,h2,h3,h4,h5,h6,head,header,hgroup,hr,html,legend,li,menuitem,meta,' + 'optgroup,option,param,rp,rt,source,style,summary,tbody,td,tfoot,th,thead,' + 'title,tr,track');

/**
 * Not type-checking this file because it's mostly vendor code.
 */

/*!
 * HTML Parser By John Resig (ejohn.org)
 * Modified by Juriy "kangax" Zaytsev
 * Original code by Erik Arvidsson, Mozilla Public License
 * http://erik.eae.net/simplehtmlparser/simplehtmlparser.js
 */

// Regular Expressions for parsing tags and attributes
var attribute = /^\s*([^\s"'<>\/=]+)(?:\s*(=)\s*(?:"([^"]*)"+|'([^']*)'+|([^\s"'=<>`]+)))?/;
// could use https://www.w3.org/TR/1999/REC-xml-names-19990114/#NT-QName
// but for Vue templates we can enforce a simple charset
var ncname = '[a-zA-Z_][\\w\\-\\.]*';
var qnameCapture = "((?:" + ncname + "\\:)?" + ncname + ")";
var startTagOpen = new RegExp("^<" + qnameCapture);
var startTagClose = /^\s*(\/?)>/;
var endTag = new RegExp("^<\\/" + qnameCapture + "[^>]*>");
var doctype = /^<!DOCTYPE [^>]+>/i;
var comment = /^<!--/;
var conditionalComment = /^<!\[/;

var IS_REGEX_CAPTURING_BROKEN = false;
'x'.replace(/x(.)?/g, function (m, g) {
  IS_REGEX_CAPTURING_BROKEN = g === '';
});

// Special Elements (can contain anything)
var isPlainTextElement = makeMap('script,style,textarea', true);
var reCache = {};

var decodingMap = {
  '&lt;': '<',
  '&gt;': '>',
  '&quot;': '"',
  '&amp;': '&',
  '&#10;': '\n',
  '&#9;': '\t'
};
var encodedAttr = /&(?:lt|gt|quot|amp);/g;
var encodedAttrWithNewLines = /&(?:lt|gt|quot|amp|#10|#9);/g;

// #5992
var isIgnoreNewlineTag = makeMap('pre,textarea', true);
var shouldIgnoreFirstNewline = function shouldIgnoreFirstNewline(tag, html) {
  return tag && isIgnoreNewlineTag(tag) && html[0] === '\n';
};

function decodeAttr(value, shouldDecodeNewlines) {
  var re = shouldDecodeNewlines ? encodedAttrWithNewLines : encodedAttr;
  return value.replace(re, function (match) {
    return decodingMap[match];
  });
}

function parseHTML(html, options) {
  var stack = [];
  var expectHTML = options.expectHTML;
  var isUnaryTag$$1 = options.isUnaryTag || no;
  var canBeLeftOpenTag$$1 = options.canBeLeftOpenTag || no;
  var index = 0;
  var last, lastTag;
  while (html) {
    last = html;
    // Make sure we're not in a plaintext content element like script/style
    if (!lastTag || !isPlainTextElement(lastTag)) {
      var textEnd = html.indexOf('<');
      if (textEnd === 0) {
        // Comment:
        if (comment.test(html)) {
          var commentEnd = html.indexOf('-->');

          if (commentEnd >= 0) {
            if (options.shouldKeepComment) {
              options.comment(html.substring(4, commentEnd));
            }
            advance(commentEnd + 3);
            continue;
          }
        }

        // http://en.wikipedia.org/wiki/Conditional_comment#Downlevel-revealed_conditional_comment
        if (conditionalComment.test(html)) {
          var conditionalEnd = html.indexOf(']>');

          if (conditionalEnd >= 0) {
            advance(conditionalEnd + 2);
            continue;
          }
        }

        // Doctype:
        var doctypeMatch = html.match(doctype);
        if (doctypeMatch) {
          advance(doctypeMatch[0].length);
          continue;
        }

        // End tag:
        var endTagMatch = html.match(endTag);
        if (endTagMatch) {
          var curIndex = index;
          advance(endTagMatch[0].length);
          parseEndTag(endTagMatch[1], curIndex, index);
          continue;
        }

        // Start tag:
        var startTagMatch = parseStartTag();
        if (startTagMatch) {
          handleStartTag(startTagMatch);
          if (shouldIgnoreFirstNewline(lastTag, html)) {
            advance(1);
          }
          continue;
        }
      }

      var text = void 0,
          rest = void 0,
          next = void 0;
      if (textEnd >= 0) {
        rest = html.slice(textEnd);
        while (!endTag.test(rest) && !startTagOpen.test(rest) && !comment.test(rest) && !conditionalComment.test(rest)) {
          // < in plain text, be forgiving and treat it as text
          next = rest.indexOf('<', 1);
          if (next < 0) {
            break;
          }
          textEnd += next;
          rest = html.slice(textEnd);
        }
        text = html.substring(0, textEnd);
        advance(textEnd);
      }

      if (textEnd < 0) {
        text = html;
        html = '';
      }

      if (options.chars && text) {
        options.chars(text);
      }
    } else {
      var endTagLength = 0;
      var stackedTag = lastTag.toLowerCase();
      var reStackedTag = reCache[stackedTag] || (reCache[stackedTag] = new RegExp('([\\s\\S]*?)(</' + stackedTag + '[^>]*>)', 'i'));
      var rest$1 = html.replace(reStackedTag, function (all, text, endTag) {
        endTagLength = endTag.length;
        if (!isPlainTextElement(stackedTag) && stackedTag !== 'noscript') {
          text = text.replace(/<!--([\s\S]*?)-->/g, '$1').replace(/<!\[CDATA\[([\s\S]*?)]]>/g, '$1');
        }
        if (shouldIgnoreFirstNewline(stackedTag, text)) {
          text = text.slice(1);
        }
        if (options.chars) {
          options.chars(text);
        }
        return '';
      });
      index += html.length - rest$1.length;
      html = rest$1;
      parseEndTag(stackedTag, index - endTagLength, index);
    }

    if (html === last) {
      options.chars && options.chars(html);
      if ("development" !== 'production' && !stack.length && options.warn) {
        options.warn("Mal-formatted tag at end of template: \"" + html + "\"");
      }
      break;
    }
  }

  // Clean up any remaining tags
  parseEndTag();

  function advance(n) {
    index += n;
    html = html.substring(n);
  }

  function parseStartTag() {
    var start = html.match(startTagOpen);
    if (start) {
      var match = {
        tagName: start[1],
        attrs: [],
        start: index
      };
      advance(start[0].length);
      var end, attr;
      while (!(end = html.match(startTagClose)) && (attr = html.match(attribute))) {
        advance(attr[0].length);
        match.attrs.push(attr);
      }
      if (end) {
        match.unarySlash = end[1];
        advance(end[0].length);
        match.end = index;
        return match;
      }
    }
  }

  function handleStartTag(match) {
    var tagName = match.tagName;
    var unarySlash = match.unarySlash;

    if (expectHTML) {
      if (lastTag === 'p' && isNonPhrasingTag(tagName)) {
        parseEndTag(lastTag);
      }
      if (canBeLeftOpenTag$$1(tagName) && lastTag === tagName) {
        parseEndTag(tagName);
      }
    }

    var unary = isUnaryTag$$1(tagName) || !!unarySlash;

    var l = match.attrs.length;
    var attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      var args = match.attrs[i];
      // hackish work around FF bug https://bugzilla.mozilla.org/show_bug.cgi?id=369778
      if (IS_REGEX_CAPTURING_BROKEN && args[0].indexOf('""') === -1) {
        if (args[3] === '') {
          delete args[3];
        }
        if (args[4] === '') {
          delete args[4];
        }
        if (args[5] === '') {
          delete args[5];
        }
      }
      var value = args[3] || args[4] || args[5] || '';
      var shouldDecodeNewlines = tagName === 'a' && args[1] === 'href' ? options.shouldDecodeNewlinesForHref : options.shouldDecodeNewlines;
      attrs[i] = {
        name: args[1],
        value: decodeAttr(value, shouldDecodeNewlines)
      };
    }

    if (!unary) {
      stack.push({ tag: tagName, lowerCasedTag: tagName.toLowerCase(), attrs: attrs });
      lastTag = tagName;
    }

    if (options.start) {
      options.start(tagName, attrs, unary, match.start, match.end);
    }
  }

  function parseEndTag(tagName, start, end) {
    var pos, lowerCasedTagName;
    if (start == null) {
      start = index;
    }
    if (end == null) {
      end = index;
    }

    if (tagName) {
      lowerCasedTagName = tagName.toLowerCase();
    }

    // Find the closest opened tag of the same type
    if (tagName) {
      for (pos = stack.length - 1; pos >= 0; pos--) {
        if (stack[pos].lowerCasedTag === lowerCasedTagName) {
          break;
        }
      }
    } else {
      // If no tag name is provided, clean shop
      pos = 0;
    }

    if (pos >= 0) {
      // Close all the open elements, up the stack
      for (var i = stack.length - 1; i >= pos; i--) {
        if ("development" !== 'production' && (i > pos || !tagName) && options.warn) {
          options.warn("tag <" + stack[i].tag + "> has no matching end tag.");
        }
        if (options.end) {
          options.end(stack[i].tag, start, end);
        }
      }

      // Remove the open elements from the stack
      stack.length = pos;
      lastTag = pos && stack[pos - 1].tag;
    } else if (lowerCasedTagName === 'br') {
      if (options.start) {
        options.start(tagName, [], true, start, end);
      }
    } else if (lowerCasedTagName === 'p') {
      if (options.start) {
        options.start(tagName, [], false, start, end);
      }
      if (options.end) {
        options.end(tagName, start, end);
      }
    }
  }
}

/*  */

var onRE = /^@|^v-on:/;
var dirRE = /^v-|^@|^:/;
var forAliasRE = /(.*?)\s+(?:in|of)\s+(.*)/;
var forIteratorRE = /\((\{[^}]*\}|[^,{]*),([^,]*)(?:,([^,]*))?\)/;
var stripParensRE = /^\(|\)$/g;

var argRE = /:(.*)$/;
var bindRE = /^:|^v-bind:/;
var modifierRE = /\.[^.]+/g;

var decodeHTMLCached = cached(he.decode);

// configurable state
var warn$2;
var delimiters;
var transforms;
var preTransforms;
var postTransforms;
var platformIsPreTag;
var platformMustUseProp;
var platformGetTagNamespace;

function createASTElement(tag, attrs, parent) {
  return {
    type: 1,
    tag: tag,
    attrsList: attrs,
    attrsMap: makeAttrsMap(attrs),
    parent: parent,
    children: []
  };
}

/**
 * Convert HTML string to AST.
 */
function parse(template, options) {
  warn$2 = options.warn || baseWarn;

  platformIsPreTag = options.isPreTag || no;
  platformMustUseProp = options.mustUseProp || no;
  platformGetTagNamespace = options.getTagNamespace || no;

  transforms = pluckModuleFunction(options.modules, 'transformNode');
  preTransforms = pluckModuleFunction(options.modules, 'preTransformNode');
  postTransforms = pluckModuleFunction(options.modules, 'postTransformNode');

  delimiters = options.delimiters;

  var stack = [];
  var preserveWhitespace = options.preserveWhitespace !== false;
  var root;
  var currentParent;
  var inVPre = false;
  var inPre = false;
  var warned = false;

  function warnOnce(msg) {
    if (!warned) {
      warned = true;
      warn$2(msg);
    }
  }

  function endPre(element) {
    // check pre state
    if (element.pre) {
      inVPre = false;
    }
    if (platformIsPreTag(element.tag)) {
      inPre = false;
    }
  }

  parseHTML(template, {
    warn: warn$2,
    expectHTML: options.expectHTML,
    isUnaryTag: options.isUnaryTag,
    canBeLeftOpenTag: options.canBeLeftOpenTag,
    shouldDecodeNewlines: options.shouldDecodeNewlines,
    shouldDecodeNewlinesForHref: options.shouldDecodeNewlinesForHref,
    shouldKeepComment: options.comments,
    start: function start(tag, attrs, unary) {
      // check namespace.
      // inherit parent ns if there is one
      var ns = currentParent && currentParent.ns || platformGetTagNamespace(tag);

      // handle IE svg bug
      /* istanbul ignore if */
      if (isIE && ns === 'svg') {
        attrs = guardIESVGBug(attrs);
      }

      var element = createASTElement(tag, attrs, currentParent);
      if (ns) {
        element.ns = ns;
      }

      if (isForbiddenTag(element) && !isServerRendering()) {
        element.forbidden = true;
        "development" !== 'production' && warn$2('Templates should only be responsible for mapping the state to the ' + 'UI. Avoid placing tags with side-effects in your templates, such as ' + "<" + tag + ">" + ', as they will not be parsed.');
      }

      // apply pre-transforms
      for (var i = 0; i < preTransforms.length; i++) {
        element = preTransforms[i](element, options) || element;
      }

      if (!inVPre) {
        processPre(element);
        if (element.pre) {
          inVPre = true;
        }
      }
      if (platformIsPreTag(element.tag)) {
        inPre = true;
      }
      if (inVPre) {
        processRawAttrs(element);
      } else if (!element.processed) {
        // structural directives
        processFor(element);
        processIf(element);
        processOnce(element);
        // element-scope stuff
        processElement(element, options);
      }

      function checkRootConstraints(el) {
        if (true) {
          if (el.tag === 'slot' || el.tag === 'template') {
            warnOnce("Cannot use <" + el.tag + "> as component root element because it may " + 'contain multiple nodes.');
          }
          if (el.attrsMap.hasOwnProperty('v-for')) {
            warnOnce('Cannot use v-for on stateful component root element because ' + 'it renders multiple elements.');
          }
        }
      }

      // tree management
      if (!root) {
        root = element;
        checkRootConstraints(root);
      } else if (!stack.length) {
        // allow root elements with v-if, v-else-if and v-else
        if (root.if && (element.elseif || element.else)) {
          checkRootConstraints(element);
          addIfCondition(root, {
            exp: element.elseif,
            block: element
          });
        } else if (true) {
          warnOnce("Component template should contain exactly one root element. " + "If you are using v-if on multiple elements, " + "use v-else-if to chain them instead.");
        }
      }
      if (currentParent && !element.forbidden) {
        if (element.elseif || element.else) {
          processIfConditions(element, currentParent);
        } else if (element.slotScope) {
          // scoped slot
          currentParent.plain = false;
          var name = element.slotTarget || '"default"';(currentParent.scopedSlots || (currentParent.scopedSlots = {}))[name] = element;
        } else {
          currentParent.children.push(element);
          element.parent = currentParent;
        }
      }
      if (!unary) {
        currentParent = element;
        stack.push(element);
      } else {
        endPre(element);
      }
      // apply post-transforms
      for (var i$1 = 0; i$1 < postTransforms.length; i$1++) {
        postTransforms[i$1](element, options);
      }
    },

    end: function end() {
      // remove trailing whitespace
      var element = stack[stack.length - 1];
      var lastNode = element.children[element.children.length - 1];
      if (lastNode && lastNode.type === 3 && lastNode.text === ' ' && !inPre) {
        element.children.pop();
      }
      // pop stack
      stack.length -= 1;
      currentParent = stack[stack.length - 1];
      endPre(element);
    },

    chars: function chars(text) {
      if (!currentParent) {
        if (true) {
          if (text === template) {
            warnOnce('Component template requires a root element, rather than just text.');
          } else if (text = text.trim()) {
            warnOnce("text \"" + text + "\" outside root element will be ignored.");
          }
        }
        return;
      }
      // IE textarea placeholder bug
      /* istanbul ignore if */
      if (isIE && currentParent.tag === 'textarea' && currentParent.attrsMap.placeholder === text) {
        return;
      }
      var children = currentParent.children;
      text = inPre || text.trim() ? isTextTag(currentParent) ? text : decodeHTMLCached(text)
      // only preserve whitespace if its not right after a starting tag
      : preserveWhitespace && children.length ? ' ' : '';
      if (text) {
        var expression;
        if (!inVPre && text !== ' ' && (expression = parseText(text, delimiters))) {
          children.push({
            type: 2,
            expression: expression,
            text: text
          });
        } else if (text !== ' ' || !children.length || children[children.length - 1].text !== ' ') {
          children.push({
            type: 3,
            text: text
          });
        }
      }
    },
    comment: function comment(text) {
      currentParent.children.push({
        type: 3,
        text: text,
        isComment: true
      });
    }
  });
  return root;
}

function processPre(el) {
  if (getAndRemoveAttr(el, 'v-pre') != null) {
    el.pre = true;
  }
}

function processRawAttrs(el) {
  var l = el.attrsList.length;
  if (l) {
    var attrs = el.attrs = new Array(l);
    for (var i = 0; i < l; i++) {
      attrs[i] = {
        name: el.attrsList[i].name,
        value: JSON.stringify(el.attrsList[i].value)
      };
    }
  } else if (!el.pre) {
    // non root node in pre blocks with no attributes
    el.plain = true;
  }
}

function processElement(element, options) {
  processKey(element);

  // determine whether this is a plain element after
  // removing structural attributes
  element.plain = !element.key && !element.attrsList.length;

  processRef(element);
  processSlot(element);
  processComponent(element);
  for (var i = 0; i < transforms.length; i++) {
    element = transforms[i](element, options) || element;
  }
  processAttrs(element);
}

function processKey(el) {
  var exp = getBindingAttr(el, 'key');
  if (exp) {
    if ("development" !== 'production' && el.tag === 'template') {
      warn$2("<template> cannot be keyed. Place the key on real elements instead.");
    }
    el.key = exp;
  }
}

function processRef(el) {
  var ref = getBindingAttr(el, 'ref');
  if (ref) {
    el.ref = ref;
    el.refInFor = checkInFor(el);
  }
}

function processFor(el) {
  var exp;
  if (exp = getAndRemoveAttr(el, 'v-for')) {
    var inMatch = exp.match(forAliasRE);
    if (!inMatch) {
      "development" !== 'production' && warn$2("Invalid v-for expression: " + exp);
      return;
    }
    el.for = inMatch[2].trim();
    var alias = inMatch[1].trim();
    var iteratorMatch = alias.match(forIteratorRE);
    if (iteratorMatch) {
      el.alias = iteratorMatch[1].trim();
      el.iterator1 = iteratorMatch[2].trim();
      if (iteratorMatch[3]) {
        el.iterator2 = iteratorMatch[3].trim();
      }
    } else {
      el.alias = alias.replace(stripParensRE, '');
    }
  }
}

function processIf(el) {
  var exp = getAndRemoveAttr(el, 'v-if');
  if (exp) {
    el.if = exp;
    addIfCondition(el, {
      exp: exp,
      block: el
    });
  } else {
    if (getAndRemoveAttr(el, 'v-else') != null) {
      el.else = true;
    }
    var elseif = getAndRemoveAttr(el, 'v-else-if');
    if (elseif) {
      el.elseif = elseif;
    }
  }
}

function processIfConditions(el, parent) {
  var prev = findPrevElement(parent.children);
  if (prev && prev.if) {
    addIfCondition(prev, {
      exp: el.elseif,
      block: el
    });
  } else if (true) {
    warn$2("v-" + (el.elseif ? 'else-if="' + el.elseif + '"' : 'else') + " " + "used on element <" + el.tag + "> without corresponding v-if.");
  }
}

function findPrevElement(children) {
  var i = children.length;
  while (i--) {
    if (children[i].type === 1) {
      return children[i];
    } else {
      if ("development" !== 'production' && children[i].text !== ' ') {
        warn$2("text \"" + children[i].text.trim() + "\" between v-if and v-else(-if) " + "will be ignored.");
      }
      children.pop();
    }
  }
}

function addIfCondition(el, condition) {
  if (!el.ifConditions) {
    el.ifConditions = [];
  }
  el.ifConditions.push(condition);
}

function processOnce(el) {
  var once$$1 = getAndRemoveAttr(el, 'v-once');
  if (once$$1 != null) {
    el.once = true;
  }
}

function processSlot(el) {
  if (el.tag === 'slot') {
    el.slotName = getBindingAttr(el, 'name');
    if ("development" !== 'production' && el.key) {
      warn$2("`key` does not work on <slot> because slots are abstract outlets " + "and can possibly expand into multiple elements. " + "Use the key on a wrapping element instead.");
    }
  } else {
    var slotScope;
    if (el.tag === 'template') {
      slotScope = getAndRemoveAttr(el, 'scope');
      /* istanbul ignore if */
      if ("development" !== 'production' && slotScope) {
        warn$2("the \"scope\" attribute for scoped slots have been deprecated and " + "replaced by \"slot-scope\" since 2.5. The new \"slot-scope\" attribute " + "can also be used on plain elements in addition to <template> to " + "denote scoped slots.", true);
      }
      el.slotScope = slotScope || getAndRemoveAttr(el, 'slot-scope');
    } else if (slotScope = getAndRemoveAttr(el, 'slot-scope')) {
      /* istanbul ignore if */
      if ("development" !== 'production' && el.attrsMap['v-for']) {
        warn$2("Ambiguous combined usage of slot-scope and v-for on <" + el.tag + "> " + "(v-for takes higher priority). Use a wrapper <template> for the " + "scoped slot to make it clearer.", true);
      }
      el.slotScope = slotScope;
    }
    var slotTarget = getBindingAttr(el, 'slot');
    if (slotTarget) {
      el.slotTarget = slotTarget === '""' ? '"default"' : slotTarget;
      // preserve slot as an attribute for native shadow DOM compat
      // only for non-scoped slots.
      if (el.tag !== 'template' && !el.slotScope) {
        addAttr(el, 'slot', slotTarget);
      }
    }
  }
}

function processComponent(el) {
  var binding;
  if (binding = getBindingAttr(el, 'is')) {
    el.component = binding;
  }
  if (getAndRemoveAttr(el, 'inline-template') != null) {
    el.inlineTemplate = true;
  }
}

function processAttrs(el) {
  var list = el.attrsList;
  var i, l, name, rawName, value, modifiers, isProp;
  for (i = 0, l = list.length; i < l; i++) {
    name = rawName = list[i].name;
    value = list[i].value;
    if (dirRE.test(name)) {
      // mark element as dynamic
      el.hasBindings = true;
      // modifiers
      modifiers = parseModifiers(name);
      if (modifiers) {
        name = name.replace(modifierRE, '');
      }
      if (bindRE.test(name)) {
        // v-bind
        name = name.replace(bindRE, '');
        value = parseFilters(value);
        isProp = false;
        if (modifiers) {
          if (modifiers.prop) {
            isProp = true;
            name = camelize(name);
            if (name === 'innerHtml') {
              name = 'innerHTML';
            }
          }
          if (modifiers.camel) {
            name = camelize(name);
          }
          if (modifiers.sync) {
            addHandler(el, "update:" + camelize(name), genAssignmentCode(value, "$event"));
          }
        }
        if (isProp || !el.component && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
          addProp(el, name, value);
        } else {
          addAttr(el, name, value);
        }
      } else if (onRE.test(name)) {
        // v-on
        name = name.replace(onRE, '');
        addHandler(el, name, value, modifiers, false, warn$2);
      } else {
        // normal directives
        name = name.replace(dirRE, '');
        // parse arg
        var argMatch = name.match(argRE);
        var arg = argMatch && argMatch[1];
        if (arg) {
          name = name.slice(0, -(arg.length + 1));
        }
        addDirective(el, name, rawName, value, arg, modifiers);
        if ("development" !== 'production' && name === 'model') {
          checkForAliasModel(el, value);
        }
      }
    } else {
      // literal attribute
      if (true) {
        var expression = parseText(value, delimiters);
        if (expression) {
          warn$2(name + "=\"" + value + "\": " + 'Interpolation inside attributes has been removed. ' + 'Use v-bind or the colon shorthand instead. For example, ' + 'instead of <div id="{{ val }}">, use <div :id="val">.');
        }
      }
      addAttr(el, name, JSON.stringify(value));
      // #6887 firefox doesn't update muted state if set via attribute
      // even immediately after element creation
      if (!el.component && name === 'muted' && platformMustUseProp(el.tag, el.attrsMap.type, name)) {
        addProp(el, name, 'true');
      }
    }
  }
}

function checkInFor(el) {
  var parent = el;
  while (parent) {
    if (parent.for !== undefined) {
      return true;
    }
    parent = parent.parent;
  }
  return false;
}

function parseModifiers(name) {
  var match = name.match(modifierRE);
  if (match) {
    var ret = {};
    match.forEach(function (m) {
      ret[m.slice(1)] = true;
    });
    return ret;
  }
}

function makeAttrsMap(attrs) {
  var map = {};
  for (var i = 0, l = attrs.length; i < l; i++) {
    if ("development" !== 'production' && map[attrs[i].name] && !isIE && !isEdge) {
      warn$2('duplicate attribute: ' + attrs[i].name);
    }
    map[attrs[i].name] = attrs[i].value;
  }
  return map;
}

// for script (e.g. type="x/template") or style, do not decode content
function isTextTag(el) {
  return el.tag === 'script' || el.tag === 'style';
}

function isForbiddenTag(el) {
  return el.tag === 'style' || el.tag === 'script' && (!el.attrsMap.type || el.attrsMap.type === 'text/javascript');
}

var ieNSBug = /^xmlns:NS\d+/;
var ieNSPrefix = /^NS\d+:/;

/* istanbul ignore next */
function guardIESVGBug(attrs) {
  var res = [];
  for (var i = 0; i < attrs.length; i++) {
    var attr = attrs[i];
    if (!ieNSBug.test(attr.name)) {
      attr.name = attr.name.replace(ieNSPrefix, '');
      res.push(attr);
    }
  }
  return res;
}

function checkForAliasModel(el, value) {
  var _el = el;
  while (_el) {
    if (_el.for && _el.alias === value) {
      warn$2("<" + el.tag + " v-model=\"" + value + "\">: " + "You are binding v-model directly to a v-for iteration alias. " + "This will not be able to modify the v-for source array because " + "writing to the alias is like modifying a function local variable. " + "Consider using an array of objects and use v-model on an object property instead.");
    }
    _el = _el.parent;
  }
}

/*  */

/**
 * Expand input[v-model] with dyanmic type bindings into v-if-else chains
 * Turn this:
 *   <input v-model="data[type]" :type="type">
 * into this:
 *   <input v-if="type === 'checkbox'" type="checkbox" v-model="data[type]">
 *   <input v-else-if="type === 'radio'" type="radio" v-model="data[type]">
 *   <input v-else :type="type" v-model="data[type]">
 */

function preTransformNode(el, options) {
  if (el.tag === 'input') {
    var map = el.attrsMap;
    if (map['v-model'] && (map['v-bind:type'] || map[':type'])) {
      var typeBinding = getBindingAttr(el, 'type');
      var ifCondition = getAndRemoveAttr(el, 'v-if', true);
      var ifConditionExtra = ifCondition ? "&&(" + ifCondition + ")" : "";
      var hasElse = getAndRemoveAttr(el, 'v-else', true) != null;
      var elseIfCondition = getAndRemoveAttr(el, 'v-else-if', true);
      // 1. checkbox
      var branch0 = cloneASTElement(el);
      // process for on the main node
      processFor(branch0);
      addRawAttr(branch0, 'type', 'checkbox');
      processElement(branch0, options);
      branch0.processed = true; // prevent it from double-processed
      branch0.if = "(" + typeBinding + ")==='checkbox'" + ifConditionExtra;
      addIfCondition(branch0, {
        exp: branch0.if,
        block: branch0
      });
      // 2. add radio else-if condition
      var branch1 = cloneASTElement(el);
      getAndRemoveAttr(branch1, 'v-for', true);
      addRawAttr(branch1, 'type', 'radio');
      processElement(branch1, options);
      addIfCondition(branch0, {
        exp: "(" + typeBinding + ")==='radio'" + ifConditionExtra,
        block: branch1
      });
      // 3. other
      var branch2 = cloneASTElement(el);
      getAndRemoveAttr(branch2, 'v-for', true);
      addRawAttr(branch2, ':type', typeBinding);
      processElement(branch2, options);
      addIfCondition(branch0, {
        exp: ifCondition,
        block: branch2
      });

      if (hasElse) {
        branch0.else = true;
      } else if (elseIfCondition) {
        branch0.elseif = elseIfCondition;
      }

      return branch0;
    }
  }
}

function cloneASTElement(el) {
  return createASTElement(el.tag, el.attrsList.slice(), el.parent);
}

function addRawAttr(el, name, value) {
  el.attrsMap[name] = value;
  el.attrsList.push({ name: name, value: value });
}

var model$2 = {
  preTransformNode: preTransformNode
};

var modules$1 = [klass$1, style$1, model$2];

/*  */

function text(el, dir) {
  if (dir.value) {
    addProp(el, 'textContent', "_s(" + dir.value + ")");
  }
}

/*  */

function html(el, dir) {
  if (dir.value) {
    addProp(el, 'innerHTML', "_s(" + dir.value + ")");
  }
}

var directives$1 = {
  model: model,
  text: text,
  html: html
};

/*  */

var baseOptions = {
  expectHTML: true,
  modules: modules$1,
  directives: directives$1,
  isPreTag: isPreTag,
  isUnaryTag: isUnaryTag,
  mustUseProp: mustUseProp,
  canBeLeftOpenTag: canBeLeftOpenTag,
  isReservedTag: isReservedTag,
  getTagNamespace: getTagNamespace,
  staticKeys: genStaticKeys(modules$1)
};

/*  */

var isStaticKey;
var isPlatformReservedTag;

var genStaticKeysCached = cached(genStaticKeys$1);

/**
 * Goal of the optimizer: walk the generated template AST tree
 * and detect sub-trees that are purely static, i.e. parts of
 * the DOM that never needs to change.
 *
 * Once we detect these sub-trees, we can:
 *
 * 1. Hoist them into constants, so that we no longer need to
 *    create fresh nodes for them on each re-render;
 * 2. Completely skip them in the patching process.
 */
function optimize(root, options) {
  if (!root) {
    return;
  }
  isStaticKey = genStaticKeysCached(options.staticKeys || '');
  isPlatformReservedTag = options.isReservedTag || no;
  // first pass: mark all non-static nodes.
  markStatic$1(root);
  // second pass: mark static roots.
  markStaticRoots(root, false);
}

function genStaticKeys$1(keys) {
  return makeMap('type,tag,attrsList,attrsMap,plain,parent,children,attrs' + (keys ? ',' + keys : ''));
}

function markStatic$1(node) {
  node.static = isStatic(node);
  if (node.type === 1) {
    // do not make component slot content static. this avoids
    // 1. components not able to mutate slot nodes
    // 2. static slot content fails for hot-reloading
    if (!isPlatformReservedTag(node.tag) && node.tag !== 'slot' && node.attrsMap['inline-template'] == null) {
      return;
    }
    for (var i = 0, l = node.children.length; i < l; i++) {
      var child = node.children[i];
      markStatic$1(child);
      if (!child.static) {
        node.static = false;
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        var block = node.ifConditions[i$1].block;
        markStatic$1(block);
        if (!block.static) {
          node.static = false;
        }
      }
    }
  }
}

function markStaticRoots(node, isInFor) {
  if (node.type === 1) {
    if (node.static || node.once) {
      node.staticInFor = isInFor;
    }
    // For a node to qualify as a static root, it should have children that
    // are not just static text. Otherwise the cost of hoisting out will
    // outweigh the benefits and it's better off to just always render it fresh.
    if (node.static && node.children.length && !(node.children.length === 1 && node.children[0].type === 3)) {
      node.staticRoot = true;
      return;
    } else {
      node.staticRoot = false;
    }
    if (node.children) {
      for (var i = 0, l = node.children.length; i < l; i++) {
        markStaticRoots(node.children[i], isInFor || !!node.for);
      }
    }
    if (node.ifConditions) {
      for (var i$1 = 1, l$1 = node.ifConditions.length; i$1 < l$1; i$1++) {
        markStaticRoots(node.ifConditions[i$1].block, isInFor);
      }
    }
  }
}

function isStatic(node) {
  if (node.type === 2) {
    // expression
    return false;
  }
  if (node.type === 3) {
    // text
    return true;
  }
  return !!(node.pre || !node.hasBindings && // no dynamic bindings
  !node.if && !node.for && // not v-if or v-for or v-else
  !isBuiltInTag(node.tag) && // not a built-in
  isPlatformReservedTag(node.tag) && // not a component
  !isDirectChildOfTemplateFor(node) && Object.keys(node).every(isStaticKey));
}

function isDirectChildOfTemplateFor(node) {
  while (node.parent) {
    node = node.parent;
    if (node.tag !== 'template') {
      return false;
    }
    if (node.for) {
      return true;
    }
  }
  return false;
}

/*  */

var fnExpRE = /^\s*([\w$_]+|\([^)]*?\))\s*=>|^function\s*\(/;
var simplePathRE = /^\s*[A-Za-z_$][\w$]*(?:\.[A-Za-z_$][\w$]*|\['.*?']|\[".*?"]|\[\d+]|\[[A-Za-z_$][\w$]*])*\s*$/;

// keyCode aliases
var keyCodes = {
  esc: 27,
  tab: 9,
  enter: 13,
  space: 32,
  up: 38,
  left: 37,
  right: 39,
  down: 40,
  'delete': [8, 46]
};

// #4868: modifiers that prevent the execution of the listener
// need to explicitly return null so that we can determine whether to remove
// the listener for .once
var genGuard = function genGuard(condition) {
  return "if(" + condition + ")return null;";
};

var modifierCode = {
  stop: '$event.stopPropagation();',
  prevent: '$event.preventDefault();',
  self: genGuard("$event.target !== $event.currentTarget"),
  ctrl: genGuard("!$event.ctrlKey"),
  shift: genGuard("!$event.shiftKey"),
  alt: genGuard("!$event.altKey"),
  meta: genGuard("!$event.metaKey"),
  left: genGuard("'button' in $event && $event.button !== 0"),
  middle: genGuard("'button' in $event && $event.button !== 1"),
  right: genGuard("'button' in $event && $event.button !== 2")
};

function genHandlers(events, isNative, warn) {
  var res = isNative ? 'nativeOn:{' : 'on:{';
  for (var name in events) {
    res += "\"" + name + "\":" + genHandler(name, events[name]) + ",";
  }
  return res.slice(0, -1) + '}';
}

function genHandler(name, handler) {
  if (!handler) {
    return 'function(){}';
  }

  if (Array.isArray(handler)) {
    return "[" + handler.map(function (handler) {
      return genHandler(name, handler);
    }).join(',') + "]";
  }

  var isMethodPath = simplePathRE.test(handler.value);
  var isFunctionExpression = fnExpRE.test(handler.value);

  if (!handler.modifiers) {
    return isMethodPath || isFunctionExpression ? handler.value : "function($event){" + handler.value + "}"; // inline statement
  } else {
    var code = '';
    var genModifierCode = '';
    var keys = [];
    for (var key in handler.modifiers) {
      if (modifierCode[key]) {
        genModifierCode += modifierCode[key];
        // left/right
        if (keyCodes[key]) {
          keys.push(key);
        }
      } else if (key === 'exact') {
        var modifiers = handler.modifiers;
        genModifierCode += genGuard(['ctrl', 'shift', 'alt', 'meta'].filter(function (keyModifier) {
          return !modifiers[keyModifier];
        }).map(function (keyModifier) {
          return "$event." + keyModifier + "Key";
        }).join('||'));
      } else {
        keys.push(key);
      }
    }
    if (keys.length) {
      code += genKeyFilter(keys);
    }
    // Make sure modifiers like prevent and stop get executed after key filtering
    if (genModifierCode) {
      code += genModifierCode;
    }
    var handlerCode = isMethodPath ? handler.value + '($event)' : isFunctionExpression ? "(" + handler.value + ")($event)" : handler.value;
    return "function($event){" + code + handlerCode + "}";
  }
}

function genKeyFilter(keys) {
  return "if(!('button' in $event)&&" + keys.map(genFilterCode).join('&&') + ")return null;";
}

function genFilterCode(key) {
  var keyVal = parseInt(key, 10);
  if (keyVal) {
    return "$event.keyCode!==" + keyVal;
  }
  var code = keyCodes[key];
  return "_k($event.keyCode," + JSON.stringify(key) + "," + JSON.stringify(code) + "," + "$event.key)";
}

/*  */

function on(el, dir) {
  if ("development" !== 'production' && dir.modifiers) {
    warn("v-on without argument does not support modifiers.");
  }
  el.wrapListeners = function (code) {
    return "_g(" + code + "," + dir.value + ")";
  };
}

/*  */

function bind$1(el, dir) {
  el.wrapData = function (code) {
    return "_b(" + code + ",'" + el.tag + "'," + dir.value + "," + (dir.modifiers && dir.modifiers.prop ? 'true' : 'false') + (dir.modifiers && dir.modifiers.sync ? ',true' : '') + ")";
  };
}

/*  */

var baseDirectives = {
  on: on,
  bind: bind$1,
  cloak: noop
};

/*  */

var CodegenState = function CodegenState(options) {
  this.options = options;
  this.warn = options.warn || baseWarn;
  this.transforms = pluckModuleFunction(options.modules, 'transformCode');
  this.dataGenFns = pluckModuleFunction(options.modules, 'genData');
  this.directives = extend(extend({}, baseDirectives), options.directives);
  var isReservedTag = options.isReservedTag || no;
  this.maybeComponent = function (el) {
    return !isReservedTag(el.tag);
  };
  this.onceId = 0;
  this.staticRenderFns = [];
};

function generate(ast, options) {
  var state = new CodegenState(options);
  var code = ast ? genElement(ast, state) : '_c("div")';
  return {
    render: "with(this){return " + code + "}",
    staticRenderFns: state.staticRenderFns
  };
}

function genElement(el, state) {
  if (el.staticRoot && !el.staticProcessed) {
    return genStatic(el, state);
  } else if (el.once && !el.onceProcessed) {
    return genOnce(el, state);
  } else if (el.for && !el.forProcessed) {
    return genFor(el, state);
  } else if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.tag === 'template' && !el.slotTarget) {
    return genChildren(el, state) || 'void 0';
  } else if (el.tag === 'slot') {
    return genSlot(el, state);
  } else {
    // component or element
    var code;
    if (el.component) {
      code = genComponent(el.component, el, state);
    } else {
      var data = el.plain ? undefined : genData$2(el, state);

      var children = el.inlineTemplate ? null : genChildren(el, state, true);
      code = "_c('" + el.tag + "'" + (data ? "," + data : '') + (children ? "," + children : '') + ")";
    }
    // module transforms
    for (var i = 0; i < state.transforms.length; i++) {
      code = state.transforms[i](el, code);
    }
    return code;
  }
}

// hoist static sub-trees out
function genStatic(el, state, once$$1) {
  el.staticProcessed = true;
  state.staticRenderFns.push("with(this){return " + genElement(el, state) + "}");
  return "_m(" + (state.staticRenderFns.length - 1) + "," + (el.staticInFor ? 'true' : 'false') + "," + (once$$1 ? 'true' : 'false') + ")";
}

// v-once
function genOnce(el, state) {
  el.onceProcessed = true;
  if (el.if && !el.ifProcessed) {
    return genIf(el, state);
  } else if (el.staticInFor) {
    var key = '';
    var parent = el.parent;
    while (parent) {
      if (parent.for) {
        key = parent.key;
        break;
      }
      parent = parent.parent;
    }
    if (!key) {
      "development" !== 'production' && state.warn("v-once can only be used inside v-for that is keyed. ");
      return genElement(el, state);
    }
    return "_o(" + genElement(el, state) + "," + state.onceId++ + "," + key + ")";
  } else {
    return genStatic(el, state, true);
  }
}

function genIf(el, state, altGen, altEmpty) {
  el.ifProcessed = true; // avoid recursion
  return genIfConditions(el.ifConditions.slice(), state, altGen, altEmpty);
}

function genIfConditions(conditions, state, altGen, altEmpty) {
  if (!conditions.length) {
    return altEmpty || '_e()';
  }

  var condition = conditions.shift();
  if (condition.exp) {
    return "(" + condition.exp + ")?" + genTernaryExp(condition.block) + ":" + genIfConditions(conditions, state, altGen, altEmpty);
  } else {
    return "" + genTernaryExp(condition.block);
  }

  // v-if with v-once should generate code like (a)?_m(0):_m(1)
  function genTernaryExp(el) {
    return altGen ? altGen(el, state) : el.once ? genOnce(el, state) : genElement(el, state);
  }
}

function genFor(el, state, altGen, altHelper) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';

  if ("development" !== 'production' && state.maybeComponent(el) && el.tag !== 'slot' && el.tag !== 'template' && !el.key) {
    state.warn("<" + el.tag + " v-for=\"" + alias + " in " + exp + "\">: component lists rendered with " + "v-for should have explicit keys. " + "See https://vuejs.org/guide/list.html#key for more info.", true /* tip */
    );
  }

  el.forProcessed = true; // avoid recursion
  return (altHelper || '_l') + "((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + (altGen || genElement)(el, state) + '})';
}

function genData$2(el, state) {
  var data = '{';

  // directives first.
  // directives may mutate the el's other properties before they are generated.
  var dirs = genDirectives(el, state);
  if (dirs) {
    data += dirs + ',';
  }

  // key
  if (el.key) {
    data += "key:" + el.key + ",";
  }
  // ref
  if (el.ref) {
    data += "ref:" + el.ref + ",";
  }
  if (el.refInFor) {
    data += "refInFor:true,";
  }
  // pre
  if (el.pre) {
    data += "pre:true,";
  }
  // record original tag name for components using "is" attribute
  if (el.component) {
    data += "tag:\"" + el.tag + "\",";
  }
  // module data generation functions
  for (var i = 0; i < state.dataGenFns.length; i++) {
    data += state.dataGenFns[i](el);
  }
  // attributes
  if (el.attrs) {
    data += "attrs:{" + genProps(el.attrs) + "},";
  }
  // DOM props
  if (el.props) {
    data += "domProps:{" + genProps(el.props) + "},";
  }
  // event handlers
  if (el.events) {
    data += genHandlers(el.events, false, state.warn) + ",";
  }
  if (el.nativeEvents) {
    data += genHandlers(el.nativeEvents, true, state.warn) + ",";
  }
  // slot target
  // only for non-scoped slots
  if (el.slotTarget && !el.slotScope) {
    data += "slot:" + el.slotTarget + ",";
  }
  // scoped slots
  if (el.scopedSlots) {
    data += genScopedSlots(el.scopedSlots, state) + ",";
  }
  // component v-model
  if (el.model) {
    data += "model:{value:" + el.model.value + ",callback:" + el.model.callback + ",expression:" + el.model.expression + "},";
  }
  // inline-template
  if (el.inlineTemplate) {
    var inlineTemplate = genInlineTemplate(el, state);
    if (inlineTemplate) {
      data += inlineTemplate + ",";
    }
  }
  data = data.replace(/,$/, '') + '}';
  // v-bind data wrap
  if (el.wrapData) {
    data = el.wrapData(data);
  }
  // v-on data wrap
  if (el.wrapListeners) {
    data = el.wrapListeners(data);
  }
  return data;
}

function genDirectives(el, state) {
  var dirs = el.directives;
  if (!dirs) {
    return;
  }
  var res = 'directives:[';
  var hasRuntime = false;
  var i, l, dir, needRuntime;
  for (i = 0, l = dirs.length; i < l; i++) {
    dir = dirs[i];
    needRuntime = true;
    var gen = state.directives[dir.name];
    if (gen) {
      // compile-time directive that manipulates AST.
      // returns true if it also needs a runtime counterpart.
      needRuntime = !!gen(el, dir, state.warn);
    }
    if (needRuntime) {
      hasRuntime = true;
      res += "{name:\"" + dir.name + "\",rawName:\"" + dir.rawName + "\"" + (dir.value ? ",value:(" + dir.value + "),expression:" + JSON.stringify(dir.value) : '') + (dir.arg ? ",arg:\"" + dir.arg + "\"" : '') + (dir.modifiers ? ",modifiers:" + JSON.stringify(dir.modifiers) : '') + "},";
    }
  }
  if (hasRuntime) {
    return res.slice(0, -1) + ']';
  }
}

function genInlineTemplate(el, state) {
  var ast = el.children[0];
  if ("development" !== 'production' && (el.children.length !== 1 || ast.type !== 1)) {
    state.warn('Inline-template components must have exactly one child element.');
  }
  if (ast.type === 1) {
    var inlineRenderFns = generate(ast, state.options);
    return "inlineTemplate:{render:function(){" + inlineRenderFns.render + "},staticRenderFns:[" + inlineRenderFns.staticRenderFns.map(function (code) {
      return "function(){" + code + "}";
    }).join(',') + "]}";
  }
}

function genScopedSlots(slots, state) {
  return "scopedSlots:_u([" + Object.keys(slots).map(function (key) {
    return genScopedSlot(key, slots[key], state);
  }).join(',') + "])";
}

function genScopedSlot(key, el, state) {
  if (el.for && !el.forProcessed) {
    return genForScopedSlot(key, el, state);
  }
  var fn = "function(" + String(el.slotScope) + "){" + "return " + (el.tag === 'template' ? el.if ? el.if + "?" + (genChildren(el, state) || 'undefined') + ":undefined" : genChildren(el, state) || 'undefined' : genElement(el, state)) + "}";
  return "{key:" + key + ",fn:" + fn + "}";
}

function genForScopedSlot(key, el, state) {
  var exp = el.for;
  var alias = el.alias;
  var iterator1 = el.iterator1 ? "," + el.iterator1 : '';
  var iterator2 = el.iterator2 ? "," + el.iterator2 : '';
  el.forProcessed = true; // avoid recursion
  return "_l((" + exp + ")," + "function(" + alias + iterator1 + iterator2 + "){" + "return " + genScopedSlot(key, el, state) + '})';
}

function genChildren(el, state, checkSkip, altGenElement, altGenNode) {
  var children = el.children;
  if (children.length) {
    var el$1 = children[0];
    // optimize single v-for
    if (children.length === 1 && el$1.for && el$1.tag !== 'template' && el$1.tag !== 'slot') {
      return (altGenElement || genElement)(el$1, state);
    }
    var normalizationType = checkSkip ? getNormalizationType(children, state.maybeComponent) : 0;
    var gen = altGenNode || genNode;
    return "[" + children.map(function (c) {
      return gen(c, state);
    }).join(',') + "]" + (normalizationType ? "," + normalizationType : '');
  }
}

// determine the normalization needed for the children array.
// 0: no normalization needed
// 1: simple normalization needed (possible 1-level deep nested array)
// 2: full normalization needed
function getNormalizationType(children, maybeComponent) {
  var res = 0;
  for (var i = 0; i < children.length; i++) {
    var el = children[i];
    if (el.type !== 1) {
      continue;
    }
    if (needsNormalization(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return needsNormalization(c.block);
    })) {
      res = 2;
      break;
    }
    if (maybeComponent(el) || el.ifConditions && el.ifConditions.some(function (c) {
      return maybeComponent(c.block);
    })) {
      res = 1;
    }
  }
  return res;
}

function needsNormalization(el) {
  return el.for !== undefined || el.tag === 'template' || el.tag === 'slot';
}

function genNode(node, state) {
  if (node.type === 1) {
    return genElement(node, state);
  }if (node.type === 3 && node.isComment) {
    return genComment(node);
  } else {
    return genText(node);
  }
}

function genText(text) {
  return "_v(" + (text.type === 2 ? text.expression // no need for () because already wrapped in _s()
  : transformSpecialNewlines(JSON.stringify(text.text))) + ")";
}

function genComment(comment) {
  return "_e(" + JSON.stringify(comment.text) + ")";
}

function genSlot(el, state) {
  var slotName = el.slotName || '"default"';
  var children = genChildren(el, state);
  var res = "_t(" + slotName + (children ? "," + children : '');
  var attrs = el.attrs && "{" + el.attrs.map(function (a) {
    return camelize(a.name) + ":" + a.value;
  }).join(',') + "}";
  var bind$$1 = el.attrsMap['v-bind'];
  if ((attrs || bind$$1) && !children) {
    res += ",null";
  }
  if (attrs) {
    res += "," + attrs;
  }
  if (bind$$1) {
    res += (attrs ? '' : ',null') + "," + bind$$1;
  }
  return res + ')';
}

// componentName is el.component, take it as argument to shun flow's pessimistic refinement
function genComponent(componentName, el, state) {
  var children = el.inlineTemplate ? null : genChildren(el, state, true);
  return "_c(" + componentName + "," + genData$2(el, state) + (children ? "," + children : '') + ")";
}

function genProps(props) {
  var res = '';
  for (var i = 0; i < props.length; i++) {
    var prop = props[i];
    res += "\"" + prop.name + "\":" + transformSpecialNewlines(prop.value) + ",";
  }
  return res.slice(0, -1);
}

// #3895, #4268
function transformSpecialNewlines(text) {
  return text.replace(/\u2028/g, '\\u2028').replace(/\u2029/g, '\\u2029');
}

/*  */

// these keywords should not appear inside expressions, but operators like
// typeof, instanceof and in are allowed
var prohibitedKeywordRE = new RegExp('\\b' + ('do,if,for,let,new,try,var,case,else,with,await,break,catch,class,const,' + 'super,throw,while,yield,delete,export,import,return,switch,default,' + 'extends,finally,continue,debugger,function,arguments').split(',').join('\\b|\\b') + '\\b');

// these unary operators should not be used as property/method names
var unaryOperatorsRE = new RegExp('\\b' + 'delete,typeof,void'.split(',').join('\\s*\\([^\\)]*\\)|\\b') + '\\s*\\([^\\)]*\\)');

// strip strings in expressions
var stripStringRE = /'(?:[^'\\]|\\.)*'|"(?:[^"\\]|\\.)*"|`(?:[^`\\]|\\.)*\$\{|\}(?:[^`\\]|\\.)*`|`(?:[^`\\]|\\.)*`/g;

// detect problematic expressions in a template
function detectErrors(ast) {
  var errors = [];
  if (ast) {
    checkNode(ast, errors);
  }
  return errors;
}

function checkNode(node, errors) {
  if (node.type === 1) {
    for (var name in node.attrsMap) {
      if (dirRE.test(name)) {
        var value = node.attrsMap[name];
        if (value) {
          if (name === 'v-for') {
            checkFor(node, "v-for=\"" + value + "\"", errors);
          } else if (onRE.test(name)) {
            checkEvent(value, name + "=\"" + value + "\"", errors);
          } else {
            checkExpression(value, name + "=\"" + value + "\"", errors);
          }
        }
      }
    }
    if (node.children) {
      for (var i = 0; i < node.children.length; i++) {
        checkNode(node.children[i], errors);
      }
    }
  } else if (node.type === 2) {
    checkExpression(node.expression, node.text, errors);
  }
}

function checkEvent(exp, text, errors) {
  var stipped = exp.replace(stripStringRE, '');
  var keywordMatch = stipped.match(unaryOperatorsRE);
  if (keywordMatch && stipped.charAt(keywordMatch.index - 1) !== '$') {
    errors.push("avoid using JavaScript unary operator as property name: " + "\"" + keywordMatch[0] + "\" in expression " + text.trim());
  }
  checkExpression(exp, text, errors);
}

function checkFor(node, text, errors) {
  checkExpression(node.for || '', text, errors);
  checkIdentifier(node.alias, 'v-for alias', text, errors);
  checkIdentifier(node.iterator1, 'v-for iterator', text, errors);
  checkIdentifier(node.iterator2, 'v-for iterator', text, errors);
}

function checkIdentifier(ident, type, text, errors) {
  if (typeof ident === 'string') {
    try {
      new Function("var " + ident + "=_");
    } catch (e) {
      errors.push("invalid " + type + " \"" + ident + "\" in expression: " + text.trim());
    }
  }
}

function checkExpression(exp, text, errors) {
  try {
    new Function("return " + exp);
  } catch (e) {
    var keywordMatch = exp.replace(stripStringRE, '').match(prohibitedKeywordRE);
    if (keywordMatch) {
      errors.push("avoid using JavaScript keyword as property name: " + "\"" + keywordMatch[0] + "\"\n  Raw expression: " + text.trim());
    } else {
      errors.push("invalid expression: " + e.message + " in\n\n" + "    " + exp + "\n\n" + "  Raw expression: " + text.trim() + "\n");
    }
  }
}

/*  */

function createFunction(code, errors) {
  try {
    return new Function(code);
  } catch (err) {
    errors.push({ err: err, code: code });
    return noop;
  }
}

function createCompileToFunctionFn(compile) {
  var cache = Object.create(null);

  return function compileToFunctions(template, options, vm) {
    options = extend({}, options);
    var warn$$1 = options.warn || warn;
    delete options.warn;

    /* istanbul ignore if */
    if (true) {
      // detect possible CSP restriction
      try {
        new Function('return 1');
      } catch (e) {
        if (e.toString().match(/unsafe-eval|CSP/)) {
          warn$$1('It seems you are using the standalone build of Vue.js in an ' + 'environment with Content Security Policy that prohibits unsafe-eval. ' + 'The template compiler cannot work in this environment. Consider ' + 'relaxing the policy to allow unsafe-eval or pre-compiling your ' + 'templates into render functions.');
        }
      }
    }

    // check cache
    var key = options.delimiters ? String(options.delimiters) + template : template;
    if (cache[key]) {
      return cache[key];
    }

    // compile
    var compiled = compile(template, options);

    // check compilation errors/tips
    if (true) {
      if (compiled.errors && compiled.errors.length) {
        warn$$1("Error compiling template:\n\n" + template + "\n\n" + compiled.errors.map(function (e) {
          return "- " + e;
        }).join('\n') + '\n', vm);
      }
      if (compiled.tips && compiled.tips.length) {
        compiled.tips.forEach(function (msg) {
          return tip(msg, vm);
        });
      }
    }

    // turn code into functions
    var res = {};
    var fnGenErrors = [];
    res.render = createFunction(compiled.render, fnGenErrors);
    res.staticRenderFns = compiled.staticRenderFns.map(function (code) {
      return createFunction(code, fnGenErrors);
    });

    // check function generation errors.
    // this should only happen if there is a bug in the compiler itself.
    // mostly for codegen development use
    /* istanbul ignore if */
    if (true) {
      if ((!compiled.errors || !compiled.errors.length) && fnGenErrors.length) {
        warn$$1("Failed to generate render function:\n\n" + fnGenErrors.map(function (ref) {
          var err = ref.err;
          var code = ref.code;

          return err.toString() + " in\n\n" + code + "\n";
        }).join('\n'), vm);
      }
    }

    return cache[key] = res;
  };
}

/*  */

function createCompilerCreator(baseCompile) {
  return function createCompiler(baseOptions) {
    function compile(template, options) {
      var finalOptions = Object.create(baseOptions);
      var errors = [];
      var tips = [];
      finalOptions.warn = function (msg, tip) {
        (tip ? tips : errors).push(msg);
      };

      if (options) {
        // merge custom modules
        if (options.modules) {
          finalOptions.modules = (baseOptions.modules || []).concat(options.modules);
        }
        // merge custom directives
        if (options.directives) {
          finalOptions.directives = extend(Object.create(baseOptions.directives), options.directives);
        }
        // copy other options
        for (var key in options) {
          if (key !== 'modules' && key !== 'directives') {
            finalOptions[key] = options[key];
          }
        }
      }

      var compiled = baseCompile(template, finalOptions);
      if (true) {
        errors.push.apply(errors, detectErrors(compiled.ast));
      }
      compiled.errors = errors;
      compiled.tips = tips;
      return compiled;
    }

    return {
      compile: compile,
      compileToFunctions: createCompileToFunctionFn(compile)
    };
  };
}

/*  */

// `createCompilerCreator` allows creating compilers that use alternative
// parser/optimizer/codegen, e.g the SSR optimizing compiler.
// Here we just export a default compiler using the default parts.
var createCompiler = createCompilerCreator(function baseCompile(template, options) {
  var ast = parse(template.trim(), options);
  optimize(ast, options);
  var code = generate(ast, options);
  return {
    ast: ast,
    render: code.render,
    staticRenderFns: code.staticRenderFns
  };
});

/*  */

var ref$1 = createCompiler(baseOptions);
var compileToFunctions = ref$1.compileToFunctions;

/*  */

// check whether current browser encodes a char inside attribute values
var div;
function getShouldDecode(href) {
  div = div || document.createElement('div');
  div.innerHTML = href ? "<a href=\"\n\"/>" : "<div a=\"\n\"/>";
  return div.innerHTML.indexOf('&#10;') > 0;
}

// #3663: IE encodes newlines inside attribute values while other browsers don't
var shouldDecodeNewlines = inBrowser ? getShouldDecode(false) : false;
// #6828: chrome encodes content in a[href]
var shouldDecodeNewlinesForHref = inBrowser ? getShouldDecode(true) : false;

/*  */

var idToTemplate = cached(function (id) {
  var el = query(id);
  return el && el.innerHTML;
});

var mount = Vue$3.prototype.$mount;
Vue$3.prototype.$mount = function (el, hydrating) {
  el = el && query(el);

  /* istanbul ignore if */
  if (el === document.body || el === document.documentElement) {
    "development" !== 'production' && warn("Do not mount Vue to <html> or <body> - mount to normal elements instead.");
    return this;
  }

  var options = this.$options;
  // resolve template/el and convert to render function
  if (!options.render) {
    var template = options.template;
    if (template) {
      if (typeof template === 'string') {
        if (template.charAt(0) === '#') {
          template = idToTemplate(template);
          /* istanbul ignore if */
          if ("development" !== 'production' && !template) {
            warn("Template element not found or is empty: " + options.template, this);
          }
        }
      } else if (template.nodeType) {
        template = template.innerHTML;
      } else {
        if (true) {
          warn('invalid template option:' + template, this);
        }
        return this;
      }
    } else if (el) {
      template = getOuterHTML(el);
    }
    if (template) {
      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile');
      }

      var ref = compileToFunctions(template, {
        shouldDecodeNewlines: shouldDecodeNewlines,
        shouldDecodeNewlinesForHref: shouldDecodeNewlinesForHref,
        delimiters: options.delimiters,
        comments: options.comments
      }, this);
      var render = ref.render;
      var staticRenderFns = ref.staticRenderFns;
      options.render = render;
      options.staticRenderFns = staticRenderFns;

      /* istanbul ignore if */
      if ("development" !== 'production' && config.performance && mark) {
        mark('compile end');
        measure("vue " + this._name + " compile", 'compile', 'compile end');
      }
    }
  }
  return mount.call(this, el, hydrating);
};

/**
 * Get outerHTML of elements, taking care
 * of SVG elements in IE as well.
 */
function getOuterHTML(el) {
  if (el.outerHTML) {
    return el.outerHTML;
  } else {
    var container = document.createElement('div');
    container.appendChild(el.cloneNode(true));
    return container.innerHTML;
  }
}

Vue$3.compile = compileToFunctions;

module.exports = Vue$3;
/* WEBPACK VAR INJECTION */}.call(exports, __webpack_require__("./node_modules/webpack/buildin/global.js"), __webpack_require__("./node_modules/timers-browserify/main.js").setImmediate))

/***/ }),

/***/ "./node_modules/vuemit/src/Vuemit.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();
/**
 * Vuemit class.
 *
 * @author Gustavo Ocanto <gustavoocanto@gmail.com>
 * @license https://github.com/gocanto/vuemit/blob/master/LICENSE
 */

var _vue = __webpack_require__("./node_modules/vue/dist/vue.common.js");

var _vue2 = _interopRequireDefault(_vue);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

var Vuemit = function () {
    /**
    * Creates a new Event instance.
    *
    * @return {Void}
    */
    function Vuemit() {
        _classCallCheck(this, Vuemit);

        /**
        * The Vue instance.
        *
        * @type {Vue}
        */
        this.vue = new _vue2.default();
    }

    /**
    * Fires a given event/s.
    *
    * @param {Object} event
    * @param {Object} data
    * @return {Void}
    */


    _createClass(Vuemit, [{
        key: 'fire',
        value: function fire(event) {
            var _this = this;

            var data = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (Array.isArray(event)) {
                return event.forEach(function (e) {
                    _this.vue.$emit(e, data);
                });
            }

            this.vue.$emit(event, data);
        }

        /**
        * Listens for a given event/s.
        *
        * @param {Object} event
        * @param {Function} callback
        * @return {Void}
        */

    }, {
        key: 'listen',
        value: function listen(event, callback) {
            var _this2 = this;

            if (Array.isArray(event)) {
                return event.forEach(function (e) {
                    _this2.vue.$on(e, callback);
                });
            }

            this.vue.$on(event, callback);
        }

        /**
        * Listens for a given event/s for one time only.
        *
        * @param {Object} event
        * @param {Function} callback
        * @return {Void}
        */

    }, {
        key: 'listenOnce',
        value: function listenOnce(event, callback) {
            var _this3 = this;

            if (Array.isArray(event)) {
                return event.forEach(function (e) {
                    _this3.vue.$once(e, callback);
                });
            }

            this.vue.$once(event, callback);
        }

        /**
        * Removes listeners for a given event/s and callback.
        *
        * @param {Object} event
        * @param {Function} callback
        * @return {Void}
        */

    }, {
        key: 'remove',
        value: function remove(event, callback) {
            var _this4 = this;

            if (Array.isArray(event)) {
                return event.forEach(function (e) {
                    _this4.vue.$off(e, callback);
                });
            }

            this.vue.$off(event, callback);
        }

        /**
        * Removes all listeners for a given event/s.
        *
        * @param {Object} event
        * @return {Void}
        */

    }, {
        key: 'removeListenersFrom',
        value: function removeListenersFrom(event) {
            var _this5 = this;

            if (Array.isArray(event)) {
                return event.forEach(function (e) {
                    _this5.vue.$off(e);
                });
            }

            this.vue.$off(event);
        }

        /**
        * Removes all event listeners.
        *
        * @return {Void}
        */

    }, {
        key: 'removeAll',
        value: function removeAll() {
            this.vue.$off();
        }
    }]);

    return Vuemit;
}();

module.exports = new Vuemit();

/***/ }),

/***/ "./node_modules/webpack/buildin/global.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

var g;

// This works in non-strict mode
g = function () {
	return this;
}();

try {
	// This works if eval is allowed (see CSP)
	g = g || Function("return this")() || (1, eval)("this");
} catch (e) {
	// This works if the window reference is available
	if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === "object") g = window;
}

// g can still be undefined, but nothing to do about it...
// We return undefined, instead of nothing here, so it's
// easier to handle this case. if(!global) { ...}

module.exports = g;

/***/ }),

/***/ "./resources/assets/js/Main/container.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Main/container.vue")
/* template */
var __vue_template__ = null
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/Main/container.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-236d14fd", Component.options)
  } else {
    hotAPI.reload("data-v-236d14fd", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/Main/forms.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    methods: {
        scanForMissing: function scanForMissing() {
            var _this = this;

            axios.get(this.scanForMissingRoute).then(function (_ref) {
                var data = _ref.data;

                _this.showNotif(data.message);
                EventHub.fire('scan_complete', { tab: _this.activeTab });
            }).catch(function (err) {
                console.error(err);
                _this.failedAjax();
            });
        },
        addNewLocale: function addNewLocale() {
            var _this2 = this;

            if (!this.new_locale) {
                return this.missingVal();
            }

            if (!this.$refs.locale.disabled) {
                axios.post(this.addNewLocaleRoute, {
                    'file_name': this.new_locale,
                    'dir_name': this.selectedDirName || null
                }).then(function (_ref2) {
                    var data = _ref2.data;

                    if (!data.success) {
                        return _this2.showNotif(data.message, 'danger');
                    }

                    _this2.showNotif(data.message);
                    _this2.resetAll(['new_locale']);
                    EventHub.fire('new_locale_added', { tab: _this2.activeTab });
                }).catch(function (err) {
                    console.error(err);
                    _this2.failedAjax();
                });
            }
        },
        addNewFile: function addNewFile() {
            var _this3 = this;

            if (!this.new_file) {
                return this.missingVal();
            }

            if (!this.new_file.includes('.php')) {
                return this.missingVal('.php ?!!');
            }

            if (!this.$refs.file.disabled) {
                var file_name = this.new_file;

                axios.post(this.addNewFileRoute, {
                    'file_name': file_name,
                    'dir_name': this.selectedDirName || null
                }).then(function (_ref3) {
                    var data = _ref3.data;

                    if (!data.success) {
                        return _this3.showNotif(data.message, 'danger');
                    }

                    _this3.showNotif(data.message);
                    _this3.resetAll(['new_file', 'filesList']);

                    EventHub.fire('new_file_added', {
                        tab: _this3.activeTab,
                        val: file_name
                    });
                }).catch(function (err) {
                    console.error(err);
                    _this3.failedAjax();
                });
            }
        },
        addNewVendor: function addNewVendor() {
            var _this4 = this;

            if (!this.new_vendor) {
                return this.missingVal();
            }

            if (!this.$refs.vendor.disabled) {
                var vendor_name = this.new_vendor;

                axios.post(this.addNewVendorRoute, {
                    'dir_name': vendor_name
                }).then(function (_ref4) {
                    var data = _ref4.data;

                    if (!data.success) {
                        return _this4.showNotif(data.message, 'danger');
                    }

                    _this4.showNotif(data.message);
                    _this4.resetAll(['new_vendor']);
                    EventHub.fire('new_vendor_added', vendor_name);
                }).catch(function (err) {
                    console.error(err);
                    _this4.failedAjax();
                });
            }
        }
    }
};

/***/ }),

/***/ "./resources/assets/js/Tabs/default.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/default.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-f43693fc\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/default.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/Tabs/default.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-f43693fc", Component.options)
  } else {
    hotAPI.reload("data-v-f43693fc", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/Tabs/ops.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    data: function data() {
        return {
            routes: {
                filesRoute: this.$parent.filesRoute,
                selectedFileDataRoute: this.$parent.selectedFileDataRoute,
                deleteFileRoute: this.$parent.deleteFileRoute,
                deleteLocaleRoute: this.$parent.deleteLocaleRoute,
                saveFileRoute: this.$parent.saveFileRoute
            },
            files: [],
            selectedFile: '',
            locales: [],
            selectedFileData: '',
            selectedFileDataClone: '',
            newKeys: '',
            dataChanged: false,
            newItemCounter: 0,
            keyToCopy: '',
            currentInputRef: ''
        };
    },
    mounted: function mounted() {
        var _this = this;

        this.$tippy.forceUpdateHtml();

        EventHub.listen('ls-file', function (data) {
            if (data.tab == _this.getTabName()) {
                setTimeout(function () {
                    _this.selectedFile = data.val;

                    if (data.val == '' && _this.getTabName().includes('vendor')) {
                        _this.$parent.filesList = [];
                    }
                }, 50);
            }
        });

        EventHub.listen('scan_complete', function (data) {
            if (data.tab == _this.getTabName() && _this.selectedFile !== '') {
                _this.getFileContent();
            }
        });

        EventHub.listen('new_locale_added', function (data) {
            if (data.tab == _this.getTabName()) {
                _this.getFileContent();
            }
        });

        EventHub.listen('new_file_added', function (data) {
            if (data.tab == _this.getTabName()) {
                _this.getFiles();

                setTimeout(function () {
                    _this.selectedFile = data.val;
                }, 50);
            }
        });

        // before refresh
        window.onbeforeunload = function () {
            if (_this.dataChanged === true) {
                return confirm('Confirm refresh');
            }
        };

        // copy to clipboard
        document.body.onclick = function (e) {
            e = window.event ? e.srcElement : e.target;
            if (e.className && e.className.indexOf('c2c') != -1) {
                _this.$copyText(_this.keyToCopy);
                _this.refocus();
            }
        };
    },
    activated: function activated() {
        if (this.$parent.activeTab == this.getTabName()) {
            this.$parent.dirsList = this.dirs;
            this.$parent.selectedDirName = this.selectedDir;
            this.$parent.localesList = this.locales;
            this.$parent.selectedFileName = this.selectedFile;
            this.$parent.filesList = this.files;
        }
    },

    methods: {
        // data
        getFileContent: function getFileContent() {
            var _this2 = this;

            axios.post(this.routes.selectedFileDataRoute, {
                'file_name': this.selectedFile || null,
                'dir_name': this.selectedDir || null
            }).then(function (_ref) {
                var data = _ref.data;

                if (!data.success) {
                    return _this2.resetAll(['selectedFile', 'files']);
                }

                _this2.locales = data.message.locales;
                var all = data.message.all;
                if (all) {
                    _this2.selectedFileData = all;
                    _this2.selectedFileDataClone = JSON.parse(JSON.stringify(all));
                }
            }).catch(function (err) {
                console.error(err);
                _this2.$parent.failedAjax();
            });
        },

        // shared-content
        trans: function trans(key) {
            return this.parentMethod('trans', key) || '';
        },
        getTabName: function getTabName() {
            return this.$options.name;
        },
        resetAll: function resetAll(items) {
            var _this3 = this;

            items.forEach(function (e) {
                _this3[e] = '';
            });
        },
        showNotif: function showNotif(msg) {
            var s = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'success';

            this.parentMethod('showNotif', (msg, s));
        },
        failedAjax: function failedAjax() {
            this.showNotif(this.trans('ajax_error'), 'black');
        },
        parentMethod: function parentMethod(method_name) {
            var args = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            return this.$parent[method_name](args);
        },

        // copy key
        getFileName: function getFileName() {
            return this.selectedFile.replace(/(.[^.]*)$/, '');
        },
        getKey: function getKey(key) {
            var str = this.getTabName().includes('vendor') ? this.selectedDir + '::' + this.getFileName() + '.' + key : this.getFileName() + '.' + key;

            var rep = this.$parent.selectedKeyFormat !== '' ? this.$parent.selectedKeyFormat.replace('value', str) : '\'' + str + '\'';

            return rep;
        },
        refocus: function refocus() {
            if (this.currentInputRef) {
                return this.currentInputRef.target.focus();
            }
        }
    },
    watch: {
        selectedFileDataClone: function selectedFileDataClone(val) {
            var _this4 = this;

            this.$nextTick(function () {
                if (Object.keys(val).length == 0) {
                    _this4.resetAll(['newKeys']);
                }
            });
        },
        locales: function locales(val) {
            this.$parent.localesList = val;
        },
        selectedFile: function selectedFile(val) {
            this.$parent.selectedFileName = val;
            this.dataChanged = false;
            this.resetAll(['newKeys', 'currentInputRef', 'keyToCopy']);

            if (val) {
                if (this.getTabName().includes('vendor') && !this.selectedDirName) {
                    return;
                }

                this.getFileContent();
            }
        },
        files: function files(val) {
            this.$parent.filesList = val;
        }
    }
};

/***/ }),

/***/ "./resources/assets/js/Tabs/shared/content.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
function injectStyle (ssrContext) {
  if (disposed) return
  __webpack_require__("./node_modules/vue-style-loader/index.js!./node_modules/css-loader/index.js?sourceMap!./node_modules/vue-loader/lib/style-compiler/index.js?{\"vue\":true,\"id\":\"data-v-314333c4\",\"scoped\":true,\"hasInlineConfig\":true}!./node_modules/vue-loader/lib/selector.js?type=styles&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue")
}
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-314333c4\",\"hasScoped\":true,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/shared/content.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = injectStyle
/* scopeId */
var __vue_scopeId__ = "data-v-314333c4"
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/Tabs/shared/content.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-314333c4", Component.options)
  } else {
    hotAPI.reload("data-v-314333c4", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/Tabs/shared/forms.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


Object.defineProperty(exports, "__esModule", {
    value: true
});
exports.default = {
    methods: {
        removeSelectedFile: function removeSelectedFile() {
            var _this = this;

            if (confirm(this.trans('you_sure_file'))) {

                var removedFile = this.selectedFile;
                var currentDir = this.selectedDir;
                var currentFiles = Object.values(this.files);
                var lastItem = currentFiles.length == 1 && currentFiles[0] == removedFile;

                axios.post(this.routes.deleteFileRoute, {
                    'file_name': removedFile,
                    'dir_name': currentDir || null
                }).then(function (_ref) {
                    var data = _ref.data;

                    if (!data.success) {
                        return _this.parentMethod('showNotif', (data.message, 'danger'));
                    }

                    _this.parentMethod('showNotif', data.message);
                    _this.parentMethod('resetAll', ['selectedFile', 'selectedDir']);
                    _this.resetData();

                    if (lastItem) {
                        _this.selectedDir = currentDir;

                        // remove locales as they are useless
                        return _this.locales.forEach(function (e) {
                            _this.removeLocale(e, 'y');
                        });
                    }

                    _this.locales = [];
                    _this.selectedDir = currentDir;
                    _this.parentMethod('getFiles');
                }).catch(function (err) {
                    console.error(err);
                    _this.parentMethod('failedAjax');
                });
            }
        },
        removeLocale: function removeLocale(locale) {
            var _this2 = this;

            var override = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : null;

            if (override || confirm(this.trans('you_sure_locale'))) {
                axios.post(this.routes.deleteLocaleRoute, {
                    'locale': locale,
                    'dir_name': this.selectedDir || null
                }).then(function (_ref2) {
                    var data = _ref2.data;

                    if (!data.success) {
                        return _this2.parentMethod('showNotif', (data.message, 'danger'));
                    }

                    if (!override) {
                        _this2.parentMethod('showNotif', data.message);
                    }

                    _this2.locales.splice(locale, 1);
                    _this2.parentMethod('getFileContent');
                }).catch(function (err) {
                    console.error(err);
                    _this2.parentMethod('failedAjax');
                });
            }
        },
        submitNewData: function submitNewData() {
            var _this3 = this;

            if (this.dontHaveData()) {
                this.parentMethod('showNotif', (this.trans('empty_file'), 'warning'));
            }

            axios.post(this.routes.saveFileRoute, {
                'file_name': this.selectedFile,
                'dir_name': this.selectedDir || null,
                data: this.formatData()
            }).then(function (_ref3) {
                var data = _ref3.data;

                if (!data.success) {
                    return _this3.parentMethod('showNotif', (data.message, 'danger'));
                }

                _this3.parentMethod('showNotif', data.message);
                _this3.dataChanged = false;
                _this3.selectedFileData = Object.assign({}, _this3.selectedFileDataClone);
            }).catch(function (err) {
                console.error(err);
                _this3.parentMethod('failedAjax');
            });
        }
    }
};

/***/ }),

/***/ "./resources/assets/js/Tabs/vendor.vue":
/***/ (function(module, exports, __webpack_require__) {

var disposed = false
var normalizeComponent = __webpack_require__("./node_modules/vue-loader/lib/component-normalizer.js")
/* script */
var __vue_script__ = __webpack_require__("./node_modules/babel-loader/lib/index.js?{\"cacheDirectory\":true,\"presets\":[[\"env\",{\"modules\":false,\"targets\":{\"browsers\":[\"> 2%\"],\"uglify\":true}}]],\"plugins\":[\"transform-object-rest-spread\",[\"transform-runtime\",{\"polyfill\":false,\"helpers\":false}]]}!./node_modules/vue-loader/lib/selector.js?type=script&index=0&bustCache!./resources/assets/js/Tabs/vendor.vue")
/* template */
var __vue_template__ = __webpack_require__("./node_modules/vue-loader/lib/template-compiler/index.js?{\"id\":\"data-v-062335d2\",\"hasScoped\":false,\"buble\":{\"transforms\":{}}}!./node_modules/vue-loader/lib/selector.js?type=template&index=0&bustCache!./resources/assets/js/Tabs/vendor.vue")
/* template functional */
var __vue_template_functional__ = false
/* styles */
var __vue_styles__ = null
/* scopeId */
var __vue_scopeId__ = null
/* moduleIdentifier (server only) */
var __vue_module_identifier__ = null
var Component = normalizeComponent(
  __vue_script__,
  __vue_template__,
  __vue_template_functional__,
  __vue_styles__,
  __vue_scopeId__,
  __vue_module_identifier__
)
Component.options.__file = "resources/assets/js/Tabs/vendor.vue"
if (Component.esModule && Object.keys(Component.esModule).some(function (key) {  return key !== "default" && key.substr(0, 2) !== "__"})) {  console.error("named exports are not supported in *.vue files.")}

/* hot reload */
if (false) {(function () {
  var hotAPI = require("vue-hot-reload-api")
  hotAPI.install(require("vue"), false)
  if (!hotAPI.compatible) return
  module.hot.accept()
  if (!module.hot.data) {
    hotAPI.createRecord("data-v-062335d2", Component.options)
  } else {
    hotAPI.reload("data-v-062335d2", Component.options)
' + '  }
  module.hot.dispose(function (data) {
    disposed = true
  })
})()}

module.exports = Component.exports


/***/ }),

/***/ "./resources/assets/js/app.js":
/***/ (function(module, exports, __webpack_require__) {

"use strict";


__webpack_require__("./node_modules/vue-awesome/icons/trash.js");

__webpack_require__("./node_modules/vue-awesome/icons/search.js");

__webpack_require__("./node_modules/vue-awesome/icons/archive.js");

__webpack_require__("./node_modules/vue-awesome/icons/globe.js");

__webpack_require__("./node_modules/vue-awesome/icons/qrcode.js");

__webpack_require__("./node_modules/vue-awesome/icons/keyboard-o.js");

__webpack_require__("./node_modules/vue-awesome/icons/file.js");

__webpack_require__("./node_modules/vue-awesome/icons/file-o.js");

__webpack_require__("./node_modules/vue-awesome/icons/files-o.js");

__webpack_require__("./node_modules/vue-awesome/icons/folder.js");

/*                Libs                */
window.Vue = __webpack_require__("./node_modules/vue/dist/vue.common.js");
window.EventHub = __webpack_require__("./node_modules/vuemit/src/Vuemit.js");
Vue.use(__webpack_require__("./node_modules/vue-tippy/vue-tippy.js"));
Vue.use(__webpack_require__("./node_modules/vue-clipboard2/vue-clipboard.js"));
Vue.use(__webpack_require__("./node_modules/vue-ls/dist/vue-ls.js"));

// axios
window.axios = __webpack_require__("./node_modules/axios/index.js");
axios.defaults.headers.common = {
    'X-CSRF-TOKEN': document.querySelector('meta[name="csrf-token"]').getAttribute('content'),
    'X-Requested-With': 'XMLHttpRequest'
    // vue-awesome
};

Vue.component('icon', __webpack_require__("./node_modules/vue-awesome/components/Icon.vue"));

/*                Components                */
Vue.component('Lingo', __webpack_require__("./resources/assets/js/Main/container.vue"));
Vue.component('MyNotification', __webpack_require__("./node_modules/vue-notif/src/Notification.vue"));

new Vue({
    el: '#app'
});

/***/ }),

/***/ "./resources/assets/sass/app.scss":
/***/ (function(module, exports) {

// removed by extract-text-webpack-plugin

/***/ }),

/***/ 0:
/***/ (function(module, exports, __webpack_require__) {

__webpack_require__("./resources/assets/js/app.js");
module.exports = __webpack_require__("./resources/assets/sass/app.scss");


/***/ })

/******/ });
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly8vd2VicGFjay9ib290c3RyYXAgMDI2OWJhYTZmOTJlZDQ3Y2QxOWEiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYWRhcHRlcnMveGhyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvYXhpb3MuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvdHJhbnNmb3JtRGF0YS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idWlsZFVSTC5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIndlYnBhY2s6Ly8vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWUiLCJ3ZWJwYWNrOi8vL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWUiLCJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9hc3NldHMvanMvTWFpbi9jb250YWluZXIudnVlIiwid2VicGFjazovLy9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvZGVmYXVsdC52dWUiLCJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWUiLCJ3ZWJwYWNrOi8vL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy92ZW5kb3IudnVlIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jbGlwYm9hcmQvbGliL2NsaXBib2FyZC1hY3Rpb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2NsaXBib2FyZC9saWIvY2xpcGJvYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmNzcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvc2hhcmVkL2NvbnRlbnQudnVlPzc4ZmMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZT9jZjk2Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWU/ZTgwMiIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZT82ZWExIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZGVsZWdhdGUvc3JjL2Nsb3Nlc3QuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2RlbGVnYXRlL3NyYy9kZWxlZ2F0ZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvZ29vZC1saXN0ZW5lci9zcmMvaXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL2dvb2QtbGlzdGVuZXIvc3JjL2xpc3Rlbi5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3NlbGVjdC9zcmMvc2VsZWN0LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zZXRpbW1lZGlhdGUvc2V0SW1tZWRpYXRlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvc3R5bGUtbG9hZGVyL2xpYi91cmxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy90aW55LWVtaXR0ZXIvaW5kZXguanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzPzVkYTUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWUiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2ljb25zL2FyY2hpdmUuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2ljb25zL2ZpbGUtby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvZmlsZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvZmlsZXMtby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvZm9sZGVyLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtYXdlc29tZS9pY29ucy9nbG9iZS5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMva2V5Ym9hcmQtby5qcyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvcXJjb2RlLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtYXdlc29tZS9pY29ucy9zZWFyY2guanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2ljb25zL3RyYXNoLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtY2xpcGJvYXJkMi92dWUtY2xpcGJvYXJkLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvdmVuZG9yLnZ1ZT9hMThkIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWU/OTQzNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlPzJkZjAiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWU/MWVkYSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvZGVmYXVsdC52dWU/YTE5YyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLWxzL2Rpc3QvdnVlLWxzLmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZT81OGE4Iiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWU/NDRlNyIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlP2FjMGIiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWU/NTA1OCIsIndlYnBhY2s6Ly8vLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzIiwid2VicGFjazovLy8uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS10aXBweS92dWUtdGlwcHkuanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZS9kaXN0L3Z1ZS5jb21tb24uanMiLCJ3ZWJwYWNrOi8vLy4vbm9kZV9tb2R1bGVzL3Z1ZW1pdC9zcmMvVnVlbWl0LmpzIiwid2VicGFjazovLy8od2VicGFjaykvYnVpbGRpbi9nbG9iYWwuanMiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9NYWluL2NvbnRhaW5lci52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9NYWluL2Zvcm1zLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9kZWZhdWx0LnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvb3BzLmpzIiwid2VicGFjazovLy8uL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWUiLCJ3ZWJwYWNrOi8vLy4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9mb3Jtcy5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvdmVuZG9yLnZ1ZSIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL2pzL2FwcC5qcyIsIndlYnBhY2s6Ly8vLi9yZXNvdXJjZXMvYXNzZXRzL3Nhc3MvYXBwLnNjc3MiXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiLCJ1dGlscyIsInNldHRsZSIsImJ1aWxkVVJMIiwicGFyc2VIZWFkZXJzIiwiaXNVUkxTYW1lT3JpZ2luIiwiY3JlYXRlRXJyb3IiLCJidG9hIiwid2luZG93IiwiYmluZCIsInhockFkYXB0ZXIiLCJjb25maWciLCJQcm9taXNlIiwiZGlzcGF0Y2hYaHJSZXF1ZXN0IiwicmVzb2x2ZSIsInJlamVjdCIsInJlcXVlc3REYXRhIiwiZGF0YSIsInJlcXVlc3RIZWFkZXJzIiwiaGVhZGVycyIsImlzRm9ybURhdGEiLCJyZXF1ZXN0IiwiWE1MSHR0cFJlcXVlc3QiLCJsb2FkRXZlbnQiLCJ4RG9tYWluIiwiWERvbWFpblJlcXVlc3QiLCJ1cmwiLCJvbnByb2dyZXNzIiwiaGFuZGxlUHJvZ3Jlc3MiLCJvbnRpbWVvdXQiLCJoYW5kbGVUaW1lb3V0IiwiYXV0aCIsInVzZXJuYW1lIiwicGFzc3dvcmQiLCJBdXRob3JpemF0aW9uIiwib3BlbiIsIm1ldGhvZCIsInRvVXBwZXJDYXNlIiwicGFyYW1zIiwicGFyYW1zU2VyaWFsaXplciIsInRpbWVvdXQiLCJoYW5kbGVMb2FkIiwicmVhZHlTdGF0ZSIsInN0YXR1cyIsInJlc3BvbnNlVVJMIiwiaW5kZXhPZiIsInJlc3BvbnNlSGVhZGVycyIsImdldEFsbFJlc3BvbnNlSGVhZGVycyIsInJlc3BvbnNlRGF0YSIsInJlc3BvbnNlVHlwZSIsInJlc3BvbnNlVGV4dCIsInJlc3BvbnNlIiwic3RhdHVzVGV4dCIsIm9uZXJyb3IiLCJoYW5kbGVFcnJvciIsImlzU3RhbmRhcmRCcm93c2VyRW52IiwiY29va2llcyIsInhzcmZWYWx1ZSIsIndpdGhDcmVkZW50aWFscyIsInhzcmZDb29raWVOYW1lIiwicmVhZCIsInVuZGVmaW5lZCIsInhzcmZIZWFkZXJOYW1lIiwiZm9yRWFjaCIsInNldFJlcXVlc3RIZWFkZXIiLCJ2YWwiLCJrZXkiLCJ0b0xvd2VyQ2FzZSIsImUiLCJvbkRvd25sb2FkUHJvZ3Jlc3MiLCJhZGRFdmVudExpc3RlbmVyIiwib25VcGxvYWRQcm9ncmVzcyIsInVwbG9hZCIsImNhbmNlbFRva2VuIiwicHJvbWlzZSIsInRoZW4iLCJvbkNhbmNlbGVkIiwiY2FuY2VsIiwiYWJvcnQiLCJzZW5kIiwiQXhpb3MiLCJkZWZhdWx0cyIsImNyZWF0ZUluc3RhbmNlIiwiZGVmYXVsdENvbmZpZyIsImNvbnRleHQiLCJpbnN0YW5jZSIsInByb3RvdHlwZSIsImV4dGVuZCIsImF4aW9zIiwiY3JlYXRlIiwiaW5zdGFuY2VDb25maWciLCJtZXJnZSIsIkNhbmNlbCIsIkNhbmNlbFRva2VuIiwiaXNDYW5jZWwiLCJhbGwiLCJwcm9taXNlcyIsInNwcmVhZCIsImRlZmF1bHQiLCJtZXNzYWdlIiwidG9TdHJpbmciLCJfX0NBTkNFTF9fIiwiZXhlY3V0b3IiLCJUeXBlRXJyb3IiLCJyZXNvbHZlUHJvbWlzZSIsInByb21pc2VFeGVjdXRvciIsInRva2VuIiwicmVhc29uIiwidGhyb3dJZlJlcXVlc3RlZCIsInNvdXJjZSIsImMiLCJ2YWx1ZSIsIkludGVyY2VwdG9yTWFuYWdlciIsImRpc3BhdGNoUmVxdWVzdCIsImludGVyY2VwdG9ycyIsImFyZ3VtZW50cyIsImNoYWluIiwidW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMiLCJpbnRlcmNlcHRvciIsInVuc2hpZnQiLCJmdWxmaWxsZWQiLCJyZWplY3RlZCIsInB1c2hSZXNwb25zZUludGVyY2VwdG9ycyIsInB1c2giLCJsZW5ndGgiLCJzaGlmdCIsImZvckVhY2hNZXRob2ROb0RhdGEiLCJmb3JFYWNoTWV0aG9kV2l0aERhdGEiLCJoYW5kbGVycyIsInVzZSIsImVqZWN0IiwiaWQiLCJmbiIsImZvckVhY2hIYW5kbGVyIiwiaCIsImVuaGFuY2VFcnJvciIsImNvZGUiLCJlcnJvciIsIkVycm9yIiwidHJhbnNmb3JtRGF0YSIsImlzQWJzb2x1dGVVUkwiLCJjb21iaW5lVVJMcyIsInRocm93SWZDYW5jZWxsYXRpb25SZXF1ZXN0ZWQiLCJiYXNlVVJMIiwidHJhbnNmb3JtUmVxdWVzdCIsImNvbW1vbiIsImNsZWFuSGVhZGVyQ29uZmlnIiwiYWRhcHRlciIsIm9uQWRhcHRlclJlc29sdXRpb24iLCJ0cmFuc2Zvcm1SZXNwb25zZSIsIm9uQWRhcHRlclJlamVjdGlvbiIsInZhbGlkYXRlU3RhdHVzIiwiZm5zIiwidHJhbnNmb3JtIiwibm9ybWFsaXplSGVhZGVyTmFtZSIsIkRFRkFVTFRfQ09OVEVOVF9UWVBFIiwic2V0Q29udGVudFR5cGVJZlVuc2V0IiwiaXNVbmRlZmluZWQiLCJnZXREZWZhdWx0QWRhcHRlciIsInByb2Nlc3MiLCJpc0FycmF5QnVmZmVyIiwiaXNCdWZmZXIiLCJpc1N0cmVhbSIsImlzRmlsZSIsImlzQmxvYiIsImlzQXJyYXlCdWZmZXJWaWV3IiwiYnVmZmVyIiwiaXNVUkxTZWFyY2hQYXJhbXMiLCJpc09iamVjdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJwYXJzZSIsIm1heENvbnRlbnRMZW5ndGgiLCJ0aGlzQXJnIiwid3JhcCIsImFyZ3MiLCJBcnJheSIsImkiLCJhcHBseSIsImNoYXJzIiwiRSIsIm5hbWUiLCJpbnB1dCIsInN0ciIsIlN0cmluZyIsIm91dHB1dCIsImJsb2NrIiwiY2hhckNvZGUiLCJpZHgiLCJtYXAiLCJjaGFyQXQiLCJjaGFyQ29kZUF0IiwiZW5jb2RlIiwiZW5jb2RlVVJJQ29tcG9uZW50IiwicmVwbGFjZSIsInNlcmlhbGl6ZWRQYXJhbXMiLCJwYXJ0cyIsInNlcmlhbGl6ZSIsImlzQXJyYXkiLCJwYXJzZVZhbHVlIiwidiIsImlzRGF0ZSIsInRvSVNPU3RyaW5nIiwiam9pbiIsInJlbGF0aXZlVVJMIiwic3RhbmRhcmRCcm93c2VyRW52Iiwid3JpdGUiLCJleHBpcmVzIiwicGF0aCIsImRvbWFpbiIsInNlY3VyZSIsImNvb2tpZSIsImlzTnVtYmVyIiwiRGF0ZSIsInRvR01UU3RyaW5nIiwiaXNTdHJpbmciLCJkb2N1bWVudCIsIm1hdGNoIiwiUmVnRXhwIiwiZGVjb2RlVVJJQ29tcG9uZW50IiwicmVtb3ZlIiwibm93Iiwibm9uU3RhbmRhcmRCcm93c2VyRW52IiwidGVzdCIsIm1zaWUiLCJuYXZpZ2F0b3IiLCJ1c2VyQWdlbnQiLCJ1cmxQYXJzaW5nTm9kZSIsImNyZWF0ZUVsZW1lbnQiLCJvcmlnaW5VUkwiLCJyZXNvbHZlVVJMIiwiaHJlZiIsInNldEF0dHJpYnV0ZSIsInByb3RvY29sIiwiaG9zdCIsInNlYXJjaCIsImhhc2giLCJob3N0bmFtZSIsInBvcnQiLCJwYXRobmFtZSIsImxvY2F0aW9uIiwicmVxdWVzdFVSTCIsInBhcnNlZCIsIm5vcm1hbGl6ZWROYW1lIiwicHJvY2Vzc0hlYWRlciIsImlnbm9yZUR1cGxpY2F0ZU9mIiwic3BsaXQiLCJwYXJzZXIiLCJsaW5lIiwidHJpbSIsInN1YnN0ciIsImNvbmNhdCIsImNhbGxiYWNrIiwiYXJyIiwiT2JqZWN0IiwiY2FsbCIsIkZvcm1EYXRhIiwicmVzdWx0IiwiQXJyYXlCdWZmZXIiLCJpc1ZpZXciLCJpc0Z1bmN0aW9uIiwicGlwZSIsIlVSTFNlYXJjaFBhcmFtcyIsInByb2R1Y3QiLCJvYmoiLCJsIiwiaGFzT3duUHJvcGVydHkiLCJhc3NpZ25WYWx1ZSIsImEiLCJiIiwiZ2xvYmFsIiwiZmFjdG9yeSIsImRlZmluZSIsIm1vZCIsInNlbGVjdCIsImNsaXBib2FyZEFjdGlvbiIsIl9zZWxlY3QiLCJfc2VsZWN0MiIsIl9pbnRlcm9wUmVxdWlyZURlZmF1bHQiLCJfX2VzTW9kdWxlIiwiX3R5cGVvZiIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiY29uc3RydWN0b3IiLCJfY2xhc3NDYWxsQ2hlY2siLCJDb25zdHJ1Y3RvciIsIl9jcmVhdGVDbGFzcyIsImRlZmluZVByb3BlcnRpZXMiLCJ0YXJnZXQiLCJwcm9wcyIsImRlc2NyaXB0b3IiLCJlbnVtZXJhYmxlIiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJkZWZpbmVQcm9wZXJ0eSIsInByb3RvUHJvcHMiLCJzdGF0aWNQcm9wcyIsIkNsaXBib2FyZEFjdGlvbiIsIm9wdGlvbnMiLCJyZXNvbHZlT3B0aW9ucyIsImluaXRTZWxlY3Rpb24iLCJhY3Rpb24iLCJjb250YWluZXIiLCJlbWl0dGVyIiwidGV4dCIsInRyaWdnZXIiLCJzZWxlY3RlZFRleHQiLCJzZWxlY3RGYWtlIiwic2VsZWN0VGFyZ2V0IiwiX3RoaXMiLCJpc1JUTCIsImRvY3VtZW50RWxlbWVudCIsImdldEF0dHJpYnV0ZSIsInJlbW92ZUZha2UiLCJmYWtlSGFuZGxlckNhbGxiYWNrIiwiZmFrZUhhbmRsZXIiLCJmYWtlRWxlbSIsInN0eWxlIiwiZm9udFNpemUiLCJib3JkZXIiLCJwYWRkaW5nIiwibWFyZ2luIiwicG9zaXRpb24iLCJ5UG9zaXRpb24iLCJwYWdlWU9mZnNldCIsInNjcm9sbFRvcCIsInRvcCIsImFwcGVuZENoaWxkIiwiY29weVRleHQiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwicmVtb3ZlQ2hpbGQiLCJzdWNjZWVkZWQiLCJleGVjQ29tbWFuZCIsImVyciIsImhhbmRsZVJlc3VsdCIsImVtaXQiLCJjbGVhclNlbGVjdGlvbiIsImZvY3VzIiwiZ2V0U2VsZWN0aW9uIiwicmVtb3ZlQWxsUmFuZ2VzIiwiZGVzdHJveSIsInNldCIsIl9hY3Rpb24iLCJnZXQiLCJub2RlVHlwZSIsImhhc0F0dHJpYnV0ZSIsIl90YXJnZXQiLCJ0aW55RW1pdHRlciIsImdvb2RMaXN0ZW5lciIsImNsaXBib2FyZCIsIl9jbGlwYm9hcmRBY3Rpb24iLCJfdGlueUVtaXR0ZXIiLCJfZ29vZExpc3RlbmVyIiwiX2NsaXBib2FyZEFjdGlvbjIiLCJfdGlueUVtaXR0ZXIyIiwiX2dvb2RMaXN0ZW5lcjIiLCJfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybiIsInNlbGYiLCJSZWZlcmVuY2VFcnJvciIsIl9pbmhlcml0cyIsInN1YkNsYXNzIiwic3VwZXJDbGFzcyIsInNldFByb3RvdHlwZU9mIiwiX19wcm90b19fIiwiQ2xpcGJvYXJkIiwiX0VtaXR0ZXIiLCJnZXRQcm90b3R5cGVPZiIsImxpc3RlbkNsaWNrIiwiZGVmYXVsdEFjdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJkZWZhdWx0VGV4dCIsImJvZHkiLCJfdGhpczIiLCJsaXN0ZW5lciIsIm9uQ2xpY2siLCJkZWxlZ2F0ZVRhcmdldCIsImN1cnJlbnRUYXJnZXQiLCJnZXRBdHRyaWJ1dGVWYWx1ZSIsInNlbGVjdG9yIiwicXVlcnlTZWxlY3RvciIsImlzU3VwcG9ydGVkIiwiYWN0aW9ucyIsInN1cHBvcnQiLCJxdWVyeUNvbW1hbmRTdXBwb3J0ZWQiLCJzdWZmaXgiLCJlbGVtZW50IiwiYXR0cmlidXRlIiwidXNlU291cmNlTWFwIiwibGlzdCIsIml0ZW0iLCJjb250ZW50IiwiY3NzV2l0aE1hcHBpbmdUb1N0cmluZyIsIm1vZHVsZXMiLCJtZWRpYVF1ZXJ5IiwiYWxyZWFkeUltcG9ydGVkTW9kdWxlcyIsImNzc01hcHBpbmciLCJzb3VyY2VNYXBwaW5nIiwidG9Db21tZW50Iiwic291cmNlVVJMcyIsInNvdXJjZXMiLCJzb3VyY2VSb290Iiwic291cmNlTWFwIiwiYmFzZTY0IiwidW5lc2NhcGUiLCJET0NVTUVOVF9OT0RFX1RZUEUiLCJFbGVtZW50IiwibWF0Y2hlcyIsInByb3RvIiwibWF0Y2hlc1NlbGVjdG9yIiwibW96TWF0Y2hlc1NlbGVjdG9yIiwibXNNYXRjaGVzU2VsZWN0b3IiLCJvTWF0Y2hlc1NlbGVjdG9yIiwid2Via2l0TWF0Y2hlc1NlbGVjdG9yIiwiY2xvc2VzdCIsInBhcmVudE5vZGUiLCJfZGVsZWdhdGUiLCJ0eXBlIiwidXNlQ2FwdHVyZSIsImxpc3RlbmVyRm4iLCJkZWxlZ2F0ZSIsImVsZW1lbnRzIiwicXVlcnlTZWxlY3RvckFsbCIsIm5vZGUiLCJIVE1MRWxlbWVudCIsIm5vZGVMaXN0Iiwic3RyaW5nIiwiaXMiLCJsaXN0ZW4iLCJsaXN0ZW5Ob2RlIiwibGlzdGVuTm9kZUxpc3QiLCJsaXN0ZW5TZWxlY3RvciIsImlzU2xvd0J1ZmZlciIsIl9pc0J1ZmZlciIsInJlYWRGbG9hdExFIiwic2xpY2UiLCJjYWNoZWRTZXRUaW1lb3V0IiwiY2FjaGVkQ2xlYXJUaW1lb3V0IiwiZGVmYXVsdFNldFRpbW91dCIsImRlZmF1bHRDbGVhclRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2xlYXJUaW1lb3V0IiwicnVuVGltZW91dCIsImZ1biIsInJ1bkNsZWFyVGltZW91dCIsIm1hcmtlciIsInF1ZXVlIiwiZHJhaW5pbmciLCJjdXJyZW50UXVldWUiLCJxdWV1ZUluZGV4IiwiY2xlYW5VcE5leHRUaWNrIiwiZHJhaW5RdWV1ZSIsImxlbiIsInJ1biIsIm5leHRUaWNrIiwiSXRlbSIsImFycmF5IiwidGl0bGUiLCJicm93c2VyIiwiZW52IiwiYXJndiIsInZlcnNpb24iLCJ2ZXJzaW9ucyIsIm5vb3AiLCJvbiIsImFkZExpc3RlbmVyIiwib25jZSIsIm9mZiIsInJlbW92ZUxpc3RlbmVyIiwicmVtb3ZlQWxsTGlzdGVuZXJzIiwicHJlcGVuZExpc3RlbmVyIiwicHJlcGVuZE9uY2VMaXN0ZW5lciIsImxpc3RlbmVycyIsImJpbmRpbmciLCJjd2QiLCJjaGRpciIsImRpciIsInVtYXNrIiwibm9kZU5hbWUiLCJpc1JlYWRPbmx5Iiwic2V0U2VsZWN0aW9uUmFuZ2UiLCJyZW1vdmVBdHRyaWJ1dGUiLCJzZWxlY3Rpb24iLCJyYW5nZSIsImNyZWF0ZVJhbmdlIiwic2VsZWN0Tm9kZUNvbnRlbnRzIiwiYWRkUmFuZ2UiLCJzZXRJbW1lZGlhdGUiLCJuZXh0SGFuZGxlIiwidGFza3NCeUhhbmRsZSIsImN1cnJlbnRseVJ1bm5pbmdBVGFzayIsImRvYyIsInJlZ2lzdGVySW1tZWRpYXRlIiwiRnVuY3Rpb24iLCJ0YXNrIiwiY2xlYXJJbW1lZGlhdGUiLCJoYW5kbGUiLCJydW5JZlByZXNlbnQiLCJpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbiIsImNhblVzZVBvc3RNZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJpbXBvcnRTY3JpcHRzIiwicG9zdE1lc3NhZ2VJc0FzeW5jaHJvbm91cyIsIm9sZE9uTWVzc2FnZSIsIm9ubWVzc2FnZSIsImluc3RhbGxQb3N0TWVzc2FnZUltcGxlbWVudGF0aW9uIiwibWVzc2FnZVByZWZpeCIsIk1hdGgiLCJyYW5kb20iLCJvbkdsb2JhbE1lc3NhZ2UiLCJldmVudCIsImF0dGFjaEV2ZW50IiwiaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24iLCJjaGFubmVsIiwiTWVzc2FnZUNoYW5uZWwiLCJwb3J0MSIsInBvcnQyIiwiaW5zdGFsbFJlYWR5U3RhdGVDaGFuZ2VJbXBsZW1lbnRhdGlvbiIsImh0bWwiLCJzY3JpcHQiLCJvbnJlYWR5c3RhdGVjaGFuZ2UiLCJpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uIiwiYXR0YWNoVG8iLCJjc3MiLCJiYXNlVXJsIiwiY3VycmVudERpciIsImZpeGVkQ3NzIiwiZnVsbE1hdGNoIiwib3JpZ1VybCIsInVucXVvdGVkT3JpZ1VybCIsIm8iLCIkMSIsIm5ld1VybCIsIlRpbWVvdXQiLCJzZXRJbnRlcnZhbCIsImNsZWFySW50ZXJ2YWwiLCJjbG9zZSIsImNsZWFyRm4iLCJfaWQiLCJfY2xlYXJGbiIsInVucmVmIiwicmVmIiwiZW5yb2xsIiwibXNlY3MiLCJfaWRsZVRpbWVvdXRJZCIsIl9pZGxlVGltZW91dCIsInVuZW5yb2xsIiwiX3VucmVmQWN0aXZlIiwiYWN0aXZlIiwib25UaW1lb3V0IiwiX29uVGltZW91dCIsImN0eCIsIl8iLCJldnRBcnIiLCJldnRzIiwibGl2ZUV2ZW50cyIsInRpcHB5IiwiQnJvd3NlciIsIlNVUFBPUlRFRCIsIlNVUFBPUlRTX1RPVUNIIiwidG91Y2giLCJkeW5hbWljSW5wdXREZXRlY3Rpb24iLCJpT1MiLCJNU1N0cmVhbSIsIlN0b3JlIiwiU2VsZWN0b3JzIiwiUE9QUEVSIiwiVE9PTFRJUCIsIkNPTlRFTlQiLCJDSVJDTEUiLCJBUlJPVyIsIlRPT0xUSVBQRURfRUwiLCJDT05UUk9MTEVSIiwiRGVmYXVsdHMiLCJhbmltYXRpb24iLCJhbmltYXRlRmlsbCIsImFycm93IiwiYXJyb3dTaXplIiwiZGVsYXkiLCJkdXJhdGlvbiIsImludGVyYWN0aXZlIiwiaW50ZXJhY3RpdmVCb3JkZXIiLCJ0aGVtZSIsInNpemUiLCJkaXN0YW5jZSIsIm9mZnNldCIsImhpZGVPbkNsaWNrIiwibXVsdGlwbGUiLCJmb2xsb3dDdXJzb3IiLCJpbmVydGlhIiwiZmxpcER1cmF0aW9uIiwic3RpY2t5Iiwic3RpY2t5RHVyYXRpb24iLCJhcHBlbmRUbyIsInpJbmRleCIsInRvdWNoSG9sZCIsInBlcmZvcm1hbmNlIiwiZHluYW1pY1RpdGxlIiwicG9wcGVyT3B0aW9ucyIsIkRlZmF1bHRzS2V5cyIsImtleXMiLCJoaWRlQWxsUG9wcGVycyIsImV4Y2x1ZGUiLCJyZWZEYXRhIiwicG9wcGVyIiwidGlwcHlJbnN0YW5jZSIsIl9yZWZEYXRhJHNldHRpbmdzIiwic2V0dGluZ3MiLCJjb250YWlucyIsImlzSGlkZU9uQ2xpY2siLCJpc05vdEN1cnJlbnRSZWYiLCJoaWRlIiwicyIsIm93bmVyRG9jdW1lbnQiLCJtYXRjaGVzJDEiLCJwYXJlbnRTZWxlY3RvciIsIl9jbG9zZXN0IiwiZWwiLCJwYXJlbnRFbGVtZW50IiwiZmluZCIsImNoZWNrRm4iLCJmaWx0ZXIiLCJiaW5kRXZlbnRMaXN0ZW5lcnMiLCJ0b3VjaEhhbmRsZXIiLCJjbGFzc0xpc3QiLCJhZGQiLCJtb3VzZW1vdmVIYW5kbGVyIiwidGltZSIsImNsaWNrSGFuZGxlciIsIl9yZWYiLCJfcmVmJHNldHRpbmdzIiwiYmx1ckhhbmRsZXIiLCJfZG9jdW1lbnQiLCJhY3RpdmVFbGVtZW50IiwiYmx1ciIsIm1heFRvdWNoUG9pbnRzIiwibXNNYXhUb3VjaFBvaW50cyIsImluaXQiLCJkb25lIiwiZGVmZXIiLCJyZXF1ZXN0QW5pbWF0aW9uRnJhbWUiLCJwcmVmaXgiLCJwcm9wZXJ0eSIsInByZWZpeGVzIiwidXBwZXJQcm9wIiwiX3ByZWZpeCIsInByZWZpeGVkUHJvcCIsImZpbmRJbmRleCIsInJlbW92ZVRpdGxlIiwiZWxlbWVudElzSW5WaWV3cG9ydCIsInJlY3QiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJsZWZ0IiwiYm90dG9tIiwiaW5uZXJIZWlnaHQiLCJjbGllbnRIZWlnaHQiLCJyaWdodCIsImlubmVyV2lkdGgiLCJjbGllbnRXaWR0aCIsInRyaWdnZXJSZWZsb3ciLCJ0b29sdGlwIiwiY2lyY2xlIiwiZ2V0Q29tcHV0ZWRTdHlsZSIsIm9wYWNpdHkiLCJtb2RpZnlDbGFzc0xpc3QiLCJlbHMiLCJnZXRJbm5lckVsZW1lbnRzIiwiYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24iLCJpc0NvbnRlbnQiLCJfZHVyYXRpb24iLCJyb3VuZCIsImlzVmlzaWJsZSIsInZpc2liaWxpdHkiLCJpc09iamVjdExpdGVyYWwiLCJnZXRDb3JlUGxhY2VtZW50IiwicGxhY2VtZW50IiwiZm9sbG93Q3Vyc29ySGFuZGxlciIsImhhbGZQb3BwZXJXaWR0aCIsIm9mZnNldFdpZHRoIiwiaGFsZlBvcHBlckhlaWdodCIsIm9mZnNldEhlaWdodCIsInZpZXdwb3J0UGFkZGluZyIsInBhZ2VXaWR0aCIsInBhZ2VYIiwicGFnZVkiLCJ4IiwieSIsImlzUmlnaHRPdmVyZmxvd2luZyIsImlzTGVmdE92ZXJmbG93aW5nIiwiZ2V0QXJyYXlPZkVsZW1lbnRzIiwiTm9kZUxpc3QiLCJvblRyYW5zaXRpb25FbmQiLCJfZ2V0SW5uZXJFbGVtZW50cyIsInRyYW5zaXRpb25lbmRGaXJlZCIsImxpc3RlbmVyQ2FsbGJhY2siLCJfdHJhbnNpdGlvbmVuZFRpbWVvdXQiLCJpc0Jyb3dzZXIiLCJsb25nZXJUaW1lb3V0QnJvd3NlcnMiLCJ0aW1lb3V0RHVyYXRpb24iLCJtaWNyb3Rhc2tEZWJvdW5jZSIsImNhbGxlZCIsInRhc2tEZWJvdW5jZSIsInNjaGVkdWxlZCIsInN1cHBvcnRzTWljcm9UYXNrcyIsImRlYm91bmNlIiwiZnVuY3Rpb25Ub0NoZWNrIiwiZ2V0VHlwZSIsImdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eSIsImdldFBhcmVudE5vZGUiLCJnZXRTY3JvbGxQYXJlbnQiLCJfZ2V0U3R5bGVDb21wdXRlZFByb3AiLCJvdmVyZmxvdyIsIm92ZXJmbG93WCIsIm92ZXJmbG93WSIsImdldE9mZnNldFBhcmVudCIsIm9mZnNldFBhcmVudCIsImlzT2Zmc2V0Q29udGFpbmVyIiwiZmlyc3RFbGVtZW50Q2hpbGQiLCJnZXRSb290IiwiZmluZENvbW1vbk9mZnNldFBhcmVudCIsImVsZW1lbnQxIiwiZWxlbWVudDIiLCJvcmRlciIsImNvbXBhcmVEb2N1bWVudFBvc2l0aW9uIiwiTm9kZSIsIkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORyIsInN0YXJ0IiwiZW5kIiwic2V0U3RhcnQiLCJzZXRFbmQiLCJjb21tb25BbmNlc3RvckNvbnRhaW5lciIsImVsZW1lbnQxcm9vdCIsImdldFNjcm9sbCIsInNpZGUiLCJ1cHBlclNpZGUiLCJzY3JvbGxpbmdFbGVtZW50IiwiaW5jbHVkZVNjcm9sbCIsInN1YnRyYWN0Iiwic2Nyb2xsTGVmdCIsIm1vZGlmaWVyIiwiZ2V0Qm9yZGVyc1NpemUiLCJzdHlsZXMiLCJheGlzIiwic2lkZUEiLCJzaWRlQiIsInBhcnNlRmxvYXQiLCJpc0lFMTAiLCJpc0lFMTAkMSIsImFwcFZlcnNpb24iLCJnZXRTaXplIiwiY29tcHV0ZWRTdHlsZSIsIm1heCIsImdldFdpbmRvd1NpemVzIiwiaGVpZ2h0Iiwid2lkdGgiLCJjbGFzc0NhbGxDaGVjayIsImNyZWF0ZUNsYXNzIiwiX2V4dGVuZHMiLCJhc3NpZ24iLCJnZXRDbGllbnRSZWN0Iiwib2Zmc2V0cyIsInNpemVzIiwiaG9yaXpTY3JvbGxiYXIiLCJ2ZXJ0U2Nyb2xsYmFyIiwiZ2V0T2Zmc2V0UmVjdFJlbGF0aXZlVG9BcmJpdHJhcnlOb2RlIiwiY2hpbGRyZW4iLCJwYXJlbnQiLCJpc0hUTUwiLCJjaGlsZHJlblJlY3QiLCJwYXJlbnRSZWN0Iiwic2Nyb2xsUGFyZW50IiwiYm9yZGVyVG9wV2lkdGgiLCJib3JkZXJMZWZ0V2lkdGgiLCJtYXJnaW5Ub3AiLCJtYXJnaW5MZWZ0IiwiZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlIiwicmVsYXRpdmVPZmZzZXQiLCJpc0ZpeGVkIiwiZ2V0Qm91bmRhcmllcyIsInJlZmVyZW5jZSIsImJvdW5kYXJpZXNFbGVtZW50IiwiYm91bmRhcmllcyIsImJvdW5kYXJpZXNOb2RlIiwiX2dldFdpbmRvd1NpemVzIiwiZ2V0QXJlYSIsImNvbXB1dGVBdXRvUGxhY2VtZW50IiwicmVmUmVjdCIsInJlY3RzIiwic29ydGVkQXJlYXMiLCJhcmVhIiwic29ydCIsImZpbHRlcmVkQXJlYXMiLCJfcmVmMiIsImNvbXB1dGVkUGxhY2VtZW50IiwidmFyaWF0aW9uIiwiZ2V0UmVmZXJlbmNlT2Zmc2V0cyIsInN0YXRlIiwiY29tbW9uT2Zmc2V0UGFyZW50IiwiZ2V0T3V0ZXJTaXplcyIsIm1hcmdpbkJvdHRvbSIsIm1hcmdpblJpZ2h0IiwiZ2V0T3Bwb3NpdGVQbGFjZW1lbnQiLCJtYXRjaGVkIiwiZ2V0UG9wcGVyT2Zmc2V0cyIsInJlZmVyZW5jZU9mZnNldHMiLCJwb3BwZXJSZWN0IiwicG9wcGVyT2Zmc2V0cyIsImlzSG9yaXoiLCJtYWluU2lkZSIsInNlY29uZGFyeVNpZGUiLCJtZWFzdXJlbWVudCIsInNlY29uZGFyeU1lYXN1cmVtZW50IiwiZmluZCQxIiwiY2hlY2siLCJmaW5kSW5kZXgkMSIsInByb3AiLCJjdXIiLCJydW5Nb2RpZmllcnMiLCJtb2RpZmllcnMiLCJlbmRzIiwibW9kaWZpZXJzVG9SdW4iLCJjb25zb2xlIiwid2FybiIsImVuYWJsZWQiLCJ1cGRhdGUiLCJpc0Rlc3Ryb3llZCIsImFycm93U3R5bGVzIiwiYXR0cmlidXRlcyIsImZsaXBwZWQiLCJmbGlwIiwib3JpZ2luYWxQbGFjZW1lbnQiLCJpc0NyZWF0ZWQiLCJvbkNyZWF0ZSIsIm9uVXBkYXRlIiwiaXNNb2RpZmllckVuYWJsZWQiLCJtb2RpZmllck5hbWUiLCJzb21lIiwiZ2V0U3VwcG9ydGVkUHJvcGVydHlOYW1lIiwidG9DaGVjayIsImRpc2FibGVFdmVudExpc3RlbmVycyIsInJlbW92ZU9uRGVzdHJveSIsImdldFdpbmRvdyIsImRlZmF1bHRWaWV3IiwiYXR0YWNoVG9TY3JvbGxQYXJlbnRzIiwic2Nyb2xsUGFyZW50cyIsImlzQm9keSIsInBhc3NpdmUiLCJzZXR1cEV2ZW50TGlzdGVuZXJzIiwidXBkYXRlQm91bmQiLCJzY3JvbGxFbGVtZW50IiwiZXZlbnRzRW5hYmxlZCIsImVuYWJsZUV2ZW50TGlzdGVuZXJzIiwic2NoZWR1bGVVcGRhdGUiLCJyZW1vdmVFdmVudExpc3RlbmVycyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiaXNOdW1lcmljIiwibiIsImlzTmFOIiwiaXNGaW5pdGUiLCJzZXRTdHlsZXMiLCJ1bml0Iiwic2V0QXR0cmlidXRlcyIsImFwcGx5U3R5bGUiLCJhcnJvd0VsZW1lbnQiLCJhcHBseVN0eWxlT25Mb2FkIiwibW9kaWZpZXJPcHRpb25zIiwiY29tcHV0ZVN0eWxlIiwibGVnYWN5R3B1QWNjZWxlcmF0aW9uT3B0aW9uIiwiZ3B1QWNjZWxlcmF0aW9uIiwib2Zmc2V0UGFyZW50UmVjdCIsImZsb29yIiwicHJlZml4ZWRQcm9wZXJ0eSIsIndpbGxDaGFuZ2UiLCJpbnZlcnRUb3AiLCJpbnZlcnRMZWZ0IiwiaXNNb2RpZmllclJlcXVpcmVkIiwicmVxdWVzdGluZ05hbWUiLCJyZXF1ZXN0ZWROYW1lIiwicmVxdWVzdGluZyIsImlzUmVxdWlyZWQiLCJfcmVxdWVzdGluZyIsInJlcXVlc3RlZCIsIl9kYXRhJG9mZnNldHMkYXJyb3ciLCJfZGF0YSRvZmZzZXRzIiwiaXNWZXJ0aWNhbCIsInNpZGVDYXBpdGFsaXplZCIsImFsdFNpZGUiLCJvcFNpZGUiLCJhcnJvd0VsZW1lbnRTaXplIiwiY2VudGVyIiwicG9wcGVyTWFyZ2luU2lkZSIsInBvcHBlckJvcmRlclNpZGUiLCJzaWRlVmFsdWUiLCJtaW4iLCJnZXRPcHBvc2l0ZVZhcmlhdGlvbiIsInBsYWNlbWVudHMiLCJ2YWxpZFBsYWNlbWVudHMiLCJjbG9ja3dpc2UiLCJjb3VudGVyIiwiaW5kZXgiLCJyZXZlcnNlIiwiQkVIQVZJT1JTIiwiRkxJUCIsIkNMT0NLV0lTRSIsIkNPVU5URVJDTE9DS1dJU0UiLCJwbGFjZW1lbnRPcHBvc2l0ZSIsImZsaXBPcmRlciIsImJlaGF2aW9yIiwic3RlcCIsInJlZk9mZnNldHMiLCJvdmVybGFwc1JlZiIsIm92ZXJmbG93c0xlZnQiLCJvdmVyZmxvd3NSaWdodCIsIm92ZXJmbG93c1RvcCIsIm92ZXJmbG93c0JvdHRvbSIsIm92ZXJmbG93c0JvdW5kYXJpZXMiLCJmbGlwcGVkVmFyaWF0aW9uIiwiZmxpcFZhcmlhdGlvbnMiLCJrZWVwVG9nZXRoZXIiLCJ0b1ZhbHVlIiwicGFyc2VPZmZzZXQiLCJiYXNlUGxhY2VtZW50IiwidXNlSGVpZ2h0IiwiZnJhZ21lbnRzIiwiZnJhZyIsImRpdmlkZXIiLCJzcGxpdFJlZ2V4Iiwib3BzIiwib3AiLCJtZXJnZVdpdGhQcmV2aW91cyIsInJlZHVjZSIsImluZGV4MiIsInByZXZlbnRPdmVyZmxvdyIsInByaW9yaXR5IiwicHJpbWFyeSIsImVzY2FwZVdpdGhSZWZlcmVuY2UiLCJzZWNvbmRhcnkiLCJzaGlmdHZhcmlhdGlvbiIsInNoaWZ0T2Zmc2V0cyIsImJvdW5kIiwiaW5uZXIiLCJzdWJ0cmFjdExlbmd0aCIsIm9uTG9hZCIsIkRlZmF1bHRzJDEiLCJQb3BwZXIiLCJqcXVlcnkiLCJ1cGRhdGUkJDEiLCJkZXN0cm95JCQxIiwiZW5hYmxlRXZlbnRMaXN0ZW5lcnMkJDEiLCJkaXNhYmxlRXZlbnRMaXN0ZW5lcnMkJDEiLCJVdGlscyIsIlBvcHBlclV0aWxzIiwiZ2V0T2Zmc2V0RGlzdGFuY2VJblB4IiwiY2xhc3NDYWxsQ2hlY2skMSIsImNyZWF0ZUNsYXNzJDEiLCJfZXh0ZW5kcyQxIiwiY3JlYXRlUG9wcGVySW5zdGFuY2UiLCJfZGF0YSRzZXR0aW5ncyIsIk11dGF0aW9uT2JzZXJ2ZXIiLCJvYnNlcnZlciIsInBvcHBlckluc3RhbmNlIiwib2JzZXJ2ZSIsImNoaWxkTGlzdCIsInN1YnRyZWUiLCJjaGFyYWN0ZXJEYXRhIiwiX211dGF0aW9uT2JzZXJ2ZXJzIiwibW91bnRQb3BwZXIiLCJtYWtlU3RpY2t5IiwicmVtb3ZlVHJhbnNpdGlvbkR1cmF0aW9uIiwidXBkYXRlUG9zaXRpb24iLCJnZXRJbmRpdmlkdWFsU2V0dGluZ3MiLCJpbnN0YW5jZVNldHRpbmdzIiwiYWNjIiwiY3JlYXRlUG9wcGVyRWxlbWVudCIsInQiLCJfYXJyb3ciLCJ0ZW1wbGF0ZUlkIiwiaW5uZXJIVE1MIiwiZ2V0RWxlbWVudEJ5SWQiLCJjcmVhdGVUcmlnZ2VyIiwiaGFuZGxlVHJpZ2dlciIsImhhbmRsZXIiLCJoYW5kbGVNb3VzZWxlYXZlIiwiaGFuZGxlQmx1ciIsImN1cnNvcklzT3V0c2lkZUludGVyYWN0aXZlQm9yZGVyIiwiY2xpZW50WCIsImNsaWVudFkiLCJjb3JlUG9zaXRpb24iLCJib3JkZXJXaXRoRGlzdGFuY2UiLCJleGNlZWRzIiwiZ2V0RXZlbnRMaXN0ZW5lckhhbmRsZXJzIiwidG91Y2hXYWl0Iiwic2hvd0RlbGF5IiwiaGlkZURlbGF5IiwiY2xlYXJUaW1lb3V0cyIsIl9zaG93IiwiX2RlbGF5Iiwic2hvdyIsImNhbGxiYWNrcyIsIndhaXQiLCJtb3VzZWVudGVyVG91Y2giLCJpc0NsaWNrIiwiaXNOb3RQZXJzaXN0ZW50IiwiY2xpY2siLCJoYW5kbGVNb3VzZW1vdmUiLCJ0cmlnZ2VySGlkZSIsImNsb3Nlc3RUb29sdGlwcGVkRWwiLCJpc092ZXJQb3BwZXIiLCJpc092ZXJFbCIsImlzQ2xpY2tUcmlnZ2VyZWQiLCJpc092ZXJPdGhlclRvb2x0aXBwZWRFbCIsInJlbGF0ZWRUYXJnZXQiLCJldmFsdWF0ZVNldHRpbmdzIiwiaWRDb3VudGVyIiwiY3JlYXRlVG9vbHRpcHMiLCJUaXBweSIsImRlc3Ryb3llZCIsInNob3duIiwiaGlkZGVuIiwib25TaG93Iiwib25TaG93biIsIm9uSGlkZSIsIm9uSGlkZGVuIiwic3RvcmUiLCJnZXRQb3BwZXJFbGVtZW50IiwiZ2V0UmVmZXJlbmNlRWxlbWVudCIsImdldFJlZmVyZW5jZURhdGEiLCJjdXN0b21EdXJhdGlvbiIsInJlZk9iaiIsIl9vblNob3duRmlyZWQiLCJfZ2V0SW5uZXJFbGVtZW50czIiLCJfZGF0YSRzZXR0aW5nczIiLCJfZ2V0SW5uZXJFbGVtZW50czMiLCJfaXNMYXN0IiwiX3RoaXMzIiwiZGlzY29ubmVjdCIsInNwbGljZSIsImRlc3Ryb3lBbGwiLCJfdGhpczQiLCJzdG9yZUxlbmd0aCIsInRpcHB5JDIiLCJjbGFzc05hbWVzIiwiZGlzYWJsZUR5bmFtaWNJbnB1dERldGVjdGlvbiIsImVuYWJsZUR5bmFtaWNJbnB1dERldGVjdGlvbiIsInJlZ2lzdGVyIiwiVnVlQ2xpcGJvYXJkIiwiaW5zdGFsbCIsIlZ1ZSIsIiRjb3B5VGV4dCIsImZha2VfZWwiLCJkaXJlY3RpdmUiLCJ2bm9kZSIsImFyZyIsIl92X2NsaXBib2FyZF9zdWNjZXNzIiwiX3ZfY2xpcGJvYXJkX2Vycm9yIiwiX3ZfY2xpcGJvYXJkIiwidW5iaW5kIiwibHMkMSIsIm1lbW9yeVN0b3JhZ2UiLCJnZXRJdGVtIiwic2V0SXRlbSIsInJlbW92ZUl0ZW0iLCJmb3VuZCIsImNsZWFyIiwiYXN5bmNHZW5lcmF0b3IiLCJBd2FpdFZhbHVlIiwiQXN5bmNHZW5lcmF0b3IiLCJnZW4iLCJmcm9udCIsImJhY2siLCJuZXh0IiwicmVzdW1lIiwiX2ludm9rZSIsInJldHVybiIsImFzeW5jSXRlcmF0b3IiLCJ0aHJvdyIsImF3YWl0IiwiX2NsYXNzJDEiLCJfY2xhc3MiLCJnZXRWYWx1ZSIsImZpcmUiLCJuZXdWYWx1ZSIsIm9sZFZhbHVlIiwidXJpIiwic3RvcmFnZSIsIm5hbWVzcGFjZSIsImV2ZW50cyIsImdldCQkMSIsInNldE9wdGlvbnMiLCJzZXQkJDEiLCJleHBpcmUiLCJzdHJpbmdpZnlWYWx1ZSIsImdldFRpbWUiLCJkZWYiLCJyZW1vdmVkS2V5cyIsInJlZ2V4cCIsIl9rZXkiLCJsb2NhbFN0b3JhZ2UiLCJscyIsIlZ1ZUxvY2FsU3RvcmFnZSIsImxpc3RUb1N0eWxlcyIsInBhcmVudElkIiwibmV3U3R5bGVzIiwibWVkaWEiLCJwYXJ0IiwiVnVlVGlwcHkiLCIkdGlwcHlJbnN0YW5jZXMiLCIkdGlwcHlDb21wb25lbnRzIiwiJHRpcHB5IiwiZ2V0SW5zdGFuY2UiLCIkaW5zdGFuY2UiLCJnZXRUaXBweVBvcHBlciIsInNob3dQb3BwZXIiLCJnZXRUaXBweSIsImhpZGVQb3BwZXIiLCJkZXN0cm95VGlwcHkiLCJmb3JjZVVwZGF0ZUh0bWwiLCJpbnNlcnRlZCIsIm9sZFZub2RlIiwiY29tcG9uZW50T3B0aW9ucyIsIm9wdHMiLCIkY2hpbGRyZW4iLCIkdm0iLCJfdWlkIiwiJG9wdGlvbnMiLCJ1cGRhdGVkIiwic2hvd09uTG9hZCIsImNvbXBvbmVudFVwZGF0ZWQiLCIkbmV4dFRpY2siLCJ0aXAiLCJlbXB0eU9iamVjdCIsImZyZWV6ZSIsImlzVW5kZWYiLCJpc0RlZiIsImlzVHJ1ZSIsImlzRmFsc2UiLCJpc1ByaW1pdGl2ZSIsIl90b1N0cmluZyIsInRvUmF3VHlwZSIsImlzUGxhaW5PYmplY3QiLCJpc1JlZ0V4cCIsImlzVmFsaWRBcnJheUluZGV4IiwidG9OdW1iZXIiLCJtYWtlTWFwIiwiZXhwZWN0c0xvd2VyQ2FzZSIsImlzQnVpbHRJblRhZyIsImlzUmVzZXJ2ZWRBdHRyaWJ1dGUiLCJoYXNPd24iLCJjYWNoZWQiLCJjYWNoZSIsImNhY2hlZEZuIiwiaGl0IiwiY2FtZWxpemVSRSIsImNhbWVsaXplIiwiY2FwaXRhbGl6ZSIsImh5cGhlbmF0ZVJFIiwiaHlwaGVuYXRlIiwiYm91bmRGbiIsIl9sZW5ndGgiLCJ0b0FycmF5IiwicmV0IiwidG8iLCJfZnJvbSIsInRvT2JqZWN0IiwicmVzIiwibm8iLCJpZGVudGl0eSIsImdlblN0YXRpY0tleXMiLCJtIiwic3RhdGljS2V5cyIsImxvb3NlRXF1YWwiLCJpc09iamVjdEEiLCJpc09iamVjdEIiLCJpc0FycmF5QSIsImlzQXJyYXlCIiwiZXZlcnkiLCJrZXlzQSIsImtleXNCIiwibG9vc2VJbmRleE9mIiwiU1NSX0FUVFIiLCJBU1NFVF9UWVBFUyIsIkxJRkVDWUNMRV9IT09LUyIsIm9wdGlvbk1lcmdlU3RyYXRlZ2llcyIsInNpbGVudCIsInByb2R1Y3Rpb25UaXAiLCJkZXZ0b29scyIsImVycm9ySGFuZGxlciIsIndhcm5IYW5kbGVyIiwiaWdub3JlZEVsZW1lbnRzIiwia2V5Q29kZXMiLCJpc1Jlc2VydmVkVGFnIiwiaXNSZXNlcnZlZEF0dHIiLCJpc1Vua25vd25FbGVtZW50IiwiZ2V0VGFnTmFtZXNwYWNlIiwicGFyc2VQbGF0Zm9ybVRhZ05hbWUiLCJtdXN0VXNlUHJvcCIsIl9saWZlY3ljbGVIb29rcyIsImlzUmVzZXJ2ZWQiLCJiYWlsUkUiLCJwYXJzZVBhdGgiLCJzZWdtZW50cyIsImhhc1Byb3RvIiwiaW5Ccm93c2VyIiwiaW5XZWV4IiwiV1hFbnZpcm9ubWVudCIsInBsYXRmb3JtIiwid2VleFBsYXRmb3JtIiwiVUEiLCJpc0lFIiwiaXNJRTkiLCJpc0VkZ2UiLCJpc0FuZHJvaWQiLCJpc0lPUyIsImlzQ2hyb21lIiwibmF0aXZlV2F0Y2giLCJ3YXRjaCIsInN1cHBvcnRzUGFzc2l2ZSIsIl9pc1NlcnZlciIsImlzU2VydmVyUmVuZGVyaW5nIiwiVlVFX0VOViIsIl9fVlVFX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJpc05hdGl2ZSIsIkN0b3IiLCJoYXNTeW1ib2wiLCJSZWZsZWN0Iiwib3duS2V5cyIsIl9TZXQiLCJTZXQiLCJoYXMiLCJnZW5lcmF0ZUNvbXBvbmVudFRyYWNlIiwiZm9ybWF0Q29tcG9uZW50TmFtZSIsImhhc0NvbnNvbGUiLCJjbGFzc2lmeVJFIiwiY2xhc3NpZnkiLCJtc2ciLCJ2bSIsInRyYWNlIiwiaW5jbHVkZUZpbGUiLCIkcm9vdCIsImNpZCIsIl9pc1Z1ZSIsIl9jb21wb25lbnRUYWciLCJmaWxlIiwiX19maWxlIiwicmVwZWF0IiwiJHBhcmVudCIsInRyZWUiLCJjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UiLCJsYXN0IiwidWlkIiwiRGVwIiwic3VicyIsImFkZFN1YiIsInN1YiIsInJlbW92ZVN1YiIsImRlcGVuZCIsImFkZERlcCIsIm5vdGlmeSIsInRhcmdldFN0YWNrIiwicHVzaFRhcmdldCIsInBvcFRhcmdldCIsInBvcCIsIlZOb2RlIiwidGFnIiwiZWxtIiwiYXN5bmNGYWN0b3J5IiwibnMiLCJmbkNvbnRleHQiLCJmbk9wdGlvbnMiLCJmblNjb3BlSWQiLCJjb21wb25lbnRJbnN0YW5jZSIsInJhdyIsImlzU3RhdGljIiwiaXNSb290SW5zZXJ0IiwiaXNDb21tZW50IiwiaXNDbG9uZWQiLCJpc09uY2UiLCJhc3luY01ldGEiLCJpc0FzeW5jUGxhY2Vob2xkZXIiLCJwcm90b3R5cGVBY2Nlc3NvcnMiLCJjaGlsZCIsImNyZWF0ZUVtcHR5Vk5vZGUiLCJjcmVhdGVUZXh0Vk5vZGUiLCJjbG9uZVZOb2RlIiwiZGVlcCIsImNsb25lZCIsImNsb25lVk5vZGVzIiwidm5vZGVzIiwiYXJyYXlQcm90byIsImFycmF5TWV0aG9kcyIsIm9yaWdpbmFsIiwibXV0YXRvciIsIm9iIiwiX19vYl9fIiwib2JzZXJ2ZUFycmF5IiwiZGVwIiwiYXJyYXlLZXlzIiwiZ2V0T3duUHJvcGVydHlOYW1lcyIsIm9ic2VydmVyU3RhdGUiLCJzaG91bGRDb252ZXJ0IiwiT2JzZXJ2ZXIiLCJ2bUNvdW50IiwiYXVnbWVudCIsInByb3RvQXVnbWVudCIsImNvcHlBdWdtZW50Iiwid2FsayIsImRlZmluZVJlYWN0aXZlIiwiaXRlbXMiLCJzcmMiLCJhc1Jvb3REYXRhIiwiaXNFeHRlbnNpYmxlIiwiY3VzdG9tU2V0dGVyIiwic2hhbGxvdyIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsImdldHRlciIsInNldHRlciIsImNoaWxkT2IiLCJyZWFjdGl2ZUdldHRlciIsImRlcGVuZEFycmF5IiwicmVhY3RpdmVTZXR0ZXIiLCJuZXdWYWwiLCJkZWwiLCJzdHJhdHMiLCJwcm9wc0RhdGEiLCJkZWZhdWx0U3RyYXQiLCJtZXJnZURhdGEiLCJmcm9tIiwidG9WYWwiLCJmcm9tVmFsIiwibWVyZ2VEYXRhT3JGbiIsInBhcmVudFZhbCIsImNoaWxkVmFsIiwibWVyZ2VkRGF0YUZuIiwibWVyZ2VkSW5zdGFuY2VEYXRhRm4iLCJpbnN0YW5jZURhdGEiLCJkZWZhdWx0RGF0YSIsIm1lcmdlSG9vayIsImhvb2siLCJtZXJnZUFzc2V0cyIsImFzc2VydE9iamVjdFR5cGUiLCJrZXkkMSIsIm1ldGhvZHMiLCJpbmplY3QiLCJjb21wdXRlZCIsInByb3ZpZGUiLCJjaGVja0NvbXBvbmVudHMiLCJjb21wb25lbnRzIiwibG93ZXIiLCJub3JtYWxpemVQcm9wcyIsIm5vcm1hbGl6ZUluamVjdCIsIm5vcm1hbGl6ZWQiLCJub3JtYWxpemVEaXJlY3RpdmVzIiwiZGlycyIsImRpcmVjdGl2ZXMiLCJtZXJnZU9wdGlvbnMiLCJleHRlbmRzRnJvbSIsImV4dGVuZHMiLCJtaXhpbnMiLCJtZXJnZUZpZWxkIiwic3RyYXQiLCJyZXNvbHZlQXNzZXQiLCJ3YXJuTWlzc2luZyIsImFzc2V0cyIsImNhbWVsaXplZElkIiwiUGFzY2FsQ2FzZUlkIiwidmFsaWRhdGVQcm9wIiwicHJvcE9wdGlvbnMiLCJhYnNlbnQiLCJpc1R5cGUiLCJCb29sZWFuIiwiZ2V0UHJvcERlZmF1bHRWYWx1ZSIsInByZXZTaG91bGRDb252ZXJ0IiwiYXNzZXJ0UHJvcCIsIl9wcm9wcyIsInJlcXVpcmVkIiwidmFsaWQiLCJleHBlY3RlZFR5cGVzIiwiYXNzZXJ0ZWRUeXBlIiwiYXNzZXJ0VHlwZSIsImV4cGVjdGVkVHlwZSIsInZhbGlkYXRvciIsInNpbXBsZUNoZWNrUkUiLCJpbmZvIiwiaG9va3MiLCJlcnJvckNhcHR1cmVkIiwiY2FwdHVyZSIsImdsb2JhbEhhbmRsZUVycm9yIiwibG9nRXJyb3IiLCJwZW5kaW5nIiwiZmx1c2hDYWxsYmFja3MiLCJjb3BpZXMiLCJtaWNyb1RpbWVyRnVuYyIsIm1hY3JvVGltZXJGdW5jIiwidXNlTWFjcm9UYXNrIiwicCIsIndpdGhNYWNyb1Rhc2siLCJfd2l0aFRhc2siLCJjYiIsIl9yZXNvbHZlIiwibWFyayIsIm1lYXN1cmUiLCJwZXJmIiwiY2xlYXJNYXJrcyIsImNsZWFyTWVhc3VyZXMiLCJzdGFydFRhZyIsImVuZFRhZyIsImluaXRQcm94eSIsImFsbG93ZWRHbG9iYWxzIiwid2Fybk5vblByZXNlbnQiLCJoYXNQcm94eSIsIlByb3h5IiwiaXNCdWlsdEluTW9kaWZpZXIiLCJoYXNIYW5kbGVyIiwiaXNBbGxvd2VkIiwiZ2V0SGFuZGxlciIsInJlbmRlciIsIl93aXRoU3RyaXBwZWQiLCJfcmVuZGVyUHJveHkiLCJzZWVuT2JqZWN0cyIsInRyYXZlcnNlIiwiX3RyYXZlcnNlIiwic2VlbiIsImlzQSIsImlzRnJvemVuIiwiZGVwSWQiLCJub3JtYWxpemVFdmVudCIsIm9uY2UkJDEiLCJjcmVhdGVGbkludm9rZXIiLCJpbnZva2VyIiwiYXJndW1lbnRzJDEiLCJ1cGRhdGVMaXN0ZW5lcnMiLCJvbGRPbiIsInJlbW92ZSQkMSIsIm9sZCIsIm1lcmdlVk5vZGVIb29rIiwiaG9va0tleSIsIm9sZEhvb2siLCJ3cmFwcGVkSG9vayIsIm1lcmdlZCIsImV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEiLCJhdHRycyIsImFsdEtleSIsImtleUluTG93ZXJDYXNlIiwiY2hlY2tQcm9wIiwicHJlc2VydmUiLCJzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiIsIm5vcm1hbGl6ZUNoaWxkcmVuIiwibm9ybWFsaXplQXJyYXlDaGlsZHJlbiIsImlzVGV4dE5vZGUiLCJuZXN0ZWRJbmRleCIsImxhc3RJbmRleCIsIl9pc1ZMaXN0IiwiZW5zdXJlQ3RvciIsImNvbXAiLCJiYXNlIiwidG9TdHJpbmdUYWciLCJjcmVhdGVBc3luY1BsYWNlaG9sZGVyIiwicmVzb2x2ZUFzeW5jQ29tcG9uZW50IiwiYmFzZUN0b3IiLCJlcnJvckNvbXAiLCJyZXNvbHZlZCIsImxvYWRpbmciLCJsb2FkaW5nQ29tcCIsImNvbnRleHRzIiwic3luYyIsImZvcmNlUmVuZGVyIiwiJGZvcmNlVXBkYXRlIiwiY29tcG9uZW50IiwiZ2V0Rmlyc3RDb21wb25lbnRDaGlsZCIsImluaXRFdmVudHMiLCJfZXZlbnRzIiwiX2hhc0hvb2tFdmVudCIsIl9wYXJlbnRMaXN0ZW5lcnMiLCJ1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMiLCIkb25jZSIsIiRvbiIsInJlbW92ZSQxIiwiJG9mZiIsIm9sZExpc3RlbmVycyIsImV2ZW50c01peGluIiwiaG9va1JFIiwidGhpcyQxIiwiY2JzIiwiaSQxIiwiJGVtaXQiLCJsb3dlckNhc2VFdmVudCIsInJlc29sdmVTbG90cyIsInNsb3RzIiwic2xvdCIsIm5hbWUkMSIsImlzV2hpdGVzcGFjZSIsInJlc29sdmVTY29wZWRTbG90cyIsImFjdGl2ZUluc3RhbmNlIiwiaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50IiwiaW5pdExpZmVjeWNsZSIsImFic3RyYWN0IiwiJHJlZnMiLCJfd2F0Y2hlciIsIl9pbmFjdGl2ZSIsIl9kaXJlY3RJbmFjdGl2ZSIsIl9pc01vdW50ZWQiLCJfaXNEZXN0cm95ZWQiLCJfaXNCZWluZ0Rlc3Ryb3llZCIsImxpZmVjeWNsZU1peGluIiwiX3VwZGF0ZSIsImh5ZHJhdGluZyIsImNhbGxIb29rIiwicHJldkVsIiwiJGVsIiwicHJldlZub2RlIiwiX3Zub2RlIiwicHJldkFjdGl2ZUluc3RhbmNlIiwiX19wYXRjaF9fIiwiX3BhcmVudEVsbSIsIl9yZWZFbG0iLCJfX3Z1ZV9fIiwiJHZub2RlIiwiJGRlc3Ryb3kiLCJ0ZWFyZG93biIsIl93YXRjaGVycyIsIl9kYXRhIiwibW91bnRDb21wb25lbnQiLCJ0ZW1wbGF0ZSIsInVwZGF0ZUNvbXBvbmVudCIsIl9uYW1lIiwiX3JlbmRlciIsIldhdGNoZXIiLCJ1cGRhdGVDaGlsZENvbXBvbmVudCIsInBhcmVudFZub2RlIiwicmVuZGVyQ2hpbGRyZW4iLCJoYXNDaGlsZHJlbiIsIl9yZW5kZXJDaGlsZHJlbiIsInNjb3BlZFNsb3RzIiwiJHNjb3BlZFNsb3RzIiwiX3BhcmVudFZub2RlIiwiJGF0dHJzIiwiJGxpc3RlbmVycyIsInByb3BLZXlzIiwiX3Byb3BLZXlzIiwiJHNsb3RzIiwiaXNJbkluYWN0aXZlVHJlZSIsImFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJkaXJlY3QiLCJkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQiLCJqIiwiTUFYX1VQREFURV9DT1VOVCIsImFjdGl2YXRlZENoaWxkcmVuIiwiY2lyY3VsYXIiLCJ3YWl0aW5nIiwiZmx1c2hpbmciLCJyZXNldFNjaGVkdWxlclN0YXRlIiwiZmx1c2hTY2hlZHVsZXJRdWV1ZSIsIndhdGNoZXIiLCJ1c2VyIiwiZXhwcmVzc2lvbiIsImFjdGl2YXRlZFF1ZXVlIiwidXBkYXRlZFF1ZXVlIiwiY2FsbEFjdGl2YXRlZEhvb2tzIiwiY2FsbFVwZGF0ZWRIb29rcyIsInF1ZXVlQWN0aXZhdGVkQ29tcG9uZW50IiwicXVldWVXYXRjaGVyIiwidWlkJDIiLCJleHBPckZuIiwiaXNSZW5kZXJXYXRjaGVyIiwibGF6eSIsImRpcnR5IiwiZGVwcyIsIm5ld0RlcHMiLCJkZXBJZHMiLCJuZXdEZXBJZHMiLCJjbGVhbnVwRGVwcyIsInRtcCIsImV2YWx1YXRlIiwic2hhcmVkUHJvcGVydHlEZWZpbml0aW9uIiwicHJveHkiLCJzb3VyY2VLZXkiLCJwcm94eUdldHRlciIsInByb3h5U2V0dGVyIiwiaW5pdFN0YXRlIiwiaW5pdFByb3BzIiwiaW5pdE1ldGhvZHMiLCJpbml0RGF0YSIsImluaXRDb21wdXRlZCIsImluaXRXYXRjaCIsInByb3BzT3B0aW9ucyIsImlzUm9vdCIsImxvb3AiLCJoeXBoZW5hdGVkS2V5IiwiZ2V0RGF0YSIsImNvbXB1dGVkV2F0Y2hlck9wdGlvbnMiLCJ3YXRjaGVycyIsIl9jb21wdXRlZFdhdGNoZXJzIiwiaXNTU1IiLCJ1c2VyRGVmIiwiZGVmaW5lQ29tcHV0ZWQiLCIkZGF0YSIsInNob3VsZENhY2hlIiwiY3JlYXRlQ29tcHV0ZWRHZXR0ZXIiLCJjb21wdXRlZEdldHRlciIsImNyZWF0ZVdhdGNoZXIiLCJrZXlPckZuIiwiJHdhdGNoIiwic3RhdGVNaXhpbiIsImRhdGFEZWYiLCJwcm9wc0RlZiIsIm5ld0RhdGEiLCIkc2V0IiwiJGRlbGV0ZSIsImltbWVkaWF0ZSIsInVud2F0Y2hGbiIsImluaXRQcm92aWRlIiwiX3Byb3ZpZGVkIiwiaW5pdEluamVjdGlvbnMiLCJyZXNvbHZlSW5qZWN0IiwicHJvdmlkZUtleSIsInByb3ZpZGVEZWZhdWx0IiwicmVuZGVyTGlzdCIsInJlbmRlclNsb3QiLCJmYWxsYmFjayIsImJpbmRPYmplY3QiLCJzY29wZWRTbG90Rm4iLCJub2RlcyIsInNsb3ROb2RlcyIsIl9yZW5kZXJlZCIsIiRjcmVhdGVFbGVtZW50IiwicmVzb2x2ZUZpbHRlciIsImNoZWNrS2V5Q29kZXMiLCJldmVudEtleUNvZGUiLCJidWlsdEluQWxpYXMiLCJldmVudEtleU5hbWUiLCJiaW5kT2JqZWN0UHJvcHMiLCJhc1Byb3AiLCJpc1N5bmMiLCJkb21Qcm9wcyIsIiRldmVudCIsInJlbmRlclN0YXRpYyIsImlzSW5Gb3IiLCJpc09sZFZlcnNpb24iLCJyZW5kZXJGbnMiLCJzdGF0aWNSZW5kZXJGbnMiLCJfc3RhdGljVHJlZXMiLCJtYXJrU3RhdGljIiwibWFya09uY2UiLCJtYXJrU3RhdGljTm9kZSIsImJpbmRPYmplY3RMaXN0ZW5lcnMiLCJleGlzdGluZyIsIm91cnMiLCJpbnN0YWxsUmVuZGVySGVscGVycyIsIl9vIiwiX24iLCJfcyIsIl9sIiwiX3QiLCJfcSIsIl9pIiwiX20iLCJfZiIsIl9rIiwiX2IiLCJfdiIsIl9lIiwiX3UiLCJfZyIsIkZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IiwiaW5qZWN0aW9ucyIsImNvbnRleHRWbSIsImlzQ29tcGlsZWQiLCJfY29tcGlsZWQiLCJuZWVkTm9ybWFsaXphdGlvbiIsIl9zY29wZUlkIiwiX2MiLCJkIiwiY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudCIsIm1lcmdlUHJvcHMiLCJyZW5kZXJDb250ZXh0IiwiY29tcG9uZW50Vk5vZGVIb29rcyIsInBhcmVudEVsbSIsInJlZkVsbSIsImNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUiLCIkbW91bnQiLCJrZWVwQWxpdmUiLCJtb3VudGVkTm9kZSIsInByZXBhdGNoIiwiaW5zZXJ0IiwiaG9va3NUb01lcmdlIiwiY3JlYXRlQ29tcG9uZW50IiwiX2Jhc2UiLCJyZXNvbHZlQ29uc3RydWN0b3JPcHRpb25zIiwibW9kZWwiLCJ0cmFuc2Zvcm1Nb2RlbCIsImZ1bmN0aW9uYWwiLCJuYXRpdmVPbiIsIm1lcmdlSG9va3MiLCJ2bm9kZUNvbXBvbmVudE9wdGlvbnMiLCJfaXNDb21wb25lbnQiLCJpbmxpbmVUZW1wbGF0ZSIsImZyb21QYXJlbnQiLCJtZXJnZUhvb2skMSIsIm9uZSIsInR3byIsIlNJTVBMRV9OT1JNQUxJWkUiLCJBTFdBWVNfTk9STUFMSVpFIiwibm9ybWFsaXphdGlvblR5cGUiLCJhbHdheXNOb3JtYWxpemUiLCJfY3JlYXRlRWxlbWVudCIsImFwcGx5TlMiLCJmb3JjZSIsImluaXRSZW5kZXIiLCJwYXJlbnREYXRhIiwicmVuZGVyTWl4aW4iLCJyZW5kZXJFcnJvciIsInVpZCQxIiwiaW5pdE1peGluIiwiX2luaXQiLCJpbml0SW50ZXJuYWxDb21wb25lbnQiLCJfc2VsZiIsInN1cGVyIiwic3VwZXJPcHRpb25zIiwiY2FjaGVkU3VwZXJPcHRpb25zIiwibW9kaWZpZWRPcHRpb25zIiwicmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyIsImV4dGVuZE9wdGlvbnMiLCJtb2RpZmllZCIsImxhdGVzdCIsImV4dGVuZGVkIiwic2VhbGVkIiwic2VhbGVkT3B0aW9ucyIsImRlZHVwZSIsIlZ1ZSQzIiwiaW5pdFVzZSIsInBsdWdpbiIsImluc3RhbGxlZFBsdWdpbnMiLCJfaW5zdGFsbGVkUGx1Z2lucyIsImluaXRNaXhpbiQxIiwibWl4aW4iLCJpbml0RXh0ZW5kIiwiU3VwZXIiLCJTdXBlcklkIiwiY2FjaGVkQ3RvcnMiLCJfQ3RvciIsIlN1YiIsIlZ1ZUNvbXBvbmVudCIsImluaXRQcm9wcyQxIiwiaW5pdENvbXB1dGVkJDEiLCJDb21wIiwiaW5pdEFzc2V0UmVnaXN0ZXJzIiwiZGVmaW5pdGlvbiIsImdldENvbXBvbmVudE5hbWUiLCJwYXR0ZXJuIiwicHJ1bmVDYWNoZSIsImtlZXBBbGl2ZUluc3RhbmNlIiwiY2FjaGVkTm9kZSIsInBydW5lQ2FjaGVFbnRyeSIsImN1cnJlbnQiLCJjYWNoZWQkJDEiLCJwYXR0ZXJuVHlwZXMiLCJLZWVwQWxpdmUiLCJpbmNsdWRlIiwiTnVtYmVyIiwiY3JlYXRlZCIsInJlZiQxIiwicGFyc2VJbnQiLCJidWlsdEluQ29tcG9uZW50cyIsImluaXRHbG9iYWxBUEkiLCJjb25maWdEZWYiLCJ1dGlsIiwiZGVsZXRlIiwic3NyQ29udGV4dCIsImFjY2VwdFZhbHVlIiwiYXR0ciIsImlzRW51bWVyYXRlZEF0dHIiLCJpc0Jvb2xlYW5BdHRyIiwieGxpbmtOUyIsImlzWGxpbmsiLCJnZXRYbGlua1Byb3AiLCJpc0ZhbHN5QXR0clZhbHVlIiwiZ2VuQ2xhc3NGb3JWbm9kZSIsImNoaWxkTm9kZSIsIm1lcmdlQ2xhc3NEYXRhIiwicmVuZGVyQ2xhc3MiLCJzdGF0aWNDbGFzcyIsImNsYXNzIiwiZHluYW1pY0NsYXNzIiwic3RyaW5naWZ5Q2xhc3MiLCJzdHJpbmdpZnlBcnJheSIsInN0cmluZ2lmeU9iamVjdCIsInN0cmluZ2lmaWVkIiwibmFtZXNwYWNlTWFwIiwic3ZnIiwibWF0aCIsImlzSFRNTFRhZyIsImlzU1ZHIiwiaXNQcmVUYWciLCJ1bmtub3duRWxlbWVudENhY2hlIiwiSFRNTFVua25vd25FbGVtZW50IiwiaXNUZXh0SW5wdXRUeXBlIiwicXVlcnkiLCJzZWxlY3RlZCIsImNyZWF0ZUVsZW1lbnQkMSIsInRhZ05hbWUiLCJjcmVhdGVFbGVtZW50TlMiLCJjcmVhdGVUZXh0Tm9kZSIsImNyZWF0ZUNvbW1lbnQiLCJpbnNlcnRCZWZvcmUiLCJuZXdOb2RlIiwicmVmZXJlbmNlTm9kZSIsIm5leHRTaWJsaW5nIiwic2V0VGV4dENvbnRlbnQiLCJ0ZXh0Q29udGVudCIsIm5vZGVPcHMiLCJyZWdpc3RlclJlZiIsImlzUmVtb3ZhbCIsInJlZnMiLCJyZWZJbkZvciIsImVtcHR5Tm9kZSIsInNhbWVWbm9kZSIsInNhbWVJbnB1dFR5cGUiLCJ0eXBlQSIsInR5cGVCIiwiY3JlYXRlS2V5VG9PbGRJZHgiLCJiZWdpbklkeCIsImVuZElkeCIsImNyZWF0ZVBhdGNoRnVuY3Rpb24iLCJiYWNrZW5kIiwiZW1wdHlOb2RlQXQiLCJjcmVhdGVSbUNiIiwiY2hpbGRFbG0iLCJyZW1vdmVOb2RlIiwiaXNVbmtub3duRWxlbWVudCQkMSIsImluVlByZSIsImlnbm9yZSIsImNyZWF0aW5nRWxtSW5WUHJlIiwiY3JlYXRlRWxtIiwiaW5zZXJ0ZWRWbm9kZVF1ZXVlIiwibmVzdGVkIiwicHJlIiwic2V0U2NvcGUiLCJjcmVhdGVDaGlsZHJlbiIsImludm9rZUNyZWF0ZUhvb2tzIiwiaXNSZWFjdGl2YXRlZCIsImluaXRDb21wb25lbnQiLCJyZWFjdGl2YXRlQ29tcG9uZW50IiwicGVuZGluZ0luc2VydCIsImlzUGF0Y2hhYmxlIiwiaW5uZXJOb2RlIiwidHJhbnNpdGlvbiIsImFjdGl2YXRlIiwicmVmJCQxIiwiYW5jZXN0b3IiLCJhZGRWbm9kZXMiLCJzdGFydElkeCIsImludm9rZURlc3Ryb3lIb29rIiwicmVtb3ZlVm5vZGVzIiwiY2giLCJyZW1vdmVBbmRJbnZva2VSZW1vdmVIb29rIiwicm0iLCJ1cGRhdGVDaGlsZHJlbiIsIm9sZENoIiwibmV3Q2giLCJyZW1vdmVPbmx5Iiwib2xkU3RhcnRJZHgiLCJuZXdTdGFydElkeCIsIm9sZEVuZElkeCIsIm9sZFN0YXJ0Vm5vZGUiLCJvbGRFbmRWbm9kZSIsIm5ld0VuZElkeCIsIm5ld1N0YXJ0Vm5vZGUiLCJuZXdFbmRWbm9kZSIsIm9sZEtleVRvSWR4IiwiaWR4SW5PbGQiLCJ2bm9kZVRvTW92ZSIsImNhbk1vdmUiLCJwYXRjaFZub2RlIiwiZmluZElkeEluT2xkIiwiaHlkcmF0ZSIsInBvc3RwYXRjaCIsImludm9rZUluc2VydEhvb2siLCJpbml0aWFsIiwiaHlkcmF0aW9uQmFpbGVkIiwiaXNSZW5kZXJlZE1vZHVsZSIsImFzc2VydE5vZGVNYXRjaCIsImhhc0NoaWxkTm9kZXMiLCJjaGlsZHJlbk1hdGNoIiwiZmlyc3RDaGlsZCIsImNoaWxkTm9kZXMiLCJmdWxsSW52b2tlIiwicGF0Y2giLCJpc0luaXRpYWxQYXRjaCIsImlzUmVhbEVsZW1lbnQiLCJvbGRFbG0iLCJwYXJlbnRFbG0kMSIsIl9sZWF2ZUNiIiwicGF0Y2hhYmxlIiwiaSQyIiwidXBkYXRlRGlyZWN0aXZlcyIsInVuYmluZERpcmVjdGl2ZXMiLCJpc0NyZWF0ZSIsImlzRGVzdHJveSIsIm9sZERpcnMiLCJub3JtYWxpemVEaXJlY3RpdmVzJDEiLCJuZXdEaXJzIiwiZGlyc1dpdGhJbnNlcnQiLCJkaXJzV2l0aFBvc3RwYXRjaCIsIm9sZERpciIsImNhbGxIb29rJDEiLCJjYWxsSW5zZXJ0IiwiZW1wdHlNb2RpZmllcnMiLCJnZXRSYXdEaXJOYW1lIiwicmF3TmFtZSIsImJhc2VNb2R1bGVzIiwidXBkYXRlQXR0cnMiLCJpbmhlcml0QXR0cnMiLCJvbGRBdHRycyIsInNldEF0dHIiLCJyZW1vdmVBdHRyaWJ1dGVOUyIsInNldEF0dHJpYnV0ZU5TIiwiX19pZXBoIiwiYmxvY2tlciIsInN0b3BJbW1lZGlhdGVQcm9wYWdhdGlvbiIsInVwZGF0ZUNsYXNzIiwib2xkRGF0YSIsImNscyIsInRyYW5zaXRpb25DbGFzcyIsIl90cmFuc2l0aW9uQ2xhc3NlcyIsIl9wcmV2Q2xhc3MiLCJrbGFzcyIsInZhbGlkRGl2aXNpb25DaGFyUkUiLCJwYXJzZUZpbHRlcnMiLCJleHAiLCJpblNpbmdsZSIsImluRG91YmxlIiwiaW5UZW1wbGF0ZVN0cmluZyIsImluUmVnZXgiLCJjdXJseSIsInNxdWFyZSIsInBhcmVuIiwibGFzdEZpbHRlckluZGV4IiwicHJldiIsImZpbHRlcnMiLCJwdXNoRmlsdGVyIiwid3JhcEZpbHRlciIsImJhc2VXYXJuIiwicGx1Y2tNb2R1bGVGdW5jdGlvbiIsImFkZFByb3AiLCJhZGRBdHRyIiwiYWRkRGlyZWN0aXZlIiwiYWRkSGFuZGxlciIsImltcG9ydGFudCIsInByZXZlbnQiLCJtaWRkbGUiLCJuYXRpdmUiLCJuYXRpdmVFdmVudHMiLCJuZXdIYW5kbGVyIiwiZ2V0QmluZGluZ0F0dHIiLCJnZXRTdGF0aWMiLCJkeW5hbWljVmFsdWUiLCJnZXRBbmRSZW1vdmVBdHRyIiwic3RhdGljVmFsdWUiLCJyZW1vdmVGcm9tTWFwIiwiYXR0cnNNYXAiLCJhdHRyc0xpc3QiLCJnZW5Db21wb25lbnRNb2RlbCIsIm51bWJlciIsImJhc2VWYWx1ZUV4cHJlc3Npb24iLCJ2YWx1ZUV4cHJlc3Npb24iLCJhc3NpZ25tZW50IiwiZ2VuQXNzaWdubWVudENvZGUiLCJwYXJzZU1vZGVsIiwiY2hyIiwiaW5kZXgkMSIsImV4cHJlc3Npb25Qb3MiLCJleHByZXNzaW9uRW5kUG9zIiwibGFzdEluZGV4T2YiLCJlb2YiLCJpc1N0cmluZ1N0YXJ0IiwicGFyc2VTdHJpbmciLCJwYXJzZUJyYWNrZXQiLCJpbkJyYWNrZXQiLCJzdHJpbmdRdW90ZSIsIndhcm4kMSIsIlJBTkdFX1RPS0VOIiwiQ0hFQ0tCT1hfUkFESU9fVE9LRU4iLCJfd2FybiIsImdlblNlbGVjdCIsImdlbkNoZWNrYm94TW9kZWwiLCJnZW5SYWRpb01vZGVsIiwiZ2VuRGVmYXVsdE1vZGVsIiwidmFsdWVCaW5kaW5nIiwidHJ1ZVZhbHVlQmluZGluZyIsImZhbHNlVmFsdWVCaW5kaW5nIiwic2VsZWN0ZWRWYWwiLCJ2YWx1ZSQxIiwibmVlZENvbXBvc2l0aW9uR3VhcmQiLCJub3JtYWxpemVFdmVudHMiLCJjaGFuZ2UiLCJ0YXJnZXQkMSIsImNyZWF0ZU9uY2VIYW5kbGVyIiwib25jZUhhbmRsZXIiLCJyZW1vdmUkMiIsImFkZCQxIiwidXBkYXRlRE9NTGlzdGVuZXJzIiwidXBkYXRlRE9NUHJvcHMiLCJvbGRQcm9wcyIsIl92YWx1ZSIsInN0ckN1ciIsInNob3VsZFVwZGF0ZVZhbHVlIiwiY2hlY2tWYWwiLCJjb21wb3NpbmciLCJpc0RpcnR5IiwiaXNJbnB1dENoYW5nZWQiLCJub3RJbkZvY3VzIiwiX3ZNb2RpZmllcnMiLCJwYXJzZVN0eWxlVGV4dCIsImNzc1RleHQiLCJsaXN0RGVsaW1pdGVyIiwicHJvcGVydHlEZWxpbWl0ZXIiLCJub3JtYWxpemVTdHlsZURhdGEiLCJub3JtYWxpemVTdHlsZUJpbmRpbmciLCJzdGF0aWNTdHlsZSIsImJpbmRpbmdTdHlsZSIsImdldFN0eWxlIiwiY2hlY2tDaGlsZCIsInN0eWxlRGF0YSIsImNzc1ZhclJFIiwiaW1wb3J0YW50UkUiLCJzZXRQcm9wIiwic2V0UHJvcGVydHkiLCJub3JtYWxpemUiLCJ2ZW5kb3JOYW1lcyIsImVtcHR5U3R5bGUiLCJjYXBOYW1lIiwidXBkYXRlU3R5bGUiLCJvbGRTdGF0aWNTdHlsZSIsIm9sZFN0eWxlQmluZGluZyIsIm5vcm1hbGl6ZWRTdHlsZSIsIm9sZFN0eWxlIiwibmV3U3R5bGUiLCJhZGRDbGFzcyIsInJlbW92ZUNsYXNzIiwidGFyIiwicmVzb2x2ZVRyYW5zaXRpb24iLCJhdXRvQ3NzVHJhbnNpdGlvbiIsImVudGVyQ2xhc3MiLCJlbnRlclRvQ2xhc3MiLCJlbnRlckFjdGl2ZUNsYXNzIiwibGVhdmVDbGFzcyIsImxlYXZlVG9DbGFzcyIsImxlYXZlQWN0aXZlQ2xhc3MiLCJoYXNUcmFuc2l0aW9uIiwiVFJBTlNJVElPTiIsIkFOSU1BVElPTiIsInRyYW5zaXRpb25Qcm9wIiwidHJhbnNpdGlvbkVuZEV2ZW50IiwiYW5pbWF0aW9uUHJvcCIsImFuaW1hdGlvbkVuZEV2ZW50Iiwib250cmFuc2l0aW9uZW5kIiwib253ZWJraXR0cmFuc2l0aW9uZW5kIiwib25hbmltYXRpb25lbmQiLCJvbndlYmtpdGFuaW1hdGlvbmVuZCIsInJhZiIsIm5leHRGcmFtZSIsImFkZFRyYW5zaXRpb25DbGFzcyIsInRyYW5zaXRpb25DbGFzc2VzIiwicmVtb3ZlVHJhbnNpdGlvbkNsYXNzIiwid2hlblRyYW5zaXRpb25FbmRzIiwiZ2V0VHJhbnNpdGlvbkluZm8iLCJwcm9wQ291bnQiLCJlbmRlZCIsIm9uRW5kIiwidHJhbnNmb3JtUkUiLCJ0cmFuc2l0aW9uRGVsYXlzIiwidHJhbnNpdGlvbkR1cmF0aW9ucyIsInRyYW5zaXRpb25UaW1lb3V0IiwiZ2V0VGltZW91dCIsImFuaW1hdGlvbkRlbGF5cyIsImFuaW1hdGlvbkR1cmF0aW9ucyIsImFuaW1hdGlvblRpbWVvdXQiLCJoYXNUcmFuc2Zvcm0iLCJkZWxheXMiLCJkdXJhdGlvbnMiLCJ0b01zIiwiZW50ZXIiLCJ0b2dnbGVEaXNwbGF5IiwiY2FuY2VsbGVkIiwiX2VudGVyQ2IiLCJhcHBlYXJDbGFzcyIsImFwcGVhclRvQ2xhc3MiLCJhcHBlYXJBY3RpdmVDbGFzcyIsImJlZm9yZUVudGVyIiwiYWZ0ZXJFbnRlciIsImVudGVyQ2FuY2VsbGVkIiwiYmVmb3JlQXBwZWFyIiwiYXBwZWFyIiwiYWZ0ZXJBcHBlYXIiLCJhcHBlYXJDYW5jZWxsZWQiLCJ0cmFuc2l0aW9uTm9kZSIsImlzQXBwZWFyIiwic3RhcnRDbGFzcyIsImFjdGl2ZUNsYXNzIiwidG9DbGFzcyIsImJlZm9yZUVudGVySG9vayIsImVudGVySG9vayIsImFmdGVyRW50ZXJIb29rIiwiZW50ZXJDYW5jZWxsZWRIb29rIiwiZXhwbGljaXRFbnRlckR1cmF0aW9uIiwiY2hlY2tEdXJhdGlvbiIsImV4cGVjdHNDU1MiLCJ1c2VyV2FudHNDb250cm9sIiwiZ2V0SG9va0FyZ3VtZW50c0xlbmd0aCIsInBlbmRpbmdOb2RlIiwiX3BlbmRpbmciLCJpc1ZhbGlkRHVyYXRpb24iLCJsZWF2ZSIsImJlZm9yZUxlYXZlIiwiYWZ0ZXJMZWF2ZSIsImxlYXZlQ2FuY2VsbGVkIiwiZGVsYXlMZWF2ZSIsImV4cGxpY2l0TGVhdmVEdXJhdGlvbiIsInBlcmZvcm1MZWF2ZSIsImludm9rZXJGbnMiLCJfZW50ZXIiLCJwbGF0Zm9ybU1vZHVsZXMiLCJ2bW9kZWwiLCJfdk9wdGlvbnMiLCJzZXRTZWxlY3RlZCIsIm9uQ29tcG9zaXRpb25FbmQiLCJvbkNvbXBvc2l0aW9uU3RhcnQiLCJwcmV2T3B0aW9ucyIsImN1ck9wdGlvbnMiLCJuZWVkUmVzZXQiLCJoYXNOb01hdGNoaW5nT3B0aW9uIiwiYWN0dWFsbHlTZXRTZWxlY3RlZCIsImlzTXVsdGlwbGUiLCJvcHRpb24iLCJzZWxlY3RlZEluZGV4IiwiY3JlYXRlRXZlbnQiLCJpbml0RXZlbnQiLCJkaXNwYXRjaEV2ZW50IiwibG9jYXRlTm9kZSIsInRyYW5zaXRpb24kJDEiLCJvcmlnaW5hbERpc3BsYXkiLCJfX3ZPcmlnaW5hbERpc3BsYXkiLCJkaXNwbGF5IiwicGxhdGZvcm1EaXJlY3RpdmVzIiwidHJhbnNpdGlvblByb3BzIiwibW9kZSIsImdldFJlYWxDaGlsZCIsImNvbXBPcHRpb25zIiwiZXh0cmFjdFRyYW5zaXRpb25EYXRhIiwicGxhY2Vob2xkZXIiLCJyYXdDaGlsZCIsImhhc1BhcmVudFRyYW5zaXRpb24iLCJpc1NhbWVDaGlsZCIsIm9sZENoaWxkIiwiVHJhbnNpdGlvbiIsIl9sZWF2aW5nIiwib2xkUmF3Q2hpbGQiLCJkZWxheWVkTGVhdmUiLCJtb3ZlQ2xhc3MiLCJUcmFuc2l0aW9uR3JvdXAiLCJwcmV2Q2hpbGRyZW4iLCJyYXdDaGlsZHJlbiIsInRyYW5zaXRpb25EYXRhIiwia2VwdCIsInJlbW92ZWQiLCJjJDEiLCJwb3MiLCJiZWZvcmVVcGRhdGUiLCJoYXNNb3ZlIiwiY2FsbFBlbmRpbmdDYnMiLCJyZWNvcmRQb3NpdGlvbiIsImFwcGx5VHJhbnNsYXRpb24iLCJfcmVmbG93IiwibW92ZWQiLCJXZWJraXRUcmFuc2Zvcm0iLCJ0cmFuc2l0aW9uRHVyYXRpb24iLCJfbW92ZUNiIiwicHJvcGVydHlOYW1lIiwiX2hhc01vdmUiLCJjbG9uZSIsImNsb25lTm9kZSIsIm5ld1BvcyIsIm9sZFBvcyIsImR4IiwiZHkiLCJwbGF0Zm9ybUNvbXBvbmVudHMiLCJkZWZhdWx0VGFnUkUiLCJyZWdleEVzY2FwZVJFIiwiYnVpbGRSZWdleCIsImRlbGltaXRlcnMiLCJwYXJzZVRleHQiLCJ0YWdSRSIsInRva2VucyIsImV4ZWMiLCJ0cmFuc2Zvcm1Ob2RlIiwiY2xhc3NCaW5kaW5nIiwiZ2VuRGF0YSIsImtsYXNzJDEiLCJ0cmFuc2Zvcm1Ob2RlJDEiLCJzdHlsZUJpbmRpbmciLCJnZW5EYXRhJDEiLCJzdHlsZSQxIiwiZGVjb2RlciIsImhlIiwiZGVjb2RlIiwiaXNVbmFyeVRhZyIsImNhbkJlTGVmdE9wZW5UYWciLCJpc05vblBocmFzaW5nVGFnIiwibmNuYW1lIiwicW5hbWVDYXB0dXJlIiwic3RhcnRUYWdPcGVuIiwic3RhcnRUYWdDbG9zZSIsImRvY3R5cGUiLCJjb21tZW50IiwiY29uZGl0aW9uYWxDb21tZW50IiwiSVNfUkVHRVhfQ0FQVFVSSU5HX0JST0tFTiIsImciLCJpc1BsYWluVGV4dEVsZW1lbnQiLCJyZUNhY2hlIiwiZGVjb2RpbmdNYXAiLCJlbmNvZGVkQXR0ciIsImVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIiwiaXNJZ25vcmVOZXdsaW5lVGFnIiwic2hvdWxkSWdub3JlRmlyc3ROZXdsaW5lIiwiZGVjb2RlQXR0ciIsInNob3VsZERlY29kZU5ld2xpbmVzIiwicmUiLCJwYXJzZUhUTUwiLCJzdGFjayIsImV4cGVjdEhUTUwiLCJpc1VuYXJ5VGFnJCQxIiwiY2FuQmVMZWZ0T3BlblRhZyQkMSIsImxhc3RUYWciLCJ0ZXh0RW5kIiwiY29tbWVudEVuZCIsInNob3VsZEtlZXBDb21tZW50Iiwic3Vic3RyaW5nIiwiYWR2YW5jZSIsImNvbmRpdGlvbmFsRW5kIiwiZG9jdHlwZU1hdGNoIiwiZW5kVGFnTWF0Y2giLCJjdXJJbmRleCIsInBhcnNlRW5kVGFnIiwic3RhcnRUYWdNYXRjaCIsInBhcnNlU3RhcnRUYWciLCJoYW5kbGVTdGFydFRhZyIsInJlc3QiLCJlbmRUYWdMZW5ndGgiLCJzdGFja2VkVGFnIiwicmVTdGFja2VkVGFnIiwicmVzdCQxIiwidW5hcnlTbGFzaCIsInVuYXJ5Iiwic2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmIiwibG93ZXJDYXNlZFRhZyIsImxvd2VyQ2FzZWRUYWdOYW1lIiwib25SRSIsImRpclJFIiwiZm9yQWxpYXNSRSIsImZvckl0ZXJhdG9yUkUiLCJzdHJpcFBhcmVuc1JFIiwiYXJnUkUiLCJiaW5kUkUiLCJtb2RpZmllclJFIiwiZGVjb2RlSFRNTENhY2hlZCIsIndhcm4kMiIsInRyYW5zZm9ybXMiLCJwcmVUcmFuc2Zvcm1zIiwicG9zdFRyYW5zZm9ybXMiLCJwbGF0Zm9ybUlzUHJlVGFnIiwicGxhdGZvcm1NdXN0VXNlUHJvcCIsInBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlIiwiY3JlYXRlQVNURWxlbWVudCIsIm1ha2VBdHRyc01hcCIsInByZXNlcnZlV2hpdGVzcGFjZSIsInJvb3QiLCJjdXJyZW50UGFyZW50IiwiaW5QcmUiLCJ3YXJuZWQiLCJ3YXJuT25jZSIsImVuZFByZSIsImNvbW1lbnRzIiwiZ3VhcmRJRVNWR0J1ZyIsImlzRm9yYmlkZGVuVGFnIiwiZm9yYmlkZGVuIiwicHJvY2Vzc1ByZSIsInByb2Nlc3NSYXdBdHRycyIsInByb2Nlc3NlZCIsInByb2Nlc3NGb3IiLCJwcm9jZXNzSWYiLCJwcm9jZXNzT25jZSIsInByb2Nlc3NFbGVtZW50IiwiY2hlY2tSb290Q29uc3RyYWludHMiLCJpZiIsImVsc2VpZiIsImVsc2UiLCJhZGRJZkNvbmRpdGlvbiIsInByb2Nlc3NJZkNvbmRpdGlvbnMiLCJzbG90U2NvcGUiLCJwbGFpbiIsInNsb3RUYXJnZXQiLCJsYXN0Tm9kZSIsImlzVGV4dFRhZyIsInByb2Nlc3NLZXkiLCJwcm9jZXNzUmVmIiwicHJvY2Vzc1Nsb3QiLCJwcm9jZXNzQ29tcG9uZW50IiwicHJvY2Vzc0F0dHJzIiwiY2hlY2tJbkZvciIsImluTWF0Y2giLCJmb3IiLCJhbGlhcyIsIml0ZXJhdG9yTWF0Y2giLCJpdGVyYXRvcjEiLCJpdGVyYXRvcjIiLCJmaW5kUHJldkVsZW1lbnQiLCJjb25kaXRpb24iLCJpZkNvbmRpdGlvbnMiLCJzbG90TmFtZSIsImlzUHJvcCIsImhhc0JpbmRpbmdzIiwicGFyc2VNb2RpZmllcnMiLCJjYW1lbCIsImFyZ01hdGNoIiwiY2hlY2tGb3JBbGlhc01vZGVsIiwiaWVOU0J1ZyIsImllTlNQcmVmaXgiLCJfZWwiLCJwcmVUcmFuc2Zvcm1Ob2RlIiwidHlwZUJpbmRpbmciLCJpZkNvbmRpdGlvbiIsImlmQ29uZGl0aW9uRXh0cmEiLCJoYXNFbHNlIiwiZWxzZUlmQ29uZGl0aW9uIiwiYnJhbmNoMCIsImNsb25lQVNURWxlbWVudCIsImFkZFJhd0F0dHIiLCJicmFuY2gxIiwiYnJhbmNoMiIsIm1vZGVsJDIiLCJtb2R1bGVzJDEiLCJkaXJlY3RpdmVzJDEiLCJiYXNlT3B0aW9ucyIsImlzU3RhdGljS2V5IiwiaXNQbGF0Zm9ybVJlc2VydmVkVGFnIiwiZ2VuU3RhdGljS2V5c0NhY2hlZCIsImdlblN0YXRpY0tleXMkMSIsIm9wdGltaXplIiwibWFya1N0YXRpYyQxIiwibWFya1N0YXRpY1Jvb3RzIiwic3RhdGljIiwibCQxIiwic3RhdGljSW5Gb3IiLCJzdGF0aWNSb290IiwiaXNEaXJlY3RDaGlsZE9mVGVtcGxhdGVGb3IiLCJmbkV4cFJFIiwic2ltcGxlUGF0aFJFIiwiZXNjIiwidGFiIiwic3BhY2UiLCJ1cCIsImRvd24iLCJnZW5HdWFyZCIsIm1vZGlmaWVyQ29kZSIsInN0b3AiLCJjdHJsIiwiYWx0IiwibWV0YSIsImdlbkhhbmRsZXJzIiwiZ2VuSGFuZGxlciIsImlzTWV0aG9kUGF0aCIsImlzRnVuY3Rpb25FeHByZXNzaW9uIiwiZ2VuTW9kaWZpZXJDb2RlIiwia2V5TW9kaWZpZXIiLCJnZW5LZXlGaWx0ZXIiLCJoYW5kbGVyQ29kZSIsImdlbkZpbHRlckNvZGUiLCJrZXlWYWwiLCJ3cmFwTGlzdGVuZXJzIiwiYmluZCQxIiwid3JhcERhdGEiLCJiYXNlRGlyZWN0aXZlcyIsImNsb2FrIiwiQ29kZWdlblN0YXRlIiwiZGF0YUdlbkZucyIsIm1heWJlQ29tcG9uZW50Iiwib25jZUlkIiwiZ2VuZXJhdGUiLCJhc3QiLCJnZW5FbGVtZW50Iiwic3RhdGljUHJvY2Vzc2VkIiwiZ2VuU3RhdGljIiwib25jZVByb2Nlc3NlZCIsImdlbk9uY2UiLCJmb3JQcm9jZXNzZWQiLCJnZW5Gb3IiLCJpZlByb2Nlc3NlZCIsImdlbklmIiwiZ2VuQ2hpbGRyZW4iLCJnZW5TbG90IiwiZ2VuQ29tcG9uZW50IiwiZ2VuRGF0YSQyIiwiYWx0R2VuIiwiYWx0RW1wdHkiLCJnZW5JZkNvbmRpdGlvbnMiLCJjb25kaXRpb25zIiwiZ2VuVGVybmFyeUV4cCIsImFsdEhlbHBlciIsImdlbkRpcmVjdGl2ZXMiLCJnZW5Qcm9wcyIsImdlblNjb3BlZFNsb3RzIiwiZ2VuSW5saW5lVGVtcGxhdGUiLCJoYXNSdW50aW1lIiwibmVlZFJ1bnRpbWUiLCJpbmxpbmVSZW5kZXJGbnMiLCJnZW5TY29wZWRTbG90IiwiZ2VuRm9yU2NvcGVkU2xvdCIsImNoZWNrU2tpcCIsImFsdEdlbkVsZW1lbnQiLCJhbHRHZW5Ob2RlIiwiZWwkMSIsImdldE5vcm1hbGl6YXRpb25UeXBlIiwiZ2VuTm9kZSIsIm5lZWRzTm9ybWFsaXphdGlvbiIsImdlbkNvbW1lbnQiLCJnZW5UZXh0IiwidHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzIiwiYmluZCQkMSIsImNvbXBvbmVudE5hbWUiLCJwcm9oaWJpdGVkS2V5d29yZFJFIiwidW5hcnlPcGVyYXRvcnNSRSIsInN0cmlwU3RyaW5nUkUiLCJkZXRlY3RFcnJvcnMiLCJlcnJvcnMiLCJjaGVja05vZGUiLCJjaGVja0ZvciIsImNoZWNrRXZlbnQiLCJjaGVja0V4cHJlc3Npb24iLCJzdGlwcGVkIiwia2V5d29yZE1hdGNoIiwiY2hlY2tJZGVudGlmaWVyIiwiaWRlbnQiLCJjcmVhdGVGdW5jdGlvbiIsImNyZWF0ZUNvbXBpbGVUb0Z1bmN0aW9uRm4iLCJjb21waWxlIiwiY29tcGlsZVRvRnVuY3Rpb25zIiwid2FybiQkMSIsImNvbXBpbGVkIiwidGlwcyIsImZuR2VuRXJyb3JzIiwiY3JlYXRlQ29tcGlsZXJDcmVhdG9yIiwiYmFzZUNvbXBpbGUiLCJjcmVhdGVDb21waWxlciIsImZpbmFsT3B0aW9ucyIsImRpdiIsImdldFNob3VsZERlY29kZSIsImlkVG9UZW1wbGF0ZSIsIm1vdW50IiwiZ2V0T3V0ZXJIVE1MIiwib3V0ZXJIVE1MIiwiVnVlbWl0IiwidnVlIiwiZXZhbCJdLCJtYXBwaW5ncyI6IjtBQUFBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOzs7QUFHQTtBQUNBOztB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TyxRQUFRLG9CQUFRO0FBQ3ZCLE1BQU0sU0FBUyxRQUFRO29CQUNILFNBQVMsY0FBYywyQkFBMkIsYUFDbEU7d0JBRUo7QUFKZ0M7QUFDNUI7O0FBZUosSUFBSSxVQUFVLFFBQVEsb0JBQVE7O0FBRTlCO0FBQ0EsSUFBSSxVQUFVLFNBQVMsb0JBQVE7QUFDL0IsSUFBSSxVQUFVLGtCQUFrQixvQkFBUTs7QUFFeEMsSUFBSTtRQUNJO0FBQUosRzs7Ozs7OztBQ2hDSix5QyIsImZpbGUiOiIvanMvYXBwLmpzIiwic291cmNlc0NvbnRlbnQiOlsiIFx0Ly8gVGhlIG1vZHVsZSBjYWNoZVxuIFx0dmFyIGluc3RhbGxlZE1vZHVsZXMgPSB7fTtcblxuIFx0Ly8gVGhlIHJlcXVpcmUgZnVuY3Rpb25cbiBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcblxuIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbiBcdFx0aWYoaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0pIHtcbiBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbiBcdFx0fVxuIFx0XHQvLyBDcmVhdGUgYSBuZXcgbW9kdWxlIChhbmQgcHV0IGl0IGludG8gdGhlIGNhY2hlKVxuIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4gXHRcdFx0aTogbW9kdWxlSWQsXG4gXHRcdFx0bDogZmFsc2UsXG4gXHRcdFx0ZXhwb3J0czoge31cbiBcdFx0fTtcblxuIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbiBcdFx0bW9kdWxlc1ttb2R1bGVJZF0uY2FsbChtb2R1bGUuZXhwb3J0cywgbW9kdWxlLCBtb2R1bGUuZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXyk7XG5cbiBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuIFx0XHRtb2R1bGUubCA9IHRydWU7XG5cbiBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbiBcdFx0cmV0dXJuIG1vZHVsZS5leHBvcnRzO1xuIFx0fVxuXG5cbiBcdC8vIGV4cG9zZSB0aGUgbW9kdWxlcyBvYmplY3QgKF9fd2VicGFja19tb2R1bGVzX18pXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuXG4gXHQvLyBleHBvc2UgdGhlIG1vZHVsZSBjYWNoZVxuIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcblxuIFx0Ly8gZGVmaW5lIGdldHRlciBmdW5jdGlvbiBmb3IgaGFybW9ueSBleHBvcnRzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbiBcdFx0aWYoIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBuYW1lKSkge1xuIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBuYW1lLCB7XG4gXHRcdFx0XHRjb25maWd1cmFibGU6IGZhbHNlLFxuIFx0XHRcdFx0ZW51bWVyYWJsZTogdHJ1ZSxcbiBcdFx0XHRcdGdldDogZ2V0dGVyXG4gXHRcdFx0fSk7XG4gXHRcdH1cbiBcdH07XG5cbiBcdC8vIGdldERlZmF1bHRFeHBvcnQgZnVuY3Rpb24gZm9yIGNvbXBhdGliaWxpdHkgd2l0aCBub24taGFybW9ueSBtb2R1bGVzXG4gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSBmdW5jdGlvbihtb2R1bGUpIHtcbiBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4gXHRcdFx0ZnVuY3Rpb24gZ2V0RGVmYXVsdCgpIHsgcmV0dXJuIG1vZHVsZVsnZGVmYXVsdCddOyB9IDpcbiBcdFx0XHRmdW5jdGlvbiBnZXRNb2R1bGVFeHBvcnRzKCkgeyByZXR1cm4gbW9kdWxlOyB9O1xuIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4gXHRcdHJldHVybiBnZXR0ZXI7XG4gXHR9O1xuXG4gXHQvLyBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGxcbiBcdF9fd2VicGFja19yZXF1aXJlX18ubyA9IGZ1bmN0aW9uKG9iamVjdCwgcHJvcGVydHkpIHsgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmplY3QsIHByb3BlcnR5KTsgfTtcblxuIFx0Ly8gX193ZWJwYWNrX3B1YmxpY19wYXRoX19cbiBcdF9fd2VicGFja19yZXF1aXJlX18ucCA9IFwiXCI7XG5cbiBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuIFx0cmV0dXJuIF9fd2VicGFja19yZXF1aXJlX18oX193ZWJwYWNrX3JlcXVpcmVfXy5zID0gMCk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gd2VicGFjay9ib290c3RyYXAgMDI2OWJhYTZmOTJlZDQ3Y2QxOWEiLCJtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vbGliL2F4aW9zJyk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgc2V0dGxlID0gcmVxdWlyZSgnLi8uLi9jb3JlL3NldHRsZScpO1xudmFyIGJ1aWxkVVJMID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J1aWxkVVJMJyk7XG52YXIgcGFyc2VIZWFkZXJzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycycpO1xudmFyIGlzVVJMU2FtZU9yaWdpbiA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9pc1VSTFNhbWVPcmlnaW4nKTtcbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4uL2NvcmUvY3JlYXRlRXJyb3InKTtcbnZhciBidG9hID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5idG9hICYmIHdpbmRvdy5idG9hLmJpbmQod2luZG93KSkgfHwgcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2J0b2EnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB4aHJBZGFwdGVyKGNvbmZpZykge1xuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xuICAgIHZhciByZXF1ZXN0RGF0YSA9IGNvbmZpZy5kYXRhO1xuICAgIHZhciByZXF1ZXN0SGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzO1xuXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEocmVxdWVzdERhdGEpKSB7XG4gICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddOyAvLyBMZXQgdGhlIGJyb3dzZXIgc2V0IGl0XG4gICAgfVxuXG4gICAgdmFyIHJlcXVlc3QgPSBuZXcgWE1MSHR0cFJlcXVlc3QoKTtcbiAgICB2YXIgbG9hZEV2ZW50ID0gJ29ucmVhZHlzdGF0ZWNoYW5nZSc7XG4gICAgdmFyIHhEb21haW4gPSBmYWxzZTtcblxuICAgIC8vIEZvciBJRSA4LzkgQ09SUyBzdXBwb3J0XG4gICAgLy8gT25seSBzdXBwb3J0cyBQT1NUIGFuZCBHRVQgY2FsbHMgYW5kIGRvZXNuJ3QgcmV0dXJucyB0aGUgcmVzcG9uc2UgaGVhZGVycy5cbiAgICAvLyBET04nVCBkbyB0aGlzIGZvciB0ZXN0aW5nIGIvYyBYTUxIdHRwUmVxdWVzdCBpcyBtb2NrZWQsIG5vdCBYRG9tYWluUmVxdWVzdC5cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICd0ZXN0JyAmJlxuICAgICAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICB3aW5kb3cuWERvbWFpblJlcXVlc3QgJiYgISgnd2l0aENyZWRlbnRpYWxzJyBpbiByZXF1ZXN0KSAmJlxuICAgICAgICAhaXNVUkxTYW1lT3JpZ2luKGNvbmZpZy51cmwpKSB7XG4gICAgICByZXF1ZXN0ID0gbmV3IHdpbmRvdy5YRG9tYWluUmVxdWVzdCgpO1xuICAgICAgbG9hZEV2ZW50ID0gJ29ubG9hZCc7XG4gICAgICB4RG9tYWluID0gdHJ1ZTtcbiAgICAgIHJlcXVlc3Qub25wcm9ncmVzcyA9IGZ1bmN0aW9uIGhhbmRsZVByb2dyZXNzKCkge307XG4gICAgICByZXF1ZXN0Lm9udGltZW91dCA9IGZ1bmN0aW9uIGhhbmRsZVRpbWVvdXQoKSB7fTtcbiAgICB9XG5cbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXG4gICAgaWYgKGNvbmZpZy5hdXRoKSB7XG4gICAgICB2YXIgdXNlcm5hbWUgPSBjb25maWcuYXV0aC51c2VybmFtZSB8fCAnJztcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkIHx8ICcnO1xuICAgICAgcmVxdWVzdEhlYWRlcnMuQXV0aG9yaXphdGlvbiA9ICdCYXNpYyAnICsgYnRvYSh1c2VybmFtZSArICc6JyArIHBhc3N3b3JkKTtcbiAgICB9XG5cbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChjb25maWcudXJsLCBjb25maWcucGFyYW1zLCBjb25maWcucGFyYW1zU2VyaWFsaXplciksIHRydWUpO1xuXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcbiAgICByZXF1ZXN0LnRpbWVvdXQgPSBjb25maWcudGltZW91dDtcblxuICAgIC8vIExpc3RlbiBmb3IgcmVhZHkgc3RhdGVcbiAgICByZXF1ZXN0W2xvYWRFdmVudF0gPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xuICAgICAgaWYgKCFyZXF1ZXN0IHx8IChyZXF1ZXN0LnJlYWR5U3RhdGUgIT09IDQgJiYgIXhEb21haW4pKSB7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cblxuICAgICAgLy8gVGhlIHJlcXVlc3QgZXJyb3JlZCBvdXQgYW5kIHdlIGRpZG4ndCBnZXQgYSByZXNwb25zZSwgdGhpcyB3aWxsIGJlXG4gICAgICAvLyBoYW5kbGVkIGJ5IG9uZXJyb3IgaW5zdGVhZFxuICAgICAgLy8gV2l0aCBvbmUgZXhjZXB0aW9uOiByZXF1ZXN0IHRoYXQgdXNpbmcgZmlsZTogcHJvdG9jb2wsIG1vc3QgYnJvd3NlcnNcbiAgICAgIC8vIHdpbGwgcmV0dXJuIHN0YXR1cyBhcyAwIGV2ZW4gdGhvdWdoIGl0J3MgYSBzdWNjZXNzZnVsIHJlcXVlc3RcbiAgICAgIGlmIChyZXF1ZXN0LnN0YXR1cyA9PT0gMCAmJiAhKHJlcXVlc3QucmVzcG9uc2VVUkwgJiYgcmVxdWVzdC5yZXNwb25zZVVSTC5pbmRleE9mKCdmaWxlOicpID09PSAwKSkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vIFByZXBhcmUgdGhlIHJlc3BvbnNlXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XG4gICAgICB2YXIgcmVzcG9uc2VEYXRhID0gIWNvbmZpZy5yZXNwb25zZVR5cGUgfHwgY29uZmlnLnJlc3BvbnNlVHlwZSA9PT0gJ3RleHQnID8gcmVxdWVzdC5yZXNwb25zZVRleHQgOiByZXF1ZXN0LnJlc3BvbnNlO1xuICAgICAgdmFyIHJlc3BvbnNlID0ge1xuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXG4gICAgICAgIC8vIElFIHNlbmRzIDEyMjMgaW5zdGVhZCBvZiAyMDQgKGh0dHBzOi8vZ2l0aHViLmNvbS9heGlvcy9heGlvcy9pc3N1ZXMvMjAxKVxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gMjA0IDogcmVxdWVzdC5zdGF0dXMsXG4gICAgICAgIHN0YXR1c1RleHQ6IHJlcXVlc3Quc3RhdHVzID09PSAxMjIzID8gJ05vIENvbnRlbnQnIDogcmVxdWVzdC5zdGF0dXNUZXh0LFxuICAgICAgICBoZWFkZXJzOiByZXNwb25zZUhlYWRlcnMsXG4gICAgICAgIGNvbmZpZzogY29uZmlnLFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XG4gICAgICB9O1xuXG4gICAgICBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgbG93IGxldmVsIG5ldHdvcmsgZXJyb3JzXG4gICAgcmVxdWVzdC5vbmVycm9yID0gZnVuY3Rpb24gaGFuZGxlRXJyb3IoKSB7XG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcbiAgICAgIC8vIG9uZXJyb3Igc2hvdWxkIG9ubHkgZmlyZSBpZiBpdCdzIGEgbmV0d29yayBlcnJvclxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKCdOZXR3b3JrIEVycm9yJywgY29uZmlnLCBudWxsLCByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBIYW5kbGUgdGltZW91dFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcigndGltZW91dCBvZiAnICsgY29uZmlnLnRpbWVvdXQgKyAnbXMgZXhjZWVkZWQnLCBjb25maWcsICdFQ09OTkFCT1JURUQnLFxuICAgICAgICByZXF1ZXN0KSk7XG5cbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xuICAgIH07XG5cbiAgICAvLyBBZGQgeHNyZiBoZWFkZXJcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cbiAgICAvLyBTcGVjaWZpY2FsbHkgbm90IGlmIHdlJ3JlIGluIGEgd2ViIHdvcmtlciwgb3IgcmVhY3QtbmF0aXZlLlxuICAgIGlmICh1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpKSB7XG4gICAgICB2YXIgY29va2llcyA9IHJlcXVpcmUoJy4vLi4vaGVscGVycy9jb29raWVzJyk7XG5cbiAgICAgIC8vIEFkZCB4c3JmIGhlYWRlclxuICAgICAgdmFyIHhzcmZWYWx1ZSA9IChjb25maWcud2l0aENyZWRlbnRpYWxzIHx8IGlzVVJMU2FtZU9yaWdpbihjb25maWcudXJsKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cbiAgICAgICAgICBjb29raWVzLnJlYWQoY29uZmlnLnhzcmZDb29raWVOYW1lKSA6XG4gICAgICAgICAgdW5kZWZpbmVkO1xuXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XG4gICAgICAgIHJlcXVlc3RIZWFkZXJzW2NvbmZpZy54c3JmSGVhZGVyTmFtZV0gPSB4c3JmVmFsdWU7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gQWRkIGhlYWRlcnMgdG8gdGhlIHJlcXVlc3RcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcbiAgICAgIHV0aWxzLmZvckVhY2gocmVxdWVzdEhlYWRlcnMsIGZ1bmN0aW9uIHNldFJlcXVlc3RIZWFkZXIodmFsLCBrZXkpIHtcbiAgICAgICAgaWYgKHR5cGVvZiByZXF1ZXN0RGF0YSA9PT0gJ3VuZGVmaW5lZCcgJiYga2V5LnRvTG93ZXJDYXNlKCkgPT09ICdjb250ZW50LXR5cGUnKSB7XG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxuICAgICAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1trZXldO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XG4gICAgICAgICAgcmVxdWVzdC5zZXRSZXF1ZXN0SGVhZGVyKGtleSwgdmFsKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcud2l0aENyZWRlbnRpYWxzKSB7XG4gICAgICByZXF1ZXN0LndpdGhDcmVkZW50aWFscyA9IHRydWU7XG4gICAgfVxuXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxuICAgIGlmIChjb25maWcucmVzcG9uc2VUeXBlKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXF1ZXN0LnJlc3BvbnNlVHlwZSA9IGNvbmZpZy5yZXNwb25zZVR5cGU7XG4gICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIC8vIEV4cGVjdGVkIERPTUV4Y2VwdGlvbiB0aHJvd24gYnkgYnJvd3NlcnMgbm90IGNvbXBhdGlibGUgWE1MSHR0cFJlcXVlc3QgTGV2ZWwgMi5cbiAgICAgICAgLy8gQnV0LCB0aGlzIGNhbiBiZSBzdXBwcmVzc2VkIGZvciAnanNvbicgdHlwZSBhcyBpdCBjYW4gYmUgcGFyc2VkIGJ5IGRlZmF1bHQgJ3RyYW5zZm9ybVJlc3BvbnNlJyBmdW5jdGlvbi5cbiAgICAgICAgaWYgKGNvbmZpZy5yZXNwb25zZVR5cGUgIT09ICdqc29uJykge1xuICAgICAgICAgIHRocm93IGU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgcHJvZ3Jlc3MgaWYgbmVlZGVkXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICByZXF1ZXN0LmFkZEV2ZW50TGlzdGVuZXIoJ3Byb2dyZXNzJywgY29uZmlnLm9uRG93bmxvYWRQcm9ncmVzcyk7XG4gICAgfVxuXG4gICAgLy8gTm90IGFsbCBicm93c2VycyBzdXBwb3J0IHVwbG9hZCBldmVudHNcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nICYmIHJlcXVlc3QudXBsb2FkKSB7XG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcbiAgICB9XG5cbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXG4gICAgICBjb25maWcuY2FuY2VsVG9rZW4ucHJvbWlzZS50aGVuKGZ1bmN0aW9uIG9uQ2FuY2VsZWQoY2FuY2VsKSB7XG4gICAgICAgIGlmICghcmVxdWVzdCkge1xuICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcbiAgICAgICAgcmVqZWN0KGNhbmNlbCk7XG4gICAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcbiAgICAgICAgcmVxdWVzdCA9IG51bGw7XG4gICAgICB9KTtcbiAgICB9XG5cbiAgICBpZiAocmVxdWVzdERhdGEgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmVxdWVzdERhdGEgPSBudWxsO1xuICAgIH1cblxuICAgIC8vIFNlbmQgdGhlIHJlcXVlc3RcbiAgICByZXF1ZXN0LnNlbmQocmVxdWVzdERhdGEpO1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi91dGlscycpO1xudmFyIGJpbmQgPSByZXF1aXJlKCcuL2hlbHBlcnMvYmluZCcpO1xudmFyIEF4aW9zID0gcmVxdWlyZSgnLi9jb3JlL0F4aW9zJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuL2RlZmF1bHRzJyk7XG5cbi8qKlxuICogQ3JlYXRlIGFuIGluc3RhbmNlIG9mIEF4aW9zXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcbiAqIEByZXR1cm4ge0F4aW9zfSBBIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICovXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XG4gIHZhciBjb250ZXh0ID0gbmV3IEF4aW9zKGRlZmF1bHRDb25maWcpO1xuICB2YXIgaW5zdGFuY2UgPSBiaW5kKEF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0LCBjb250ZXh0KTtcblxuICAvLyBDb3B5IGF4aW9zLnByb3RvdHlwZSB0byBpbnN0YW5jZVxuICB1dGlscy5leHRlbmQoaW5zdGFuY2UsIEF4aW9zLnByb3RvdHlwZSwgY29udGV4dCk7XG5cbiAgLy8gQ29weSBjb250ZXh0IHRvIGluc3RhbmNlXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgY29udGV4dCk7XG5cbiAgcmV0dXJuIGluc3RhbmNlO1xufVxuXG4vLyBDcmVhdGUgdGhlIGRlZmF1bHQgaW5zdGFuY2UgdG8gYmUgZXhwb3J0ZWRcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcblxuLy8gRXhwb3NlIEF4aW9zIGNsYXNzIHRvIGFsbG93IGNsYXNzIGluaGVyaXRhbmNlXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xuXG4vLyBGYWN0b3J5IGZvciBjcmVhdGluZyBuZXcgaW5zdGFuY2VzXG5heGlvcy5jcmVhdGUgPSBmdW5jdGlvbiBjcmVhdGUoaW5zdGFuY2VDb25maWcpIHtcbiAgcmV0dXJuIGNyZWF0ZUluc3RhbmNlKHV0aWxzLm1lcmdlKGRlZmF1bHRzLCBpbnN0YW5jZUNvbmZpZykpO1xufTtcblxuLy8gRXhwb3NlIENhbmNlbCAmIENhbmNlbFRva2VuXG5heGlvcy5DYW5jZWwgPSByZXF1aXJlKCcuL2NhbmNlbC9DYW5jZWwnKTtcbmF4aW9zLkNhbmNlbFRva2VuID0gcmVxdWlyZSgnLi9jYW5jZWwvQ2FuY2VsVG9rZW4nKTtcbmF4aW9zLmlzQ2FuY2VsID0gcmVxdWlyZSgnLi9jYW5jZWwvaXNDYW5jZWwnKTtcblxuLy8gRXhwb3NlIGFsbC9zcHJlYWRcbmF4aW9zLmFsbCA9IGZ1bmN0aW9uIGFsbChwcm9taXNlcykge1xuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xufTtcbmF4aW9zLnNwcmVhZCA9IHJlcXVpcmUoJy4vaGVscGVycy9zcHJlYWQnKTtcblxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcblxuLy8gQWxsb3cgdXNlIG9mIGRlZmF1bHQgaW1wb3J0IHN5bnRheCBpbiBUeXBlU2NyaXB0XG5tb2R1bGUuZXhwb3J0cy5kZWZhdWx0ID0gYXhpb3M7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIEEgYENhbmNlbGAgaXMgYW4gb2JqZWN0IHRoYXQgaXMgdGhyb3duIHdoZW4gYW4gb3BlcmF0aW9uIGlzIGNhbmNlbGVkLlxuICpcbiAqIEBjbGFzc1xuICogQHBhcmFtIHtzdHJpbmc9fSBtZXNzYWdlIFRoZSBtZXNzYWdlLlxuICovXG5mdW5jdGlvbiBDYW5jZWwobWVzc2FnZSkge1xuICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xufVxuXG5DYW5jZWwucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xufTtcblxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcblxubW9kdWxlLmV4cG9ydHMgPSBDYW5jZWw7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBDYW5jZWwgPSByZXF1aXJlKCcuL0NhbmNlbCcpO1xuXG4vKipcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXG4gKlxuICogQGNsYXNzXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIENhbmNlbFRva2VuKGV4ZWN1dG9yKSB7XG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdleGVjdXRvciBtdXN0IGJlIGEgZnVuY3Rpb24uJyk7XG4gIH1cblxuICB2YXIgcmVzb2x2ZVByb21pc2U7XG4gIHRoaXMucHJvbWlzZSA9IG5ldyBQcm9taXNlKGZ1bmN0aW9uIHByb21pc2VFeGVjdXRvcihyZXNvbHZlKSB7XG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xuICB9KTtcblxuICB2YXIgdG9rZW4gPSB0aGlzO1xuICBleGVjdXRvcihmdW5jdGlvbiBjYW5jZWwobWVzc2FnZSkge1xuICAgIGlmICh0b2tlbi5yZWFzb24pIHtcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHRva2VuLnJlYXNvbiA9IG5ldyBDYW5jZWwobWVzc2FnZSk7XG4gICAgcmVzb2x2ZVByb21pc2UodG9rZW4ucmVhc29uKTtcbiAgfSk7XG59XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xuICBpZiAodGhpcy5yZWFzb24pIHtcbiAgICB0aHJvdyB0aGlzLnJlYXNvbjtcbiAgfVxufTtcblxuLyoqXG4gKiBSZXR1cm5zIGFuIG9iamVjdCB0aGF0IGNvbnRhaW5zIGEgbmV3IGBDYW5jZWxUb2tlbmAgYW5kIGEgZnVuY3Rpb24gdGhhdCwgd2hlbiBjYWxsZWQsXG4gKiBjYW5jZWxzIHRoZSBgQ2FuY2VsVG9rZW5gLlxuICovXG5DYW5jZWxUb2tlbi5zb3VyY2UgPSBmdW5jdGlvbiBzb3VyY2UoKSB7XG4gIHZhciBjYW5jZWw7XG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XG4gICAgY2FuY2VsID0gYztcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgdG9rZW46IHRva2VuLFxuICAgIGNhbmNlbDogY2FuY2VsXG4gIH07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcbiAgcmV0dXJuICEhKHZhbHVlICYmIHZhbHVlLl9fQ0FOQ0VMX18pO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL2lzQ2FuY2VsLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLy4uL2RlZmF1bHRzJyk7XG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gcmVxdWlyZSgnLi9JbnRlcmNlcHRvck1hbmFnZXInKTtcbnZhciBkaXNwYXRjaFJlcXVlc3QgPSByZXF1aXJlKCcuL2Rpc3BhdGNoUmVxdWVzdCcpO1xuXG4vKipcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSBpbnN0YW5jZUNvbmZpZyBUaGUgZGVmYXVsdCBjb25maWcgZm9yIHRoZSBpbnN0YW5jZVxuICovXG5mdW5jdGlvbiBBeGlvcyhpbnN0YW5jZUNvbmZpZykge1xuICB0aGlzLmRlZmF1bHRzID0gaW5zdGFuY2VDb25maWc7XG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xuICAgIHJlcXVlc3Q6IG5ldyBJbnRlcmNlcHRvck1hbmFnZXIoKSxcbiAgICByZXNwb25zZTogbmV3IEludGVyY2VwdG9yTWFuYWdlcigpXG4gIH07XG59XG5cbi8qKlxuICogRGlzcGF0Y2ggYSByZXF1ZXN0XG4gKlxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXG4gKi9cbkF4aW9zLnByb3RvdHlwZS5yZXF1ZXN0ID0gZnVuY3Rpb24gcmVxdWVzdChjb25maWcpIHtcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gIC8vIEFsbG93IGZvciBheGlvcygnZXhhbXBsZS91cmwnWywgY29uZmlnXSkgYSBsYSBmZXRjaCBBUElcbiAgaWYgKHR5cGVvZiBjb25maWcgPT09ICdzdHJpbmcnKSB7XG4gICAgY29uZmlnID0gdXRpbHMubWVyZ2Uoe1xuICAgICAgdXJsOiBhcmd1bWVudHNbMF1cbiAgICB9LCBhcmd1bWVudHNbMV0pO1xuICB9XG5cbiAgY29uZmlnID0gdXRpbHMubWVyZ2UoZGVmYXVsdHMsIHRoaXMuZGVmYXVsdHMsIHsgbWV0aG9kOiAnZ2V0JyB9LCBjb25maWcpO1xuICBjb25maWcubWV0aG9kID0gY29uZmlnLm1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuXG4gIC8vIEhvb2sgdXAgaW50ZXJjZXB0b3JzIG1pZGRsZXdhcmVcbiAgdmFyIGNoYWluID0gW2Rpc3BhdGNoUmVxdWVzdCwgdW5kZWZpbmVkXTtcbiAgdmFyIHByb21pc2UgPSBQcm9taXNlLnJlc29sdmUoY29uZmlnKTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcbiAgICBjaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xuICB9KTtcblxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xuICAgIGNoYWluLnB1c2goaW50ZXJjZXB0b3IuZnVsZmlsbGVkLCBpbnRlcmNlcHRvci5yZWplY3RlZCk7XG4gIH0pO1xuXG4gIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xuICB9XG5cbiAgcmV0dXJuIHByb21pc2U7XG59O1xuXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcbnV0aWxzLmZvckVhY2goWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAnb3B0aW9ucyddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XG4gICAgcmV0dXJuIHRoaXMucmVxdWVzdCh1dGlscy5tZXJnZShjb25maWcgfHwge30sIHtcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxuICAgICAgdXJsOiB1cmxcbiAgICB9KSk7XG4gIH07XG59KTtcblxudXRpbHMuZm9yRWFjaChbJ3Bvc3QnLCAncHV0JywgJ3BhdGNoJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2RXaXRoRGF0YShtZXRob2QpIHtcbiAgLyplc2xpbnQgZnVuYy1uYW1lczowKi9cbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xuICAgIHJldHVybiB0aGlzLnJlcXVlc3QodXRpbHMubWVyZ2UoY29uZmlnIHx8IHt9LCB7XG4gICAgICBtZXRob2Q6IG1ldGhvZCxcbiAgICAgIHVybDogdXJsLFxuICAgICAgZGF0YTogZGF0YVxuICAgIH0pKTtcbiAgfTtcbn0pO1xuXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcbiAgdGhpcy5oYW5kbGVycyA9IFtdO1xufVxuXG4vKipcbiAqIEFkZCBhIG5ldyBpbnRlcmNlcHRvciB0byB0aGUgc3RhY2tcbiAqXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBmdWxmaWxsZWQgVGhlIGZ1bmN0aW9uIHRvIGhhbmRsZSBgdGhlbmAgZm9yIGEgYFByb21pc2VgXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSByZWplY3RlZCBUaGUgZnVuY3Rpb24gdG8gaGFuZGxlIGByZWplY3RgIGZvciBhIGBQcm9taXNlYFxuICpcbiAqIEByZXR1cm4ge051bWJlcn0gQW4gSUQgdXNlZCB0byByZW1vdmUgaW50ZXJjZXB0b3IgbGF0ZXJcbiAqL1xuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCkge1xuICB0aGlzLmhhbmRsZXJzLnB1c2goe1xuICAgIGZ1bGZpbGxlZDogZnVsZmlsbGVkLFxuICAgIHJlamVjdGVkOiByZWplY3RlZFxuICB9KTtcbiAgcmV0dXJuIHRoaXMuaGFuZGxlcnMubGVuZ3RoIC0gMTtcbn07XG5cbi8qKlxuICogUmVtb3ZlIGFuIGludGVyY2VwdG9yIGZyb20gdGhlIHN0YWNrXG4gKlxuICogQHBhcmFtIHtOdW1iZXJ9IGlkIFRoZSBJRCB0aGF0IHdhcyByZXR1cm5lZCBieSBgdXNlYFxuICovXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcbiAgaWYgKHRoaXMuaGFuZGxlcnNbaWRdKSB7XG4gICAgdGhpcy5oYW5kbGVyc1tpZF0gPSBudWxsO1xuICB9XG59O1xuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbGwgdGhlIHJlZ2lzdGVyZWQgaW50ZXJjZXB0b3JzXG4gKlxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcbiAqIGludGVyY2VwdG9ycyB0aGF0IG1heSBoYXZlIGJlY29tZSBgbnVsbGAgY2FsbGluZyBgZWplY3RgLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXG4gKi9cbkludGVyY2VwdG9yTWFuYWdlci5wcm90b3R5cGUuZm9yRWFjaCA9IGZ1bmN0aW9uIGZvckVhY2goZm4pIHtcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XG4gICAgaWYgKGggIT09IG51bGwpIHtcbiAgICAgIGZuKGgpO1xuICAgIH1cbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEludGVyY2VwdG9yTWFuYWdlcjtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBlbmhhbmNlRXJyb3IgPSByZXF1aXJlKCcuL2VuaGFuY2VFcnJvcicpO1xuXG4vKipcbiAqIENyZWF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgbWVzc2FnZSwgY29uZmlnLCBlcnJvciBjb2RlLCByZXF1ZXN0IGFuZCByZXNwb25zZS5cbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gbWVzc2FnZSBUaGUgZXJyb3IgbWVzc2FnZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjcmVhdGVFcnJvcihtZXNzYWdlLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcbiAgcmV0dXJuIGVuaGFuY2VFcnJvcihlcnJvciwgY29uZmlnLCBjb2RlLCByZXF1ZXN0LCByZXNwb25zZSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG52YXIgdHJhbnNmb3JtRGF0YSA9IHJlcXVpcmUoJy4vdHJhbnNmb3JtRGF0YScpO1xudmFyIGlzQ2FuY2VsID0gcmVxdWlyZSgnLi4vY2FuY2VsL2lzQ2FuY2VsJyk7XG52YXIgZGVmYXVsdHMgPSByZXF1aXJlKCcuLi9kZWZhdWx0cycpO1xudmFyIGlzQWJzb2x1dGVVUkwgPSByZXF1aXJlKCcuLy4uL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTCcpO1xudmFyIGNvbWJpbmVVUkxzID0gcmVxdWlyZSgnLi8uLi9oZWxwZXJzL2NvbWJpbmVVUkxzJyk7XG5cbi8qKlxuICogVGhyb3dzIGEgYENhbmNlbGAgaWYgY2FuY2VsbGF0aW9uIGhhcyBiZWVuIHJlcXVlc3RlZC5cbiAqL1xuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcbiAgaWYgKGNvbmZpZy5jYW5jZWxUb2tlbikge1xuICAgIGNvbmZpZy5jYW5jZWxUb2tlbi50aHJvd0lmUmVxdWVzdGVkKCk7XG4gIH1cbn1cblxuLyoqXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxuICpcbiAqIEBwYXJhbSB7b2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZyB0aGF0IGlzIHRvIGJlIHVzZWQgZm9yIHRoZSByZXF1ZXN0XG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZGlzcGF0Y2hSZXF1ZXN0KGNvbmZpZykge1xuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XG5cbiAgLy8gU3VwcG9ydCBiYXNlVVJMIGNvbmZpZ1xuICBpZiAoY29uZmlnLmJhc2VVUkwgJiYgIWlzQWJzb2x1dGVVUkwoY29uZmlnLnVybCkpIHtcbiAgICBjb25maWcudXJsID0gY29tYmluZVVSTHMoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xuICB9XG5cbiAgLy8gRW5zdXJlIGhlYWRlcnMgZXhpc3RcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcblxuICAvLyBUcmFuc2Zvcm0gcmVxdWVzdCBkYXRhXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICBjb25maWcuZGF0YSxcbiAgICBjb25maWcuaGVhZGVycyxcbiAgICBjb25maWcudHJhbnNmb3JtUmVxdWVzdFxuICApO1xuXG4gIC8vIEZsYXR0ZW4gaGVhZGVyc1xuICBjb25maWcuaGVhZGVycyA9IHV0aWxzLm1lcmdlKFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVyc1tjb25maWcubWV0aG9kXSB8fCB7fSxcbiAgICBjb25maWcuaGVhZGVycyB8fCB7fVxuICApO1xuXG4gIHV0aWxzLmZvckVhY2goXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXG4gICAgZnVuY3Rpb24gY2xlYW5IZWFkZXJDb25maWcobWV0aG9kKSB7XG4gICAgICBkZWxldGUgY29uZmlnLmhlYWRlcnNbbWV0aG9kXTtcbiAgICB9XG4gICk7XG5cbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xuXG4gIHJldHVybiBhZGFwdGVyKGNvbmZpZykudGhlbihmdW5jdGlvbiBvbkFkYXB0ZXJSZXNvbHV0aW9uKHJlc3BvbnNlKSB7XG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgLy8gVHJhbnNmb3JtIHJlc3BvbnNlIGRhdGFcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YShcbiAgICAgIHJlc3BvbnNlLmRhdGEsXG4gICAgICByZXNwb25zZS5oZWFkZXJzLFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXG4gICAgKTtcblxuICAgIHJldHVybiByZXNwb25zZTtcbiAgfSwgZnVuY3Rpb24gb25BZGFwdGVyUmVqZWN0aW9uKHJlYXNvbikge1xuICAgIGlmICghaXNDYW5jZWwocmVhc29uKSkge1xuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xuXG4gICAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcbiAgICAgICAgcmVhc29uLnJlc3BvbnNlLmRhdGEgPSB0cmFuc2Zvcm1EYXRhKFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5oZWFkZXJzLFxuICAgICAgICAgIGNvbmZpZy50cmFuc2Zvcm1SZXNwb25zZVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChyZWFzb24pO1xuICB9KTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXG4gKlxuICogQHBhcmFtIHtFcnJvcn0gZXJyb3IgVGhlIGVycm9yIHRvIHVwZGF0ZS5cbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXG4gKiBAcGFyYW0ge09iamVjdH0gW3JlcXVlc3RdIFRoZSByZXF1ZXN0LlxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxuICogQHJldHVybnMge0Vycm9yfSBUaGUgZXJyb3IuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XG4gIGVycm9yLmNvbmZpZyA9IGNvbmZpZztcbiAgaWYgKGNvZGUpIHtcbiAgICBlcnJvci5jb2RlID0gY29kZTtcbiAgfVxuICBlcnJvci5yZXF1ZXN0ID0gcmVxdWVzdDtcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcbiAgcmV0dXJuIGVycm9yO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBjcmVhdGVFcnJvciA9IHJlcXVpcmUoJy4vY3JlYXRlRXJyb3InKTtcblxuLyoqXG4gKiBSZXNvbHZlIG9yIHJlamVjdCBhIFByb21pc2UgYmFzZWQgb24gcmVzcG9uc2Ugc3RhdHVzLlxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtGdW5jdGlvbn0gcmVqZWN0IEEgZnVuY3Rpb24gdGhhdCByZWplY3RzIHRoZSBwcm9taXNlLlxuICogQHBhcmFtIHtvYmplY3R9IHJlc3BvbnNlIFRoZSByZXNwb25zZS5cbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCByZXNwb25zZSkge1xuICB2YXIgdmFsaWRhdGVTdGF0dXMgPSByZXNwb25zZS5jb25maWcudmFsaWRhdGVTdGF0dXM7XG4gIC8vIE5vdGU6IHN0YXR1cyBpcyBub3QgZXhwb3NlZCBieSBYRG9tYWluUmVxdWVzdFxuICBpZiAoIXJlc3BvbnNlLnN0YXR1cyB8fCAhdmFsaWRhdGVTdGF0dXMgfHwgdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKSkge1xuICAgIHJlc29sdmUocmVzcG9uc2UpO1xuICB9IGVsc2Uge1xuICAgIHJlamVjdChjcmVhdGVFcnJvcihcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXG4gICAgICByZXNwb25zZS5jb25maWcsXG4gICAgICBudWxsLFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcbiAgICAgIHJlc3BvbnNlXG4gICAgKSk7XG4gIH1cbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvc2V0dGxlLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbi8qKlxuICogVHJhbnNmb3JtIHRoZSBkYXRhIGZvciBhIHJlcXVlc3Qgb3IgYSByZXNwb25zZVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fFN0cmluZ30gZGF0YSBUaGUgZGF0YSB0byBiZSB0cmFuc2Zvcm1lZFxuICogQHBhcmFtIHtBcnJheX0gaGVhZGVycyBUaGUgaGVhZGVycyBmb3IgdGhlIHJlcXVlc3Qgb3IgcmVzcG9uc2VcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcbiAqIEByZXR1cm5zIHsqfSBUaGUgcmVzdWx0aW5nIHRyYW5zZm9ybWVkIGRhdGFcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgdXRpbHMuZm9yRWFjaChmbnMsIGZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuICAgIGRhdGEgPSBmbihkYXRhLCBoZWFkZXJzKTtcbiAgfSk7XG5cbiAgcmV0dXJuIGRhdGE7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vdXRpbHMnKTtcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gcmVxdWlyZSgnLi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUnKTtcblxudmFyIERFRkFVTFRfQ09OVEVOVF9UWVBFID0ge1xuICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCdcbn07XG5cbmZ1bmN0aW9uIHNldENvbnRlbnRUeXBlSWZVbnNldChoZWFkZXJzLCB2YWx1ZSkge1xuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xuICAgIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID0gdmFsdWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0RGVmYXVsdEFkYXB0ZXIoKSB7XG4gIHZhciBhZGFwdGVyO1xuICBpZiAodHlwZW9mIFhNTEh0dHBSZXF1ZXN0ICE9PSAndW5kZWZpbmVkJykge1xuICAgIC8vIEZvciBicm93c2VycyB1c2UgWEhSIGFkYXB0ZXJcbiAgICBhZGFwdGVyID0gcmVxdWlyZSgnLi9hZGFwdGVycy94aHInKTtcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAvLyBGb3Igbm9kZSB1c2UgSFRUUCBhZGFwdGVyXG4gICAgYWRhcHRlciA9IHJlcXVpcmUoJy4vYWRhcHRlcnMvaHR0cCcpO1xuICB9XG4gIHJldHVybiBhZGFwdGVyO1xufVxuXG52YXIgZGVmYXVsdHMgPSB7XG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXG5cbiAgdHJhbnNmb3JtUmVxdWVzdDogW2Z1bmN0aW9uIHRyYW5zZm9ybVJlcXVlc3QoZGF0YSwgaGVhZGVycykge1xuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0NvbnRlbnQtVHlwZScpO1xuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XG4gICAgICB1dGlscy5pc0J1ZmZlcihkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNTdHJlYW0oZGF0YSkgfHxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxuICAgICAgdXRpbHMuaXNCbG9iKGRhdGEpXG4gICAgKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzQXJyYXlCdWZmZXJWaWV3KGRhdGEpKSB7XG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XG4gICAgfVxuICAgIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhkYXRhKSkge1xuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIGRhdGEudG9TdHJpbmcoKTtcbiAgICB9XG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpKSB7XG4gICAgICBzZXRDb250ZW50VHlwZUlmVW5zZXQoaGVhZGVycywgJ2FwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtOCcpO1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgIH1cbiAgICByZXR1cm4gZGF0YTtcbiAgfV0sXG5cbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XG4gICAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgdHJ5IHtcbiAgICAgICAgZGF0YSA9IEpTT04ucGFyc2UoZGF0YSk7XG4gICAgICB9IGNhdGNoIChlKSB7IC8qIElnbm9yZSAqLyB9XG4gICAgfVxuICAgIHJldHVybiBkYXRhO1xuICB9XSxcblxuICB0aW1lb3V0OiAwLFxuXG4gIHhzcmZDb29raWVOYW1lOiAnWFNSRi1UT0tFTicsXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcblxuICBtYXhDb250ZW50TGVuZ3RoOiAtMSxcblxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XG4gICAgcmV0dXJuIHN0YXR1cyA+PSAyMDAgJiYgc3RhdHVzIDwgMzAwO1xuICB9XG59O1xuXG5kZWZhdWx0cy5oZWFkZXJzID0ge1xuICBjb21tb246IHtcbiAgICAnQWNjZXB0JzogJ2FwcGxpY2F0aW9uL2pzb24sIHRleHQvcGxhaW4sICovKidcbiAgfVxufTtcblxudXRpbHMuZm9yRWFjaChbJ2RlbGV0ZScsICdnZXQnLCAnaGVhZCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kTm9EYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcbn0pO1xuXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB1dGlscy5tZXJnZShERUZBVUxUX0NPTlRFTlRfVFlQRSk7XG59KTtcblxubW9kdWxlLmV4cG9ydHMgPSBkZWZhdWx0cztcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMuanMiLCIndXNlIHN0cmljdCc7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xuICByZXR1cm4gZnVuY3Rpb24gd3JhcCgpIHtcbiAgICB2YXIgYXJncyA9IG5ldyBBcnJheShhcmd1bWVudHMubGVuZ3RoKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFyZ3NbaV0gPSBhcmd1bWVudHNbaV07XG4gICAgfVxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcbiAgfTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyIsIid1c2Ugc3RyaWN0JztcblxuLy8gYnRvYSBwb2x5ZmlsbCBmb3IgSUU8MTAgY291cnRlc3kgaHR0cHM6Ly9naXRodWIuY29tL2RhdmlkY2hhbWJlcnMvQmFzZTY0LmpzXG5cbnZhciBjaGFycyA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cbmZ1bmN0aW9uIEUoKSB7XG4gIHRoaXMubWVzc2FnZSA9ICdTdHJpbmcgY29udGFpbnMgYW4gaW52YWxpZCBjaGFyYWN0ZXInO1xufVxuRS5wcm90b3R5cGUgPSBuZXcgRXJyb3I7XG5FLnByb3RvdHlwZS5jb2RlID0gNTtcbkUucHJvdG90eXBlLm5hbWUgPSAnSW52YWxpZENoYXJhY3RlckVycm9yJztcblxuZnVuY3Rpb24gYnRvYShpbnB1dCkge1xuICB2YXIgc3RyID0gU3RyaW5nKGlucHV0KTtcbiAgdmFyIG91dHB1dCA9ICcnO1xuICBmb3IgKFxuICAgIC8vIGluaXRpYWxpemUgcmVzdWx0IGFuZCBjb3VudGVyXG4gICAgdmFyIGJsb2NrLCBjaGFyQ29kZSwgaWR4ID0gMCwgbWFwID0gY2hhcnM7XG4gICAgLy8gaWYgdGhlIG5leHQgc3RyIGluZGV4IGRvZXMgbm90IGV4aXN0OlxuICAgIC8vICAgY2hhbmdlIHRoZSBtYXBwaW5nIHRhYmxlIHRvIFwiPVwiXG4gICAgLy8gICBjaGVjayBpZiBkIGhhcyBubyBmcmFjdGlvbmFsIGRpZ2l0c1xuICAgIHN0ci5jaGFyQXQoaWR4IHwgMCkgfHwgKG1hcCA9ICc9JywgaWR4ICUgMSk7XG4gICAgLy8gXCI4IC0gaWR4ICUgMSAqIDhcIiBnZW5lcmF0ZXMgdGhlIHNlcXVlbmNlIDIsIDQsIDYsIDhcbiAgICBvdXRwdXQgKz0gbWFwLmNoYXJBdCg2MyAmIGJsb2NrID4+IDggLSBpZHggJSAxICogOClcbiAgKSB7XG4gICAgY2hhckNvZGUgPSBzdHIuY2hhckNvZGVBdChpZHggKz0gMyAvIDQpO1xuICAgIGlmIChjaGFyQ29kZSA+IDB4RkYpIHtcbiAgICAgIHRocm93IG5ldyBFKCk7XG4gICAgfVxuICAgIGJsb2NrID0gYmxvY2sgPDwgOCB8IGNoYXJDb2RlO1xuICB9XG4gIHJldHVybiBvdXRwdXQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gYnRvYTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9idG9hLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbmZ1bmN0aW9uIGVuY29kZSh2YWwpIHtcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxuICAgIHJlcGxhY2UoLyU0MC9naSwgJ0AnKS5cbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXG4gICAgcmVwbGFjZSgvJTI0L2csICckJykuXG4gICAgcmVwbGFjZSgvJTJDL2dpLCAnLCcpLlxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxuICAgIHJlcGxhY2UoLyU1Qi9naSwgJ1snKS5cbiAgICByZXBsYWNlKC8lNUQvZ2ksICddJyk7XG59XG5cbi8qKlxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXG4gKlxuICogQHBhcmFtIHtzdHJpbmd9IHVybCBUaGUgYmFzZSBvZiB0aGUgdXJsIChlLmcuLCBodHRwOi8vd3d3Lmdvb2dsZS5jb20pXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGZvcm1hdHRlZCB1cmxcbiAqL1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xuICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgaWYgKCFwYXJhbXMpIHtcbiAgICByZXR1cm4gdXJsO1xuICB9XG5cbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XG4gIGlmIChwYXJhbXNTZXJpYWxpemVyKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtc1NlcmlhbGl6ZXIocGFyYW1zKTtcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XG4gICAgc2VyaWFsaXplZFBhcmFtcyA9IHBhcmFtcy50b1N0cmluZygpO1xuICB9IGVsc2Uge1xuICAgIHZhciBwYXJ0cyA9IFtdO1xuXG4gICAgdXRpbHMuZm9yRWFjaChwYXJhbXMsIGZ1bmN0aW9uIHNlcmlhbGl6ZSh2YWwsIGtleSkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGlmICh1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAga2V5ID0ga2V5ICsgJ1tdJztcbiAgICAgIH1cblxuICAgICAgaWYgKCF1dGlscy5pc0FycmF5KHZhbCkpIHtcbiAgICAgICAgdmFsID0gW3ZhbF07XG4gICAgICB9XG5cbiAgICAgIHV0aWxzLmZvckVhY2godmFsLCBmdW5jdGlvbiBwYXJzZVZhbHVlKHYpIHtcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xuICAgICAgICAgIHYgPSB2LnRvSVNPU3RyaW5nKCk7XG4gICAgICAgIH0gZWxzZSBpZiAodXRpbHMuaXNPYmplY3QodikpIHtcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XG4gICAgICAgIH1cbiAgICAgICAgcGFydHMucHVzaChlbmNvZGUoa2V5KSArICc9JyArIGVuY29kZSh2KSk7XG4gICAgICB9KTtcbiAgICB9KTtcblxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XG4gIH1cblxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xuICAgIHVybCArPSAodXJsLmluZGV4T2YoJz8nKSA9PT0gLTEgPyAnPycgOiAnJicpICsgc2VyaWFsaXplZFBhcmFtcztcbiAgfVxuXG4gIHJldHVybiB1cmw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgc3BlY2lmaWVkIFVSTHNcbiAqXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcbiAqIEBwYXJhbSB7c3RyaW5nfSByZWxhdGl2ZVVSTCBUaGUgcmVsYXRpdmUgVVJMXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBUaGUgY29tYmluZWQgVVJMXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gY29tYmluZVVSTHMoYmFzZVVSTCwgcmVsYXRpdmVVUkwpIHtcbiAgcmV0dXJuIHJlbGF0aXZlVVJMXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcLyskLywgJycpICsgJy8nICsgcmVsYXRpdmVVUkwucmVwbGFjZSgvXlxcLysvLCAnJylcbiAgICA6IGJhc2VVUkw7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLy4uL3V0aWxzJyk7XG5cbm1vZHVsZS5leHBvcnRzID0gKFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cblxuICAvLyBTdGFuZGFyZCBicm93c2VyIGVudnMgc3VwcG9ydCBkb2N1bWVudC5jb29raWVcbiAgKGZ1bmN0aW9uIHN0YW5kYXJkQnJvd3NlckVudigpIHtcbiAgICByZXR1cm4ge1xuICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKG5hbWUsIHZhbHVlLCBleHBpcmVzLCBwYXRoLCBkb21haW4sIHNlY3VyZSkge1xuICAgICAgICB2YXIgY29va2llID0gW107XG4gICAgICAgIGNvb2tpZS5wdXNoKG5hbWUgKyAnPScgKyBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpKTtcblxuICAgICAgICBpZiAodXRpbHMuaXNOdW1iZXIoZXhwaXJlcykpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgnZXhwaXJlcz0nICsgbmV3IERhdGUoZXhwaXJlcykudG9HTVRTdHJpbmcoKSk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcbiAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcoZG9tYWluKSkge1xuICAgICAgICAgIGNvb2tpZS5wdXNoKCdkb21haW49JyArIGRvbWFpbik7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoc2VjdXJlID09PSB0cnVlKSB7XG4gICAgICAgICAgY29va2llLnB1c2goJ3NlY3VyZScpO1xuICAgICAgICB9XG5cbiAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XG4gICAgICB9LFxuXG4gICAgICByZWFkOiBmdW5jdGlvbiByZWFkKG5hbWUpIHtcbiAgICAgICAgdmFyIG1hdGNoID0gZG9jdW1lbnQuY29va2llLm1hdGNoKG5ldyBSZWdFeHAoJyhefDtcXFxccyopKCcgKyBuYW1lICsgJyk9KFteO10qKScpKTtcbiAgICAgICAgcmV0dXJuIChtYXRjaCA/IGRlY29kZVVSSUNvbXBvbmVudChtYXRjaFszXSkgOiBudWxsKTtcbiAgICAgIH0sXG5cbiAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcbiAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcbiAgICAgIH1cbiAgICB9O1xuICB9KSgpIDpcblxuICAvLyBOb24gc3RhbmRhcmQgYnJvd3NlciBlbnYgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZSgpIHt9LFxuICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZCgpIHsgcmV0dXJuIG51bGw7IH0sXG4gICAgICByZW1vdmU6IGZ1bmN0aW9uIHJlbW92ZSgpIHt9XG4gICAgfTtcbiAgfSkoKVxuKTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG4vKipcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZVxuICpcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgc3BlY2lmaWVkIFVSTCBpcyBhYnNvbHV0ZSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcbiAgLy8gQSBVUkwgaXMgY29uc2lkZXJlZCBhYnNvbHV0ZSBpZiBpdCBiZWdpbnMgd2l0aCBcIjxzY2hlbWU+Oi8vXCIgb3IgXCIvL1wiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxuICAvLyBSRkMgMzk4NiBkZWZpbmVzIHNjaGVtZSBuYW1lIGFzIGEgc2VxdWVuY2Ugb2YgY2hhcmFjdGVycyBiZWdpbm5pbmcgd2l0aCBhIGxldHRlciBhbmQgZm9sbG93ZWRcbiAgLy8gYnkgYW55IGNvbWJpbmF0aW9uIG9mIGxldHRlcnMsIGRpZ2l0cywgcGx1cywgcGVyaW9kLCBvciBoeXBoZW4uXG4gIHJldHVybiAvXihbYS16XVthLXpcXGRcXCtcXC1cXC5dKjopP1xcL1xcLy9pLnRlc3QodXJsKTtcbn07XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qcyIsIid1c2Ugc3RyaWN0JztcblxudmFyIHV0aWxzID0gcmVxdWlyZSgnLi8uLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IChcbiAgdXRpbHMuaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSA/XG5cbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIGhhdmUgZnVsbCBzdXBwb3J0IG9mIHRoZSBBUElzIG5lZWRlZCB0byB0ZXN0XG4gIC8vIHdoZXRoZXIgdGhlIHJlcXVlc3QgVVJMIGlzIG9mIHRoZSBzYW1lIG9yaWdpbiBhcyBjdXJyZW50IGxvY2F0aW9uLlxuICAoZnVuY3Rpb24gc3RhbmRhcmRCcm93c2VyRW52KCkge1xuICAgIHZhciBtc2llID0gLyhtc2llfHRyaWRlbnQpL2kudGVzdChuYXZpZ2F0b3IudXNlckFnZW50KTtcbiAgICB2YXIgdXJsUGFyc2luZ05vZGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdhJyk7XG4gICAgdmFyIG9yaWdpblVSTDtcblxuICAgIC8qKlxuICAgICogUGFyc2UgYSBVUkwgdG8gZGlzY292ZXIgaXQncyBjb21wb25lbnRzXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxuICAgICogQHJldHVybnMge09iamVjdH1cbiAgICAqL1xuICAgIGZ1bmN0aW9uIHJlc29sdmVVUkwodXJsKSB7XG4gICAgICB2YXIgaHJlZiA9IHVybDtcblxuICAgICAgaWYgKG1zaWUpIHtcbiAgICAgICAgLy8gSUUgbmVlZHMgYXR0cmlidXRlIHNldCB0d2ljZSB0byBub3JtYWxpemUgcHJvcGVydGllc1xuICAgICAgICB1cmxQYXJzaW5nTm9kZS5zZXRBdHRyaWJ1dGUoJ2hyZWYnLCBocmVmKTtcbiAgICAgICAgaHJlZiA9IHVybFBhcnNpbmdOb2RlLmhyZWY7XG4gICAgICB9XG5cbiAgICAgIHVybFBhcnNpbmdOb2RlLnNldEF0dHJpYnV0ZSgnaHJlZicsIGhyZWYpO1xuXG4gICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXG4gICAgICByZXR1cm4ge1xuICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxuICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxuICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxuICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFw/LywgJycpIDogJycsXG4gICAgICAgIGhhc2g6IHVybFBhcnNpbmdOb2RlLmhhc2ggPyB1cmxQYXJzaW5nTm9kZS5oYXNoLnJlcGxhY2UoL14jLywgJycpIDogJycsXG4gICAgICAgIGhvc3RuYW1lOiB1cmxQYXJzaW5nTm9kZS5ob3N0bmFtZSxcbiAgICAgICAgcG9ydDogdXJsUGFyc2luZ05vZGUucG9ydCxcbiAgICAgICAgcGF0aG5hbWU6ICh1cmxQYXJzaW5nTm9kZS5wYXRobmFtZS5jaGFyQXQoMCkgPT09ICcvJykgP1xuICAgICAgICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxuICAgICAgICAgICAgICAgICAgJy8nICsgdXJsUGFyc2luZ05vZGUucGF0aG5hbWVcbiAgICAgIH07XG4gICAgfVxuXG4gICAgb3JpZ2luVVJMID0gcmVzb2x2ZVVSTCh3aW5kb3cubG9jYXRpb24uaHJlZik7XG5cbiAgICAvKipcbiAgICAqIERldGVybWluZSBpZiBhIFVSTCBzaGFyZXMgdGhlIHNhbWUgb3JpZ2luIGFzIHRoZSBjdXJyZW50IGxvY2F0aW9uXG4gICAgKlxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XG4gICAgKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiwgb3RoZXJ3aXNlIGZhbHNlXG4gICAgKi9cbiAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKHJlcXVlc3RVUkwpIHtcbiAgICAgIHZhciBwYXJzZWQgPSAodXRpbHMuaXNTdHJpbmcocmVxdWVzdFVSTCkpID8gcmVzb2x2ZVVSTChyZXF1ZXN0VVJMKSA6IHJlcXVlc3RVUkw7XG4gICAgICByZXR1cm4gKHBhcnNlZC5wcm90b2NvbCA9PT0gb3JpZ2luVVJMLnByb3RvY29sICYmXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xuICAgIH07XG4gIH0pKCkgOlxuXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudnMgKHdlYiB3b3JrZXJzLCByZWFjdC1uYXRpdmUpIGxhY2sgbmVlZGVkIHN1cHBvcnQuXG4gIChmdW5jdGlvbiBub25TdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIGlzVVJMU2FtZU9yaWdpbigpIHtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH07XG4gIH0pKClcbik7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzIiwiJ3VzZSBzdHJpY3QnO1xuXG52YXIgdXRpbHMgPSByZXF1aXJlKCcuLi91dGlscycpO1xuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgbm9ybWFsaXplZE5hbWUpIHtcbiAgdXRpbHMuZm9yRWFjaChoZWFkZXJzLCBmdW5jdGlvbiBwcm9jZXNzSGVhZGVyKHZhbHVlLCBuYW1lKSB7XG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xuICAgICAgaGVhZGVyc1tub3JtYWxpemVkTmFtZV0gPSB2YWx1ZTtcbiAgICAgIGRlbGV0ZSBoZWFkZXJzW25hbWVdO1xuICAgIH1cbiAgfSk7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciB1dGlscyA9IHJlcXVpcmUoJy4vLi4vdXRpbHMnKTtcblxuLy8gSGVhZGVycyB3aG9zZSBkdXBsaWNhdGVzIGFyZSBpZ25vcmVkIGJ5IG5vZGVcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcbnZhciBpZ25vcmVEdXBsaWNhdGVPZiA9IFtcbiAgJ2FnZScsICdhdXRob3JpemF0aW9uJywgJ2NvbnRlbnQtbGVuZ3RoJywgJ2NvbnRlbnQtdHlwZScsICdldGFnJyxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxuICAnbGFzdC1tb2RpZmllZCcsICdsb2NhdGlvbicsICdtYXgtZm9yd2FyZHMnLCAncHJveHktYXV0aG9yaXphdGlvbicsXG4gICdyZWZlcmVyJywgJ3JldHJ5LWFmdGVyJywgJ3VzZXItYWdlbnQnXG5dO1xuXG4vKipcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcbiAqXG4gKiBgYGBcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXG4gKiBDb250ZW50LVR5cGU6IGFwcGxpY2F0aW9uL2pzb25cbiAqIENvbm5lY3Rpb246IGtlZXAtYWxpdmVcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBIZWFkZXJzIHBhcnNlZCBpbnRvIGFuIG9iamVjdFxuICovXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XG4gIHZhciBwYXJzZWQgPSB7fTtcbiAgdmFyIGtleTtcbiAgdmFyIHZhbDtcbiAgdmFyIGk7XG5cbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cblxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMuc3BsaXQoJ1xcbicpLCBmdW5jdGlvbiBwYXJzZXIobGluZSkge1xuICAgIGkgPSBsaW5lLmluZGV4T2YoJzonKTtcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xuICAgIHZhbCA9IHV0aWxzLnRyaW0obGluZS5zdWJzdHIoaSArIDEpKTtcblxuICAgIGlmIChrZXkpIHtcbiAgICAgIGlmIChwYXJzZWRba2V5XSAmJiBpZ25vcmVEdXBsaWNhdGVPZi5pbmRleE9mKGtleSkgPj0gMCkge1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBpZiAoa2V5ID09PSAnc2V0LWNvb2tpZScpIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSAocGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSA6IFtdKS5jb25jYXQoW3ZhbF0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgcGFyc2VkW2tleV0gPSBwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldICsgJywgJyArIHZhbCA6IHZhbDtcbiAgICAgIH1cbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBwYXJzZWQ7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qcyIsIid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBTeW50YWN0aWMgc3VnYXIgZm9yIGludm9raW5nIGEgZnVuY3Rpb24gYW5kIGV4cGFuZGluZyBhbiBhcnJheSBmb3IgYXJndW1lbnRzLlxuICpcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXG4gKlxuICogIGBgYGpzXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxuICogIHZhciBhcmdzID0gWzEsIDIsIDNdO1xuICogIGYuYXBwbHkobnVsbCwgYXJncyk7XG4gKiAgYGBgXG4gKlxuICogV2l0aCBgc3ByZWFkYCB0aGlzIGV4YW1wbGUgY2FuIGJlIHJlLXdyaXR0ZW4uXG4gKlxuICogIGBgYGpzXG4gKiAgc3ByZWFkKGZ1bmN0aW9uKHgsIHksIHopIHt9KShbMSwgMiwgM10pO1xuICogIGBgYFxuICpcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc3ByZWFkKGNhbGxiYWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xuICAgIHJldHVybiBjYWxsYmFjay5hcHBseShudWxsLCBhcnIpO1xuICB9O1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanMiLCIndXNlIHN0cmljdCc7XG5cbnZhciBiaW5kID0gcmVxdWlyZSgnLi9oZWxwZXJzL2JpbmQnKTtcbnZhciBpc0J1ZmZlciA9IHJlcXVpcmUoJ2lzLWJ1ZmZlcicpO1xuXG4vKmdsb2JhbCB0b1N0cmluZzp0cnVlKi9cblxuLy8gdXRpbHMgaXMgYSBsaWJyYXJ5IG9mIGdlbmVyaWMgaGVscGVyIGZ1bmN0aW9ucyBub24tc3BlY2lmaWMgdG8gYXhpb3NcblxudmFyIHRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheVxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5LCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXldJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBBcnJheUJ1ZmZlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlcih2YWwpIHtcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgQXJyYXlCdWZmZXJdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Zvcm1EYXRhKHZhbCkge1xuICByZXR1cm4gKHR5cGVvZiBGb3JtRGF0YSAhPT0gJ3VuZGVmaW5lZCcpICYmICh2YWwgaW5zdGFuY2VvZiBGb3JtRGF0YSk7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSB2aWV3IG9uIGFuIEFycmF5QnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNBcnJheUJ1ZmZlclZpZXcodmFsKSB7XG4gIHZhciByZXN1bHQ7XG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcbiAgICByZXN1bHQgPSBBcnJheUJ1ZmZlci5pc1ZpZXcodmFsKTtcbiAgfSBlbHNlIHtcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKHZhbC5idWZmZXIgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcik7XG4gIH1cbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFN0cmluZ1xuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgU3RyaW5nLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnc3RyaW5nJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIE51bWJlclxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgTnVtYmVyLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNOdW1iZXIodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAnbnVtYmVyJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyB1bmRlZmluZWRcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB0aGUgdmFsdWUgaXMgdW5kZWZpbmVkLCBvdGhlcndpc2UgZmFsc2VcbiAqL1xuZnVuY3Rpb24gaXNVbmRlZmluZWQodmFsKSB7XG4gIHJldHVybiB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc09iamVjdCh2YWwpIHtcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0Jztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIERhdGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIERhdGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0RhdGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IERhdGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0ZpbGUodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJsb2JcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEJsb2IsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEJsb2JdJztcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZ1bmN0aW9uXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBGdW5jdGlvbiwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzRnVuY3Rpb24odmFsKSB7XG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59XG5cbi8qKlxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXG4gKi9cbmZ1bmN0aW9uIGlzU3RyZWFtKHZhbCkge1xuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcbn1cblxuLyoqXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3RcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFVSTFNlYXJjaFBhcmFtcyBvYmplY3QsIG90aGVyd2lzZSBmYWxzZVxuICovXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiBVUkxTZWFyY2hQYXJhbXMgIT09ICd1bmRlZmluZWQnICYmIHZhbCBpbnN0YW5jZW9mIFVSTFNlYXJjaFBhcmFtcztcbn1cblxuLyoqXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc3RyIFRoZSBTdHJpbmcgdG8gdHJpbVxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxuICovXG5mdW5jdGlvbiB0cmltKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoL15cXHMqLywgJycpLnJlcGxhY2UoL1xccyokLywgJycpO1xufVxuXG4vKipcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxuICpcbiAqIFRoaXMgYWxsb3dzIGF4aW9zIHRvIHJ1biBpbiBhIHdlYiB3b3JrZXIsIGFuZCByZWFjdC1uYXRpdmUuXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXG4gKlxuICogd2ViIHdvcmtlcnM6XG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcbiAqICB0eXBlb2YgZG9jdW1lbnQgLT4gdW5kZWZpbmVkXG4gKlxuICogcmVhY3QtbmF0aXZlOlxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdSZWFjdE5hdGl2ZSdcbiAqL1xuZnVuY3Rpb24gaXNTdGFuZGFyZEJyb3dzZXJFbnYoKSB7XG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiBuYXZpZ2F0b3IucHJvZHVjdCA9PT0gJ1JlYWN0TmF0aXZlJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICByZXR1cm4gKFxuICAgIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJ1xuICApO1xufVxuXG4vKipcbiAqIEl0ZXJhdGUgb3ZlciBhbiBBcnJheSBvciBhbiBPYmplY3QgaW52b2tpbmcgYSBmdW5jdGlvbiBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcbiAqIHRoZSB2YWx1ZSwgaW5kZXgsIGFuZCBjb21wbGV0ZSBhcnJheSBmb3IgZWFjaCBpdGVtLlxuICpcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXG4gKiB0aGUgdmFsdWUsIGtleSwgYW5kIGNvbXBsZXRlIG9iamVjdCBmb3IgZWFjaCBwcm9wZXJ0eS5cbiAqXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gZm4gVGhlIGNhbGxiYWNrIHRvIGludm9rZSBmb3IgZWFjaCBpdGVtXG4gKi9cbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xuICAvLyBEb24ndCBib3RoZXIgaWYgbm8gdmFsdWUgcHJvdmlkZWRcbiAgaWYgKG9iaiA9PT0gbnVsbCB8fCB0eXBlb2Ygb2JqID09PSAndW5kZWZpbmVkJykge1xuICAgIHJldHVybjtcbiAgfVxuXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxuICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcpIHtcbiAgICAvKmVzbGludCBuby1wYXJhbS1yZWFzc2lnbjowKi9cbiAgICBvYmogPSBbb2JqXTtcbiAgfVxuXG4gIGlmIChpc0FycmF5KG9iaikpIHtcbiAgICAvLyBJdGVyYXRlIG92ZXIgYXJyYXkgdmFsdWVzXG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBvYmoubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXG4gICAgZm9yICh2YXIga2V5IGluIG9iaikge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSkpIHtcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIEFjY2VwdHMgdmFyYXJncyBleHBlY3RpbmcgZWFjaCBhcmd1bWVudCB0byBiZSBhbiBvYmplY3QsIHRoZW5cbiAqIGltbXV0YWJseSBtZXJnZXMgdGhlIHByb3BlcnRpZXMgb2YgZWFjaCBvYmplY3QgYW5kIHJldHVybnMgcmVzdWx0LlxuICpcbiAqIFdoZW4gbXVsdGlwbGUgb2JqZWN0cyBjb250YWluIHRoZSBzYW1lIGtleSB0aGUgbGF0ZXIgb2JqZWN0IGluXG4gKiB0aGUgYXJndW1lbnRzIGxpc3Qgd2lsbCB0YWtlIHByZWNlZGVuY2UuXG4gKlxuICogRXhhbXBsZTpcbiAqXG4gKiBgYGBqc1xuICogdmFyIHJlc3VsdCA9IG1lcmdlKHtmb286IDEyM30sIHtmb286IDQ1Nn0pO1xuICogY29uc29sZS5sb2cocmVzdWx0LmZvbyk7IC8vIG91dHB1dHMgNDU2XG4gKiBgYGBcbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gb2JqMSBPYmplY3QgdG8gbWVyZ2VcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xuICovXG5mdW5jdGlvbiBtZXJnZSgvKiBvYmoxLCBvYmoyLCBvYmozLCAuLi4gKi8pIHtcbiAgdmFyIHJlc3VsdCA9IHt9O1xuICBmdW5jdGlvbiBhc3NpZ25WYWx1ZSh2YWwsIGtleSkge1xuICAgIGlmICh0eXBlb2YgcmVzdWx0W2tleV0gPT09ICdvYmplY3QnICYmIHR5cGVvZiB2YWwgPT09ICdvYmplY3QnKSB7XG4gICAgICByZXN1bHRba2V5XSA9IG1lcmdlKHJlc3VsdFtrZXldLCB2YWwpO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXN1bHRba2V5XSA9IHZhbDtcbiAgICB9XG4gIH1cblxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBmb3JFYWNoKGFyZ3VtZW50c1tpXSwgYXNzaWduVmFsdWUpO1xuICB9XG4gIHJldHVybiByZXN1bHQ7XG59XG5cbi8qKlxuICogRXh0ZW5kcyBvYmplY3QgYSBieSBtdXRhYmx5IGFkZGluZyB0byBpdCB0aGUgcHJvcGVydGllcyBvZiBvYmplY3QgYi5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXG4gKiBAcGFyYW0ge09iamVjdH0gYiBUaGUgb2JqZWN0IHRvIGNvcHkgcHJvcGVydGllcyBmcm9tXG4gKiBAcGFyYW0ge09iamVjdH0gdGhpc0FyZyBUaGUgb2JqZWN0IHRvIGJpbmQgZnVuY3Rpb24gdG9cbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxuICovXG5mdW5jdGlvbiBleHRlbmQoYSwgYiwgdGhpc0FyZykge1xuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XG4gICAgaWYgKHRoaXNBcmcgJiYgdHlwZW9mIHZhbCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgYVtrZXldID0gYmluZCh2YWwsIHRoaXNBcmcpO1xuICAgIH0gZWxzZSB7XG4gICAgICBhW2tleV0gPSB2YWw7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGE7XG59XG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICBpc0FycmF5OiBpc0FycmF5LFxuICBpc0FycmF5QnVmZmVyOiBpc0FycmF5QnVmZmVyLFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXG4gIGlzRm9ybURhdGE6IGlzRm9ybURhdGEsXG4gIGlzQXJyYXlCdWZmZXJWaWV3OiBpc0FycmF5QnVmZmVyVmlldyxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxuICBpc051bWJlcjogaXNOdW1iZXIsXG4gIGlzT2JqZWN0OiBpc09iamVjdCxcbiAgaXNVbmRlZmluZWQ6IGlzVW5kZWZpbmVkLFxuICBpc0RhdGU6IGlzRGF0ZSxcbiAgaXNGaWxlOiBpc0ZpbGUsXG4gIGlzQmxvYjogaXNCbG9iLFxuICBpc0Z1bmN0aW9uOiBpc0Z1bmN0aW9uLFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXG4gIGlzVVJMU2VhcmNoUGFyYW1zOiBpc1VSTFNlYXJjaFBhcmFtcyxcbiAgaXNTdGFuZGFyZEJyb3dzZXJFbnY6IGlzU3RhbmRhcmRCcm93c2VyRW52LFxuICBmb3JFYWNoOiBmb3JFYWNoLFxuICBtZXJnZTogbWVyZ2UsXG4gIGV4dGVuZDogZXh0ZW5kLFxuICB0cmltOiB0cmltXG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qcyIsIjx0ZW1wbGF0ZT5cbiAgPHN2ZyB2ZXJzaW9uPVwiMS4xXCJcbiAgICA6Y2xhc3M9XCJrbGFzc1wiXG4gICAgOnJvbGU9XCJsYWJlbCA/ICdpbWcnIDogJ3ByZXNlbnRhdGlvbidcIlxuICAgIDphcmlhLWxhYmVsPVwibGFiZWxcIlxuICAgIDp4PVwieFwiXG4gICAgOnk9XCJ5XCJcbiAgICA6d2lkdGg9XCJ3aWR0aFwiXG4gICAgOmhlaWdodD1cImhlaWdodFwiXG4gICAgOnZpZXdCb3g9XCJib3hcIlxuICAgIDpzdHlsZT1cInN0eWxlXCI+XG4gICAgPHNsb3Q+XG4gICAgICA8dGVtcGxhdGUgdi1pZj1cImljb24gJiYgaWNvbi5wYXRoc1wiPlxuICAgICAgICA8cGF0aCB2LWZvcj1cIihwYXRoLCBpKSBpbiBpY29uLnBhdGhzXCIgOmtleT1cImBwYXRoLSR7aX1gXCIgdi1iaW5kPVwicGF0aFwiLz5cbiAgICAgIDwvdGVtcGxhdGU+XG4gICAgICA8dGVtcGxhdGUgdi1pZj1cImljb24gJiYgaWNvbi5wb2x5Z29uc1wiPlxuICAgICAgICA8cG9seWdvbiB2LWZvcj1cIihwb2x5Z29uLCBpKSBpbiBpY29uLnBvbHlnb25zXCIgOmtleT1cImBwb2x5Z29uLSR7aX1gXCIgdi1iaW5kPVwicG9seWdvblwiLz5cbiAgICAgIDwvdGVtcGxhdGU+XGJcbiAgICAgIDx0ZW1wbGF0ZSB2LWlmPVwiaWNvbiAmJiBpY29uLnJhd1wiPjxnIHYtaHRtbD1cInJhd1wiPjwvZz48L3RlbXBsYXRlPlxuICAgIDwvc2xvdD5cbiAgPC9zdmc+XG48L3RlbXBsYXRlPlxuXG48c3R5bGU+XG4uZmEtaWNvbiB7XG4gIGRpc3BsYXk6IGlubGluZS1ibG9jaztcbiAgZmlsbDogY3VycmVudENvbG9yO1xufVxuXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcbiAgdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XG59XG5cbi5mYS1mbGlwLXZlcnRpY2FsIHtcbiAgdHJhbnNmb3JtOiBzY2FsZSgxLCAtMSk7XG59XG5cbi5mYS1zcGluIHtcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDFzIDBzIGluZmluaXRlIGxpbmVhcjtcbn1cblxuLmZhLWludmVyc2Uge1xuICBjb2xvcjogI2ZmZjtcbn1cblxuLmZhLXB1bHNlIHtcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDFzIGluZmluaXRlIHN0ZXBzKDgpO1xufVxuXG5Aa2V5ZnJhbWVzIGZhLXNwaW4ge1xuICAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XG4gIH1cbiAgMTAwJSB7XG4gICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcbiAgfVxufVxuPC9zdHlsZT5cblxuPHNjcmlwdD5cbmxldCBpY29ucyA9IHt9XG5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgbmFtZTogJ2ljb24nLFxuICBwcm9wczoge1xuICAgIG5hbWU6IHtcbiAgICAgIHR5cGU6IFN0cmluZyxcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICBpZiAoISh2YWwgaW4gaWNvbnMpKSB7XG4gICAgICAgICAgICBjb25zb2xlLndhcm4oYEludmFsaWQgcHJvcDogcHJvcCBcIm5hbWVcIiBpcyByZWZlcnJpbmcgdG8gYW4gdW5yZWdpc3RlcmVkIGljb24gXCIke3ZhbH1cIi5gICtcbiAgICAgICAgICAgICAgYFxcblBsZXNhc2UgbWFrZSBzdXJlIHlvdSBoYXZlIGltcG9ydGVkIHRoaXMgaWNvbiBiZWZvcmUgdXNpbmcgaXQuYClcbiAgICAgICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgICAgIH1cbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwcm9wOiBwcm9wIFwibmFtZVwiIGlzIHJlcXVpcmVkLmApXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0sXG4gICAgc2NhbGU6IFtOdW1iZXIsIFN0cmluZ10sXG4gICAgc3BpbjogQm9vbGVhbixcbiAgICBpbnZlcnNlOiBCb29sZWFuLFxuICAgIHB1bHNlOiBCb29sZWFuLFxuICAgIGZsaXA6IHtcbiAgICAgIHZhbGlkYXRvciAodmFsKSB7XG4gICAgICAgIHJldHVybiB2YWwgPT09ICdob3Jpem9udGFsJyB8fCB2YWwgPT09ICd2ZXJ0aWNhbCdcbiAgICAgIH1cbiAgICB9LFxuICAgIGxhYmVsOiBTdHJpbmdcbiAgfSxcbiAgZGF0YSAoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHg6IGZhbHNlLFxuICAgICAgeTogZmFsc2UsXG4gICAgICBjaGlsZHJlbldpZHRoOiAwLFxuICAgICAgY2hpbGRyZW5IZWlnaHQ6IDAsXG4gICAgICBvdXRlclNjYWxlOiAxXG4gICAgfVxuICB9LFxuICBjb21wdXRlZDoge1xuICAgIG5vcm1hbGl6ZWRTY2FsZSAoKSB7XG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlXG4gICAgICBzY2FsZSA9IHR5cGVvZiBzY2FsZSA9PT0gJ3VuZGVmaW5lZCcgPyAxIDogTnVtYmVyKHNjYWxlKVxuICAgICAgaWYgKGlzTmFOKHNjYWxlKSB8fCBzY2FsZSA8PSAwKSB7XG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwcm9wOiBwcm9wIFwic2NhbGVcIiBzaG91bGQgYmUgYSBudW1iZXIgb3ZlciAwLmAsIHRoaXMpXG4gICAgICAgIHJldHVybiB0aGlzLm91dGVyU2NhbGVcbiAgICAgIH1cbiAgICAgIHJldHVybiBzY2FsZSAqIHRoaXMub3V0ZXJTY2FsZVxuICAgIH0sXG4gICAga2xhc3MgKCkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgJ2ZhLWljb24nOiB0cnVlLFxuICAgICAgICAnZmEtc3Bpbic6IHRoaXMuc3BpbixcbiAgICAgICAgJ2ZhLWZsaXAtaG9yaXpvbnRhbCc6IHRoaXMuZmxpcCA9PT0gJ2hvcml6b250YWwnLFxuICAgICAgICAnZmEtZmxpcC12ZXJ0aWNhbCc6IHRoaXMuZmxpcCA9PT0gJ3ZlcnRpY2FsJyxcbiAgICAgICAgJ2ZhLWludmVyc2UnOiB0aGlzLmludmVyc2UsXG4gICAgICAgICdmYS1wdWxzZSc6IHRoaXMucHVsc2VcbiAgICAgIH1cbiAgICB9LFxuICAgIGljb24gKCkge1xuICAgICAgaWYgKHRoaXMubmFtZSkge1xuICAgICAgICByZXR1cm4gaWNvbnNbdGhpcy5uYW1lXVxuICAgICAgfVxuICAgICAgcmV0dXJuIG51bGxcbiAgICB9LFxuICAgIGJveCAoKSB7XG4gICAgICBpZiAodGhpcy5pY29uKSB7XG4gICAgICAgIHJldHVybiBgMCAwICR7dGhpcy5pY29uLndpZHRofSAke3RoaXMuaWNvbi5oZWlnaHR9YFxuICAgICAgfVxuICAgICAgcmV0dXJuIGAwIDAgJHt0aGlzLndpZHRofSAke3RoaXMuaGVpZ2h0fWBcbiAgICB9LFxuICAgIHJhdGlvICgpIHtcbiAgICAgIGlmICghdGhpcy5pY29uKSB7XG4gICAgICAgIHJldHVybiAxXG4gICAgICB9XG4gICAgICBsZXQgeyB3aWR0aCwgaGVpZ2h0IH0gPSB0aGlzLmljb25cbiAgICAgIHJldHVybiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIDE2XG4gICAgfSxcbiAgICB3aWR0aCAoKSB7XG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbldpZHRoIHx8IHRoaXMuaWNvbiAmJiB0aGlzLmljb24ud2lkdGggLyB0aGlzLnJhdGlvICogdGhpcy5ub3JtYWxpemVkU2NhbGUgfHwgMFxuICAgIH0sXG4gICAgaGVpZ2h0ICgpIHtcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuSGVpZ2h0IHx8IHRoaXMuaWNvbiAmJiB0aGlzLmljb24uaGVpZ2h0IC8gdGhpcy5yYXRpbyAqIHRoaXMubm9ybWFsaXplZFNjYWxlIHx8IDBcbiAgICB9LFxuICAgIHN0eWxlICgpIHtcbiAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZWRTY2FsZSA9PT0gMSkge1xuICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgIH1cbiAgICAgIHJldHVybiB7XG4gICAgICAgIGZvbnRTaXplOiB0aGlzLm5vcm1hbGl6ZWRTY2FsZSArICdlbSdcbiAgICAgIH1cbiAgICB9LFxuICAgIHJhdyAoKSB7XG4gICAgICAvLyBnZW5lcmF0ZSB1bmlxdWUgaWQgZm9yIGVhY2ggaWNvbidzIFNWRyBlbGVtZW50IHdpdGggSURcbiAgICAgIGlmICghdGhpcy5pY29uIHx8ICF0aGlzLmljb24ucmF3KSB7XG4gICAgICAgIHJldHVybiBudWxsXG4gICAgICB9XG4gICAgICBsZXQgcmF3ID0gdGhpcy5pY29uLnJhd1xuICAgICAgbGV0IGlkcyA9IHt9XG4gICAgICByYXcgPSByYXcucmVwbGFjZSgvXFxzKD86eG1sOik/aWQ9W1wiJ10/KFteXCInKVxcc10rKS9nLCAobWF0Y2gsIGlkKSA9PiB7XG4gICAgICAgIGxldCB1bmlxdWVJZCA9IGdldElkKClcbiAgICAgICAgaWRzW2lkXSA9IHVuaXF1ZUlkXG4gICAgICAgIHJldHVybiBgIGlkPVwiJHt1bmlxdWVJZH1cImBcbiAgICAgIH0pXG4gICAgICByYXcgPSByYXcucmVwbGFjZSgvIyg/OihbXidcIilcXHNdKyl8eHBvaW50ZXJcXChpZFxcKChbJ1wiXT8pKFteJyldKylcXDJcXClcXCkpL2csIChtYXRjaCwgcmF3SWQsIF8sIHBvaW50ZXJJZCkgPT4ge1xuICAgICAgICBsZXQgaWQgPSByYXdJZCB8fCBwb2ludGVySWRcbiAgICAgICAgaWYgKCFpZCB8fCAhaWRzW2lkXSkge1xuICAgICAgICAgIHJldHVybiBtYXRjaFxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGAjJHtpZHNbaWRdfWBcbiAgICAgIH0pXG5cbiAgICAgIHJldHVybiByYXdcbiAgICB9XG4gIH0sXG4gIG1vdW50ZWQgKCkge1xuICAgIGlmICh0aGlzLmljb24pIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcbiAgICAgIGNoaWxkLm91dGVyU2NhbGUgPSB0aGlzLm5vcm1hbGl6ZWRTY2FsZVxuICAgIH0pXG4gICAgbGV0IHdpZHRoID0gMFxuICAgIGxldCBoZWlnaHQgPSAwXG4gICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjaGlsZC53aWR0aClcbiAgICAgIGhlaWdodCA9IE1hdGgubWF4KGhlaWdodCwgY2hpbGQuaGVpZ2h0KVxuICAgIH0pXG4gICAgdGhpcy5jaGlsZHJlbldpZHRoID0gd2lkdGhcbiAgICB0aGlzLmNoaWxkcmVuSGVpZ2h0ID0gaGVpZ2h0XG4gICAgdGhpcy4kY2hpbGRyZW4uZm9yRWFjaChjaGlsZCA9PiB7XG4gICAgICBjaGlsZC54ID0gKHdpZHRoIC0gY2hpbGQud2lkdGgpIC8gMlxuICAgICAgY2hpbGQueSA9IChoZWlnaHQgLSBjaGlsZC5oZWlnaHQpIC8gMlxuICAgIH0pXG4gIH0sXG4gIHJlZ2lzdGVyIChkYXRhKSB7XG4gICAgZm9yIChsZXQgbmFtZSBpbiBkYXRhKSB7XG4gICAgICBsZXQgaWNvbiA9IGRhdGFbbmFtZV1cblxuICAgICAgaWYgKCFpY29uLnBhdGhzKSB7XG4gICAgICAgIGljb24ucGF0aHMgPSBbXVxuICAgICAgfVxuICAgICAgaWYgKGljb24uZCkge1xuICAgICAgICBpY29uLnBhdGhzLnB1c2goeyBkOiBpY29uLmQgfSlcbiAgICAgIH1cblxuICAgICAgaWYgKCFpY29uLnBvbHlnb25zKSB7XG4gICAgICAgIGljb24ucG9seWdvbnMgPSBbXVxuICAgICAgfVxuICAgICAgaWYgKGljb24ucG9pbnRzKSB7XG4gICAgICAgIGljb24ucG9seWdvbnMucHVzaCh7IHBvaW50czogaWNvbi5wb2ludHMgfSlcbiAgICAgIH1cblxuICAgICAgaWNvbnNbbmFtZV0gPSBpY29uXG4gICAgfVxuICB9LFxuICBpY29uc1xufVxuXG5sZXQgY3Vyc29yID0gMHhkNDkzN1xuZnVuY3Rpb24gZ2V0SWQgKCkge1xuICByZXR1cm4gYGZhLSR7KGN1cnNvcisrKS50b1N0cmluZygxNil9YFxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWU/MjFhMjY5ODIiLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPCEtLSBzaW5nbGUgLS0+XG4gICAgICAgIDx0cmFuc2l0aW9uIG5hbWU9XCJzbGlkZS1mYWRlXCIgdi1pZj1cInNlbGZfc2hvd1wiPlxuICAgICAgICAgICAgPGRpdiA6Y2xhc3M9XCJjbGFzc09iaihzZWxmX3R5cGUpXCIgY2xhc3M9XCJpdGVtXCI+XG5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZGVsZXRlXCIgQGNsaWNrPVwic2VsZl9zaG93ID0gZmFsc2VcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWFcIj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lZGlhLWxlZnRcIiB2LWlmPVwic2VsZl9pY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVwiaWNvbiBpcy1sYXJnZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj57eyBnZXRJY29uKHNlbGZfdHlwZSkgfX08L2k+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJtZWRpYS1jb250ZW50XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+e3sgc2VsZl90aXRsZSB9fTwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9oND5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVwic3VidGl0bGVcIj57eyBzZWxmX2JvZHkgfX08L3A+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgPC90cmFuc2l0aW9uPlxuXG4gICAgICAgIDwhLS0gZXZlbnRzIC0tPlxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cIiFzZWxmX3RpdGxlXCI+XG4gICAgICAgICAgICA8c3BhbiBpZD1cImNsb3NlX2FsbFwiIGNsYXNzPVwidGFnIGlzLWRhcmsgaXMtbWVkaXVtXCJcbiAgICAgICAgICAgICAgICB2LWlmPVwiY2hlY2tGb3JHcm91cCgpXCIgQGNsaWNrPVwiY2xvc2VBbGwoKVwiPlxuICAgICAgICAgICAgICAgIENsb3NlIEFsbFxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XCJkZWxldGVcIj48L2J1dHRvbj5cbiAgICAgICAgICAgIDwvc3Bhbj5cblxuICAgICAgICAgICAgPHRyYW5zaXRpb24tZ3JvdXAgbmFtZT1cInNsaWRlLWZhZGVcIiB0YWc9XCJ1bFwiPlxuICAgICAgICAgICAgICAgIDxsaSB2LWZvcj1cIihvbmUsaW5kZXgpIGluIG5vdGlmX2dyb3VwXCIgOmtleT1cImluZGV4XCJcbiAgICAgICAgICAgICAgICAgICAgY2xhc3M9XCJpdGVtXCIgOmNsYXNzPVwiY2xhc3NPYmoob25lLnR5cGUpXCJcbiAgICAgICAgICAgICAgICAgICAgdi1pZj1cIklzVmlzaWJsZShpbmRleClcIj5cblxuICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiZGVsZXRlXCIgQGNsaWNrPVwiY2xvc2VOb3RpZihpbmRleClcIj48L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lZGlhXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibWVkaWEtbGVmdFwiIHYtaWY9XCJvbmUuaWNvblwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XCJpY29uIGlzLWxhcmdlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVwibWF0ZXJpYWwtaWNvbnNcIj57eyBnZXRJY29uKG9uZS50eXBlKSB9fTwvaT5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2ZpZ3VyZT5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cIm1lZGlhLWNvbnRlbnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XCJ0aXRsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPnt7IG9uZS50aXRsZSB9fTwvc3Ryb25nPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XCJzdWJ0aXRsZVwiPnt7IG9uZS5ib2R5IH19PC9wPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuXG4gICAgICAgICAgICAgICAgPC9saT5cbiAgICAgICAgICAgIDwvdHJhbnNpdGlvbi1ncm91cD5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZT5cbiAgICAubm90aWYtY29udGFpbmVyIHtcbiAgICAgICAgcGFkZGluZzogMDtcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xuICAgICAgICB0b3A6IDRyZW07XG4gICAgICAgIHJpZ2h0OiAxcmVtO1xuICAgICAgICB6LWluZGV4OiAxMDAwMDtcbiAgICB9XG48L3N0eWxlPlxuXG48c3R5bGUgc2NvcGVkPlxuICAgIEBpbXBvcnQgdXJsKGh0dHBzOi8vZm9udHMuZ29vZ2xlYXBpcy5jb20vaWNvbj9mYW1pbHk9TWF0ZXJpYWwrSWNvbnMpO1xuXG4gICAgLyphbmltYXRpb24qL1xuICAgIC5zbGlkZS1mYWRlLWVudGVyLWFjdGl2ZSxcbiAgICAuc2xpZGUtZmFkZS1sZWF2ZS1hY3RpdmUge1xuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xuICAgIH1cbiAgICAuc2xpZGUtZmFkZS1lbnRlcixcbiAgICAuc2xpZGUtZmFkZS1sZWF2ZS10byB7XG4gICAgICAgIG9wYWNpdHk6IDA7XG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcbiAgICB9XG5cbiAgICAvKm5vdGlpZmNhdGlvbiBjYXJkKi9cbiAgICAuaXRlbSB7XG4gICAgICAgIHdpZHRoOiAzMzBweDtcbiAgICB9XG4gICAgLm1hdGVyaWFsLWljb25zIHtcbiAgICAgICAgZm9udC1zaXplOiAzcmVtO1xuICAgIH1cbiAgICAubWVkaWEtbGVmdCB7XG4gICAgICAgIGFsaWduLXNlbGY6IGNlbnRlcjtcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEuMjVyZW07XG4gICAgfVxuXG4gICAgLmhhcy1zaGFkb3cge1xuICAgICAgICBib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjEyKSwgMCAwIDZweCByZ2JhKDAsMCwwLDAuMDQpO1xuICAgIH1cbiAgICAubm90aWZpY2F0aW9uIHtcbiAgICAgICAgcGFkZGluZzogMS4yNXJlbTtcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcbiAgICB9XG5cbiAgICAubm90aWZpY2F0aW9uIC5kZWxldGUge1xuICAgICAgICByaWdodDogMC41cmVtO1xuICAgICAgICB0b3A6IDAuNXJlbTtcbiAgICB9XG5cbiAgICAjY2xvc2VfYWxsIHtcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg1NCwgNTQsIDU0LCAwLjkpO1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgICAgIHBvc2l0aW9uOiBmaXhlZDtcbiAgICAgICAgei1pbmRleDogMTtcbiAgICAgICAgdG9wOiAxcmVtO1xuICAgICAgICByaWdodDogMXJlbTtcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwdnc7XG4gICAgfVxuICAgICNjbG9zZV9hbGw6aG92ZXJ7XG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYig1NCwgNTQsIDU0KTtcbiAgICB9XG5cbiAgICAjY2xvc2VfYWxsIC5kZWxldGUge1xuICAgICAgICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAtMC4zNzVyZW07XG4gICAgfVxuPC9zdHlsZT5cblxuPHNjcmlwdD5cbmV4cG9ydCBkZWZhdWx0IHtcbiAgICBwcm9wczoge1xuICAgICAgICB0aXRsZTogJycsXG4gICAgICAgIGJvZHk6ICcnLFxuICAgICAgICBpY29uOiB7XG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IHtkZWZhdWx0OiAnaW5mbyd9LFxuICAgICAgICBkdXJhdGlvbjogbnVsbFxuICAgIH0sXG5cbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbm90aWZfZ3JvdXA6IFtdLFxuICAgICAgICAgICAgc2VsZl90aXRsZTogdGhpcy50aXRsZSxcbiAgICAgICAgICAgIHNlbGZfYm9keTogdGhpcy5ib2R5LFxuICAgICAgICAgICAgc2VsZl90eXBlOiB0aGlzLnR5cGUsXG4gICAgICAgICAgICBzZWxmX2ljb246IEJvb2xlYW4odGhpcy5pY29uKSxcbiAgICAgICAgICAgIHNlbGZfZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXG4gICAgICAgICAgICBzZWxmX3Nob3c6IGZhbHNlXG4gICAgICAgIH1cbiAgICB9LFxuXG4gICAgY3JlYXRlZCgpIHtcbiAgICAgICAgdGhpcy5jaGVja1Byb3AoKVxuXG4gICAgICAgIEV2ZW50SHViLmxpc3Rlbignc2hvd05vdGlmJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdERhdGEoZGF0YSlcbiAgICAgICAgfSlcbiAgICB9LFxuXG4gICAgbWV0aG9kczoge1xuICAgICAgICBjaGVja0Zvckdyb3VwKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZfZ3JvdXAubGVuZ3RoID4gMSAmJlxuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwLmZpbHRlcigoaXRlbSkgPT4gaXRlbS5zaG93ID09IHRydWUpLmxlbmd0aCA+IDFcbiAgICAgICAgfSxcbiAgICAgICAgY2xvc2VBbGwoKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwLm1hcCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGl0ZW0uc2hvdyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgaXRlbS5kdXJhdGlvbiA9IG51bGxcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGNoZWNrUHJvcCgpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnNlbGZfdGl0bGUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGZfc2hvdyA9IHRydWVcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZl9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZl9zaG93ID0gZmFsc2VcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnNlbGZfZHVyYXRpb24gKiAxMDAwKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjb2xsZWN0RGF0YShkYXRhKSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwLnB1c2goe1xuICAgICAgICAgICAgICAgIHRpdGxlOiBkYXRhLnRpdGxlLFxuICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEuYm9keSxcbiAgICAgICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXG4gICAgICAgICAgICAgICAgaWNvbjogZGF0YS5pY29uID09IG51bGwgPyB0cnVlIDogZmFsc2UsXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEuZHVyYXRpb24sXG4gICAgICAgICAgICAgICAgb25DbG9zZTogZGF0YS5vbkNsb3NlLFxuICAgICAgICAgICAgICAgIHNob3c6IHRydWVcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIElzVmlzaWJsZShpbmRleCkge1xuICAgICAgICAgICAgbGV0IGR1ciA9IHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLmR1cmF0aW9uXG5cbiAgICAgICAgICAgIGlmIChkdXIgIT0gdW5kZWZpbmVkIHx8IGR1ciAhPSBudWxsKSB7XG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VOb3RpZihpbmRleClcbiAgICAgICAgICAgICAgICB9LCBkdXIgKiAxMDAwKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5ub3RpZl9ncm91cFtpbmRleF0uc2hvd1xuICAgICAgICB9LFxuICAgICAgICBjbG9zZU5vdGlmKGluZGV4KSB7XG4gICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwW2luZGV4XS5zaG93ID0gZmFsc2VcblxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm5vdGlmX2dyb3VwW2luZGV4XS5vbkNsb3NlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5ub3RpZl9ncm91cFtpbmRleF0ub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLm9uQ2xvc2UoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBjbGFzc09iaih0eXBlKSB7XG4gICAgICAgICAgICByZXR1cm4gYG5vdGlmaWNhdGlvbiBoYXMtc2hhZG93IGlzLSR7dHlwZX1gXG4gICAgICAgIH0sXG4gICAgICAgIGdldEljb24odHlwZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgICAgICBjYXNlICdwcmltYXJ5JzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3RyYWNrX2NoYW5nZXMnXG4gICAgICAgICAgICBjYXNlICdzdWNjZXNzJzpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoZWNrX2NpcmNsZSdcbiAgICAgICAgICAgIGNhc2UgJ2luZm8nOlxuICAgICAgICAgICAgICAgIHJldHVybiAnbGl2ZV9oZWxwJ1xuICAgICAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICAgICAgcmV0dXJuICdwb3dlcl9zZXR0aW5nc19uZXcnXG4gICAgICAgICAgICBjYXNlICdkYW5nZXInOlxuICAgICAgICAgICAgICAgIHJldHVybiAnYWRkX2FsZXJ0J1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJ1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZT82OGQxYTVhYSIsIjxzY3JpcHQ+XG5pbXBvcnQgRm9ybXMgZnJvbSAnLi9mb3JtcydcbmltcG9ydCBEZWZhdWx0VGFiIGZyb20gJy4vLi4vVGFicy9kZWZhdWx0J1xuaW1wb3J0IFZlbmRvclRhYiBmcm9tICcuLy4uL1RhYnMvdmVuZG9yJ1xuXG5leHBvcnQgZGVmYXVsdCB7XG4gICAgY29tcG9uZW50czoge0RlZmF1bHRUYWIsIFZlbmRvclRhYn0sXG4gICAgbmFtZTogJ2xpbmdvJyxcbiAgICBtaXhpbnM6IFtGb3Jtc10sXG4gICAgcHJvcHM6IFtcbiAgICAgICAgJ3NjYW5Gb3JNaXNzaW5nUm91dGUnLFxuICAgICAgICAnYWRkTmV3TG9jYWxlUm91dGUnLFxuICAgICAgICAnYWRkTmV3RmlsZVJvdXRlJyxcbiAgICAgICAgJ2FkZE5ld1ZlbmRvclJvdXRlJyxcbiAgICAgICAgJ2ZpbGVzUm91dGUnLFxuICAgICAgICAnc2VsZWN0ZWRGaWxlRGF0YVJvdXRlJyxcbiAgICAgICAgJ2RlbGV0ZUZpbGVSb3V0ZScsXG4gICAgICAgICdkZWxldGVMb2NhbGVSb3V0ZScsXG4gICAgICAgICdzYXZlRmlsZVJvdXRlJyxcbiAgICAgICAgJ2xpbmdvVHJhbnMnXG4gICAgXSxcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgYWN0aXZlVGFiOiAnZGVmYXVsdC10YWInLFxuICAgICAgICAgICAgbmV3X2xvY2FsZTogbnVsbCxcbiAgICAgICAgICAgIG5ld19maWxlOiBudWxsLFxuICAgICAgICAgICAgbmV3X3ZlbmRvcjogbnVsbCxcbiAgICAgICAgICAgIGxvY2FsZXNMaXN0OiBbXSxcbiAgICAgICAgICAgIGZpbGVzTGlzdDogW10sXG4gICAgICAgICAgICBkaXJzTGlzdDogW10sXG4gICAgICAgICAgICBzZWxlY3RlZERpck5hbWU6ICcnLFxuICAgICAgICAgICAgc2VsZWN0ZWRGaWxlTmFtZTogJycsXG4gICAgICAgICAgICBzZWxlY3RlZEtleUZvcm1hdDogJycsXG4gICAgICAgICAgICBjb3B5S2V5Rm9ybWF0OiBbXG4gICAgICAgICAgICAgICAgJ3RyYW5zKFxcJ3ZhbHVlXFwnKScsXG4gICAgICAgICAgICAgICAgJ19fKFxcJ3ZhbHVlXFwnKScsXG4gICAgICAgICAgICAgICAgJ3shISB0cmFucyhcXCd2YWx1ZVxcJykgISF9JyxcbiAgICAgICAgICAgICAgICAneyEhIF9fKFxcJ3ZhbHVlXFwnKSAhIX0nLFxuICAgICAgICAgICAgICAgICd7eyB0cmFucyhcXCd2YWx1ZVxcJykgfX0nLFxuICAgICAgICAgICAgICAgICd7eyBfXyhcXCd2YWx1ZVxcJykgfX0nLFxuICAgICAgICAgICAgICAgICdAbGFuZyhcXCd2YWx1ZVxcJyknXG4gICAgICAgICAgICBdXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGxvY2FsZUV4aXN0KCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubG9jYWxlc0xpc3QgJiYgdGhpcy5sb2NhbGVzTGlzdC5pbmNsdWRlcyh0aGlzLm5ld19sb2NhbGUpIHx8IGZhbHNlXG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVFeGlzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmZpbGVzTGlzdCAmJiB0aGlzLmZpbGVzTGlzdC5pbmNsdWRlcyh0aGlzLm5ld19maWxlKSB8fCBmYWxzZVxuICAgICAgICB9LFxuICAgICAgICBkaXJFeGlzdCgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLmRpcnNMaXN0ICYmIHRoaXMuZGlyc0xpc3QuaW5jbHVkZXModGhpcy5uZXdfdmVuZG9yKSB8fCBmYWxzZVxuICAgICAgICB9XG4gICAgfSxcbiAgICBiZWZvcmVNb3VudCgpIHtcbiAgICAgICAgdGhpcy5wcmVWaXNpdGVkKClcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLy8gbG9jYWwtc3RvcmFnZVxuICAgICAgICBwcmVWaXNpdGVkKCkge1xuICAgICAgICAgICAgbGV0IGxzID0gdGhpcy4kbHMuZ2V0KCdsaW5nbycpXG5cbiAgICAgICAgICAgIGlmIChscykge1xuICAgICAgICAgICAgICAgIHRoaXMuYWN0aXZlVGFiID0gbHMudGFiXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEtleUZvcm1hdCA9IGxzLmZvcm1hdFxuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIEV2ZW50SHViLmZpcmUoJ2xzLWRpcicsIGxzLmRpcilcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRIdWIuZmlyZSgnbHMtZmlsZScsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYjogbHMudGFiLFxuICAgICAgICAgICAgICAgICAgICAgICAgdmFsOiBscy5maWxlXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgfSwgNTApXG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHRoaXMuJGxzLnNldChcbiAgICAgICAgICAgICAgICAgICAgJ2xpbmdvJyxcbiAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGFiOiB0aGlzLmFjdGl2ZVRhYixcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogdGhpcy5zZWxlY3RlZERpck5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWxlOiB0aGlzLnNlbGVjdGVkRmlsZU5hbWUsXG4gICAgICAgICAgICAgICAgICAgICAgICBmb3JtYXQ6IHRoaXMuc2VsZWN0ZWRLZXlGb3JtYXRcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0YWJzXG4gICAgICAgIGFjdGl2ZVRhYklzKHRhYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGFiID09IHRhYlxuICAgICAgICB9LFxuICAgICAgICB0b2dnbGVUYWIodGFiKSB7XG4gICAgICAgICAgICB0aGlzLmFjdGl2ZVRhYiA9IHRhYlxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHBoXG4gICAgICAgIHBsYWNlSG9sZGVyKHZhbCwgYWxsID0gJycpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnZlbmRvckNoZWNrKClcbiAgICAgICAgICAgICAgICA/IGBsYW5nL3ZlbmRvci8ke3RoaXMuc2VsZWN0ZWREaXJOYW1lfS8ke2FsbH0ke3ZhbH1gXG4gICAgICAgICAgICAgICAgOiBgbGFuZy8ke2FsbH0ke3ZhbH1gXG4gICAgICAgIH0sXG4gICAgICAgIHZlbmRvclBIKHZhbCkge1xuICAgICAgICAgICAgcmV0dXJuIGBsYW5nL3ZlbmRvci8ke3ZhbH1gXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gdmVuZG9yXG4gICAgICAgIHZlbmRvckNoZWNrKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWN0aXZlVGFiSXMoJ3ZlbmRvci10YWInKSAmJiB0aGlzLnNlbGVjdGVkRGlyTmFtZVxuICAgICAgICB9LFxuICAgICAgICBuZXdWZW5kb3IoKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy52ZW5kb3JDaGVjaygpICYmIHRoaXMuZmlsZXNMaXN0Lmxlbmd0aCA9PSAwXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gdXRpbHNcbiAgICAgICAgdXBkYXRlTHMob2JqKSB7XG4gICAgICAgICAgICBsZXQgb2xkTHMgPSB0aGlzLiRscy5nZXQoJ2xpbmdvJywge30pXG5cbiAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob2xkTHMsIG9iailcbiAgICAgICAgICAgIHRoaXMuJGxzLnNldCgnbGluZ28nLCBvbGRMcylcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRBbGwoaXRlbXMpIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzW2VdID0gJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHRyYW5zKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMubGluZ29UcmFuc1trZXldXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gbm90aWZzXG4gICAgICAgIHNob3dOb3RpZihtc2csIHMgPSAnc3VjY2VzcycpIHtcblxuICAgICAgICAgICAgbGV0IHRpdGxlXG4gICAgICAgICAgICBsZXQgZHVyYXRpb24gPSBudWxsXG5cbiAgICAgICAgICAgIHN3aXRjaCAocykge1xuICAgICAgICAgICAgY2FzZSAnYmxhY2snOlxuICAgICAgICAgICAgY2FzZSAnZGFuZ2VyJzpcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICdFcnJvcidcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgY2FzZSAnd2FybmluZyc6XG4gICAgICAgICAgICAgICAgdGl0bGUgPSAnV2FybmluZydcbiAgICAgICAgICAgICAgICBkdXJhdGlvbiA9IDJcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICB0aXRsZSA9ICdTdWNjZXNzJ1xuICAgICAgICAgICAgICAgIGR1cmF0aW9uID0gM1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBFdmVudEh1Yi5maXJlKCdzaG93Tm90aWYnLCB7XG4gICAgICAgICAgICAgICAgdGl0bGU6IHRpdGxlLFxuICAgICAgICAgICAgICAgIGJvZHk6IG1zZyxcbiAgICAgICAgICAgICAgICB0eXBlOiBzLFxuICAgICAgICAgICAgICAgIGR1cmF0aW9uOiBkdXJhdGlvblxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFpbGVkQWpheCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmKHRoaXMudHJhbnMoJ2FqYXhfZXJyb3InKSwgJ2JsYWNrJylcbiAgICAgICAgfSxcbiAgICAgICAgbWlzc2luZ1ZhbChtc2cgPSBudWxsKSB7XG4gICAgICAgICAgICB0aGlzLnNob3dOb3RpZihtc2cgfHwgdGhpcy50cmFucygnbm9fdmFsJyksICd3YXJuaW5nJylcbiAgICAgICAgfVxuICAgIH0sXG4gICAgd2F0Y2g6IHtcbiAgICAgICAgYWN0aXZlVGFiKHZhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMcyh7dGFiIDogdmFsfSlcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWREaXJOYW1lKHZhbCkge1xuICAgICAgICAgICAgdGhpcy51cGRhdGVMcyh7ZGlyIDogdmFsfSlcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWRGaWxlTmFtZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMudXBkYXRlTHMoe2ZpbGUgOiB2YWx9KVxuICAgICAgICB9LFxuICAgICAgICBzZWxlY3RlZEtleUZvcm1hdCh2YWwpIHtcbiAgICAgICAgICAgIGlmICh2YWwgPT0gJ2NsZWFyJykge1xuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRLZXlGb3JtYXQgPSAnJ1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnVwZGF0ZUxzKHtmb3JtYXQgOiB2YWx9KVxuICAgICAgICB9XG4gICAgfSxcbiAgICByZW5kZXIoKSB7fVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9NYWluL2NvbnRhaW5lci52dWU/ZDE2ZjJlNzYiLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPCEtLSBzZWxlY3QgZmlsZSAtLT5cbiAgICAgICAgPHNoYXJlZC1jb250ZW50Lz5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgT3BzIGZyb20gJy4vb3BzJ1xuaW1wb3J0IFNoYXJlZENvbnRlbnQgZnJvbSAnLi9zaGFyZWQvY29udGVudCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBvbmVudHM6IHtTaGFyZWRDb250ZW50fSxcbiAgICBuYW1lOiAnZGVmYXVsdC10YWInLFxuICAgIG1peGluczogW09wc10sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgdGhpcy5nZXRGaWxlcygpXG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIGdldEZpbGVzKCkge1xuICAgICAgICAgICAgYXhpb3MucG9zdCh0aGlzLnJvdXRlcy5maWxlc1JvdXRlLCB7fSlcbiAgICAgICAgICAgICAgICAudGhlbigoe2RhdGF9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZmlsZXMgPSBkYXRhLm1lc3NhZ2VcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZXRob2QoJ2ZhaWxlZEFqYXgnKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH1cbiAgICB9XG59XG48L3NjcmlwdD5cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyByZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvZGVmYXVsdC52dWU/ZTkxNDMxMDQiLCI8dGVtcGxhdGU+XG4gICAgPGRpdj5cbiAgICAgICAgPGRpdiBjbGFzcz1cImxldmVsIGlzLW1vYmlsZSBpcy1tYXJnaW5sZXNzXCI+XG4gICAgICAgICAgICA8IS0tIGl0ZW1zIGNvdW50IC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxldmVsLWxlZnRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLWxlZnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJjb250cm9sXCIgdi1pZj1cInNlbGVjdGVkRmlsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cInRpdGxlIGlzLTRcIj5cInt7IGl0ZW1zQ291bnQgfX1cIiBJdGVtL3M8L2g0PlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gc2VsZWN0IGZpbGUgLS0+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtcmlnaHRcIj5cbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwibGV2ZWwtaXRlbVwiPlxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLXJpZ2h0XCIgdi1pZj1cImZpbGVzLmxlbmd0aFwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2wgaGFzLWljb25zLWxlZnRcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVwic2VsZWN0XCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzZWxlY3Qgdi1tb2RlbD1cInNlbGVjdGVkRmlsZVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiIGRpc2FibGVkPnt7IHRyYW5zKCdzZWxlY3RfZmlsZScpIH19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHYtZm9yPVwiKGYsIGkpIGluIGZpbGVzXCIgOmtleT1cImlcIj57eyBmIH19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvc2VsZWN0PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIj48aWNvbiBuYW1lPVwiZmlsZVwiLz48L2Rpdj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIiB2LWlmPVwic2VsZWN0ZWRGaWxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1kYW5nZXJcIiBAY2xpY2s9XCJyZW1vdmVTZWxlY3RlZEZpbGUoKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpY29uIG5hbWU9XCJ0cmFzaFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvZGl2PlxuXG4gICAgICAgIDwhLS0gZGF0YSAtLT5cbiAgICAgICAgPHNlY3Rpb24gdi1pZj1cInNlbGVjdGVkRmlsZVwiIGNsYXNzPVwibS10LTUwXCI+XG4gICAgICAgICAgICA8IS0tIHRhYmxlIC0tPlxuICAgICAgICAgICAgPHRhYmxlIGNsYXNzPVwidGFibGUgaXMtZnVsbHdpZHRoIGlzLWhvdmVyYWJsZSBpcy1ib3JkZXJlZFwiPlxuICAgICAgICAgICAgICAgIDx0aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgPHRyIGNsYXNzPVwiaXMtdW5zZWxlY3RhYmxlXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJpcy1saW5rXCIgd2lkdGg9XCIxJVwiPnt7IHRyYW5zKCdrZXknKSB9fTwvdGg+XG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XCJpcy1saW5rXCIgdi1mb3I9XCIobCwgaSkgaW4gbG9jYWxlc1wiIDprZXk9XCJpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cInRhZ3MgaGFzLWFkZG9uc1wiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZyBpcy1saWdodCBpcy1tZWRpdW1cIj57eyBsIH19PC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cInRhZyBpcy13YXJuaW5nIGlzLW1lZGl1bVwiIEBjbGljaz1cInJlbW92ZUxvY2FsZShsKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGljb24gbmFtZT1cInRyYXNoXCIvPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L3NwYW4+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxuICAgICAgICAgICAgICAgICAgICAgICAgPHRoIGNsYXNzPVwiaXMtbGlua1wiPnt7IHRyYW5zKCdvcHMnKSB9fTwvdGg+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90aGVhZD5cbiAgICAgICAgICAgICAgICA8dGJvZHk+XG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cIihtYWluViwgbWFpbkssIG1haW5JKSBpbiBzZWxlY3RlZEZpbGVEYXRhQ2xvbmVcIiA6a2V5PVwibWFpbklcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBub3dyYXAgY29udGVudGVkaXRhYmxlIGRpcj1cImF1dG9cIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDp0aXRsZT1cImdldEtleShtYWluSylcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHYtdGlwcHk9XCJ7IHBvc2l0aW9uIDogJ3JpZ2h0JywgYXJyb3c6IHRydWUsIGludGVyYWN0aXZlOiB0cnVlLCB0cmlnZ2VyOiAnbW91c2VlbnRlcid9XCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWh0bWw9XCIjdGlwcHlUZW1wbGF0ZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQG1vdXNlZW50ZXI9XCJrZXlUb0NvcHkgPSBnZXRLZXkobWFpbkspXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAc2hvd249XCJyZWZvY3VzKClcIlxuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmNsYXNzPVwibmVzdENoZWNrKG1haW5LKVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmRhdGEtbWFpbi1rZXk9XCJtYWluS1wiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGtleWRvd24uZW50ZXIucHJldmVudFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIm5ld0VudHJ5KClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBmb2N1cz1cImdldFBvcygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYmx1cj1cInNhdmVOZXdLZXkoJGV2ZW50KVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IG1haW5LIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxuXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgdi1mb3I9XCIobmVzdFYsIG5lc3RLLCBuZXN0SSkgaW4gbWFpblZcIiA6a2V5PVwibmVzdElcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZSBkaXI9XCJhdXRvXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZGF0YS1tYWluLWtleT1cIm1haW5LXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ZGF0YS1jb2RlPVwibmVzdEtcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cIm5ld0VudHJ5KClcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBmb2N1cz1cImdldFBvcygkZXZlbnQpXCJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAYmx1cj1cInNhdmVOZXdWYWx1ZSgkZXZlbnQpXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgbmVzdFYgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB3aWR0aD1cIjElXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cImJ1dHRvbiBpcy1kYW5nZXJcIiBAY2xpY2s9XCJyZW1vdmVJdGVtKG1haW5LKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cImljb25cIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpY29uIG5hbWU9XCJ0cmFzaFwiLz5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cbiAgICAgICAgICAgICAgICAgICAgPC90cj5cblxuICAgICAgICAgICAgICAgICAgICA8IS0tIG5vdGhpbmcgZm91bmQgLS0+XG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWlmPVwiZG9udEhhdmVEYXRhKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCA6Y29sc3Bhbj1cImxvY2FsZXMubGVuZ3RoICsgMlwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHRyYW5zKCdub19kYXRhJykgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvdGQ+XG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XG4gICAgICAgICAgICAgICAgPC90Ym9keT5cbiAgICAgICAgICAgIDwvdGFibGU+XG5cbiAgICAgICAgICAgIDwhLS0gb3BzIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxldmVsXCI+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImxldmVsLXJpZ2h0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLWxpbmtcIiBAY2xpY2sucHJldmVudD1cImFkZE5ld0l0ZW0oKVwiPlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IHRyYW5zKCdhZGRfbmV3JykgfX1cbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgICAgICA8L2Rpdj5cblxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1sZWZ0XCI+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLXN1Y2Nlc3NcIiA6ZGlzYWJsZWQ9XCIhZGF0YUNoYW5nZWRcIiBAY2xpY2s9XCJzdWJtaXROZXdEYXRhKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFucygnc2F2ZScpIH19XG4gICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJsZXZlbC1pdGVtXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uXCIgOmRpc2FibGVkPVwiIWRhdGFDaGFuZ2VkXCIgQGNsaWNrPVwicmVzZXREYXRhKClcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFucygncmVzZXQnKSB9fVxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgICAgIDwhLS0gdGlwcHkgdGVtcGxhdGUgLS0+XG4gICAgICAgICAgICA8ZGl2IGlkPVwidGlwcHlUZW1wbGF0ZVwiPlxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVwiYzJjXCI+e3sga2V5VG9Db3B5IH19PC9zcGFuPlxuICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgIDwvc2VjdGlvbj5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzdHlsZSBzY29wZWQ+XG4gICAgI3RpcHB5VGVtcGxhdGUge1xuICAgICAgICBkaXNwbGF5OiBub25lO1xuICAgIH1cblxuICAgIC5jMmMge1xuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XG4gICAgfVxuPC9zdHlsZT5cblxuPHNjcmlwdD5cbmltcG9ydCBGb3JtcyBmcm9tICcuL2Zvcm1zJ1xuXG5leHBvcnQgZGVmYXVsdHtcbiAgICBuYW1lOiAnY29udGVudCcsXG4gICAgbWl4aW5zOiBbRm9ybXNdLFxuICAgIGRhdGEoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQuJGRhdGFcbiAgICB9LFxuICAgIGNvbXB1dGVkOiB7XG4gICAgICAgIGl0ZW1zQ291bnQoKSB7XG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmUpLmxlbmd0aFxuICAgICAgICB9XG4gICAgfSxcbiAgICB1cGRhdGVkKCkge1xuICAgICAgICB0aGlzLnRhYmxlQ29sdW1uUmVzaXplKClcbiAgICB9LFxuICAgIG1ldGhvZHM6IHtcbiAgICAgICAgLy8gdGFibGUgb3BzXG4gICAgICAgIHRhYmxlQ29sdW1uUmVzaXplKCkge1xuICAgICAgICAgICAgbGV0IGVsXG4gICAgICAgICAgICBsZXQgc3RhcnRPZmZzZXRcblxuICAgICAgICAgICAgZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbCgndGFibGUgdGgnKS5mb3JFYWNoKCh0aCkgPT4ge1xuICAgICAgICAgICAgICAgIHRoLnN0eWxlLnBvc2l0aW9uID0gJ3N0aWNreSdcblxuICAgICAgICAgICAgICAgIGxldCBncmlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2JylcbiAgICAgICAgICAgICAgICBncmlwLmlubmVySFRNTCA9ICcmbmJzcDsnXG4gICAgICAgICAgICAgICAgZ3JpcC5zdHlsZS50b3AgPSAwXG4gICAgICAgICAgICAgICAgZ3JpcC5zdHlsZS5yaWdodCA9IDBcbiAgICAgICAgICAgICAgICBncmlwLnN0eWxlLmJvdHRvbSA9IDBcbiAgICAgICAgICAgICAgICBncmlwLnN0eWxlLndpZHRoID0gJzEwcHgnXG4gICAgICAgICAgICAgICAgZ3JpcC5zdHlsZS5wb3NpdGlvbiA9ICdhYnNvbHV0ZSdcbiAgICAgICAgICAgICAgICBncmlwLnN0eWxlLmN1cnNvciA9ICdjb2wtcmVzaXplJ1xuICAgICAgICAgICAgICAgIGdyaXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgZWwgPSB0aFxuICAgICAgICAgICAgICAgICAgICBzdGFydE9mZnNldCA9IHRoLm9mZnNldFdpZHRoIC0gZS5wYWdlWFxuICAgICAgICAgICAgICAgIH0pXG5cbiAgICAgICAgICAgICAgICB0aC5hcHBlbmRDaGlsZChncmlwKVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgKGUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcbiAgICAgICAgICAgICAgICAgICAgZWwuc3R5bGUud2lkdGggPSBzdGFydE9mZnNldCArIGUucGFnZVggKyAncHgnXG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSlcblxuICAgICAgICAgICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcignbW91c2V1cCcsICgpID0+IHtcbiAgICAgICAgICAgICAgICBlbCA9IHVuZGVmaW5lZFxuICAgICAgICAgICAgfSlcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBvcHNcbiAgICAgICAgYWRkTmV3SXRlbSgpIHtcbiAgICAgICAgICAgIGxldCBuYW1lID0gJ25ld0l0ZW0nICsgdGhpcy5uZXdJdGVtQ291bnRlclxuICAgICAgICAgICAgbGV0IGZpbGVEYXRhID0gdGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmVcblxuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWVcblxuICAgICAgICAgICAgLy8gaW5jYXNlIHdlIGFscmVhZHkgaGF2ZSBrZXlzID09IG5hbWVcbiAgICAgICAgICAgIGlmIChmaWxlRGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xuICAgICAgICAgICAgICAgIHRoaXMubmV3SXRlbUNvdW50ZXIrK1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLmFkZE5ld0l0ZW0oKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLmxvY2FsZXMuZm9yRWFjaCgoaXRlbSkgPT4ge1xuICAgICAgICAgICAgICAgIGlmICghZmlsZURhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpbGVEYXRhLCBuYW1lLCB7W2l0ZW1dOiAnJ30pXG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpbGVEYXRhW25hbWVdLCBpdGVtLCAnJylcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICB0aGlzLm5ld0l0ZW1Db3VudGVyKytcbiAgICAgICAgfSxcbiAgICAgICAgcmVtb3ZlSXRlbShpdGVtKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgdGhpcy4kZGVsZXRlKHRoaXMuc2VsZWN0ZWRGaWxlRGF0YUNsb25lLCBpdGVtKVxuICAgICAgICB9LFxuICAgICAgICByZXNldERhdGEoKSB7XG4gICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gZmFsc2VcbiAgICAgICAgICAgIHRoaXMubmV3SXRlbUNvdW50ZXIgPSAwXG4gICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZURhdGFDbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkodGhpcy5zZWxlY3RlZEZpbGVEYXRhKSlcblxuICAgICAgICAgICAgLy8gaGFja3kgZml4IGFzIG5ld2tleXMgZG9udCByZXNldFxuICAgICAgICAgICAgaWYgKHRoaXMubmV3S2V5cykge1xuICAgICAgICAgICAgICAgIGxldCBvbGQgPSB0aGlzLnNlbGVjdGVkRmlsZVxuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gb2xkXG4gICAgICAgICAgICAgICAgfSwgMTApXG5cbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgncmVzZXRBbGwnLCBbJ3NlbGVjdGVkRmlsZSddKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgncmVzZXRBbGwnLCBbJ2tleVRvQ29weScsICdjdXJyZW50SW5wdXRSZWYnXSlcbiAgICAgICAgfSxcblxuICAgICAgICAvLyB1dGlsXG4gICAgICAgIG5ld0VudHJ5KCkge1xuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWVcbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZU5ld0tleShlKSB7XG4gICAgICAgICAgICBsZXQgb2xkX2tleSA9IGUudGFyZ2V0LmRhdGFzZXQubWFpbktleVxuICAgICAgICAgICAgbGV0IHRleHQgPSBlLnRhcmdldC5pbm5lclRleHQgPSBlLnRhcmdldC5pbm5lclRleHQudG9Mb3dlckNhc2UoKS5yZXBsYWNlKC9cXHMvZywgJ18nKVxuICAgICAgICAgICAgbGV0IG5ld19rZXkgPSB0ZXh0XG5cbiAgICAgICAgICAgIGlmIChvbGRfa2V5ICE9PSBuZXdfa2V5KSB7XG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWVcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLm5ld0tleXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubmV3S2V5c1tvbGRfa2V5XSA9IG5ld19rZXlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB0aGlzLm5ld0tleXMgPSB7W29sZF9rZXldIDogbmV3X2tleX1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgc2F2ZU5ld1ZhbHVlKGUpIHtcbiAgICAgICAgICAgIGxldCBjb2RlID0gZS50YXJnZXQuZGF0YXNldC5jb2RlXG4gICAgICAgICAgICBsZXQga2V5ID0gZS50YXJnZXQuZGF0YXNldC5tYWluS2V5XG4gICAgICAgICAgICBsZXQgdGV4dCA9IGUudGFyZ2V0LmlubmVyVGV4dCA9IGUudGFyZ2V0LmlubmVyVGV4dC5yZXBsYWNlKC9cXG4vZywgJzxicj4nKVxuICAgICAgICAgICAgbGV0IHZhbHVlID0gdGV4dFxuXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmVba2V5XVtjb2RlXSAhPT0gdmFsdWUpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZVxuICAgICAgICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnNlbGVjdGVkRmlsZURhdGFDbG9uZVtrZXldLCBjb2RlLCB2YWx1ZSlcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICAgICAgZm9ybWF0RGF0YSgpIHtcbiAgICAgICAgICAgIGxldCBtYWluID0gdGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmVcbiAgICAgICAgICAgIGxldCBuZXdEYXRhID0gdGhpcy5uZXdLZXlzXG5cbiAgICAgICAgICAgIGxldCBtYWluX2tleXMgPSBPYmplY3Qua2V5cyhtYWluKVxuICAgICAgICAgICAgbGV0IG5ld0RhdGFfa2V5cyA9IE9iamVjdC5rZXlzKG5ld0RhdGEpXG5cbiAgICAgICAgICAgIC8vIHJlcGxhY2UgY2hhbmdlZCBrZXlzXG4gICAgICAgICAgICBpZiAobmV3RGF0YV9rZXlzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIG1haW5fa2V5cy5tYXAoKG9sZF9rZXkpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKG5ld0RhdGFfa2V5cy5pbmNsdWRlcyhvbGRfa2V5KSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbGV0IG5ld19rZXkgPSBuZXdEYXRhW29sZF9rZXldXG5cbiAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYWluLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19rZXksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihtYWluLCBvbGRfa2V5KVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWxldGUgbWFpbltvbGRfa2V5XVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgcmV0dXJuIG1haW5cbiAgICAgICAgfSxcblxuICAgICAgICAvLyB0aXBweSAmIGN0Y3BcbiAgICAgICAgZ2V0UG9zKGUpIHtcbiAgICAgICAgICAgIHRoaXMuY3VycmVudElucHV0UmVmID0gZVxuICAgICAgICB9LFxuICAgICAgICByZWZvY3VzKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWV0aG9kKCdyZWZvY3VzJylcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0S2V5KGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWV0aG9kKCdnZXRLZXknLCBrZXkpXG4gICAgICAgIH0sXG5cbiAgICAgICAgLy8gb3RoZXJcbiAgICAgICAgbmVzdENoZWNrKGl0ZW0pIHtcbiAgICAgICAgICAgIHJldHVybiBpdGVtLmluY2x1ZGVzKCcuJykgPyAnbmVzdGVkS2V5JyA6ICcnXG4gICAgICAgIH0sXG4gICAgICAgIGRvbnRIYXZlRGF0YSgpIHtcbiAgICAgICAgICAgIHJldHVybiBPYmplY3Qua2V5cyh0aGlzLnNlbGVjdGVkRmlsZURhdGFDbG9uZSkubGVuZ3RoID09IDBcbiAgICAgICAgfSxcbiAgICAgICAgdHJhbnMoa2V5KSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNZXRob2QoJ3RyYW5zJywga2V5KVxuICAgICAgICB9LFxuICAgICAgICBwYXJlbnRNZXRob2QobWV0aG9kX25hbWUsIGFyZ3MgPSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gdGhpcy4kcGFyZW50W21ldGhvZF9uYW1lXShhcmdzKVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZT83ZGYwMTViZSIsIjx0ZW1wbGF0ZT5cbiAgICA8ZGl2PlxuICAgICAgICA8IS0tIHNlbGVjdCBwYWNrYWdlIC0tPlxuICAgICAgICA8ZGl2IGNsYXNzPVwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLXJpZ2h0XCIgdi1pZj1cImRpcnMubGVuZ3RoXCI+XG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiPlxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XCJzZWxlY3RcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNlbGVjdCB2LW1vZGVsPVwic2VsZWN0ZWREaXJcIj5cbiAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdmFsdWU9XCJcIiBkaXNhYmxlZD57eyB0cmFucygnc2VsZWN0X2RpcicpIH19PC9vcHRpb24+XG4gICAgICAgICAgICAgICAgICAgICAgICA8b3B0aW9uIHYtZm9yPVwiKGQsIGkpIGluIGRpcnNcIiA6a2V5PVwiaVwiPnt7IGQgfX08L29wdGlvbj5cbiAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XG4gICAgICAgICAgICAgICAgPC9kaXY+XG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cImljb24gaXMtc21hbGwgaXMtbGVmdFwiPjxpY29uIG5hbWU9XCJmb2xkZXJcIi8+PC9kaXY+XG4gICAgICAgICAgICA8L2Rpdj5cbiAgICAgICAgICAgIDwhLS0gcmVtb3ZlIC0tPlxuICAgICAgICAgICAgPGRpdiBjbGFzcz1cImNvbnRyb2xcIiB2LWlmPVwic2VsZWN0ZWREaXJcIj5cbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVwiYnV0dG9uIGlzLWRhbmdlclwiIEBjbGljaz1cInJlbW92ZVNlbGVjdGVkRGlyKClcIj5cbiAgICAgICAgICAgICAgICAgICAgPHNwYW4gY2xhc3M9XCJpY29uXCI+XG4gICAgICAgICAgICAgICAgICAgICAgICA8aWNvbiBuYW1lPVwidHJhc2hcIi8+XG4gICAgICAgICAgICAgICAgICAgIDwvc3Bhbj5cbiAgICAgICAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgICAgIDwvZGl2PlxuICAgICAgICA8L2Rpdj5cblxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cInNlbGVjdGVkRGlyXCI+XG4gICAgICAgICAgICA8IS0tIHNlbGVjdCBmaWxlIC0tPlxuICAgICAgICAgICAgPHNoYXJlZC1jb250ZW50Lz5cbiAgICAgICAgPC90ZW1wbGF0ZT5cbiAgICA8L2Rpdj5cbjwvdGVtcGxhdGU+XG5cbjxzY3JpcHQ+XG5pbXBvcnQgT3BzIGZyb20gJy4vb3BzJ1xuaW1wb3J0IFNoYXJlZENvbnRlbnQgZnJvbSAnLi9zaGFyZWQvY29udGVudCdcblxuZXhwb3J0IGRlZmF1bHQge1xuICAgIGNvbXBvbmVudHM6IHtTaGFyZWRDb250ZW50fSxcbiAgICBuYW1lOiAndmVuZG9yLXRhYicsXG4gICAgbWl4aW5zOiBbT3BzXSxcbiAgICBwcm9wczogW1xuICAgICAgICAnZGlyc1JvdXRlJyxcbiAgICAgICAgJ2RlbGV0ZVZlbmRvclJvdXRlJ1xuICAgIF0sXG4gICAgZGF0YSgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGRpcnM6IFtdLFxuICAgICAgICAgICAgc2VsZWN0ZWREaXI6ICcnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIGJlZm9yZU1vdW50KCkge1xuICAgICAgICB0aGlzLmdldERpcnMoKVxuICAgIH0sXG4gICAgbW91bnRlZCgpIHtcbiAgICAgICAgRXZlbnRIdWIubGlzdGVuKCdscy1kaXInLCAodmFsKSA9PiB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5kaXJzLmxlbmd0aCAmJiB0aGlzLmRpcnMuaW5jbHVkZXModmFsKSkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zZWxlY3RlZERpciA9IHZhbFxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sIDEwMClcbiAgICAgICAgfSlcblxuICAgICAgICBFdmVudEh1Yi5saXN0ZW4oJ25ld192ZW5kb3JfYWRkZWQnLCAodmFsKSA9PiB7XG4gICAgICAgICAgICB0aGlzLmdldERpcnMoKVxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERpciA9IHZhbFxuICAgICAgICB9KVxuICAgIH0sXG4gICAgbWV0aG9kczoge1xuICAgICAgICBnZXREaXJzKCkge1xuICAgICAgICAgICAgYXhpb3MuZ2V0KHRoaXMuZGlyc1JvdXRlKS50aGVuKCh7ZGF0YX0pID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLmRpcnMgPSBkYXRhXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRBamF4KClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGdldEZpbGVzKCkge1xuICAgICAgICAgICAgYXhpb3MucG9zdCh0aGlzLnJvdXRlcy5maWxlc1JvdXRlLCB7XG4gICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJyA6IHRoaXMuc2VsZWN0ZWREaXJcbiAgICAgICAgICAgIH0pLnRoZW4oKHtkYXRhfSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgaWYgKGRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmZpbGVzID0gZGF0YS5tZXNzYWdlXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuZmlsZXMubGVuZ3RoID09IDEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gdGhpcy5maWxlc1swXVxuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLy8gd2hlbiBjaGFuZ2luZyBkaXJzIHdpdGggZmlsZXNcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGwoWydzZWxlY3RlZEZpbGUnLCAnbG9jYWxlcyddKVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gbmV3IHZlbmRvciAvIG5vIGZpbGVzXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGwoWydzZWxlY3RlZEZpbGUnLCAnbG9jYWxlcyddKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIC8vIGdldCBmaWxlIGRhdGEgb3IgYXZhaWwgbG9jYWxlc1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RmlsZUNvbnRlbnQoKVxuXG4gICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRBamF4KClcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZVNlbGVjdGVkRGlyKCkge1xuICAgICAgICAgICAgaWYgKGNvbmZpcm0odGhpcy50cmFucygneW91X3N1cmVfcGFja2FnZScpKSkge1xuICAgICAgICAgICAgICAgIGF4aW9zLnBvc3QodGhpcy5kZWxldGVWZW5kb3JSb3V0ZSwge1xuICAgICAgICAgICAgICAgICAgICAnZGlyX25hbWUnIDogdGhpcy5zZWxlY3RlZERpclxuICAgICAgICAgICAgICAgIH0pLnRoZW4oKHtkYXRhfSkgPT4ge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5zaG93Tm90aWYoZGF0YS5tZXNzYWdlLCAnZGFuZ2VyJylcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmKGRhdGEubWVzc2FnZSlcblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWxsKFtcbiAgICAgICAgICAgICAgICAgICAgICAgICdzZWxlY3RlZERpcicsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWRGaWxlJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdsb2NhbGVzJyxcbiAgICAgICAgICAgICAgICAgICAgICAgICdmaWxlcycsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWRGaWxlRGF0YScsXG4gICAgICAgICAgICAgICAgICAgICAgICAnc2VsZWN0ZWRGaWxlRGF0YUNsb25lJ1xuICAgICAgICAgICAgICAgICAgICBdKVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZ2V0RGlycygpXG5cbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZEFqYXgoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIGRpcnModmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuZGlyc0xpc3QgPSB2YWxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWREaXIodmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuc2VsZWN0ZWREaXJOYW1lID0gdmFsXG4gICAgICAgICAgICB0aGlzLnJlc2V0QWxsKFsnbmV3S2V5cycsICdjdXJyZW50SW5wdXRSZWYnLCAna2V5VG9Db3B5J10pXG5cbiAgICAgICAgICAgIGlmICh2YWwpIHtcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0l0ZW1Db3VudGVyID0gMFxuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RmlsZXMoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxuPC9zY3JpcHQ+XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3ZlbmRvci52dWU/NDcxMDJmODgiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydtb2R1bGUnLCAnc2VsZWN0J10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJ3NlbGVjdCcpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kID0ge1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgfTtcbiAgICAgICAgZmFjdG9yeShtb2QsIGdsb2JhbC5zZWxlY3QpO1xuICAgICAgICBnbG9iYWwuY2xpcGJvYXJkQWN0aW9uID0gbW9kLmV4cG9ydHM7XG4gICAgfVxufSkodGhpcywgZnVuY3Rpb24gKG1vZHVsZSwgX3NlbGVjdCkge1xuICAgICd1c2Ugc3RyaWN0JztcblxuICAgIHZhciBfc2VsZWN0MiA9IF9pbnRlcm9wUmVxdWlyZURlZmF1bHQoX3NlbGVjdCk7XG5cbiAgICBmdW5jdGlvbiBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KG9iaikge1xuICAgICAgICByZXR1cm4gb2JqICYmIG9iai5fX2VzTW9kdWxlID8gb2JqIDoge1xuICAgICAgICAgICAgZGVmYXVsdDogb2JqXG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgdmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gXCJzeW1ib2xcIiA/IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiBvYmo7XG4gICAgfSA6IGZ1bmN0aW9uIChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgb2JqLmNvbnN0cnVjdG9yID09PSBTeW1ib2wgJiYgb2JqICE9PSBTeW1ib2wucHJvdG90eXBlID8gXCJzeW1ib2xcIiA6IHR5cGVvZiBvYmo7XG4gICAgfTtcblxuICAgIGZ1bmN0aW9uIF9jbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3QgY2FsbCBhIGNsYXNzIGFzIGEgZnVuY3Rpb25cIik7XG4gICAgICAgIH1cbiAgICB9XG5cbiAgICB2YXIgX2NyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgICAgICAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgICAgICAgICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICAgICAgICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgICAgICAgICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICAgICAgICB9O1xuICAgIH0oKTtcblxuICAgIHZhciBDbGlwYm9hcmRBY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qKlxuICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgICAgICAgKi9cbiAgICAgICAgZnVuY3Rpb24gQ2xpcGJvYXJkQWN0aW9uKG9wdGlvbnMpIHtcbiAgICAgICAgICAgIF9jbGFzc0NhbGxDaGVjayh0aGlzLCBDbGlwYm9hcmRBY3Rpb24pO1xuXG4gICAgICAgICAgICB0aGlzLnJlc29sdmVPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICAgICAgdGhpcy5pbml0U2VsZWN0aW9uKCk7XG4gICAgICAgIH1cblxuICAgICAgICAvKipcbiAgICAgICAgICogRGVmaW5lcyBiYXNlIHByb3BlcnRpZXMgcGFzc2VkIGZyb20gY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZEFjdGlvbiwgW3tcbiAgICAgICAgICAgIGtleTogJ3Jlc29sdmVPcHRpb25zJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbiA9IG9wdGlvbnMuYWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyID0gb3B0aW9ucy5jb250YWluZXI7XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0dGVyID0gb3B0aW9ucy5lbWl0dGVyO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gb3B0aW9ucy50YXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gb3B0aW9ucy50ZXh0O1xuICAgICAgICAgICAgICAgIHRoaXMudHJpZ2dlciA9IG9wdGlvbnMudHJpZ2dlcjtcblxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRUZXh0ID0gJyc7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2luaXRTZWxlY3Rpb24nLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGluaXRTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudGV4dCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdEZha2UoKTtcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHRoaXMudGFyZ2V0KSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0VGFyZ2V0KCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdzZWxlY3RGYWtlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RGYWtlKCkge1xuICAgICAgICAgICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB2YXIgaXNSVEwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuZ2V0QXR0cmlidXRlKCdkaXInKSA9PSAncnRsJztcblxuICAgICAgICAgICAgICAgIHRoaXMucmVtb3ZlRmFrZSgpO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMucmVtb3ZlRmFrZSgpO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IHRoaXMuY29udGFpbmVyLmFkZEV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKSB8fCB0cnVlO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3RleHRhcmVhJyk7XG4gICAgICAgICAgICAgICAgLy8gUHJldmVudCB6b29taW5nIG9uIGlPU1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUuZm9udFNpemUgPSAnMTJwdCc7XG4gICAgICAgICAgICAgICAgLy8gUmVzZXQgYm94IG1vZGVsXG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5ib3JkZXIgPSAnMCc7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS5zdHlsZS5wYWRkaW5nID0gJzAnO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUubWFyZ2luID0gJzAnO1xuICAgICAgICAgICAgICAgIC8vIE1vdmUgZWxlbWVudCBvdXQgb2Ygc2NyZWVuIGhvcml6b250YWxseVxuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnO1xuICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0uc3R5bGVbaXNSVEwgPyAncmlnaHQnIDogJ2xlZnQnXSA9ICctOTk5OXB4JztcbiAgICAgICAgICAgICAgICAvLyBNb3ZlIGVsZW1lbnQgdG8gdGhlIHNhbWUgcG9zaXRpb24gdmVydGljYWxseVxuICAgICAgICAgICAgICAgIHZhciB5UG9zaXRpb24gPSB3aW5kb3cucGFnZVlPZmZzZXQgfHwgZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50LnNjcm9sbFRvcDtcbiAgICAgICAgICAgICAgICB0aGlzLmZha2VFbGVtLnN0eWxlLnRvcCA9IHlQb3NpdGlvbiArICdweCc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmZha2VFbGVtLnNldEF0dHJpYnV0ZSgncmVhZG9ubHknLCAnJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5mYWtlRWxlbS52YWx1ZSA9IHRoaXMudGV4dDtcblxuICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLmFwcGVuZENoaWxkKHRoaXMuZmFrZUVsZW0pO1xuXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy5mYWtlRWxlbSk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb3B5VGV4dCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdyZW1vdmVGYWtlJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmVGYWtlKCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmZha2VIYW5kbGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY29udGFpbmVyLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2NsaWNrJywgdGhpcy5mYWtlSGFuZGxlckNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWtlSGFuZGxlciA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZUhhbmRsZXJDYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZmFrZUVsZW0pIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIucmVtb3ZlQ2hpbGQodGhpcy5mYWtlRWxlbSk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuZmFrZUVsZW0gPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnc2VsZWN0VGFyZ2V0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBzZWxlY3RUYXJnZXQoKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZFRleHQgPSAoMCwgX3NlbGVjdDIuZGVmYXVsdCkodGhpcy50YXJnZXQpO1xuICAgICAgICAgICAgICAgIHRoaXMuY29weVRleHQoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnY29weVRleHQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGNvcHlUZXh0KCkge1xuICAgICAgICAgICAgICAgIHZhciBzdWNjZWVkZWQgPSB2b2lkIDA7XG5cbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBzdWNjZWVkZWQgPSBkb2N1bWVudC5leGVjQ29tbWFuZCh0aGlzLmFjdGlvbik7XG4gICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIHN1Y2NlZWRlZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMuaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2hhbmRsZVJlc3VsdCcsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gaGFuZGxlUmVzdWx0KHN1Y2NlZWRlZCkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdHRlci5lbWl0KHN1Y2NlZWRlZCA/ICdzdWNjZXNzJyA6ICdlcnJvcicsIHtcbiAgICAgICAgICAgICAgICAgICAgYWN0aW9uOiB0aGlzLmFjdGlvbixcbiAgICAgICAgICAgICAgICAgICAgdGV4dDogdGhpcy5zZWxlY3RlZFRleHQsXG4gICAgICAgICAgICAgICAgICAgIHRyaWdnZXI6IHRoaXMudHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgY2xlYXJTZWxlY3Rpb246IHRoaXMuY2xlYXJTZWxlY3Rpb24uYmluZCh0aGlzKVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdjbGVhclNlbGVjdGlvbicsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXJTZWxlY3Rpb24oKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMudHJpZ2dlcikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnRyaWdnZXIuZm9jdXMoKTtcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB3aW5kb3cuZ2V0U2VsZWN0aW9uKCkucmVtb3ZlQWxsUmFuZ2VzKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5yZW1vdmVGYWtlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2FjdGlvbicsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYWN0aW9uID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiAnY29weSc7XG5cbiAgICAgICAgICAgICAgICB0aGlzLl9hY3Rpb24gPSBhY3Rpb247XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5fYWN0aW9uICE9PSAnY29weScgJiYgdGhpcy5fYWN0aW9uICE9PSAnY3V0Jykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJhY3Rpb25cIiB2YWx1ZSwgdXNlIGVpdGhlciBcImNvcHlcIiBvciBcImN1dFwiJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLl9hY3Rpb247XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ3RhcmdldCcsXG4gICAgICAgICAgICBzZXQ6IGZ1bmN0aW9uIHNldCh0YXJnZXQpIHtcbiAgICAgICAgICAgICAgICBpZiAodGFyZ2V0ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRhcmdldCAmJiAodHlwZW9mIHRhcmdldCA9PT0gJ3VuZGVmaW5lZCcgPyAndW5kZWZpbmVkJyA6IF90eXBlb2YodGFyZ2V0KSkgPT09ICdvYmplY3QnICYmIHRhcmdldC5ub2RlVHlwZSA9PT0gMSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHRoaXMuYWN0aW9uID09PSAnY29weScgJiYgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignSW52YWxpZCBcInRhcmdldFwiIGF0dHJpYnV0ZS4gUGxlYXNlIHVzZSBcInJlYWRvbmx5XCIgaW5zdGVhZCBvZiBcImRpc2FibGVkXCIgYXR0cmlidXRlJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmFjdGlvbiA9PT0gJ2N1dCcgJiYgKHRhcmdldC5oYXNBdHRyaWJ1dGUoJ3JlYWRvbmx5JykgfHwgdGFyZ2V0Lmhhc0F0dHJpYnV0ZSgnZGlzYWJsZWQnKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgXCJ0YXJnZXRcIiBhdHRyaWJ1dGUuIFlvdSBjYW5cXCd0IGN1dCB0ZXh0IGZyb20gZWxlbWVudHMgd2l0aCBcInJlYWRvbmx5XCIgb3IgXCJkaXNhYmxlZFwiIGF0dHJpYnV0ZXMnKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fdGFyZ2V0ID0gdGFyZ2V0O1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIFwidGFyZ2V0XCIgdmFsdWUsIHVzZSBhIHZhbGlkIEVsZW1lbnQnKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQ6IGZ1bmN0aW9uIGdldCgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdGFyZ2V0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIENsaXBib2FyZEFjdGlvbjtcbiAgICB9KCk7XG5cbiAgICBtb2R1bGUuZXhwb3J0cyA9IENsaXBib2FyZEFjdGlvbjtcbn0pO1xuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9jbGlwYm9hcmQvbGliL2NsaXBib2FyZC1hY3Rpb24uanMiLCIoZnVuY3Rpb24gKGdsb2JhbCwgZmFjdG9yeSkge1xuICAgIGlmICh0eXBlb2YgZGVmaW5lID09PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICAgICAgICBkZWZpbmUoWydtb2R1bGUnLCAnLi9jbGlwYm9hcmQtYWN0aW9uJywgJ3RpbnktZW1pdHRlcicsICdnb29kLWxpc3RlbmVyJ10sIGZhY3RvcnkpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIGV4cG9ydHMgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgZmFjdG9yeShtb2R1bGUsIHJlcXVpcmUoJy4vY2xpcGJvYXJkLWFjdGlvbicpLCByZXF1aXJlKCd0aW55LWVtaXR0ZXInKSwgcmVxdWlyZSgnZ29vZC1saXN0ZW5lcicpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICB2YXIgbW9kID0ge1xuICAgICAgICAgICAgZXhwb3J0czoge31cbiAgICAgICAgfTtcbiAgICAgICAgZmFjdG9yeShtb2QsIGdsb2JhbC5jbGlwYm9hcmRBY3Rpb24sIGdsb2JhbC50aW55RW1pdHRlciwgZ2xvYmFsLmdvb2RMaXN0ZW5lcik7XG4gICAgICAgIGdsb2JhbC5jbGlwYm9hcmQgPSBtb2QuZXhwb3J0cztcbiAgICB9XG59KSh0aGlzLCBmdW5jdGlvbiAobW9kdWxlLCBfY2xpcGJvYXJkQWN0aW9uLCBfdGlueUVtaXR0ZXIsIF9nb29kTGlzdGVuZXIpIHtcbiAgICAndXNlIHN0cmljdCc7XG5cbiAgICB2YXIgX2NsaXBib2FyZEFjdGlvbjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9jbGlwYm9hcmRBY3Rpb24pO1xuXG4gICAgdmFyIF90aW55RW1pdHRlcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF90aW55RW1pdHRlcik7XG5cbiAgICB2YXIgX2dvb2RMaXN0ZW5lcjIgPSBfaW50ZXJvcFJlcXVpcmVEZWZhdWx0KF9nb29kTGlzdGVuZXIpO1xuXG4gICAgZnVuY3Rpb24gX2ludGVyb3BSZXF1aXJlRGVmYXVsdChvYmopIHtcbiAgICAgICAgcmV0dXJuIG9iaiAmJiBvYmouX19lc01vZHVsZSA/IG9iaiA6IHtcbiAgICAgICAgICAgIGRlZmF1bHQ6IG9ialxuICAgICAgICB9O1xuICAgIH1cblxuICAgIHZhciBfdHlwZW9mID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFwic3ltYm9sXCIgPyBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiB0eXBlb2Ygb2JqO1xuICAgIH0gOiBmdW5jdGlvbiAob2JqKSB7XG4gICAgICAgIHJldHVybiBvYmogJiYgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFwic3ltYm9sXCIgOiB0eXBlb2Ygb2JqO1xuICAgIH07XG5cbiAgICBmdW5jdGlvbiBfY2xhc3NDYWxsQ2hlY2soaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gICAgICAgIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgdmFyIF9jcmVhdGVDbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgICAgICAgICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICAgICAgICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICAgICAgICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgICAgICAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICAgICAgICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgICAgICAgfTtcbiAgICB9KCk7XG5cbiAgICBmdW5jdGlvbiBfcG9zc2libGVDb25zdHJ1Y3RvclJldHVybihzZWxmLCBjYWxsKSB7XG4gICAgICAgIGlmICghc2VsZikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFJlZmVyZW5jZUVycm9yKFwidGhpcyBoYXNuJ3QgYmVlbiBpbml0aWFsaXNlZCAtIHN1cGVyKCkgaGFzbid0IGJlZW4gY2FsbGVkXCIpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGNhbGwgJiYgKHR5cGVvZiBjYWxsID09PSBcIm9iamVjdFwiIHx8IHR5cGVvZiBjYWxsID09PSBcImZ1bmN0aW9uXCIpID8gY2FsbCA6IHNlbGY7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gX2luaGVyaXRzKHN1YkNsYXNzLCBzdXBlckNsYXNzKSB7XG4gICAgICAgIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXCJmdW5jdGlvblwiICYmIHN1cGVyQ2xhc3MgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTdXBlciBleHByZXNzaW9uIG11c3QgZWl0aGVyIGJlIG51bGwgb3IgYSBmdW5jdGlvbiwgbm90IFwiICsgdHlwZW9mIHN1cGVyQ2xhc3MpO1xuICAgICAgICB9XG5cbiAgICAgICAgc3ViQ2xhc3MucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShzdXBlckNsYXNzICYmIHN1cGVyQ2xhc3MucHJvdG90eXBlLCB7XG4gICAgICAgICAgICBjb25zdHJ1Y3Rvcjoge1xuICAgICAgICAgICAgICAgIHZhbHVlOiBzdWJDbGFzcyxcbiAgICAgICAgICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgICAgICAgICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICBjb25maWd1cmFibGU6IHRydWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChzdXBlckNsYXNzKSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2Yoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIDogc3ViQ2xhc3MuX19wcm90b19fID0gc3VwZXJDbGFzcztcbiAgICB9XG5cbiAgICB2YXIgQ2xpcGJvYXJkID0gZnVuY3Rpb24gKF9FbWl0dGVyKSB7XG4gICAgICAgIF9pbmhlcml0cyhDbGlwYm9hcmQsIF9FbWl0dGVyKTtcblxuICAgICAgICAvKipcbiAgICAgICAgICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRyaWdnZXJcbiAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnNcbiAgICAgICAgICovXG4gICAgICAgIGZ1bmN0aW9uIENsaXBib2FyZCh0cmlnZ2VyLCBvcHRpb25zKSB7XG4gICAgICAgICAgICBfY2xhc3NDYWxsQ2hlY2sodGhpcywgQ2xpcGJvYXJkKTtcblxuICAgICAgICAgICAgdmFyIF90aGlzID0gX3Bvc3NpYmxlQ29uc3RydWN0b3JSZXR1cm4odGhpcywgKENsaXBib2FyZC5fX3Byb3RvX18gfHwgT2JqZWN0LmdldFByb3RvdHlwZU9mKENsaXBib2FyZCkpLmNhbGwodGhpcykpO1xuXG4gICAgICAgICAgICBfdGhpcy5yZXNvbHZlT3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgICAgIF90aGlzLmxpc3RlbkNsaWNrKHRyaWdnZXIpO1xuICAgICAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgICAgICB9XG5cbiAgICAgICAgLyoqXG4gICAgICAgICAqIERlZmluZXMgaWYgYXR0cmlidXRlcyB3b3VsZCBiZSByZXNvbHZlZCB1c2luZyBpbnRlcm5hbCBzZXR0ZXIgZnVuY3Rpb25zXG4gICAgICAgICAqIG9yIGN1c3RvbSBmdW5jdGlvbnMgdGhhdCB3ZXJlIHBhc3NlZCBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAgICAgICAqL1xuXG5cbiAgICAgICAgX2NyZWF0ZUNsYXNzKENsaXBib2FyZCwgW3tcbiAgICAgICAgICAgIGtleTogJ3Jlc29sdmVPcHRpb25zJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiByZXNvbHZlT3B0aW9ucygpIHtcbiAgICAgICAgICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG5cbiAgICAgICAgICAgICAgICB0aGlzLmFjdGlvbiA9IHR5cGVvZiBvcHRpb25zLmFjdGlvbiA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMuYWN0aW9uIDogdGhpcy5kZWZhdWx0QWN0aW9uO1xuICAgICAgICAgICAgICAgIHRoaXMudGFyZ2V0ID0gdHlwZW9mIG9wdGlvbnMudGFyZ2V0ID09PSAnZnVuY3Rpb24nID8gb3B0aW9ucy50YXJnZXQgOiB0aGlzLmRlZmF1bHRUYXJnZXQ7XG4gICAgICAgICAgICAgICAgdGhpcy50ZXh0ID0gdHlwZW9mIG9wdGlvbnMudGV4dCA9PT0gJ2Z1bmN0aW9uJyA/IG9wdGlvbnMudGV4dCA6IHRoaXMuZGVmYXVsdFRleHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jb250YWluZXIgPSBfdHlwZW9mKG9wdGlvbnMuY29udGFpbmVyKSA9PT0gJ29iamVjdCcgPyBvcHRpb25zLmNvbnRhaW5lciA6IGRvY3VtZW50LmJvZHk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0sIHtcbiAgICAgICAgICAgIGtleTogJ2xpc3RlbkNsaWNrJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBsaXN0ZW5DbGljayh0cmlnZ2VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyID0gKDAsIF9nb29kTGlzdGVuZXIyLmRlZmF1bHQpKHRyaWdnZXIsICdjbGljaycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpczIub25DbGljayhlKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnb25DbGljaycsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gb25DbGljayhlKSB7XG4gICAgICAgICAgICAgICAgdmFyIHRyaWdnZXIgPSBlLmRlbGVnYXRlVGFyZ2V0IHx8IGUuY3VycmVudFRhcmdldDtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXBib2FyZEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbiA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5jbGlwYm9hcmRBY3Rpb24gPSBuZXcgX2NsaXBib2FyZEFjdGlvbjIuZGVmYXVsdCh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogdGhpcy5hY3Rpb24odHJpZ2dlciksXG4gICAgICAgICAgICAgICAgICAgIHRhcmdldDogdGhpcy50YXJnZXQodHJpZ2dlciksXG4gICAgICAgICAgICAgICAgICAgIHRleHQ6IHRoaXMudGV4dCh0cmlnZ2VyKSxcbiAgICAgICAgICAgICAgICAgICAgY29udGFpbmVyOiB0aGlzLmNvbnRhaW5lcixcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcjogdHJpZ2dlcixcbiAgICAgICAgICAgICAgICAgICAgZW1pdHRlcjogdGhpc1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdkZWZhdWx0QWN0aW9uJyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0QWN0aW9uKHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ2FjdGlvbicsIHRyaWdnZXIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB7XG4gICAgICAgICAgICBrZXk6ICdkZWZhdWx0VGFyZ2V0JyxcbiAgICAgICAgICAgIHZhbHVlOiBmdW5jdGlvbiBkZWZhdWx0VGFyZ2V0KHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICB2YXIgc2VsZWN0b3IgPSBnZXRBdHRyaWJ1dGVWYWx1ZSgndGFyZ2V0JywgdHJpZ2dlcik7XG5cbiAgICAgICAgICAgICAgICBpZiAoc2VsZWN0b3IpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3Ioc2VsZWN0b3IpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnZGVmYXVsdFRleHQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGRlZmF1bHRUZXh0KHRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZ2V0QXR0cmlidXRlVmFsdWUoJ3RleHQnLCB0cmlnZ2VyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwge1xuICAgICAgICAgICAga2V5OiAnZGVzdHJveScsXG4gICAgICAgICAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveSgpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmxpc3RlbmVyLmRlc3Ryb3koKTtcblxuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNsaXBib2FyZEFjdGlvbikge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsaXBib2FyZEFjdGlvbi5kZXN0cm95KCk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xpcGJvYXJkQWN0aW9uID0gbnVsbDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1dLCBbe1xuICAgICAgICAgICAga2V5OiAnaXNTdXBwb3J0ZWQnLFxuICAgICAgICAgICAgdmFsdWU6IGZ1bmN0aW9uIGlzU3VwcG9ydGVkKCkge1xuICAgICAgICAgICAgICAgIHZhciBhY3Rpb24gPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IFsnY29weScsICdjdXQnXTtcblxuICAgICAgICAgICAgICAgIHZhciBhY3Rpb25zID0gdHlwZW9mIGFjdGlvbiA9PT0gJ3N0cmluZycgPyBbYWN0aW9uXSA6IGFjdGlvbjtcbiAgICAgICAgICAgICAgICB2YXIgc3VwcG9ydCA9ICEhZG9jdW1lbnQucXVlcnlDb21tYW5kU3VwcG9ydGVkO1xuXG4gICAgICAgICAgICAgICAgYWN0aW9ucy5mb3JFYWNoKGZ1bmN0aW9uIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICAgICAgc3VwcG9ydCA9IHN1cHBvcnQgJiYgISFkb2N1bWVudC5xdWVyeUNvbW1hbmRTdXBwb3J0ZWQoYWN0aW9uKTtcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIHJldHVybiBzdXBwb3J0O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XSk7XG5cbiAgICAgICAgcmV0dXJuIENsaXBib2FyZDtcbiAgICB9KF90aW55RW1pdHRlcjIuZGVmYXVsdCk7XG5cbiAgICAvKipcbiAgICAgKiBIZWxwZXIgZnVuY3Rpb24gdG8gcmV0cmlldmUgYXR0cmlidXRlIHZhbHVlLlxuICAgICAqIEBwYXJhbSB7U3RyaW5nfSBzdWZmaXhcbiAgICAgKiBAcGFyYW0ge0VsZW1lbnR9IGVsZW1lbnRcbiAgICAgKi9cbiAgICBmdW5jdGlvbiBnZXRBdHRyaWJ1dGVWYWx1ZShzdWZmaXgsIGVsZW1lbnQpIHtcbiAgICAgICAgdmFyIGF0dHJpYnV0ZSA9ICdkYXRhLWNsaXBib2FyZC0nICsgc3VmZml4O1xuXG4gICAgICAgIGlmICghZWxlbWVudC5oYXNBdHRyaWJ1dGUoYXR0cmlidXRlKSkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGVsZW1lbnQuZ2V0QXR0cmlidXRlKGF0dHJpYnV0ZSk7XG4gICAgfVxuXG4gICAgbW9kdWxlLmV4cG9ydHMgPSBDbGlwYm9hcmQ7XG59KTtcblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY2xpcGJvYXJkL2xpYi9jbGlwYm9hcmQuanMiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanNcIikodW5kZWZpbmVkKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIi50aXBweS10b3VjaHtjdXJzb3I6cG9pbnRlciFpbXBvcnRhbnR9LnRpcHB5LW5vdHJhbnNpdGlvbnstd2Via2l0LXRyYW5zaXRpb246bm9uZSFpbXBvcnRhbnQ7dHJhbnNpdGlvbjpub25lIWltcG9ydGFudH0udGlwcHktcG9wcGVye21heC13aWR0aDo0MDBweDstd2Via2l0LXBlcnNwZWN0aXZlOjgwMHB4O3BlcnNwZWN0aXZlOjgwMHB4O3otaW5kZXg6OTk5OTtvdXRsaW5lOjA7LXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjE2NSwuODQsLjQ0LDEpO3RyYW5zaXRpb24tdGltaW5nLWZ1bmN0aW9uOmN1YmljLWJlemllciguMTY1LC44NCwuNDQsMSk7cG9pbnRlci1ldmVudHM6bm9uZX0udGlwcHktcG9wcGVyLmh0bWwtdGVtcGxhdGV7bWF4LXdpZHRoOjk2JTttYXgtd2lkdGg6Y2FsYygxMDAlIC0gMjBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbeC1hcnJvd117Ym9yZGVyLXRvcDo3cHggc29saWQgIzMzMztib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3R0b206LTdweDttYXJnaW46MCA5cHh9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbeC1hcnJvd10uYXJyb3ctc21hbGx7Ym9yZGVyLXRvcDo1cHggc29saWQgIzMzMztib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3R0b206LTVweH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFt4LWFycm93XS5hcnJvdy1iaWd7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkICMzMzM7Ym9yZGVyLXJpZ2h0OjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3R0b206LTEwcHh9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbeC1jaXJjbGVdey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjowIDMzJTt0cmFuc2Zvcm0tb3JpZ2luOjAgMzMlfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW3gtY2lyY2xlXS5lbnRlcnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwtNTUlKTt0cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsLTU1JSk7b3BhY2l0eToxfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW3gtY2lyY2xlXS5sZWF2ZXstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSguMTUpIHRyYW5zbGF0ZSgtNTAlLC01MCUpO3RyYW5zZm9ybTpzY2FsZSguMTUpIHRyYW5zbGF0ZSgtNTAlLC01MCUpO29wYWNpdHk6MH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lIFt4LWNpcmNsZV17YmFja2dyb3VuZC1jb2xvcjojZmZmfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3dde2JvcmRlci10b3A6N3B4IHNvbGlkICNmZmY7Ym9yZGVyLXJpZ2h0OjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDo3cHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSAudGlwcHktdG9vbHRpcC5saWdodC10aGVtZSBbeC1hcnJvd10uYXJyb3ctc21hbGx7Ym9yZGVyLXRvcDo1cHggc29saWQgI2ZmZjtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lIFt4LWFycm93XS5hcnJvdy1iaWd7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkICNmZmY7Ym9yZGVyLXJpZ2h0OjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWNpcmNsZV17YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC43KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWFycm93XXtib3JkZXItdG9wOjdweCBzb2xpZCByZ2JhKDAsMCwwLC43KTtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWFycm93XS5hcnJvdy1zbWFsbHtib3JkZXItdG9wOjVweCBzb2xpZCByZ2JhKDAsMCwwLC43KTtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjVweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWFycm93XS5hcnJvdy1iaWd7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci1yaWdodDoxMHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjEwcHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjpib3R0b207dHJhbnNmb3JtLW9yaWdpbjpib3R0b219LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KSByb3RhdGVYKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KSByb3RhdGVYKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXS5sZWF2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVYKDkwZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVYKDkwZGVnKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj10b3BdIFtkYXRhLWFuaW1hdGlvbj1mYWRlXS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmxlYXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249c2hpZnRdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKC0xMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49dG9wXSBbZGF0YS1hbmltYXRpb249c2hpZnRdLmxlYXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDApO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXNjYWxlXS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgtMTBweCkgc2NhbGUoMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoLTEwcHgpIHNjYWxlKDEpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXRvcF0gW2RhdGEtYW5pbWF0aW9uPXNjYWxlXS5sZWF2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSBzY2FsZSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSBzY2FsZSgwKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFt4LWFycm93XXtib3JkZXItYm90dG9tOjdweCBzb2xpZCAjMzMzO2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O3RvcDotN3B4O21hcmdpbjowIDlweH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFt4LWFycm93XS5hcnJvdy1zbWFsbHtib3JkZXItYm90dG9tOjVweCBzb2xpZCAjMzMzO2JvcmRlci1yaWdodDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50O3RvcDotNXB4fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItYm90dG9tOjEwcHggc29saWQgIzMzMztib3JkZXItcmlnaHQ6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoxMHB4IHNvbGlkIHRyYW5zcGFyZW50O3RvcDotMTBweH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFt4LWNpcmNsZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOjAgLTUwJTt0cmFuc2Zvcm0tb3JpZ2luOjAgLTUwJX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFt4LWNpcmNsZV0uZW50ZXJ7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsLTQ1JSk7dHJhbnNmb3JtOnNjYWxlKDEpIHRyYW5zbGF0ZSgtNTAlLC00NSUpO29wYWNpdHk6MX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFt4LWNpcmNsZV0ubGVhdmV7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoLjE1KSB0cmFuc2xhdGUoLTUwJSwtNSUpO3RyYW5zZm9ybTpzY2FsZSguMTUpIHRyYW5zbGF0ZSgtNTAlLC01JSk7b3BhY2l0eTowfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtY2lyY2xlXXtiYWNrZ3JvdW5kLWNvbG9yOiNmZmZ9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSAudGlwcHktdG9vbHRpcC5saWdodC10aGVtZSBbeC1hcnJvd117Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgI2ZmZjtib3JkZXItcmlnaHQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1sZWZ0OjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lIFt4LWFycm93XS5hcnJvdy1zbWFsbHtib3JkZXItYm90dG9tOjVweCBzb2xpZCAjZmZmO2JvcmRlci1yaWdodDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItYm90dG9tOjEwcHggc29saWQgI2ZmZjtib3JkZXItcmlnaHQ6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItbGVmdDoxMHB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtY2lyY2xlXXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjcpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtYXJyb3dde2JvcmRlci1ib3R0b206N3B4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci1yaWdodDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtYXJyb3ddLmFycm93LXNtYWxse2JvcmRlci1ib3R0b206NXB4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci1yaWdodDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItYm90dG9tOjEwcHggc29saWQgcmdiYSgwLDAsMCwuNyk7Ym9yZGVyLXJpZ2h0OjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOnRvcDt0cmFuc2Zvcm0tb3JpZ2luOnRvcH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV0uZW50ZXJ7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMTBweCkgcm90YXRlWCgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KSByb3RhdGVYKDApfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXS5sZWF2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSByb3RhdGVYKC05MGRlZyk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCkgcm90YXRlWCgtOTBkZWcpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmxlYXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0XS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgxMHB4KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1ib3R0b21dIFtkYXRhLWFuaW1hdGlvbj1zaGlmdF0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVkoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49Ym90dG9tXSBbZGF0YS1hbmltYXRpb249c2NhbGVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpIHNjYWxlKDEpO3RyYW5zZm9ybTp0cmFuc2xhdGVZKDEwcHgpIHNjYWxlKDEpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWJvdHRvbV0gW2RhdGEtYW5pbWF0aW9uPXNjYWxlXS5sZWF2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSBzY2FsZSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWSgwKSBzY2FsZSgwKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbeC1hcnJvd117Ym9yZGVyLWxlZnQ6N3B4IHNvbGlkICMzMzM7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7cmlnaHQ6LTdweDttYXJnaW46NnB4IDB9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW3gtYXJyb3ddLmFycm93LXNtYWxse2JvcmRlci1sZWZ0OjVweCBzb2xpZCAjMzMzO2JvcmRlci10b3A6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206NXB4IHNvbGlkIHRyYW5zcGFyZW50O3JpZ2h0Oi01cHh9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItbGVmdDoxMHB4IHNvbGlkICMzMzM7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206MTBweCBzb2xpZCB0cmFuc3BhcmVudDtyaWdodDotMTBweH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbeC1jaXJjbGVdey13ZWJraXQtdHJhbnNmb3JtLW9yaWdpbjo1MCUgMDt0cmFuc2Zvcm0tb3JpZ2luOjUwJSAwfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFt4LWNpcmNsZV0uZW50ZXJ7LXdlYmtpdC10cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnNjYWxlKDEpIHRyYW5zbGF0ZSgtNTAlLC01MCUpO29wYWNpdHk6MX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbeC1jaXJjbGVdLmxlYXZley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC4xNSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnNjYWxlKC4xNSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7b3BhY2l0eTowfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lIFt4LWNpcmNsZV17YmFja2dyb3VuZC1jb2xvcjojZmZmfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lIFt4LWFycm93XXtib3JkZXItbGVmdDo3cHggc29saWQgI2ZmZjtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSAudGlwcHktdG9vbHRpcC5saWdodC10aGVtZSBbeC1hcnJvd10uYXJyb3ctc21hbGx7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkICNmZmY7Ym9yZGVyLXRvcDo1cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo1cHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItbGVmdDoxMHB4IHNvbGlkICNmZmY7Ym9yZGVyLXRvcDoxMHB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206MTBweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSAudGlwcHktdG9vbHRpcC50cmFuc3BhcmVudC10aGVtZSBbeC1jaXJjbGVde2JhY2tncm91bmQtY29sb3I6cmdiYSgwLDAsMCwuNyl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtYXJyb3dde2JvcmRlci1sZWZ0OjdweCBzb2xpZCByZ2JhKDAsMCwwLC43KTtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSAudGlwcHktdG9vbHRpcC50cmFuc3BhcmVudC10aGVtZSBbeC1hcnJvd10uYXJyb3ctc21hbGx7Ym9yZGVyLWxlZnQ6NXB4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci10b3A6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206NXB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWFycm93XS5hcnJvdy1iaWd7Ym9yZGVyLWxlZnQ6MTBweCBzb2xpZCByZ2JhKDAsMCwwLC43KTtib3JkZXItdG9wOjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbToxMHB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOnJpZ2h0O3RyYW5zZm9ybS1vcmlnaW46cmlnaHR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCkgcm90YXRlWSgwKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCkgcm90YXRlWSgwKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1sZWZ0XSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdLmxlYXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDApIHJvdGF0ZVkoLTkwZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKSByb3RhdGVZKC05MGRlZyl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmxlYXZle29wYWNpdHk6MDstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKC0xMHB4KTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXNoaWZ0XS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdF0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49bGVmdF0gW2RhdGEtYW5pbWF0aW9uPXNjYWxlXS5lbnRlcntvcGFjaXR5OjE7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgtMTBweCkgc2NhbGUoMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoLTEwcHgpIHNjYWxlKDEpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePWxlZnRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFt4LWFycm93XXtib3JkZXItcmlnaHQ6N3B4IHNvbGlkICMzMzM7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnQ7bGVmdDotN3B4O21hcmdpbjo2cHggMH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW3gtYXJyb3ddLmFycm93LXNtYWxse2JvcmRlci1yaWdodDo1cHggc29saWQgIzMzMztib3JkZXItdG9wOjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjVweCBzb2xpZCB0cmFuc3BhcmVudDtsZWZ0Oi01cHh9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFt4LWFycm93XS5hcnJvdy1iaWd7Ym9yZGVyLXJpZ2h0OjEwcHggc29saWQgIzMzMztib3JkZXItdG9wOjEwcHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbToxMHB4IHNvbGlkIHRyYW5zcGFyZW50O2xlZnQ6LTEwcHh9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFt4LWNpcmNsZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOi01MCUgMDt0cmFuc2Zvcm0tb3JpZ2luOi01MCUgMH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW3gtY2lyY2xlXS5lbnRlcnstd2Via2l0LXRyYW5zZm9ybTpzY2FsZSgxKSB0cmFuc2xhdGUoLTUwJSwtNTAlKTt0cmFuc2Zvcm06c2NhbGUoMSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7b3BhY2l0eToxfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSBbeC1jaXJjbGVdLmxlYXZley13ZWJraXQtdHJhbnNmb3JtOnNjYWxlKC4xNSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7dHJhbnNmb3JtOnNjYWxlKC4xNSkgdHJhbnNsYXRlKC01MCUsLTUwJSk7b3BhY2l0eTowfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktdG9vbHRpcC5saWdodC10aGVtZSBbeC1jaXJjbGVde2JhY2tncm91bmQtY29sb3I6I2ZmZn0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3dde2JvcmRlci1yaWdodDo3cHggc29saWQgI2ZmZjtib3JkZXItdG9wOjdweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjdweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3ddLmFycm93LXNtYWxse2JvcmRlci1yaWdodDo1cHggc29saWQgI2ZmZjtib3JkZXItdG9wOjVweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjVweCBzb2xpZCB0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LXRvb2x0aXAubGlnaHQtdGhlbWUgW3gtYXJyb3ddLmFycm93LWJpZ3tib3JkZXItcmlnaHQ6MTBweCBzb2xpZCAjZmZmO2JvcmRlci10b3A6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjEwcHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWNpcmNsZV17YmFja2dyb3VuZC1jb2xvcjpyZ2JhKDAsMCwwLC43KX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWUgW3gtYXJyb3dde2JvcmRlci1yaWdodDo3cHggc29saWQgcmdiYSgwLDAsMCwuNyk7Ym9yZGVyLXRvcDo3cHggc29saWQgdHJhbnNwYXJlbnQ7Ym9yZGVyLWJvdHRvbTo3cHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIC50aXBweS10b29sdGlwLnRyYW5zcGFyZW50LXRoZW1lIFt4LWFycm93XS5hcnJvdy1zbWFsbHtib3JkZXItcmlnaHQ6NXB4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci10b3A6NXB4IHNvbGlkIHRyYW5zcGFyZW50O2JvcmRlci1ib3R0b206NXB4IHNvbGlkIHRyYW5zcGFyZW50fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSAudGlwcHktdG9vbHRpcC50cmFuc3BhcmVudC10aGVtZSBbeC1hcnJvd10uYXJyb3ctYmlne2JvcmRlci1yaWdodDoxMHB4IHNvbGlkIHJnYmEoMCwwLDAsLjcpO2JvcmRlci10b3A6MTBweCBzb2xpZCB0cmFuc3BhcmVudDtib3JkZXItYm90dG9tOjEwcHggc29saWQgdHJhbnNwYXJlbnR9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1wZXJzcGVjdGl2ZV17LXdlYmtpdC10cmFuc2Zvcm0tb3JpZ2luOmxlZnQ7dHJhbnNmb3JtLW9yaWdpbjpsZWZ0fS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSBbZGF0YS1hbmltYXRpb249cGVyc3BlY3RpdmVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwcHgpIHJvdGF0ZVkoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCkgcm90YXRlWSgwKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPXBlcnNwZWN0aXZlXS5sZWF2ZXtvcGFjaXR5OjA7LXdlYmtpdC10cmFuc2Zvcm06dHJhbnNsYXRlWCgwKSByb3RhdGVZKDkwZGVnKTt0cmFuc2Zvcm06dHJhbnNsYXRlWCgwKSByb3RhdGVZKDkwZGVnKX0udGlwcHktcG9wcGVyW3gtcGxhY2VtZW50Xj1yaWdodF0gW2RhdGEtYW5pbWF0aW9uPWZhZGVdLmVudGVye29wYWNpdHk6MTstd2Via2l0LXRyYW5zZm9ybTp0cmFuc2xhdGVYKDEwcHgpO3RyYW5zZm9ybTp0cmFuc2xhdGVYKDEwcHgpfS50aXBweS1wb3BwZXJbeC1wbGFjZW1lbnRePXJpZ2h0XSBbZGF0YS1hbmltYXRpb249ZmFkZV0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdF0uZW50ZXJ7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zaGlmdF0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV0uZW50ZXJ7b3BhY2l0eToxOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCkgc2NhbGUoMSk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMTBweCkgc2NhbGUoMSl9LnRpcHB5LXBvcHBlclt4LXBsYWNlbWVudF49cmlnaHRdIFtkYXRhLWFuaW1hdGlvbj1zY2FsZV0ubGVhdmV7b3BhY2l0eTowOy13ZWJraXQtdHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCk7dHJhbnNmb3JtOnRyYW5zbGF0ZVgoMCkgc2NhbGUoMCl9LnRpcHB5LXBvcHBlciAudGlwcHktdG9vbHRpcC50cmFuc3BhcmVudC10aGVtZXtiYWNrZ3JvdW5kLWNvbG9yOnJnYmEoMCwwLDAsLjcpfS50aXBweS1wb3BwZXIgLnRpcHB5LXRvb2x0aXAudHJhbnNwYXJlbnQtdGhlbWVbZGF0YS1hbmltYXRlZmlsbF17YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0udGlwcHktcG9wcGVyIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1le2NvbG9yOiMyNjMyM2Q7Ym94LXNoYWRvdzowIDRweCAyMHB4IDRweCByZ2JhKDAsMjAsNjAsLjEpLDAgNHB4IDgwcHggLThweCByZ2JhKDAsMjAsNjAsLjIpO2JhY2tncm91bmQtY29sb3I6I2ZmZn0udGlwcHktcG9wcGVyIC50aXBweS10b29sdGlwLmxpZ2h0LXRoZW1lW2RhdGEtYW5pbWF0ZWZpbGxde2JhY2tncm91bmQtY29sb3I6dHJhbnNwYXJlbnR9LnRpcHB5LXRvb2x0aXB7cG9zaXRpb246cmVsYXRpdmU7Y29sb3I6I2ZmZjtib3JkZXItcmFkaXVzOjRweDtmb250LXNpemU6Ljk1cmVtO3BhZGRpbmc6LjRyZW0gLjhyZW07dGV4dC1hbGlnbjpjZW50ZXI7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtOy13ZWJraXQtZm9udC1zbW9vdGhpbmc6YW50aWFsaWFzZWQ7LW1vei1vc3gtZm9udC1zbW9vdGhpbmc6Z3JheXNjYWxlO2JhY2tncm91bmQtY29sb3I6IzMzM30udGlwcHktdG9vbHRpcC0tc21hbGx7cGFkZGluZzouMjVyZW0gLjVyZW07Zm9udC1zaXplOi44cmVtfS50aXBweS10b29sdGlwLS1iaWd7cGFkZGluZzouNnJlbSAxLjJyZW07Zm9udC1zaXplOjEuMnJlbX0udGlwcHktdG9vbHRpcFtkYXRhLWFuaW1hdGVmaWxsXXtvdmVyZmxvdzpoaWRkZW47YmFja2dyb3VuZC1jb2xvcjp0cmFuc3BhcmVudH0udGlwcHktdG9vbHRpcFtkYXRhLWludGVyYWN0aXZlXXtwb2ludGVyLWV2ZW50czphdXRvfS50aXBweS10b29sdGlwW2RhdGEtaW5lcnRpYV17LXdlYmtpdC10cmFuc2l0aW9uLXRpbWluZy1mdW5jdGlvbjpjdWJpYy1iZXppZXIoLjUzLDEsLjM2LC44NSk7dHJhbnNpdGlvbi10aW1pbmctZnVuY3Rpb246Y3ViaWMtYmV6aWVyKC41MywyLC4zNiwuODUpfS50aXBweS10b29sdGlwIFt4LWFycm93XXtwb3NpdGlvbjphYnNvbHV0ZTt3aWR0aDowO2hlaWdodDowfS50aXBweS10b29sdGlwIFt4LWNpcmNsZV17cG9zaXRpb246YWJzb2x1dGU7d2lsbC1jaGFuZ2U6dHJhbnNmb3JtO2JhY2tncm91bmQtY29sb3I6IzMzMztib3JkZXItcmFkaXVzOjUwJTt3aWR0aDoxMzAlO3dpZHRoOmNhbGMoMTEwJSArIDJyZW0pO2xlZnQ6NTAlO3RvcDo1MCU7ei1pbmRleDotMTtvdmVyZmxvdzpoaWRkZW47LXdlYmtpdC10cmFuc2l0aW9uOmFsbCBlYXNlO3RyYW5zaXRpb246YWxsIGVhc2V9LnRpcHB5LXRvb2x0aXAgW3gtY2lyY2xlXTpiZWZvcmV7Y29udGVudDpcXFwiXFxcIjtwYWRkaW5nLXRvcDo5MCU7ZmxvYXQ6bGVmdH1AbWVkaWEgKG1heC13aWR0aDo0NTBweCl7LnRpcHB5LXBvcHBlcnttYXgtd2lkdGg6OTYlO21heC13aWR0aDpjYWxjKDEwMCUgLSAyMHB4KX19XCIsIFwiXCJdKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlciEuL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmNzc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy90aXBweS5qcy9kaXN0L3RpcHB5LmNzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnRzID0gbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKFwiLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuI3RpcHB5VGVtcGxhdGVbZGF0YS12LTMxNDMzM2M0XSB7XFxuICAgIGRpc3BsYXk6IG5vbmU7XFxufVxcbi5jMmNbZGF0YS12LTMxNDMzM2M0XSB7XFxuICAgIGN1cnNvcjogcG9pbnRlcjtcXG59XFxuXCIsIFwiXCIsIHtcInZlcnNpb25cIjozLFwic291cmNlc1wiOltcIi9Vc2Vycy9rYWJib3VjaGkvU2l0ZXMvbGFyYXZlbC1saW5nby9wYWNrYWdlcy9jdGYwL2xpbmdvL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZT83ZGYwMTViZVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBd0lBO0lBQ0EsY0FBQTtDQUNBO0FBRUE7SUFDQSxnQkFBQTtDQUNBXCIsXCJmaWxlXCI6XCJjb250ZW50LnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXY+XFxuICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXZlbCBpcy1tb2JpbGUgaXMtbWFyZ2lubGVzc1xcXCI+XFxuICAgICAgICAgICAgPCEtLSBpdGVtcyBjb3VudCAtLT5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXZlbC1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGV2ZWwtaXRlbVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZCBpcy1ncm91cGVkIGlzLWdyb3VwZWQtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbFxcXCIgdi1pZj1cXFwic2VsZWN0ZWRGaWxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGg0IGNsYXNzPVxcXCJ0aXRsZSBpcy00XFxcIj5cXFwie3sgaXRlbXNDb3VudCB9fVxcXCIgSXRlbS9zPC9oND5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8IS0tIHNlbGVjdCBmaWxlIC0tPlxcbiAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldmVsLXJpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibGV2ZWwtaXRlbVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJmaWVsZCBpcy1ncm91cGVkIGlzLWdyb3VwZWQtcmlnaHRcXFwiIHYtaWY9XFxcImZpbGVzLmxlbmd0aFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInNlbGVjdFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c2VsZWN0IHYtbW9kZWw9XFxcInNlbGVjdGVkRmlsZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cXFwiXFxcIiBkaXNhYmxlZD57eyB0cmFucygnc2VsZWN0X2ZpbGUnKSB9fTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxvcHRpb24gdi1mb3I9XFxcIihmLCBpKSBpbiBmaWxlc1xcXCIgOmtleT1cXFwiaVxcXCI+e3sgZiB9fTwvb3B0aW9uPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zZWxlY3Q+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcXFwiPjxpY29uIG5hbWU9XFxcImZpbGVcXFwiLz48L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJjb250cm9sXFxcIiB2LWlmPVxcXCJzZWxlY3RlZEZpbGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gaXMtZGFuZ2VyXFxcIiBAY2xpY2s9XFxcInJlbW92ZVNlbGVjdGVkRmlsZSgpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWNvbiBuYW1lPVxcXCJ0cmFzaFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgPCEtLSBkYXRhIC0tPlxcbiAgICAgICAgPHNlY3Rpb24gdi1pZj1cXFwic2VsZWN0ZWRGaWxlXFxcIiBjbGFzcz1cXFwibS10LTUwXFxcIj5cXG4gICAgICAgICAgICA8IS0tIHRhYmxlIC0tPlxcbiAgICAgICAgICAgIDx0YWJsZSBjbGFzcz1cXFwidGFibGUgaXMtZnVsbHdpZHRoIGlzLWhvdmVyYWJsZSBpcy1ib3JkZXJlZFxcXCI+XFxuICAgICAgICAgICAgICAgIDx0aGVhZD5cXG4gICAgICAgICAgICAgICAgICAgIDx0ciBjbGFzcz1cXFwiaXMtdW5zZWxlY3RhYmxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcImlzLWxpbmtcXFwiIHdpZHRoPVxcXCIxJVxcXCI+e3sgdHJhbnMoJ2tleScpIH19PC90aD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGggY2xhc3M9XFxcImlzLWxpbmtcXFwiIHYtZm9yPVxcXCIobCwgaSkgaW4gbG9jYWxlc1xcXCIgOmtleT1cXFwiaVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcInRhZ3MgaGFzLWFkZG9uc1xcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3BhbiBjbGFzcz1cXFwidGFnIGlzLWxpZ2h0IGlzLW1lZGl1bVxcXCI+e3sgbCB9fTwvc3Bhbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJ0YWcgaXMtd2FybmluZyBpcy1tZWRpdW1cXFwiIEBjbGljaz1cXFwicmVtb3ZlTG9jYWxlKGwpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWNvbiBuYW1lPVxcXCJ0cmFzaFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RoPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0aCBjbGFzcz1cXFwiaXMtbGlua1xcXCI+e3sgdHJhbnMoJ29wcycpIH19PC90aD5cXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgIDwvdGhlYWQ+XFxuICAgICAgICAgICAgICAgIDx0Ym9keT5cXG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWZvcj1cXFwiKG1haW5WLCBtYWluSywgbWFpbkkpIGluIHNlbGVjdGVkRmlsZURhdGFDbG9uZVxcXCIgOmtleT1cXFwibWFpbklcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCBub3dyYXAgY29udGVudGVkaXRhYmxlIGRpcj1cXFwiYXV0b1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOnRpdGxlPVxcXCJnZXRLZXkobWFpbkspXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2LXRpcHB5PVxcXCJ7IHBvc2l0aW9uIDogJ3JpZ2h0JywgYXJyb3c6IHRydWUsIGludGVyYWN0aXZlOiB0cnVlLCB0cmlnZ2VyOiAnbW91c2VlbnRlcid9XFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkYXRhLWh0bWw9XFxcIiN0aXBweVRlbXBsYXRlXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAbW91c2VlbnRlcj1cXFwia2V5VG9Db3B5ID0gZ2V0S2V5KG1haW5LKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQHNob3duPVxcXCJyZWZvY3VzKClcXFwiXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpjbGFzcz1cXFwibmVzdENoZWNrKG1haW5LKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmRhdGEtbWFpbi1rZXk9XFxcIm1haW5LXFxcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBAa2V5ZG93bi5lbnRlci5wcmV2ZW50XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cXFwibmV3RW50cnkoKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGZvY3VzPVxcXCJnZXRQb3MoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJsdXI9XFxcInNhdmVOZXdLZXkoJGV2ZW50KVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHt7IG1haW5LIH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8dGQgdi1mb3I9XFxcIihuZXN0ViwgbmVzdEssIG5lc3RJKSBpbiBtYWluVlxcXCIgOmtleT1cXFwibmVzdElcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZSBkaXI9XFxcImF1dG9cXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDpkYXRhLW1haW4ta2V5PVxcXCJtYWluS1xcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOmRhdGEtY29kZT1cXFwibmVzdEtcXFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIEBpbnB1dD1cXFwibmV3RW50cnkoKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGZvY3VzPVxcXCJnZXRQb3MoJGV2ZW50KVxcXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgQGJsdXI9XFxcInNhdmVOZXdWYWx1ZSgkZXZlbnQpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgbmVzdFYgfX1cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcblxcbiAgICAgICAgICAgICAgICAgICAgICAgIDx0ZCB3aWR0aD1cXFwiMSVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJidXR0b24gaXMtZGFuZ2VyXFxcIiBAY2xpY2s9XFxcInJlbW92ZUl0ZW0obWFpbkspXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJpY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aWNvbiBuYW1lPVxcXCJ0cmFzaFxcXCIvPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9zcGFuPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L3RkPlxcbiAgICAgICAgICAgICAgICAgICAgPC90cj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDwhLS0gbm90aGluZyBmb3VuZCAtLT5cXG4gICAgICAgICAgICAgICAgICAgIDx0ciB2LWlmPVxcXCJkb250SGF2ZURhdGEoKVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPHRkIDpjb2xzcGFuPVxcXCJsb2NhbGVzLmxlbmd0aCArIDJcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFucygnbm9fZGF0YScpIH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC90ZD5cXG4gICAgICAgICAgICAgICAgICAgIDwvdHI+XFxuICAgICAgICAgICAgICAgIDwvdGJvZHk+XFxuICAgICAgICAgICAgPC90YWJsZT5cXG5cXG4gICAgICAgICAgICA8IS0tIG9wcyAtLT5cXG4gICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXZlbFxcXCI+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldmVsLXJpZ2h0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldmVsLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1saW5rXFxcIiBAY2xpY2sucHJldmVudD1cXFwiYWRkTmV3SXRlbSgpXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAge3sgdHJhbnMoJ2FkZF9uZXcnKSB9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJsZXZlbC1sZWZ0XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldmVsLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvbiBpcy1zdWNjZXNzXFxcIiA6ZGlzYWJsZWQ9XFxcIiFkYXRhQ2hhbmdlZFxcXCIgQGNsaWNrPVxcXCJzdWJtaXROZXdEYXRhKClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFucygnc2F2ZScpIH19XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcImxldmVsLWl0ZW1cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImJ1dHRvblxcXCIgOmRpc2FibGVkPVxcXCIhZGF0YUNoYW5nZWRcXFwiIEBjbGljaz1cXFwicmVzZXREYXRhKClcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7eyB0cmFucygncmVzZXQnKSB9fVxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvYnV0dG9uPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDwhLS0gdGlwcHkgdGVtcGxhdGUgLS0+XFxuICAgICAgICAgICAgPGRpdiBpZD1cXFwidGlwcHlUZW1wbGF0ZVxcXCI+XFxuICAgICAgICAgICAgICAgIDxzcGFuIGNsYXNzPVxcXCJjMmNcXFwiPnt7IGtleVRvQ29weSB9fTwvc3Bhbj5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvc2VjdGlvbj5cXG4gICAgPC9kaXY+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbiAgICAjdGlwcHlUZW1wbGF0ZSB7XFxuICAgICAgICBkaXNwbGF5OiBub25lO1xcbiAgICB9XFxuXFxuICAgIC5jMmMge1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICB9XFxuPC9zdHlsZT5cXG5cXG48c2NyaXB0PlxcbmltcG9ydCBGb3JtcyBmcm9tICcuL2Zvcm1zJ1xcblxcbmV4cG9ydCBkZWZhdWx0e1xcbiAgICBuYW1lOiAnY29udGVudCcsXFxuICAgIG1peGluczogW0Zvcm1zXSxcXG4gICAgZGF0YSgpIHtcXG4gICAgICAgIHJldHVybiB0aGlzLiRwYXJlbnQuJGRhdGFcXG4gICAgfSxcXG4gICAgY29tcHV0ZWQ6IHtcXG4gICAgICAgIGl0ZW1zQ291bnQoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHRoaXMuc2VsZWN0ZWRGaWxlRGF0YUNsb25lKS5sZW5ndGhcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgdXBkYXRlZCgpIHtcXG4gICAgICAgIHRoaXMudGFibGVDb2x1bW5SZXNpemUoKVxcbiAgICB9LFxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICAvLyB0YWJsZSBvcHNcXG4gICAgICAgIHRhYmxlQ29sdW1uUmVzaXplKCkge1xcbiAgICAgICAgICAgIGxldCBlbFxcbiAgICAgICAgICAgIGxldCBzdGFydE9mZnNldFxcblxcbiAgICAgICAgICAgIGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoJ3RhYmxlIHRoJykuZm9yRWFjaCgodGgpID0+IHtcXG4gICAgICAgICAgICAgICAgdGguc3R5bGUucG9zaXRpb24gPSAnc3RpY2t5J1xcblxcbiAgICAgICAgICAgICAgICBsZXQgZ3JpcCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpXFxuICAgICAgICAgICAgICAgIGdyaXAuaW5uZXJIVE1MID0gJyZuYnNwOydcXG4gICAgICAgICAgICAgICAgZ3JpcC5zdHlsZS50b3AgPSAwXFxuICAgICAgICAgICAgICAgIGdyaXAuc3R5bGUucmlnaHQgPSAwXFxuICAgICAgICAgICAgICAgIGdyaXAuc3R5bGUuYm90dG9tID0gMFxcbiAgICAgICAgICAgICAgICBncmlwLnN0eWxlLndpZHRoID0gJzEwcHgnXFxuICAgICAgICAgICAgICAgIGdyaXAuc3R5bGUucG9zaXRpb24gPSAnYWJzb2x1dGUnXFxuICAgICAgICAgICAgICAgIGdyaXAuc3R5bGUuY3Vyc29yID0gJ2NvbC1yZXNpemUnXFxuICAgICAgICAgICAgICAgIGdyaXAuYWRkRXZlbnRMaXN0ZW5lcignbW91c2Vkb3duJywgKGUpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGVsID0gdGhcXG4gICAgICAgICAgICAgICAgICAgIHN0YXJ0T2Zmc2V0ID0gdGgub2Zmc2V0V2lkdGggLSBlLnBhZ2VYXFxuICAgICAgICAgICAgICAgIH0pXFxuXFxuICAgICAgICAgICAgICAgIHRoLmFwcGVuZENoaWxkKGdyaXApXFxuICAgICAgICAgICAgfSlcXG5cXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCAoZSkgPT4ge1xcbiAgICAgICAgICAgICAgICBpZiAoZWwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGVsLnN0eWxlLndpZHRoID0gc3RhcnRPZmZzZXQgKyBlLnBhZ2VYICsgJ3B4J1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfSlcXG5cXG4gICAgICAgICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZXVwJywgKCkgPT4ge1xcbiAgICAgICAgICAgICAgICBlbCA9IHVuZGVmaW5lZFxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9LFxcblxcbiAgICAgICAgLy8gb3BzXFxuICAgICAgICBhZGROZXdJdGVtKCkge1xcbiAgICAgICAgICAgIGxldCBuYW1lID0gJ25ld0l0ZW0nICsgdGhpcy5uZXdJdGVtQ291bnRlclxcbiAgICAgICAgICAgIGxldCBmaWxlRGF0YSA9IHRoaXMuc2VsZWN0ZWRGaWxlRGF0YUNsb25lXFxuXFxuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWVcXG5cXG4gICAgICAgICAgICAvLyBpbmNhc2Ugd2UgYWxyZWFkeSBoYXZlIGtleXMgPT0gbmFtZVxcbiAgICAgICAgICAgIGlmIChmaWxlRGF0YS5oYXNPd25Qcm9wZXJ0eShuYW1lKSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLm5ld0l0ZW1Db3VudGVyKytcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuYWRkTmV3SXRlbSgpXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMubG9jYWxlcy5mb3JFYWNoKChpdGVtKSA9PiB7XFxuICAgICAgICAgICAgICAgIGlmICghZmlsZURhdGEuaGFzT3duUHJvcGVydHkobmFtZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuJHNldChmaWxlRGF0YSwgbmFtZSwge1tpdGVtXTogJyd9KVxcbiAgICAgICAgICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy4kc2V0KGZpbGVEYXRhW25hbWVdLCBpdGVtLCAnJylcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0pXFxuXFxuICAgICAgICAgICAgdGhpcy5uZXdJdGVtQ291bnRlcisrXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVtb3ZlSXRlbShpdGVtKSB7XFxuICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IHRydWVcXG4gICAgICAgICAgICB0aGlzLiRkZWxldGUodGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmUsIGl0ZW0pXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVzZXREYXRhKCkge1xcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZVxcbiAgICAgICAgICAgIHRoaXMubmV3SXRlbUNvdW50ZXIgPSAwXFxuICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmUgPSBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHRoaXMuc2VsZWN0ZWRGaWxlRGF0YSkpXFxuXFxuICAgICAgICAgICAgLy8gaGFja3kgZml4IGFzIG5ld2tleXMgZG9udCByZXNldFxcbiAgICAgICAgICAgIGlmICh0aGlzLm5ld0tleXMpIHtcXG4gICAgICAgICAgICAgICAgbGV0IG9sZCA9IHRoaXMuc2VsZWN0ZWRGaWxlXFxuXFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGUgPSBvbGRcXG4gICAgICAgICAgICAgICAgfSwgMTApXFxuXFxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdyZXNldEFsbCcsIFsnc2VsZWN0ZWRGaWxlJ10pXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdyZXNldEFsbCcsIFsna2V5VG9Db3B5JywgJ2N1cnJlbnRJbnB1dFJlZiddKVxcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIC8vIHV0aWxcXG4gICAgICAgIG5ld0VudHJ5KCkge1xcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgc2F2ZU5ld0tleShlKSB7XFxuICAgICAgICAgICAgbGV0IG9sZF9rZXkgPSBlLnRhcmdldC5kYXRhc2V0Lm1haW5LZXlcXG4gICAgICAgICAgICBsZXQgdGV4dCA9IGUudGFyZ2V0LmlubmVyVGV4dCA9IGUudGFyZ2V0LmlubmVyVGV4dC50b0xvd2VyQ2FzZSgpLnJlcGxhY2UoL1xcXFxzL2csICdfJylcXG4gICAgICAgICAgICBsZXQgbmV3X2tleSA9IHRleHRcXG5cXG4gICAgICAgICAgICBpZiAob2xkX2tleSAhPT0gbmV3X2tleSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLmRhdGFDaGFuZ2VkID0gdHJ1ZVxcblxcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5uZXdLZXlzKSB7XFxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5uZXdLZXlzW29sZF9rZXldID0gbmV3X2tleVxcbiAgICAgICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgICAgIHRoaXMubmV3S2V5cyA9IHtbb2xkX2tleV0gOiBuZXdfa2V5fVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBzYXZlTmV3VmFsdWUoZSkge1xcbiAgICAgICAgICAgIGxldCBjb2RlID0gZS50YXJnZXQuZGF0YXNldC5jb2RlXFxuICAgICAgICAgICAgbGV0IGtleSA9IGUudGFyZ2V0LmRhdGFzZXQubWFpbktleVxcbiAgICAgICAgICAgIGxldCB0ZXh0ID0gZS50YXJnZXQuaW5uZXJUZXh0ID0gZS50YXJnZXQuaW5uZXJUZXh0LnJlcGxhY2UoL1xcXFxuL2csICc8YnI+JylcXG4gICAgICAgICAgICBsZXQgdmFsdWUgPSB0ZXh0XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZWN0ZWRGaWxlRGF0YUNsb25lW2tleV1bY29kZV0gIT09IHZhbHVlKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSB0cnVlXFxuICAgICAgICAgICAgICAgIHRoaXMuJHNldCh0aGlzLnNlbGVjdGVkRmlsZURhdGFDbG9uZVtrZXldLCBjb2RlLCB2YWx1ZSlcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgZm9ybWF0RGF0YSgpIHtcXG4gICAgICAgICAgICBsZXQgbWFpbiA9IHRoaXMuc2VsZWN0ZWRGaWxlRGF0YUNsb25lXFxuICAgICAgICAgICAgbGV0IG5ld0RhdGEgPSB0aGlzLm5ld0tleXNcXG5cXG4gICAgICAgICAgICBsZXQgbWFpbl9rZXlzID0gT2JqZWN0LmtleXMobWFpbilcXG4gICAgICAgICAgICBsZXQgbmV3RGF0YV9rZXlzID0gT2JqZWN0LmtleXMobmV3RGF0YSlcXG5cXG4gICAgICAgICAgICAvLyByZXBsYWNlIGNoYW5nZWQga2V5c1xcbiAgICAgICAgICAgIGlmIChuZXdEYXRhX2tleXMubGVuZ3RoKSB7XFxuICAgICAgICAgICAgICAgIG1haW5fa2V5cy5tYXAoKG9sZF9rZXkpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIGlmIChuZXdEYXRhX2tleXMuaW5jbHVkZXMob2xkX2tleSkpIHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBsZXQgbmV3X2tleSA9IG5ld0RhdGFbb2xkX2tleV1cXG5cXG4gICAgICAgICAgICAgICAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1haW4sXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ld19rZXksXFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IobWFpbiwgb2xkX2tleSlcXG4gICAgICAgICAgICAgICAgICAgICAgICApXFxuXFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVsZXRlIG1haW5bb2xkX2tleV1cXG4gICAgICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgfSlcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIG1haW5cXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvLyB0aXBweSAmIGN0Y3BcXG4gICAgICAgIGdldFBvcyhlKSB7XFxuICAgICAgICAgICAgdGhpcy5jdXJyZW50SW5wdXRSZWYgPSBlXFxuICAgICAgICB9LFxcbiAgICAgICAgcmVmb2N1cygpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNZXRob2QoJ3JlZm9jdXMnKVxcbiAgICAgICAgfSxcXG4gICAgICAgIGdldEtleShrZXkpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGhpcy5wYXJlbnRNZXRob2QoJ2dldEtleScsIGtleSlcXG4gICAgICAgIH0sXFxuXFxuICAgICAgICAvLyBvdGhlclxcbiAgICAgICAgbmVzdENoZWNrKGl0ZW0pIHtcXG4gICAgICAgICAgICByZXR1cm4gaXRlbS5pbmNsdWRlcygnLicpID8gJ25lc3RlZEtleScgOiAnJ1xcbiAgICAgICAgfSxcXG4gICAgICAgIGRvbnRIYXZlRGF0YSgpIHtcXG4gICAgICAgICAgICByZXR1cm4gT2JqZWN0LmtleXModGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmUpLmxlbmd0aCA9PSAwXFxuICAgICAgICB9LFxcbiAgICAgICAgdHJhbnMoa2V5KSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWV0aG9kKCd0cmFucycsIGtleSlcXG4gICAgICAgIH0sXFxuICAgICAgICBwYXJlbnRNZXRob2QobWV0aG9kX25hbWUsIGFyZ3MgPSBudWxsKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudFttZXRob2RfbmFtZV0oYXJncylcXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtMzE0MzMzYzRcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTMxNDMzM2M0XCIsXCJzY29wZWRcIjp0cnVlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvc2hhcmVkL2NvbnRlbnQudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydHMgPSBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoXCIuLi8uLi9jc3MtbG9hZGVyL2xpYi9jc3MtYmFzZS5qc1wiKSh0cnVlKTtcbi8vIGltcG9ydHNcblxuXG4vLyBtb2R1bGVcbmV4cG9ydHMucHVzaChbbW9kdWxlLmlkLCBcIlxcbi5ub3RpZi1jb250YWluZXIge1xcbiAgICBwYWRkaW5nOiAwO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHRvcDogNHJlbTtcXG4gICAgcmlnaHQ6IDFyZW07XFxuICAgIHotaW5kZXg6IDEwMDAwO1xcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL1VzZXJzL2thYmJvdWNoaS9TaXRlcy9sYXJhdmVsLWxpbmdvL3BhY2thZ2VzL2N0ZjAvbGluZ28vbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZT82OGQxYTVhYVwiXSxcIm5hbWVzXCI6W10sXCJtYXBwaW5nc1wiOlwiO0FBMkRBO0lBQ0EsV0FBQTtJQUNBLGdCQUFBO0lBQ0EsVUFBQTtJQUNBLFlBQUE7SUFDQSxlQUFBO0NBQ0FcIixcImZpbGVcIjpcIk5vdGlmaWNhdGlvbi52dWVcIixcInNvdXJjZXNDb250ZW50XCI6W1wiPHRlbXBsYXRlPlxcbiAgICA8ZGl2PlxcbiAgICAgICAgPCEtLSBzaW5nbGUgLS0+XFxuICAgICAgICA8dHJhbnNpdGlvbiBuYW1lPVxcXCJzbGlkZS1mYWRlXFxcIiB2LWlmPVxcXCJzZWxmX3Nob3dcXFwiPlxcbiAgICAgICAgICAgIDxkaXYgOmNsYXNzPVxcXCJjbGFzc09iaihzZWxmX3R5cGUpXFxcIiBjbGFzcz1cXFwiaXRlbVxcXCI+XFxuXFxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRlbGV0ZVxcXCIgQGNsaWNrPVxcXCJzZWxmX3Nob3cgPSBmYWxzZVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWxlZnRcXFwiIHYtaWY9XFxcInNlbGZfaWNvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGZpZ3VyZSBjbGFzcz1cXFwiaWNvbiBpcy1sYXJnZVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29uc1xcXCI+e3sgZ2V0SWNvbihzZWxmX3R5cGUpIH19PC9pPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZWRpYS1jb250ZW50XFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcInRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz57eyBzZWxmX3RpdGxlIH19PC9zdHJvbmc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9oND5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8cCBjbGFzcz1cXFwic3VidGl0bGVcXFwiPnt7IHNlbGZfYm9keSB9fTwvcD5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgIDwvdHJhbnNpdGlvbj5cXG5cXG4gICAgICAgIDwhLS0gZXZlbnRzIC0tPlxcbiAgICAgICAgPHRlbXBsYXRlIHYtaWY9XFxcIiFzZWxmX3RpdGxlXFxcIj5cXG4gICAgICAgICAgICA8c3BhbiBpZD1cXFwiY2xvc2VfYWxsXFxcIiBjbGFzcz1cXFwidGFnIGlzLWRhcmsgaXMtbWVkaXVtXFxcIlxcbiAgICAgICAgICAgICAgICB2LWlmPVxcXCJjaGVja0Zvckdyb3VwKClcXFwiIEBjbGljaz1cXFwiY2xvc2VBbGwoKVxcXCI+XFxuICAgICAgICAgICAgICAgIENsb3NlIEFsbFxcbiAgICAgICAgICAgICAgICA8YnV0dG9uIGNsYXNzPVxcXCJkZWxldGVcXFwiPjwvYnV0dG9uPlxcbiAgICAgICAgICAgIDwvc3Bhbj5cXG5cXG4gICAgICAgICAgICA8dHJhbnNpdGlvbi1ncm91cCBuYW1lPVxcXCJzbGlkZS1mYWRlXFxcIiB0YWc9XFxcInVsXFxcIj5cXG4gICAgICAgICAgICAgICAgPGxpIHYtZm9yPVxcXCIob25lLGluZGV4KSBpbiBub3RpZl9ncm91cFxcXCIgOmtleT1cXFwiaW5kZXhcXFwiXFxuICAgICAgICAgICAgICAgICAgICBjbGFzcz1cXFwiaXRlbVxcXCIgOmNsYXNzPVxcXCJjbGFzc09iaihvbmUudHlwZSlcXFwiXFxuICAgICAgICAgICAgICAgICAgICB2LWlmPVxcXCJJc1Zpc2libGUoaW5kZXgpXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRlbGV0ZVxcXCIgQGNsaWNrPVxcXCJjbG9zZU5vdGlmKGluZGV4KVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZWRpYVxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVkaWEtbGVmdFxcXCIgdi1pZj1cXFwib25lLmljb25cXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVxcXCJpY29uIGlzLWxhcmdlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxpIGNsYXNzPVxcXCJtYXRlcmlhbC1pY29uc1xcXCI+e3sgZ2V0SWNvbihvbmUudHlwZSkgfX08L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvZmlndXJlPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8aDQgY2xhc3M9XFxcInRpdGxlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxzdHJvbmc+e3sgb25lLnRpdGxlIH19PC9zdHJvbmc+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDwvaDQ+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJzdWJ0aXRsZVxcXCI+e3sgb25lLmJvZHkgfX08L3A+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG5cXG4gICAgICAgICAgICAgICAgPC9saT5cXG4gICAgICAgICAgICA8L3RyYW5zaXRpb24tZ3JvdXA+XFxuICAgICAgICA8L3RlbXBsYXRlPlxcbiAgICA8L2Rpdj5cXG48L3RlbXBsYXRlPlxcblxcbjxzdHlsZT5cXG4gICAgLm5vdGlmLWNvbnRhaW5lciB7XFxuICAgICAgICBwYWRkaW5nOiAwO1xcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICAgICAgdG9wOiA0cmVtO1xcbiAgICAgICAgcmlnaHQ6IDFyZW07XFxuICAgICAgICB6LWluZGV4OiAxMDAwMDtcXG4gICAgfVxcbjwvc3R5bGU+XFxuXFxuPHN0eWxlIHNjb3BlZD5cXG4gICAgQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9pY29uP2ZhbWlseT1NYXRlcmlhbCtJY29ucyk7XFxuXFxuICAgIC8qYW5pbWF0aW9uKi9cXG4gICAgLnNsaWRlLWZhZGUtZW50ZXItYWN0aXZlLFxcbiAgICAuc2xpZGUtZmFkZS1sZWF2ZS1hY3RpdmUge1xcbiAgICAgICAgdHJhbnNpdGlvbjogYWxsIDAuM3MgZWFzZTtcXG4gICAgfVxcbiAgICAuc2xpZGUtZmFkZS1lbnRlcixcXG4gICAgLnNsaWRlLWZhZGUtbGVhdmUtdG8ge1xcbiAgICAgICAgb3BhY2l0eTogMDtcXG4gICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcXG4gICAgfVxcblxcbiAgICAvKm5vdGlpZmNhdGlvbiBjYXJkKi9cXG4gICAgLml0ZW0ge1xcbiAgICAgICAgd2lkdGg6IDMzMHB4O1xcbiAgICB9XFxuICAgIC5tYXRlcmlhbC1pY29ucyB7XFxuICAgICAgICBmb250LXNpemU6IDNyZW07XFxuICAgIH1cXG4gICAgLm1lZGlhLWxlZnQge1xcbiAgICAgICAgYWxpZ24tc2VsZjogY2VudGVyO1xcbiAgICAgICAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgICAgICAgbWFyZ2luLXJpZ2h0OiAxLjI1cmVtO1xcbiAgICB9XFxuXFxuICAgIC5oYXMtc2hhZG93IHtcXG4gICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMTIpLCAwIDAgNnB4IHJnYmEoMCwwLDAsMC4wNCk7XFxuICAgIH1cXG4gICAgLm5vdGlmaWNhdGlvbiB7XFxuICAgICAgICBwYWRkaW5nOiAxLjI1cmVtO1xcbiAgICAgICAgbWFyZ2luLWJvdHRvbTogMTBweDtcXG4gICAgfVxcblxcbiAgICAubm90aWZpY2F0aW9uIC5kZWxldGUge1xcbiAgICAgICAgcmlnaHQ6IDAuNXJlbTtcXG4gICAgICAgIHRvcDogMC41cmVtO1xcbiAgICB9XFxuXFxuICAgICNjbG9zZV9hbGwge1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiYSg1NCwgNTQsIDU0LCAwLjkpO1xcbiAgICAgICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICAgICAgcG9zaXRpb246IGZpeGVkO1xcbiAgICAgICAgei1pbmRleDogMTtcXG4gICAgICAgIHRvcDogMXJlbTtcXG4gICAgICAgIHJpZ2h0OiAxcmVtO1xcbiAgICAgICAgYm9yZGVyLXJhZGl1czogMTAwdnc7XFxuICAgIH1cXG4gICAgI2Nsb3NlX2FsbDpob3ZlcntcXG4gICAgICAgIGJhY2tncm91bmQtY29sb3I6IHJnYig1NCwgNTQsIDU0KTtcXG4gICAgfVxcblxcbiAgICAjY2xvc2VfYWxsIC5kZWxldGUge1xcbiAgICAgICAgbWFyZ2luLWxlZnQ6IDAuMjVyZW07XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IC0wLjM3NXJlbTtcXG4gICAgfVxcbjwvc3R5bGU+XFxuXFxuPHNjcmlwdD5cXG5leHBvcnQgZGVmYXVsdCB7XFxuICAgIHByb3BzOiB7XFxuICAgICAgICB0aXRsZTogJycsXFxuICAgICAgICBib2R5OiAnJyxcXG4gICAgICAgIGljb246IHtcXG4gICAgICAgICAgICBkZWZhdWx0OiB0cnVlXFxuICAgICAgICB9LFxcbiAgICAgICAgdHlwZToge2RlZmF1bHQ6ICdpbmZvJ30sXFxuICAgICAgICBkdXJhdGlvbjogbnVsbFxcbiAgICB9LFxcblxcbiAgICBkYXRhKCkge1xcbiAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICBub3RpZl9ncm91cDogW10sXFxuICAgICAgICAgICAgc2VsZl90aXRsZTogdGhpcy50aXRsZSxcXG4gICAgICAgICAgICBzZWxmX2JvZHk6IHRoaXMuYm9keSxcXG4gICAgICAgICAgICBzZWxmX3R5cGU6IHRoaXMudHlwZSxcXG4gICAgICAgICAgICBzZWxmX2ljb246IEJvb2xlYW4odGhpcy5pY29uKSxcXG4gICAgICAgICAgICBzZWxmX2R1cmF0aW9uOiB0aGlzLmR1cmF0aW9uLFxcbiAgICAgICAgICAgIHNlbGZfc2hvdzogZmFsc2VcXG4gICAgICAgIH1cXG4gICAgfSxcXG5cXG4gICAgY3JlYXRlZCgpIHtcXG4gICAgICAgIHRoaXMuY2hlY2tQcm9wKClcXG5cXG4gICAgICAgIEV2ZW50SHViLmxpc3Rlbignc2hvd05vdGlmJywgKGRhdGEpID0+IHtcXG4gICAgICAgICAgICB0aGlzLmNvbGxlY3REYXRhKGRhdGEpXFxuICAgICAgICB9KVxcbiAgICB9LFxcblxcbiAgICBtZXRob2RzOiB7XFxuICAgICAgICBjaGVja0Zvckdyb3VwKCkge1xcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmX2dyb3VwLmxlbmd0aCA+IDEgJiZcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZfZ3JvdXAuZmlsdGVyKChpdGVtKSA9PiBpdGVtLnNob3cgPT0gdHJ1ZSkubGVuZ3RoID4gMVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNsb3NlQWxsKCkge1xcbiAgICAgICAgICAgIHRoaXMubm90aWZfZ3JvdXAubWFwKChpdGVtKSA9PiB7XFxuICAgICAgICAgICAgICAgIGl0ZW0uc2hvdyA9IGZhbHNlXFxuICAgICAgICAgICAgICAgIGl0ZW0uZHVyYXRpb24gPSBudWxsXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBjaGVja1Byb3AoKSB7XFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZl90aXRsZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLnNlbGZfc2hvdyA9IHRydWVcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaWYgKHRoaXMuc2VsZl9kdXJhdGlvbiAhPT0gdW5kZWZpbmVkKSB7XFxuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxmX3Nob3cgPSBmYWxzZVxcbiAgICAgICAgICAgICAgICB9LCB0aGlzLnNlbGZfZHVyYXRpb24gKiAxMDAwKVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH0sXFxuICAgICAgICBjb2xsZWN0RGF0YShkYXRhKSB7XFxuICAgICAgICAgICAgdGhpcy5ub3RpZl9ncm91cC5wdXNoKHtcXG4gICAgICAgICAgICAgICAgdGl0bGU6IGRhdGEudGl0bGUsXFxuICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEuYm9keSxcXG4gICAgICAgICAgICAgICAgdHlwZTogZGF0YS50eXBlLFxcbiAgICAgICAgICAgICAgICBpY29uOiBkYXRhLmljb24gPT0gbnVsbCA/IHRydWUgOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgZHVyYXRpb246IGRhdGEuZHVyYXRpb24sXFxuICAgICAgICAgICAgICAgIG9uQ2xvc2U6IGRhdGEub25DbG9zZSxcXG4gICAgICAgICAgICAgICAgc2hvdzogdHJ1ZVxcbiAgICAgICAgICAgIH0pXFxuICAgICAgICB9LFxcbiAgICAgICAgSXNWaXNpYmxlKGluZGV4KSB7XFxuICAgICAgICAgICAgbGV0IGR1ciA9IHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLmR1cmF0aW9uXFxuXFxuICAgICAgICAgICAgaWYgKGR1ciAhPSB1bmRlZmluZWQgfHwgZHVyICE9IG51bGwpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLmNsb3NlTm90aWYoaW5kZXgpXFxuICAgICAgICAgICAgICAgIH0sIGR1ciAqIDEwMDApXFxuICAgICAgICAgICAgfVxcblxcbiAgICAgICAgICAgIHJldHVybiB0aGlzLm5vdGlmX2dyb3VwW2luZGV4XS5zaG93XFxuICAgICAgICB9LFxcbiAgICAgICAgY2xvc2VOb3RpZihpbmRleCkge1xcbiAgICAgICAgICAgIHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLnNob3cgPSBmYWxzZVxcblxcbiAgICAgICAgICAgIGlmICh0eXBlb2YgdGhpcy5ub3RpZl9ncm91cFtpbmRleF0ub25DbG9zZSAhPT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLm9uQ2xvc2UgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICAgICAgdGhpcy5ub3RpZl9ncm91cFtpbmRleF0ub25DbG9zZSgpXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNsYXNzT2JqKHR5cGUpIHtcXG4gICAgICAgICAgICByZXR1cm4gYG5vdGlmaWNhdGlvbiBoYXMtc2hhZG93IGlzLSR7dHlwZX1gXFxuICAgICAgICB9LFxcbiAgICAgICAgZ2V0SWNvbih0eXBlKSB7XFxuICAgICAgICAgICAgc3dpdGNoICh0eXBlKSB7XFxuICAgICAgICAgICAgY2FzZSAncHJpbWFyeSc6XFxuICAgICAgICAgICAgICAgIHJldHVybiAndHJhY2tfY2hhbmdlcydcXG4gICAgICAgICAgICBjYXNlICdzdWNjZXNzJzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdjaGVja19jaXJjbGUnXFxuICAgICAgICAgICAgY2FzZSAnaW5mbyc6XFxuICAgICAgICAgICAgICAgIHJldHVybiAnbGl2ZV9oZWxwJ1xcbiAgICAgICAgICAgIGNhc2UgJ3dhcm5pbmcnOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ3Bvd2VyX3NldHRpbmdzX25ldydcXG4gICAgICAgICAgICBjYXNlICdkYW5nZXInOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2FkZF9hbGVydCdcXG4gICAgICAgICAgICBkZWZhdWx0OlxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2Vycm9yJ1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcbn1cXG48L3NjcmlwdD5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNjRkODE3YzNcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi02NGQ4MTdjM1wiLFwic2NvcGVkXCI6ZmFsc2UsXCJoYXNJbmxpbmVDb25maWdcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiQGltcG9ydCB1cmwoaHR0cHM6Ly9mb250cy5nb29nbGVhcGlzLmNvbS9pY29uP2ZhbWlseT1NYXRlcmlhbCtJY29ucyk7XCIsIFwiXCJdKTtcblxuLy8gbW9kdWxlXG5leHBvcnRzLnB1c2goW21vZHVsZS5pZCwgXCJcXG4vKmFuaW1hdGlvbiovXFxuLnNsaWRlLWZhZGUtZW50ZXItYWN0aXZlW2RhdGEtdi02NGQ4MTdjM10sXFxuLnNsaWRlLWZhZGUtbGVhdmUtYWN0aXZlW2RhdGEtdi02NGQ4MTdjM10ge1xcbiAgICAtd2Via2l0LXRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxuICAgIHRyYW5zaXRpb246IGFsbCAwLjNzIGVhc2U7XFxufVxcbi5zbGlkZS1mYWRlLWVudGVyW2RhdGEtdi02NGQ4MTdjM10sXFxuLnNsaWRlLWZhZGUtbGVhdmUtdG9bZGF0YS12LTY0ZDgxN2MzXSB7XFxuICAgIG9wYWNpdHk6IDA7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwcHgpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogdHJhbnNsYXRlWCgxMHB4KTtcXG59XFxuXFxuLypub3RpaWZjYXRpb24gY2FyZCovXFxuLml0ZW1bZGF0YS12LTY0ZDgxN2MzXSB7XFxuICAgIHdpZHRoOiAzMzBweDtcXG59XFxuLm1hdGVyaWFsLWljb25zW2RhdGEtdi02NGQ4MTdjM10ge1xcbiAgICBmb250LXNpemU6IDNyZW07XFxufVxcbi5tZWRpYS1sZWZ0W2RhdGEtdi02NGQ4MTdjM10ge1xcbiAgICAtbXMtZmxleC1pdGVtLWFsaWduOiBjZW50ZXI7XFxuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgIHBvc2l0aW9uOiByZWxhdGl2ZTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAxLjI1cmVtO1xcbn1cXG4uaGFzLXNoYWRvd1tkYXRhLXYtNjRkODE3YzNdIHtcXG4gICAgLXdlYmtpdC1ib3gtc2hhZG93OiAwIDJweCA0cHggcmdiYSgwLDAsMCwwLjEyKSwgMCAwIDZweCByZ2JhKDAsMCwwLDAuMDQpO1xcbiAgICAgICAgICAgIGJveC1zaGFkb3c6IDAgMnB4IDRweCByZ2JhKDAsMCwwLDAuMTIpLCAwIDAgNnB4IHJnYmEoMCwwLDAsMC4wNCk7XFxufVxcbi5ub3RpZmljYXRpb25bZGF0YS12LTY0ZDgxN2MzXSB7XFxuICAgIHBhZGRpbmc6IDEuMjVyZW07XFxuICAgIG1hcmdpbi1ib3R0b206IDEwcHg7XFxufVxcbi5ub3RpZmljYXRpb24gLmRlbGV0ZVtkYXRhLXYtNjRkODE3YzNdIHtcXG4gICAgcmlnaHQ6IDAuNXJlbTtcXG4gICAgdG9wOiAwLjVyZW07XFxufVxcbiNjbG9zZV9hbGxbZGF0YS12LTY0ZDgxN2MzXSB7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYmEoNTQsIDU0LCA1NCwgMC45KTtcXG4gICAgY3Vyc29yOiBwb2ludGVyO1xcbiAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgIHotaW5kZXg6IDE7XFxuICAgIHRvcDogMXJlbTtcXG4gICAgcmlnaHQ6IDFyZW07XFxuICAgIGJvcmRlci1yYWRpdXM6IDEwMHZ3O1xcbn1cXG4jY2xvc2VfYWxsW2RhdGEtdi02NGQ4MTdjM106aG92ZXJ7XFxuICAgIGJhY2tncm91bmQtY29sb3I6IHJnYig1NCwgNTQsIDU0KTtcXG59XFxuI2Nsb3NlX2FsbCAuZGVsZXRlW2RhdGEtdi02NGQ4MTdjM10ge1xcbiAgICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcXG4gICAgbWFyZ2luLXJpZ2h0OiAtMC4zNzVyZW07XFxufVxcblwiLCBcIlwiLCB7XCJ2ZXJzaW9uXCI6MyxcInNvdXJjZXNcIjpbXCIvVXNlcnMva2FiYm91Y2hpL1NpdGVzL2xhcmF2ZWwtbGluZ28vcGFja2FnZXMvY3RmMC9saW5nby9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlPzY4ZDFhNWFhXCJdLFwibmFtZXNcIjpbXSxcIm1hcHBpbmdzXCI6XCI7QUF1RUEsYUFBQTtBQUNBOztJQUVBLGtDQUFBO0lBQUEsMEJBQUE7Q0FDQTtBQUNBOztJQUVBLFdBQUE7SUFDQSxvQ0FBQTtZQUFBLDRCQUFBO0NBQ0E7O0FBRUEscUJBQUE7QUFDQTtJQUNBLGFBQUE7Q0FDQTtBQUNBO0lBQ0EsZ0JBQUE7Q0FDQTtBQUNBO0lBQ0EsNEJBQUE7UUFBQSxtQkFBQTtJQUNBLG1CQUFBO0lBQ0Esc0JBQUE7Q0FDQTtBQUVBO0lBQ0EseUVBQUE7WUFBQSxpRUFBQTtDQUNBO0FBQ0E7SUFDQSxpQkFBQTtJQUNBLG9CQUFBO0NBQ0E7QUFFQTtJQUNBLGNBQUE7SUFDQSxZQUFBO0NBQ0E7QUFFQTtJQUNBLHdDQUFBO0lBQ0EsZ0JBQUE7SUFDQSxnQkFBQTtJQUNBLFdBQUE7SUFDQSxVQUFBO0lBQ0EsWUFBQTtJQUNBLHFCQUFBO0NBQ0E7QUFDQTtJQUNBLGtDQUFBO0NBQ0E7QUFFQTtJQUNBLHFCQUFBO0lBQ0Esd0JBQUE7Q0FDQVwiLFwiZmlsZVwiOlwiTm90aWZpY2F0aW9uLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICAgIDxkaXY+XFxuICAgICAgICA8IS0tIHNpbmdsZSAtLT5cXG4gICAgICAgIDx0cmFuc2l0aW9uIG5hbWU9XFxcInNsaWRlLWZhZGVcXFwiIHYtaWY9XFxcInNlbGZfc2hvd1xcXCI+XFxuICAgICAgICAgICAgPGRpdiA6Y2xhc3M9XFxcImNsYXNzT2JqKHNlbGZfdHlwZSlcXFwiIGNsYXNzPVxcXCJpdGVtXFxcIj5cXG5cXG4gICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlXFxcIiBAY2xpY2s9XFxcInNlbGZfc2hvdyA9IGZhbHNlXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVkaWFcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVkaWEtbGVmdFxcXCIgdi1pZj1cXFwic2VsZl9pY29uXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZmlndXJlIGNsYXNzPVxcXCJpY29uIGlzLWxhcmdlXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zXFxcIj57eyBnZXRJY29uKHNlbGZfdHlwZSkgfX08L2k+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9maWd1cmU+XFxuICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhLWNvbnRlbnRcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cXFwidGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICA8c3Ryb25nPnt7IHNlbGZfdGl0bGUgfX08L3N0cm9uZz5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2g0PlxcbiAgICAgICAgICAgICAgICAgICAgICAgIDxwIGNsYXNzPVxcXCJzdWJ0aXRsZVxcXCI+e3sgc2VsZl9ib2R5IH19PC9wPlxcbiAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgIDwvZGl2PlxcbiAgICAgICAgPC90cmFuc2l0aW9uPlxcblxcbiAgICAgICAgPCEtLSBldmVudHMgLS0+XFxuICAgICAgICA8dGVtcGxhdGUgdi1pZj1cXFwiIXNlbGZfdGl0bGVcXFwiPlxcbiAgICAgICAgICAgIDxzcGFuIGlkPVxcXCJjbG9zZV9hbGxcXFwiIGNsYXNzPVxcXCJ0YWcgaXMtZGFyayBpcy1tZWRpdW1cXFwiXFxuICAgICAgICAgICAgICAgIHYtaWY9XFxcImNoZWNrRm9yR3JvdXAoKVxcXCIgQGNsaWNrPVxcXCJjbG9zZUFsbCgpXFxcIj5cXG4gICAgICAgICAgICAgICAgQ2xvc2UgQWxsXFxuICAgICAgICAgICAgICAgIDxidXR0b24gY2xhc3M9XFxcImRlbGV0ZVxcXCI+PC9idXR0b24+XFxuICAgICAgICAgICAgPC9zcGFuPlxcblxcbiAgICAgICAgICAgIDx0cmFuc2l0aW9uLWdyb3VwIG5hbWU9XFxcInNsaWRlLWZhZGVcXFwiIHRhZz1cXFwidWxcXFwiPlxcbiAgICAgICAgICAgICAgICA8bGkgdi1mb3I9XFxcIihvbmUsaW5kZXgpIGluIG5vdGlmX2dyb3VwXFxcIiA6a2V5PVxcXCJpbmRleFxcXCJcXG4gICAgICAgICAgICAgICAgICAgIGNsYXNzPVxcXCJpdGVtXFxcIiA6Y2xhc3M9XFxcImNsYXNzT2JqKG9uZS50eXBlKVxcXCJcXG4gICAgICAgICAgICAgICAgICAgIHYtaWY9XFxcIklzVmlzaWJsZShpbmRleClcXFwiPlxcblxcbiAgICAgICAgICAgICAgICAgICAgPGJ1dHRvbiBjbGFzcz1cXFwiZGVsZXRlXFxcIiBAY2xpY2s9XFxcImNsb3NlTm90aWYoaW5kZXgpXFxcIj48L2J1dHRvbj5cXG4gICAgICAgICAgICAgICAgICAgIDxkaXYgY2xhc3M9XFxcIm1lZGlhXFxcIj5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8ZGl2IGNsYXNzPVxcXCJtZWRpYS1sZWZ0XFxcIiB2LWlmPVxcXCJvbmUuaWNvblxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxmaWd1cmUgY2xhc3M9XFxcImljb24gaXMtbGFyZ2VcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPGkgY2xhc3M9XFxcIm1hdGVyaWFsLWljb25zXFxcIj57eyBnZXRJY29uKG9uZS50eXBlKSB9fTwvaT5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9maWd1cmU+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPC9kaXY+XFxuICAgICAgICAgICAgICAgICAgICAgICAgPGRpdiBjbGFzcz1cXFwibWVkaWEtY29udGVudFxcXCI+XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDxoNCBjbGFzcz1cXFwidGl0bGVcXFwiPlxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPHN0cm9uZz57eyBvbmUudGl0bGUgfX08L3N0cm9uZz5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPC9oND5cXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPHAgY2xhc3M9XFxcInN1YnRpdGxlXFxcIj57eyBvbmUuYm9keSB9fTwvcD5cXG4gICAgICAgICAgICAgICAgICAgICAgICA8L2Rpdj5cXG4gICAgICAgICAgICAgICAgICAgIDwvZGl2PlxcblxcbiAgICAgICAgICAgICAgICA8L2xpPlxcbiAgICAgICAgICAgIDwvdHJhbnNpdGlvbi1ncm91cD5cXG4gICAgICAgIDwvdGVtcGxhdGU+XFxuICAgIDwvZGl2PlxcbjwvdGVtcGxhdGU+XFxuXFxuPHN0eWxlPlxcbiAgICAubm90aWYtY29udGFpbmVyIHtcXG4gICAgICAgIHBhZGRpbmc6IDA7XFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgICB0b3A6IDRyZW07XFxuICAgICAgICByaWdodDogMXJlbTtcXG4gICAgICAgIHotaW5kZXg6IDEwMDAwO1xcbiAgICB9XFxuPC9zdHlsZT5cXG5cXG48c3R5bGUgc2NvcGVkPlxcbiAgICBAaW1wb3J0IHVybChodHRwczovL2ZvbnRzLmdvb2dsZWFwaXMuY29tL2ljb24/ZmFtaWx5PU1hdGVyaWFsK0ljb25zKTtcXG5cXG4gICAgLyphbmltYXRpb24qL1xcbiAgICAuc2xpZGUtZmFkZS1lbnRlci1hY3RpdmUsXFxuICAgIC5zbGlkZS1mYWRlLWxlYXZlLWFjdGl2ZSB7XFxuICAgICAgICB0cmFuc2l0aW9uOiBhbGwgMC4zcyBlYXNlO1xcbiAgICB9XFxuICAgIC5zbGlkZS1mYWRlLWVudGVyLFxcbiAgICAuc2xpZGUtZmFkZS1sZWF2ZS10byB7XFxuICAgICAgICBvcGFjaXR5OiAwO1xcbiAgICAgICAgdHJhbnNmb3JtOiB0cmFuc2xhdGVYKDEwcHgpO1xcbiAgICB9XFxuXFxuICAgIC8qbm90aWlmY2F0aW9uIGNhcmQqL1xcbiAgICAuaXRlbSB7XFxuICAgICAgICB3aWR0aDogMzMwcHg7XFxuICAgIH1cXG4gICAgLm1hdGVyaWFsLWljb25zIHtcXG4gICAgICAgIGZvbnQtc2l6ZTogM3JlbTtcXG4gICAgfVxcbiAgICAubWVkaWEtbGVmdCB7XFxuICAgICAgICBhbGlnbi1zZWxmOiBjZW50ZXI7XFxuICAgICAgICBwb3NpdGlvbjogcmVsYXRpdmU7XFxuICAgICAgICBtYXJnaW4tcmlnaHQ6IDEuMjVyZW07XFxuICAgIH1cXG5cXG4gICAgLmhhcy1zaGFkb3cge1xcbiAgICAgICAgYm94LXNoYWRvdzogMCAycHggNHB4IHJnYmEoMCwwLDAsMC4xMiksIDAgMCA2cHggcmdiYSgwLDAsMCwwLjA0KTtcXG4gICAgfVxcbiAgICAubm90aWZpY2F0aW9uIHtcXG4gICAgICAgIHBhZGRpbmc6IDEuMjVyZW07XFxuICAgICAgICBtYXJnaW4tYm90dG9tOiAxMHB4O1xcbiAgICB9XFxuXFxuICAgIC5ub3RpZmljYXRpb24gLmRlbGV0ZSB7XFxuICAgICAgICByaWdodDogMC41cmVtO1xcbiAgICAgICAgdG9wOiAwLjVyZW07XFxuICAgIH1cXG5cXG4gICAgI2Nsb3NlX2FsbCB7XFxuICAgICAgICBiYWNrZ3JvdW5kLWNvbG9yOiByZ2JhKDU0LCA1NCwgNTQsIDAuOSk7XFxuICAgICAgICBjdXJzb3I6IHBvaW50ZXI7XFxuICAgICAgICBwb3NpdGlvbjogZml4ZWQ7XFxuICAgICAgICB6LWluZGV4OiAxO1xcbiAgICAgICAgdG9wOiAxcmVtO1xcbiAgICAgICAgcmlnaHQ6IDFyZW07XFxuICAgICAgICBib3JkZXItcmFkaXVzOiAxMDB2dztcXG4gICAgfVxcbiAgICAjY2xvc2VfYWxsOmhvdmVye1xcbiAgICAgICAgYmFja2dyb3VuZC1jb2xvcjogcmdiKDU0LCA1NCwgNTQpO1xcbiAgICB9XFxuXFxuICAgICNjbG9zZV9hbGwgLmRlbGV0ZSB7XFxuICAgICAgICBtYXJnaW4tbGVmdDogMC4yNXJlbTtcXG4gICAgICAgIG1hcmdpbi1yaWdodDogLTAuMzc1cmVtO1xcbiAgICB9XFxuPC9zdHlsZT5cXG5cXG48c2NyaXB0PlxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gICAgcHJvcHM6IHtcXG4gICAgICAgIHRpdGxlOiAnJyxcXG4gICAgICAgIGJvZHk6ICcnLFxcbiAgICAgICAgaWNvbjoge1xcbiAgICAgICAgICAgIGRlZmF1bHQ6IHRydWVcXG4gICAgICAgIH0sXFxuICAgICAgICB0eXBlOiB7ZGVmYXVsdDogJ2luZm8nfSxcXG4gICAgICAgIGR1cmF0aW9uOiBudWxsXFxuICAgIH0sXFxuXFxuICAgIGRhdGEoKSB7XFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICAgIG5vdGlmX2dyb3VwOiBbXSxcXG4gICAgICAgICAgICBzZWxmX3RpdGxlOiB0aGlzLnRpdGxlLFxcbiAgICAgICAgICAgIHNlbGZfYm9keTogdGhpcy5ib2R5LFxcbiAgICAgICAgICAgIHNlbGZfdHlwZTogdGhpcy50eXBlLFxcbiAgICAgICAgICAgIHNlbGZfaWNvbjogQm9vbGVhbih0aGlzLmljb24pLFxcbiAgICAgICAgICAgIHNlbGZfZHVyYXRpb246IHRoaXMuZHVyYXRpb24sXFxuICAgICAgICAgICAgc2VsZl9zaG93OiBmYWxzZVxcbiAgICAgICAgfVxcbiAgICB9LFxcblxcbiAgICBjcmVhdGVkKCkge1xcbiAgICAgICAgdGhpcy5jaGVja1Byb3AoKVxcblxcbiAgICAgICAgRXZlbnRIdWIubGlzdGVuKCdzaG93Tm90aWYnLCAoZGF0YSkgPT4ge1xcbiAgICAgICAgICAgIHRoaXMuY29sbGVjdERhdGEoZGF0YSlcXG4gICAgICAgIH0pXFxuICAgIH0sXFxuXFxuICAgIG1ldGhvZHM6IHtcXG4gICAgICAgIGNoZWNrRm9yR3JvdXAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZfZ3JvdXAubGVuZ3RoID4gMSAmJlxcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZl9ncm91cC5maWx0ZXIoKGl0ZW0pID0+IGl0ZW0uc2hvdyA9PSB0cnVlKS5sZW5ndGggPiAxXFxuICAgICAgICB9LFxcbiAgICAgICAgY2xvc2VBbGwoKSB7XFxuICAgICAgICAgICAgdGhpcy5ub3RpZl9ncm91cC5tYXAoKGl0ZW0pID0+IHtcXG4gICAgICAgICAgICAgICAgaXRlbS5zaG93ID0gZmFsc2VcXG4gICAgICAgICAgICAgICAgaXRlbS5kdXJhdGlvbiA9IG51bGxcXG4gICAgICAgICAgICB9KVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNoZWNrUHJvcCgpIHtcXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxmX3RpdGxlKSB7XFxuICAgICAgICAgICAgICAgIHRoaXMuc2VsZl9zaG93ID0gdHJ1ZVxcbiAgICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgICBpZiAodGhpcy5zZWxmX2R1cmF0aW9uICE9PSB1bmRlZmluZWQpIHtcXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGZfc2hvdyA9IGZhbHNlXFxuICAgICAgICAgICAgICAgIH0sIHRoaXMuc2VsZl9kdXJhdGlvbiAqIDEwMDApXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSxcXG4gICAgICAgIGNvbGxlY3REYXRhKGRhdGEpIHtcXG4gICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwLnB1c2goe1xcbiAgICAgICAgICAgICAgICB0aXRsZTogZGF0YS50aXRsZSxcXG4gICAgICAgICAgICAgICAgYm9keTogZGF0YS5ib2R5LFxcbiAgICAgICAgICAgICAgICB0eXBlOiBkYXRhLnR5cGUsXFxuICAgICAgICAgICAgICAgIGljb246IGRhdGEuaWNvbiA9PSBudWxsID8gdHJ1ZSA6IGZhbHNlLFxcbiAgICAgICAgICAgICAgICBkdXJhdGlvbjogZGF0YS5kdXJhdGlvbixcXG4gICAgICAgICAgICAgICAgb25DbG9zZTogZGF0YS5vbkNsb3NlLFxcbiAgICAgICAgICAgICAgICBzaG93OiB0cnVlXFxuICAgICAgICAgICAgfSlcXG4gICAgICAgIH0sXFxuICAgICAgICBJc1Zpc2libGUoaW5kZXgpIHtcXG4gICAgICAgICAgICBsZXQgZHVyID0gdGhpcy5ub3RpZl9ncm91cFtpbmRleF0uZHVyYXRpb25cXG5cXG4gICAgICAgICAgICBpZiAoZHVyICE9IHVuZGVmaW5lZCB8fCBkdXIgIT0gbnVsbCkge1xcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KCgpID0+IHtcXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2xvc2VOb3RpZihpbmRleClcXG4gICAgICAgICAgICAgICAgfSwgZHVyICogMTAwMClcXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgcmV0dXJuIHRoaXMubm90aWZfZ3JvdXBbaW5kZXhdLnNob3dcXG4gICAgICAgIH0sXFxuICAgICAgICBjbG9zZU5vdGlmKGluZGV4KSB7XFxuICAgICAgICAgICAgdGhpcy5ub3RpZl9ncm91cFtpbmRleF0uc2hvdyA9IGZhbHNlXFxuXFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLm5vdGlmX2dyb3VwW2luZGV4XS5vbkNsb3NlICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2YgdGhpcy5ub3RpZl9ncm91cFtpbmRleF0ub25DbG9zZSA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmX2dyb3VwW2luZGV4XS5vbkNsb3NlKClcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9LFxcbiAgICAgICAgY2xhc3NPYmoodHlwZSkge1xcbiAgICAgICAgICAgIHJldHVybiBgbm90aWZpY2F0aW9uIGhhcy1zaGFkb3cgaXMtJHt0eXBlfWBcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXRJY29uKHR5cGUpIHtcXG4gICAgICAgICAgICBzd2l0Y2ggKHR5cGUpIHtcXG4gICAgICAgICAgICBjYXNlICdwcmltYXJ5JzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuICd0cmFja19jaGFuZ2VzJ1xcbiAgICAgICAgICAgIGNhc2UgJ3N1Y2Nlc3MnOlxcbiAgICAgICAgICAgICAgICByZXR1cm4gJ2NoZWNrX2NpcmNsZSdcXG4gICAgICAgICAgICBjYXNlICdpbmZvJzpcXG4gICAgICAgICAgICAgICAgcmV0dXJuICdsaXZlX2hlbHAnXFxuICAgICAgICAgICAgY2FzZSAnd2FybmluZyc6XFxuICAgICAgICAgICAgICAgIHJldHVybiAncG93ZXJfc2V0dGluZ3NfbmV3J1xcbiAgICAgICAgICAgIGNhc2UgJ2Rhbmdlcic6XFxuICAgICAgICAgICAgICAgIHJldHVybiAnYWRkX2FsZXJ0J1xcbiAgICAgICAgICAgIGRlZmF1bHQ6XFxuICAgICAgICAgICAgICAgIHJldHVybiAnZXJyb3InXFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICB9XFxufVxcbjwvc2NyaXB0PlxcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuXG4vLyBleHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi02NGQ4MTdjM1wiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNjRkODE3YzNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xJmJ1c3RDYWNoZSEuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZShcIi4uLy4uL2Nzcy1sb2FkZXIvbGliL2Nzcy1iYXNlLmpzXCIpKHRydWUpO1xuLy8gaW1wb3J0c1xuXG5cbi8vIG1vZHVsZVxuZXhwb3J0cy5wdXNoKFttb2R1bGUuaWQsIFwiXFxuLmZhLWljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZmlsbDogY3VycmVudENvbG9yO1xcbn1cXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcXG4gIC13ZWJraXQtdHJhbnNmb3JtOiBzY2FsZSgtMSwgMSk7XFxuICAgICAgICAgIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xcbn1cXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICAtd2Via2l0LXRyYW5zZm9ybTogc2NhbGUoMSwgLTEpO1xcbiAgICAgICAgICB0cmFuc2Zvcm06IHNjYWxlKDEsIC0xKTtcXG59XFxuLmZhLXNwaW4ge1xcbiAgLXdlYmtpdC1hbmltYXRpb246IGZhLXNwaW4gMXMgMHMgaW5maW5pdGUgbGluZWFyO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMXMgMHMgaW5maW5pdGUgbGluZWFyO1xcbn1cXG4uZmEtaW52ZXJzZSB7XFxuICBjb2xvcjogI2ZmZjtcXG59XFxuLmZhLXB1bHNlIHtcXG4gIC13ZWJraXQtYW5pbWF0aW9uOiBmYS1zcGluIDFzIGluZmluaXRlIHN0ZXBzKDgpO1xcbiAgICAgICAgICBhbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7XFxufVxcbkAtd2Via2l0LWtleWZyYW1lcyBmYS1zcGluIHtcXG4wJSB7XFxuICAgIC13ZWJraXQtdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMGRlZyk7XFxufVxcbjEwMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICAgICAgICAgICAgdHJhbnNmb3JtOiByb3RhdGUoMzYwZGVnKTtcXG59XFxufVxcbkBrZXlmcmFtZXMgZmEtc3BpbiB7XFxuMCUge1xcbiAgICAtd2Via2l0LXRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbn1cXG4xMDAlIHtcXG4gICAgLXdlYmtpdC10cmFuc2Zvcm06IHJvdGF0ZSgzNjBkZWcpO1xcbiAgICAgICAgICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxufVxcbn1cXG5cIiwgXCJcIiwge1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wiL1VzZXJzL2thYmJvdWNoaS9TaXRlcy9sYXJhdmVsLWxpbmdvL3BhY2thZ2VzL2N0ZjAvbGluZ28vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWU/MjFhMjY5ODJcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIjtBQXdCQTtFQUNBLHNCQUFBO0VBQ0EsbUJBQUE7Q0FDQTtBQUVBO0VBQ0EsZ0NBQUE7VUFBQSx3QkFBQTtDQUNBO0FBRUE7RUFDQSxnQ0FBQTtVQUFBLHdCQUFBO0NBQ0E7QUFFQTtFQUNBLGlEQUFBO1VBQUEseUNBQUE7Q0FDQTtBQUVBO0VBQ0EsWUFBQTtDQUNBO0FBRUE7RUFDQSxnREFBQTtVQUFBLHdDQUFBO0NBQ0E7QUFFQTtBQUNBO0lBQ0EsZ0NBQUE7WUFBQSx3QkFBQTtDQUNBO0FBQ0E7SUFDQSxrQ0FBQTtZQUFBLDBCQUFBO0NBQ0E7Q0FDQTtBQVBBO0FBQ0E7SUFDQSxnQ0FBQTtZQUFBLHdCQUFBO0NBQ0E7QUFDQTtJQUNBLGtDQUFBO1lBQUEsMEJBQUE7Q0FDQTtDQUNBXCIsXCJmaWxlXCI6XCJJY29uLnZ1ZVwiLFwic291cmNlc0NvbnRlbnRcIjpbXCI8dGVtcGxhdGU+XFxuICA8c3ZnIHZlcnNpb249XFxcIjEuMVxcXCJcXG4gICAgOmNsYXNzPVxcXCJrbGFzc1xcXCJcXG4gICAgOnJvbGU9XFxcImxhYmVsID8gJ2ltZycgOiAncHJlc2VudGF0aW9uJ1xcXCJcXG4gICAgOmFyaWEtbGFiZWw9XFxcImxhYmVsXFxcIlxcbiAgICA6eD1cXFwieFxcXCJcXG4gICAgOnk9XFxcInlcXFwiXFxuICAgIDp3aWR0aD1cXFwid2lkdGhcXFwiXFxuICAgIDpoZWlnaHQ9XFxcImhlaWdodFxcXCJcXG4gICAgOnZpZXdCb3g9XFxcImJveFxcXCJcXG4gICAgOnN0eWxlPVxcXCJzdHlsZVxcXCI+XFxuICAgIDxzbG90PlxcbiAgICAgIDx0ZW1wbGF0ZSB2LWlmPVxcXCJpY29uICYmIGljb24ucGF0aHNcXFwiPlxcbiAgICAgICAgPHBhdGggdi1mb3I9XFxcIihwYXRoLCBpKSBpbiBpY29uLnBhdGhzXFxcIiA6a2V5PVxcXCJgcGF0aC0ke2l9YFxcXCIgdi1iaW5kPVxcXCJwYXRoXFxcIi8+XFxuICAgICAgPC90ZW1wbGF0ZT5cXG4gICAgICA8dGVtcGxhdGUgdi1pZj1cXFwiaWNvbiAmJiBpY29uLnBvbHlnb25zXFxcIj5cXG4gICAgICAgIDxwb2x5Z29uIHYtZm9yPVxcXCIocG9seWdvbiwgaSkgaW4gaWNvbi5wb2x5Z29uc1xcXCIgOmtleT1cXFwiYHBvbHlnb24tJHtpfWBcXFwiIHYtYmluZD1cXFwicG9seWdvblxcXCIvPlxcbiAgICAgIDwvdGVtcGxhdGU+XFxiXFxuICAgICAgPHRlbXBsYXRlIHYtaWY9XFxcImljb24gJiYgaWNvbi5yYXdcXFwiPjxnIHYtaHRtbD1cXFwicmF3XFxcIj48L2c+PC90ZW1wbGF0ZT5cXG4gICAgPC9zbG90PlxcbiAgPC9zdmc+XFxuPC90ZW1wbGF0ZT5cXG5cXG48c3R5bGU+XFxuLmZhLWljb24ge1xcbiAgZGlzcGxheTogaW5saW5lLWJsb2NrO1xcbiAgZmlsbDogY3VycmVudENvbG9yO1xcbn1cXG5cXG4uZmEtZmxpcC1ob3Jpem9udGFsIHtcXG4gIHRyYW5zZm9ybTogc2NhbGUoLTEsIDEpO1xcbn1cXG5cXG4uZmEtZmxpcC12ZXJ0aWNhbCB7XFxuICB0cmFuc2Zvcm06IHNjYWxlKDEsIC0xKTtcXG59XFxuXFxuLmZhLXNwaW4ge1xcbiAgYW5pbWF0aW9uOiBmYS1zcGluIDFzIDBzIGluZmluaXRlIGxpbmVhcjtcXG59XFxuXFxuLmZhLWludmVyc2Uge1xcbiAgY29sb3I6ICNmZmY7XFxufVxcblxcbi5mYS1wdWxzZSB7XFxuICBhbmltYXRpb246IGZhLXNwaW4gMXMgaW5maW5pdGUgc3RlcHMoOCk7XFxufVxcblxcbkBrZXlmcmFtZXMgZmEtc3BpbiB7XFxuICAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDBkZWcpO1xcbiAgfVxcbiAgMTAwJSB7XFxuICAgIHRyYW5zZm9ybTogcm90YXRlKDM2MGRlZyk7XFxuICB9XFxufVxcbjwvc3R5bGU+XFxuXFxuPHNjcmlwdD5cXG5sZXQgaWNvbnMgPSB7fVxcblxcbmV4cG9ydCBkZWZhdWx0IHtcXG4gIG5hbWU6ICdpY29uJyxcXG4gIHByb3BzOiB7XFxuICAgIG5hbWU6IHtcXG4gICAgICB0eXBlOiBTdHJpbmcsXFxuICAgICAgdmFsaWRhdG9yICh2YWwpIHtcXG4gICAgICAgIGlmICh2YWwpIHtcXG4gICAgICAgICAgaWYgKCEodmFsIGluIGljb25zKSkge1xcbiAgICAgICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwcm9wOiBwcm9wIFxcXCJuYW1lXFxcIiBpcyByZWZlcnJpbmcgdG8gYW4gdW5yZWdpc3RlcmVkIGljb24gXFxcIiR7dmFsfVxcXCIuYCArXFxuICAgICAgICAgICAgICBgXFxcXG5QbGVzYXNlIG1ha2Ugc3VyZSB5b3UgaGF2ZSBpbXBvcnRlZCB0aGlzIGljb24gYmVmb3JlIHVzaW5nIGl0LmApXFxuICAgICAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgICAgIH1cXG4gICAgICAgICAgcmV0dXJuIHRydWVcXG4gICAgICAgIH1cXG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwcm9wOiBwcm9wIFxcXCJuYW1lXFxcIiBpcyByZXF1aXJlZC5gKVxcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBzY2FsZTogW051bWJlciwgU3RyaW5nXSxcXG4gICAgc3BpbjogQm9vbGVhbixcXG4gICAgaW52ZXJzZTogQm9vbGVhbixcXG4gICAgcHVsc2U6IEJvb2xlYW4sXFxuICAgIGZsaXA6IHtcXG4gICAgICB2YWxpZGF0b3IgKHZhbCkge1xcbiAgICAgICAgcmV0dXJuIHZhbCA9PT0gJ2hvcml6b250YWwnIHx8IHZhbCA9PT0gJ3ZlcnRpY2FsJ1xcbiAgICAgIH1cXG4gICAgfSxcXG4gICAgbGFiZWw6IFN0cmluZ1xcbiAgfSxcXG4gIGRhdGEgKCkge1xcbiAgICByZXR1cm4ge1xcbiAgICAgIHg6IGZhbHNlLFxcbiAgICAgIHk6IGZhbHNlLFxcbiAgICAgIGNoaWxkcmVuV2lkdGg6IDAsXFxuICAgICAgY2hpbGRyZW5IZWlnaHQ6IDAsXFxuICAgICAgb3V0ZXJTY2FsZTogMVxcbiAgICB9XFxuICB9LFxcbiAgY29tcHV0ZWQ6IHtcXG4gICAgbm9ybWFsaXplZFNjYWxlICgpIHtcXG4gICAgICBsZXQgc2NhbGUgPSB0aGlzLnNjYWxlXFxuICAgICAgc2NhbGUgPSB0eXBlb2Ygc2NhbGUgPT09ICd1bmRlZmluZWQnID8gMSA6IE51bWJlcihzY2FsZSlcXG4gICAgICBpZiAoaXNOYU4oc2NhbGUpIHx8IHNjYWxlIDw9IDApIHtcXG4gICAgICAgIGNvbnNvbGUud2FybihgSW52YWxpZCBwcm9wOiBwcm9wIFxcXCJzY2FsZVxcXCIgc2hvdWxkIGJlIGEgbnVtYmVyIG92ZXIgMC5gLCB0aGlzKVxcbiAgICAgICAgcmV0dXJuIHRoaXMub3V0ZXJTY2FsZVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gc2NhbGUgKiB0aGlzLm91dGVyU2NhbGVcXG4gICAgfSxcXG4gICAga2xhc3MgKCkge1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICAnZmEtaWNvbic6IHRydWUsXFxuICAgICAgICAnZmEtc3Bpbic6IHRoaXMuc3BpbixcXG4gICAgICAgICdmYS1mbGlwLWhvcml6b250YWwnOiB0aGlzLmZsaXAgPT09ICdob3Jpem9udGFsJyxcXG4gICAgICAgICdmYS1mbGlwLXZlcnRpY2FsJzogdGhpcy5mbGlwID09PSAndmVydGljYWwnLFxcbiAgICAgICAgJ2ZhLWludmVyc2UnOiB0aGlzLmludmVyc2UsXFxuICAgICAgICAnZmEtcHVsc2UnOiB0aGlzLnB1bHNlXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICBpY29uICgpIHtcXG4gICAgICBpZiAodGhpcy5uYW1lKSB7XFxuICAgICAgICByZXR1cm4gaWNvbnNbdGhpcy5uYW1lXVxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gbnVsbFxcbiAgICB9LFxcbiAgICBib3ggKCkge1xcbiAgICAgIGlmICh0aGlzLmljb24pIHtcXG4gICAgICAgIHJldHVybiBgMCAwICR7dGhpcy5pY29uLndpZHRofSAke3RoaXMuaWNvbi5oZWlnaHR9YFxcbiAgICAgIH1cXG4gICAgICByZXR1cm4gYDAgMCAke3RoaXMud2lkdGh9ICR7dGhpcy5oZWlnaHR9YFxcbiAgICB9LFxcbiAgICByYXRpbyAoKSB7XFxuICAgICAgaWYgKCF0aGlzLmljb24pIHtcXG4gICAgICAgIHJldHVybiAxXFxuICAgICAgfVxcbiAgICAgIGxldCB7IHdpZHRoLCBoZWlnaHQgfSA9IHRoaXMuaWNvblxcbiAgICAgIHJldHVybiBNYXRoLm1heCh3aWR0aCwgaGVpZ2h0KSAvIDE2XFxuICAgIH0sXFxuICAgIHdpZHRoICgpIHtcXG4gICAgICByZXR1cm4gdGhpcy5jaGlsZHJlbldpZHRoIHx8IHRoaXMuaWNvbiAmJiB0aGlzLmljb24ud2lkdGggLyB0aGlzLnJhdGlvICogdGhpcy5ub3JtYWxpemVkU2NhbGUgfHwgMFxcbiAgICB9LFxcbiAgICBoZWlnaHQgKCkge1xcbiAgICAgIHJldHVybiB0aGlzLmNoaWxkcmVuSGVpZ2h0IHx8IHRoaXMuaWNvbiAmJiB0aGlzLmljb24uaGVpZ2h0IC8gdGhpcy5yYXRpbyAqIHRoaXMubm9ybWFsaXplZFNjYWxlIHx8IDBcXG4gICAgfSxcXG4gICAgc3R5bGUgKCkge1xcbiAgICAgIGlmICh0aGlzLm5vcm1hbGl6ZWRTY2FsZSA9PT0gMSkge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlXFxuICAgICAgfVxcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBmb250U2l6ZTogdGhpcy5ub3JtYWxpemVkU2NhbGUgKyAnZW0nXFxuICAgICAgfVxcbiAgICB9LFxcbiAgICByYXcgKCkge1xcbiAgICAgIC8vIGdlbmVyYXRlIHVuaXF1ZSBpZCBmb3IgZWFjaCBpY29uJ3MgU1ZHIGVsZW1lbnQgd2l0aCBJRFxcbiAgICAgIGlmICghdGhpcy5pY29uIHx8ICF0aGlzLmljb24ucmF3KSB7XFxuICAgICAgICByZXR1cm4gbnVsbFxcbiAgICAgIH1cXG4gICAgICBsZXQgcmF3ID0gdGhpcy5pY29uLnJhd1xcbiAgICAgIGxldCBpZHMgPSB7fVxcbiAgICAgIHJhdyA9IHJhdy5yZXBsYWNlKC9cXFxccyg/OnhtbDopP2lkPVtcXFwiJ10/KFteXFxcIicpXFxcXHNdKykvZywgKG1hdGNoLCBpZCkgPT4ge1xcbiAgICAgICAgbGV0IHVuaXF1ZUlkID0gZ2V0SWQoKVxcbiAgICAgICAgaWRzW2lkXSA9IHVuaXF1ZUlkXFxuICAgICAgICByZXR1cm4gYCBpZD1cXFwiJHt1bmlxdWVJZH1cXFwiYFxcbiAgICAgIH0pXFxuICAgICAgcmF3ID0gcmF3LnJlcGxhY2UoLyMoPzooW14nXFxcIilcXFxcc10rKXx4cG9pbnRlclxcXFwoaWRcXFxcKChbJ1xcXCJdPykoW14nKV0rKVxcXFwyXFxcXClcXFxcKSkvZywgKG1hdGNoLCByYXdJZCwgXywgcG9pbnRlcklkKSA9PiB7XFxuICAgICAgICBsZXQgaWQgPSByYXdJZCB8fCBwb2ludGVySWRcXG4gICAgICAgIGlmICghaWQgfHwgIWlkc1tpZF0pIHtcXG4gICAgICAgICAgcmV0dXJuIG1hdGNoXFxuICAgICAgICB9XFxuXFxuICAgICAgICByZXR1cm4gYCMke2lkc1tpZF19YFxcbiAgICAgIH0pXFxuXFxuICAgICAgcmV0dXJuIHJhd1xcbiAgICB9XFxuICB9LFxcbiAgbW91bnRlZCAoKSB7XFxuICAgIGlmICh0aGlzLmljb24pIHtcXG4gICAgICByZXR1cm5cXG4gICAgfVxcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcXG4gICAgICBjaGlsZC5vdXRlclNjYWxlID0gdGhpcy5ub3JtYWxpemVkU2NhbGVcXG4gICAgfSlcXG4gICAgbGV0IHdpZHRoID0gMFxcbiAgICBsZXQgaGVpZ2h0ID0gMFxcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcXG4gICAgICB3aWR0aCA9IE1hdGgubWF4KHdpZHRoLCBjaGlsZC53aWR0aClcXG4gICAgICBoZWlnaHQgPSBNYXRoLm1heChoZWlnaHQsIGNoaWxkLmhlaWdodClcXG4gICAgfSlcXG4gICAgdGhpcy5jaGlsZHJlbldpZHRoID0gd2lkdGhcXG4gICAgdGhpcy5jaGlsZHJlbkhlaWdodCA9IGhlaWdodFxcbiAgICB0aGlzLiRjaGlsZHJlbi5mb3JFYWNoKGNoaWxkID0+IHtcXG4gICAgICBjaGlsZC54ID0gKHdpZHRoIC0gY2hpbGQud2lkdGgpIC8gMlxcbiAgICAgIGNoaWxkLnkgPSAoaGVpZ2h0IC0gY2hpbGQuaGVpZ2h0KSAvIDJcXG4gICAgfSlcXG4gIH0sXFxuICByZWdpc3RlciAoZGF0YSkge1xcbiAgICBmb3IgKGxldCBuYW1lIGluIGRhdGEpIHtcXG4gICAgICBsZXQgaWNvbiA9IGRhdGFbbmFtZV1cXG5cXG4gICAgICBpZiAoIWljb24ucGF0aHMpIHtcXG4gICAgICAgIGljb24ucGF0aHMgPSBbXVxcbiAgICAgIH1cXG4gICAgICBpZiAoaWNvbi5kKSB7XFxuICAgICAgICBpY29uLnBhdGhzLnB1c2goeyBkOiBpY29uLmQgfSlcXG4gICAgICB9XFxuXFxuICAgICAgaWYgKCFpY29uLnBvbHlnb25zKSB7XFxuICAgICAgICBpY29uLnBvbHlnb25zID0gW11cXG4gICAgICB9XFxuICAgICAgaWYgKGljb24ucG9pbnRzKSB7XFxuICAgICAgICBpY29uLnBvbHlnb25zLnB1c2goeyBwb2ludHM6IGljb24ucG9pbnRzIH0pXFxuICAgICAgfVxcblxcbiAgICAgIGljb25zW25hbWVdID0gaWNvblxcbiAgICB9XFxuICB9LFxcbiAgaWNvbnNcXG59XFxuXFxubGV0IGN1cnNvciA9IDB4ZDQ5MzdcXG5mdW5jdGlvbiBnZXRJZCAoKSB7XFxuICByZXR1cm4gYGZhLSR7KGN1cnNvcisrKS50b1N0cmluZygxNil9YFxcbn1cXG48L3NjcmlwdD5cXG5cIl0sXCJzb3VyY2VSb290XCI6XCJcIn1dKTtcblxuLy8gZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYWZhYWJkNzBcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYWZhYWJkNzBcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuLy8gY3NzIGJhc2UgY29kZSwgaW5qZWN0ZWQgYnkgdGhlIGNzcy1sb2FkZXJcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24odXNlU291cmNlTWFwKSB7XG5cdHZhciBsaXN0ID0gW107XG5cblx0Ly8gcmV0dXJuIHRoZSBsaXN0IG9mIG1vZHVsZXMgYXMgY3NzIHN0cmluZ1xuXHRsaXN0LnRvU3RyaW5nID0gZnVuY3Rpb24gdG9TdHJpbmcoKSB7XG5cdFx0cmV0dXJuIHRoaXMubWFwKGZ1bmN0aW9uIChpdGVtKSB7XG5cdFx0XHR2YXIgY29udGVudCA9IGNzc1dpdGhNYXBwaW5nVG9TdHJpbmcoaXRlbSwgdXNlU291cmNlTWFwKTtcblx0XHRcdGlmKGl0ZW1bMl0pIHtcblx0XHRcdFx0cmV0dXJuIFwiQG1lZGlhIFwiICsgaXRlbVsyXSArIFwie1wiICsgY29udGVudCArIFwifVwiO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0cmV0dXJuIGNvbnRlbnQ7XG5cdFx0XHR9XG5cdFx0fSkuam9pbihcIlwiKTtcblx0fTtcblxuXHQvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuXHRsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5KSB7XG5cdFx0aWYodHlwZW9mIG1vZHVsZXMgPT09IFwic3RyaW5nXCIpXG5cdFx0XHRtb2R1bGVzID0gW1tudWxsLCBtb2R1bGVzLCBcIlwiXV07XG5cdFx0dmFyIGFscmVhZHlJbXBvcnRlZE1vZHVsZXMgPSB7fTtcblx0XHRmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGlkID0gdGhpc1tpXVswXTtcblx0XHRcdGlmKHR5cGVvZiBpZCA9PT0gXCJudW1iZXJcIilcblx0XHRcdFx0YWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpZF0gPSB0cnVlO1xuXHRcdH1cblx0XHRmb3IoaSA9IDA7IGkgPCBtb2R1bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0XHR2YXIgaXRlbSA9IG1vZHVsZXNbaV07XG5cdFx0XHQvLyBza2lwIGFscmVhZHkgaW1wb3J0ZWQgbW9kdWxlXG5cdFx0XHQvLyB0aGlzIGltcGxlbWVudGF0aW9uIGlzIG5vdCAxMDAlIHBlcmZlY3QgZm9yIHdlaXJkIG1lZGlhIHF1ZXJ5IGNvbWJpbmF0aW9uc1xuXHRcdFx0Ly8gIHdoZW4gYSBtb2R1bGUgaXMgaW1wb3J0ZWQgbXVsdGlwbGUgdGltZXMgd2l0aCBkaWZmZXJlbnQgbWVkaWEgcXVlcmllcy5cblx0XHRcdC8vICBJIGhvcGUgdGhpcyB3aWxsIG5ldmVyIG9jY3VyIChIZXkgdGhpcyB3YXkgd2UgaGF2ZSBzbWFsbGVyIGJ1bmRsZXMpXG5cdFx0XHRpZih0eXBlb2YgaXRlbVswXSAhPT0gXCJudW1iZXJcIiB8fCAhYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuXHRcdFx0XHRpZihtZWRpYVF1ZXJ5ICYmICFpdGVtWzJdKSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IG1lZGlhUXVlcnk7XG5cdFx0XHRcdH0gZWxzZSBpZihtZWRpYVF1ZXJ5KSB7XG5cdFx0XHRcdFx0aXRlbVsyXSA9IFwiKFwiICsgaXRlbVsyXSArIFwiKSBhbmQgKFwiICsgbWVkaWFRdWVyeSArIFwiKVwiO1xuXHRcdFx0XHR9XG5cdFx0XHRcdGxpc3QucHVzaChpdGVtKTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG5cdHJldHVybiBsaXN0O1xufTtcblxuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcblx0dmFyIGNvbnRlbnQgPSBpdGVtWzFdIHx8ICcnO1xuXHR2YXIgY3NzTWFwcGluZyA9IGl0ZW1bM107XG5cdGlmICghY3NzTWFwcGluZykge1xuXHRcdHJldHVybiBjb250ZW50O1xuXHR9XG5cblx0aWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gJ2Z1bmN0aW9uJykge1xuXHRcdHZhciBzb3VyY2VNYXBwaW5nID0gdG9Db21tZW50KGNzc01hcHBpbmcpO1xuXHRcdHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbiAoc291cmNlKSB7XG5cdFx0XHRyZXR1cm4gJy8qIyBzb3VyY2VVUkw9JyArIGNzc01hcHBpbmcuc291cmNlUm9vdCArIHNvdXJjZSArICcgKi8nXG5cdFx0fSk7XG5cblx0XHRyZXR1cm4gW2NvbnRlbnRdLmNvbmNhdChzb3VyY2VVUkxzKS5jb25jYXQoW3NvdXJjZU1hcHBpbmddKS5qb2luKCdcXG4nKTtcblx0fVxuXG5cdHJldHVybiBbY29udGVudF0uam9pbignXFxuJyk7XG59XG5cbi8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcblx0Ly8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXVuZGVmXG5cdHZhciBiYXNlNjQgPSBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpO1xuXHR2YXIgZGF0YSA9ICdzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtjaGFyc2V0PXV0Zi04O2Jhc2U2NCwnICsgYmFzZTY0O1xuXG5cdHJldHVybiAnLyojICcgKyBkYXRhICsgJyAqLyc7XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9saWIvY3NzLWJhc2UuanMiLCJ2YXIgRE9DVU1FTlRfTk9ERV9UWVBFID0gOTtcblxuLyoqXG4gKiBBIHBvbHlmaWxsIGZvciBFbGVtZW50Lm1hdGNoZXMoKVxuICovXG5pZiAodHlwZW9mIEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmICFFbGVtZW50LnByb3RvdHlwZS5tYXRjaGVzKSB7XG4gICAgdmFyIHByb3RvID0gRWxlbWVudC5wcm90b3R5cGU7XG5cbiAgICBwcm90by5tYXRjaGVzID0gcHJvdG8ubWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLm1vek1hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5tc01hdGNoZXNTZWxlY3RvciB8fFxuICAgICAgICAgICAgICAgICAgICBwcm90by5vTWF0Y2hlc1NlbGVjdG9yIHx8XG4gICAgICAgICAgICAgICAgICAgIHByb3RvLndlYmtpdE1hdGNoZXNTZWxlY3Rvcjtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgY2xvc2VzdCBwYXJlbnQgdGhhdCBtYXRjaGVzIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEByZXR1cm4ge0Z1bmN0aW9ufVxuICovXG5mdW5jdGlvbiBjbG9zZXN0IChlbGVtZW50LCBzZWxlY3Rvcikge1xuICAgIHdoaWxlIChlbGVtZW50ICYmIGVsZW1lbnQubm9kZVR5cGUgIT09IERPQ1VNRU5UX05PREVfVFlQRSkge1xuICAgICAgICBpZiAodHlwZW9mIGVsZW1lbnQubWF0Y2hlcyA9PT0gJ2Z1bmN0aW9uJyAmJlxuICAgICAgICAgICAgZWxlbWVudC5tYXRjaGVzKHNlbGVjdG9yKSkge1xuICAgICAgICAgIHJldHVybiBlbGVtZW50O1xuICAgICAgICB9XG4gICAgICAgIGVsZW1lbnQgPSBlbGVtZW50LnBhcmVudE5vZGU7XG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGNsb3Nlc3Q7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGVsZWdhdGUvc3JjL2Nsb3Nlc3QuanMiLCJ2YXIgY2xvc2VzdCA9IHJlcXVpcmUoJy4vY2xvc2VzdCcpO1xuXG4vKipcbiAqIERlbGVnYXRlcyBldmVudCB0byBhIHNlbGVjdG9yLlxuICpcbiAqIEBwYXJhbSB7RWxlbWVudH0gZWxlbWVudFxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBfZGVsZWdhdGUoZWxlbWVudCwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgdmFyIGxpc3RlbmVyRm4gPSBsaXN0ZW5lci5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXG4gICAgZWxlbWVudC5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGxpc3RlbmVyRm4sIHVzZUNhcHR1cmUpO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIodHlwZSwgbGlzdGVuZXJGbiwgdXNlQ2FwdHVyZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbi8qKlxuICogRGVsZWdhdGVzIGV2ZW50IHRvIGEgc2VsZWN0b3IuXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fFN0cmluZ3xBcnJheX0gW2VsZW1lbnRzXVxuICogQHBhcmFtIHtTdHJpbmd9IHNlbGVjdG9yXG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gdXNlQ2FwdHVyZVxuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBkZWxlZ2F0ZShlbGVtZW50cywgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrLCB1c2VDYXB0dXJlKSB7XG4gICAgLy8gSGFuZGxlIHRoZSByZWd1bGFyIEVsZW1lbnQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzLmFkZEV2ZW50TGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZS5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBFbGVtZW50LWxlc3MgdXNhZ2UsIGl0IGRlZmF1bHRzIHRvIGdsb2JhbCBkZWxlZ2F0aW9uXG4gICAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIC8vIFVzZSBgZG9jdW1lbnRgIGFzIHRoZSBmaXJzdCBwYXJhbWV0ZXIsIHRoZW4gYXBwbHkgYXJndW1lbnRzXG4gICAgICAgIC8vIFRoaXMgaXMgYSBzaG9ydCB3YXkgdG8gLnVuc2hpZnQgYGFyZ3VtZW50c2Agd2l0aG91dCBydW5uaW5nIGludG8gZGVvcHRpbWl6YXRpb25zXG4gICAgICAgIHJldHVybiBfZGVsZWdhdGUuYmluZChudWxsLCBkb2N1bWVudCkuYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB9XG5cbiAgICAvLyBIYW5kbGUgU2VsZWN0b3ItYmFzZWQgdXNhZ2VcbiAgICBpZiAodHlwZW9mIGVsZW1lbnRzID09PSAnc3RyaW5nJykge1xuICAgICAgICBlbGVtZW50cyA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3JBbGwoZWxlbWVudHMpO1xuICAgIH1cblxuICAgIC8vIEhhbmRsZSBBcnJheS1saWtlIGJhc2VkIHVzYWdlXG4gICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5tYXAuY2FsbChlbGVtZW50cywgZnVuY3Rpb24gKGVsZW1lbnQpIHtcbiAgICAgICAgcmV0dXJuIF9kZWxlZ2F0ZShlbGVtZW50LCBzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2ssIHVzZUNhcHR1cmUpO1xuICAgIH0pO1xufVxuXG4vKipcbiAqIEZpbmRzIGNsb3Nlc3QgbWF0Y2ggYW5kIGludm9rZXMgY2FsbGJhY2suXG4gKlxuICogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7RnVuY3Rpb259XG4gKi9cbmZ1bmN0aW9uIGxpc3RlbmVyKGVsZW1lbnQsIHNlbGVjdG9yLCB0eXBlLCBjYWxsYmFjaykge1xuICAgIHJldHVybiBmdW5jdGlvbihlKSB7XG4gICAgICAgIGUuZGVsZWdhdGVUYXJnZXQgPSBjbG9zZXN0KGUudGFyZ2V0LCBzZWxlY3Rvcik7XG5cbiAgICAgICAgaWYgKGUuZGVsZWdhdGVUYXJnZXQpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrLmNhbGwoZWxlbWVudCwgZSk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbm1vZHVsZS5leHBvcnRzID0gZGVsZWdhdGU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZGVsZWdhdGUvc3JjL2RlbGVnYXRlLmpzIiwiLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIEhUTUwgZWxlbWVudC5cbiAqXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsdWVcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmV4cG9ydHMubm9kZSA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWRcbiAgICAgICAgJiYgdmFsdWUgaW5zdGFuY2VvZiBIVE1MRWxlbWVudFxuICAgICAgICAmJiB2YWx1ZS5ub2RlVHlwZSA9PT0gMTtcbn07XG5cbi8qKlxuICogQ2hlY2sgaWYgYXJndW1lbnQgaXMgYSBsaXN0IG9mIEhUTUwgZWxlbWVudHMuXG4gKlxuICogQHBhcmFtIHtPYmplY3R9IHZhbHVlXG4gKiBAcmV0dXJuIHtCb29sZWFufVxuICovXG5leHBvcnRzLm5vZGVMaXN0ID0gZnVuY3Rpb24odmFsdWUpIHtcbiAgICB2YXIgdHlwZSA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSk7XG5cbiAgICByZXR1cm4gdmFsdWUgIT09IHVuZGVmaW5lZFxuICAgICAgICAmJiAodHlwZSA9PT0gJ1tvYmplY3QgTm9kZUxpc3RdJyB8fCB0eXBlID09PSAnW29iamVjdCBIVE1MQ29sbGVjdGlvbl0nKVxuICAgICAgICAmJiAoJ2xlbmd0aCcgaW4gdmFsdWUpXG4gICAgICAgICYmICh2YWx1ZS5sZW5ndGggPT09IDAgfHwgZXhwb3J0cy5ub2RlKHZhbHVlWzBdKSk7XG59O1xuXG4vKipcbiAqIENoZWNrIGlmIGFyZ3VtZW50IGlzIGEgc3RyaW5nLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5zdHJpbmcgPSBmdW5jdGlvbih2YWx1ZSkge1xuICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnXG4gICAgICAgIHx8IHZhbHVlIGluc3RhbmNlb2YgU3RyaW5nO1xufTtcblxuLyoqXG4gKiBDaGVjayBpZiBhcmd1bWVudCBpcyBhIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWx1ZVxuICogQHJldHVybiB7Qm9vbGVhbn1cbiAqL1xuZXhwb3J0cy5mbiA9IGZ1bmN0aW9uKHZhbHVlKSB7XG4gICAgdmFyIHR5cGUgPSBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwodmFsdWUpO1xuXG4gICAgcmV0dXJuIHR5cGUgPT09ICdbb2JqZWN0IEZ1bmN0aW9uXSc7XG59O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL2dvb2QtbGlzdGVuZXIvc3JjL2lzLmpzIiwidmFyIGlzID0gcmVxdWlyZSgnLi9pcycpO1xudmFyIGRlbGVnYXRlID0gcmVxdWlyZSgnZGVsZWdhdGUnKTtcblxuLyoqXG4gKiBWYWxpZGF0ZXMgYWxsIHBhcmFtcyBhbmQgY2FsbHMgdGhlIHJpZ2h0XG4gKiBsaXN0ZW5lciBmdW5jdGlvbiBiYXNlZCBvbiBpdHMgdGFyZ2V0IHR5cGUuXG4gKlxuICogQHBhcmFtIHtTdHJpbmd8SFRNTEVsZW1lbnR8SFRNTENvbGxlY3Rpb258Tm9kZUxpc3R9IHRhcmdldFxuICogQHBhcmFtIHtTdHJpbmd9IHR5cGVcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gKiBAcmV0dXJuIHtPYmplY3R9XG4gKi9cbmZ1bmN0aW9uIGxpc3Rlbih0YXJnZXQsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgaWYgKCF0YXJnZXQgJiYgIXR5cGUgJiYgIWNhbGxiYWNrKSB7XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignTWlzc2luZyByZXF1aXJlZCBhcmd1bWVudHMnKTtcbiAgICB9XG5cbiAgICBpZiAoIWlzLnN0cmluZyh0eXBlKSkge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdTZWNvbmQgYXJndW1lbnQgbXVzdCBiZSBhIFN0cmluZycpO1xuICAgIH1cblxuICAgIGlmICghaXMuZm4oY2FsbGJhY2spKSB7XG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoaXJkIGFyZ3VtZW50IG11c3QgYmUgYSBGdW5jdGlvbicpO1xuICAgIH1cblxuICAgIGlmIChpcy5ub2RlKHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGUodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGlzLm5vZGVMaXN0KHRhcmdldCkpIHtcbiAgICAgICAgcmV0dXJuIGxpc3Rlbk5vZGVMaXN0KHRhcmdldCwgdHlwZSwgY2FsbGJhY2spO1xuICAgIH1cbiAgICBlbHNlIGlmIChpcy5zdHJpbmcodGFyZ2V0KSkge1xuICAgICAgICByZXR1cm4gbGlzdGVuU2VsZWN0b3IodGFyZ2V0LCB0eXBlLCBjYWxsYmFjayk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdGaXJzdCBhcmd1bWVudCBtdXN0IGJlIGEgU3RyaW5nLCBIVE1MRWxlbWVudCwgSFRNTENvbGxlY3Rpb24sIG9yIE5vZGVMaXN0Jyk7XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZHMgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBIVE1MIGVsZW1lbnRcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7SFRNTEVsZW1lbnR9IG5vZGVcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5Ob2RlKG5vZGUsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgbm9kZS5hZGRFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcblxuICAgIHJldHVybiB7XG4gICAgICAgIGRlc3Ryb3k6IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH1cbn1cblxuLyoqXG4gKiBBZGQgYW4gZXZlbnQgbGlzdGVuZXIgdG8gYSBsaXN0IG9mIEhUTUwgZWxlbWVudHNcbiAqIGFuZCByZXR1cm5zIGEgcmVtb3ZlIGxpc3RlbmVyIGZ1bmN0aW9uLlxuICpcbiAqIEBwYXJhbSB7Tm9kZUxpc3R8SFRNTENvbGxlY3Rpb259IG5vZGVMaXN0XG4gKiBAcGFyYW0ge1N0cmluZ30gdHlwZVxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAqIEByZXR1cm4ge09iamVjdH1cbiAqL1xuZnVuY3Rpb24gbGlzdGVuTm9kZUxpc3Qobm9kZUxpc3QsIHR5cGUsIGNhbGxiYWNrKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLmZvckVhY2guY2FsbChub2RlTGlzdCwgZnVuY3Rpb24obm9kZSkge1xuICAgICAgICBub2RlLmFkZEV2ZW50TGlzdGVuZXIodHlwZSwgY2FsbGJhY2spO1xuICAgIH0pO1xuXG4gICAgcmV0dXJuIHtcbiAgICAgICAgZGVzdHJveTogZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICBBcnJheS5wcm90b3R5cGUuZm9yRWFjaC5jYWxsKG5vZGVMaXN0LCBmdW5jdGlvbihub2RlKSB7XG4gICAgICAgICAgICAgICAgbm9kZS5yZW1vdmVFdmVudExpc3RlbmVyKHR5cGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxufVxuXG4vKipcbiAqIEFkZCBhbiBldmVudCBsaXN0ZW5lciB0byBhIHNlbGVjdG9yXG4gKiBhbmQgcmV0dXJucyBhIHJlbW92ZSBsaXN0ZW5lciBmdW5jdGlvbi5cbiAqXG4gKiBAcGFyYW0ge1N0cmluZ30gc2VsZWN0b3JcbiAqIEBwYXJhbSB7U3RyaW5nfSB0eXBlXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICogQHJldHVybiB7T2JqZWN0fVxuICovXG5mdW5jdGlvbiBsaXN0ZW5TZWxlY3RvcihzZWxlY3RvciwgdHlwZSwgY2FsbGJhY2spIHtcbiAgICByZXR1cm4gZGVsZWdhdGUoZG9jdW1lbnQuYm9keSwgc2VsZWN0b3IsIHR5cGUsIGNhbGxiYWNrKTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBsaXN0ZW47XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvZ29vZC1saXN0ZW5lci9zcmMvbGlzdGVuLmpzIiwiLyohXG4gKiBEZXRlcm1pbmUgaWYgYW4gb2JqZWN0IGlzIGEgQnVmZmVyXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL1xuXG4vLyBUaGUgX2lzQnVmZmVyIGNoZWNrIGlzIGZvciBTYWZhcmkgNS03IHN1cHBvcnQsIGJlY2F1c2UgaXQncyBtaXNzaW5nXG4vLyBPYmplY3QucHJvdG90eXBlLmNvbnN0cnVjdG9yLiBSZW1vdmUgdGhpcyBldmVudHVhbGx5XG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmopIHtcbiAgcmV0dXJuIG9iaiAhPSBudWxsICYmIChpc0J1ZmZlcihvYmopIHx8IGlzU2xvd0J1ZmZlcihvYmopIHx8ICEhb2JqLl9pc0J1ZmZlcilcbn1cblxuZnVuY3Rpb24gaXNCdWZmZXIgKG9iaikge1xuICByZXR1cm4gISFvYmouY29uc3RydWN0b3IgJiYgdHlwZW9mIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlciA9PT0gJ2Z1bmN0aW9uJyAmJiBvYmouY29uc3RydWN0b3IuaXNCdWZmZXIob2JqKVxufVxuXG4vLyBGb3IgTm9kZSB2MC4xMCBzdXBwb3J0LiBSZW1vdmUgdGhpcyBldmVudHVhbGx5LlxuZnVuY3Rpb24gaXNTbG93QnVmZmVyIChvYmopIHtcbiAgcmV0dXJuIHR5cGVvZiBvYmoucmVhZEZsb2F0TEUgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIG9iai5zbGljZSA9PT0gJ2Z1bmN0aW9uJyAmJiBpc0J1ZmZlcihvYmouc2xpY2UoMCwgMCkpXG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvaXMtYnVmZmVyL2luZGV4LmpzIiwiLy8gc2hpbSBmb3IgdXNpbmcgcHJvY2VzcyBpbiBicm93c2VyXG52YXIgcHJvY2VzcyA9IG1vZHVsZS5leHBvcnRzID0ge307XG5cbi8vIGNhY2hlZCBmcm9tIHdoYXRldmVyIGdsb2JhbCBpcyBwcmVzZW50IHNvIHRoYXQgdGVzdCBydW5uZXJzIHRoYXQgc3R1YiBpdFxuLy8gZG9uJ3QgYnJlYWsgdGhpbmdzLiAgQnV0IHdlIG5lZWQgdG8gd3JhcCBpdCBpbiBhIHRyeSBjYXRjaCBpbiBjYXNlIGl0IGlzXG4vLyB3cmFwcGVkIGluIHN0cmljdCBtb2RlIGNvZGUgd2hpY2ggZG9lc24ndCBkZWZpbmUgYW55IGdsb2JhbHMuICBJdCdzIGluc2lkZSBhXG4vLyBmdW5jdGlvbiBiZWNhdXNlIHRyeS9jYXRjaGVzIGRlb3B0aW1pemUgaW4gY2VydGFpbiBlbmdpbmVzLlxuXG52YXIgY2FjaGVkU2V0VGltZW91dDtcbnZhciBjYWNoZWRDbGVhclRpbWVvdXQ7XG5cbmZ1bmN0aW9uIGRlZmF1bHRTZXRUaW1vdXQoKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdzZXRUaW1lb3V0IGhhcyBub3QgYmVlbiBkZWZpbmVkJyk7XG59XG5mdW5jdGlvbiBkZWZhdWx0Q2xlYXJUaW1lb3V0ICgpIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ2NsZWFyVGltZW91dCBoYXMgbm90IGJlZW4gZGVmaW5lZCcpO1xufVxuKGZ1bmN0aW9uICgpIHtcbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBzZXRUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IGRlZmF1bHRTZXRUaW1vdXQ7XG4gICAgICAgIH1cbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgIGNhY2hlZFNldFRpbWVvdXQgPSBkZWZhdWx0U2V0VGltb3V0O1xuICAgIH1cbiAgICB0cnkge1xuICAgICAgICBpZiAodHlwZW9mIGNsZWFyVGltZW91dCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gY2xlYXJUaW1lb3V0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY2FjaGVkQ2xlYXJUaW1lb3V0ID0gZGVmYXVsdENsZWFyVGltZW91dDtcbiAgICB9XG59ICgpKVxuZnVuY3Rpb24gcnVuVGltZW91dChmdW4pIHtcbiAgICBpZiAoY2FjaGVkU2V0VGltZW91dCA9PT0gc2V0VGltZW91dCkge1xuICAgICAgICAvL25vcm1hbCBlbnZpcm9tZW50cyBpbiBzYW5lIHNpdHVhdGlvbnNcbiAgICAgICAgcmV0dXJuIHNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9XG4gICAgLy8gaWYgc2V0VGltZW91dCB3YXNuJ3QgYXZhaWxhYmxlIGJ1dCB3YXMgbGF0dGVyIGRlZmluZWRcbiAgICBpZiAoKGNhY2hlZFNldFRpbWVvdXQgPT09IGRlZmF1bHRTZXRUaW1vdXQgfHwgIWNhY2hlZFNldFRpbWVvdXQpICYmIHNldFRpbWVvdXQpIHtcbiAgICAgICAgY2FjaGVkU2V0VGltZW91dCA9IHNldFRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBzZXRUaW1lb3V0KGZ1biwgMCk7XG4gICAgfVxuICAgIHRyeSB7XG4gICAgICAgIC8vIHdoZW4gd2hlbiBzb21lYm9keSBoYXMgc2NyZXdlZCB3aXRoIHNldFRpbWVvdXQgYnV0IG5vIEkuRS4gbWFkZG5lc3NcbiAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQoZnVuLCAwKTtcbiAgICB9IGNhdGNoKGUpe1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gV2hlbiB3ZSBhcmUgaW4gSS5FLiBidXQgdGhlIHNjcmlwdCBoYXMgYmVlbiBldmFsZWQgc28gSS5FLiBkb2Vzbid0IHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkU2V0VGltZW91dC5jYWxsKG51bGwsIGZ1biwgMCk7XG4gICAgICAgIH0gY2F0Y2goZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvclxuICAgICAgICAgICAgcmV0dXJuIGNhY2hlZFNldFRpbWVvdXQuY2FsbCh0aGlzLCBmdW4sIDApO1xuICAgICAgICB9XG4gICAgfVxuXG5cbn1cbmZ1bmN0aW9uIHJ1bkNsZWFyVGltZW91dChtYXJrZXIpIHtcbiAgICBpZiAoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBjbGVhclRpbWVvdXQpIHtcbiAgICAgICAgLy9ub3JtYWwgZW52aXJvbWVudHMgaW4gc2FuZSBzaXR1YXRpb25zXG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgLy8gaWYgY2xlYXJUaW1lb3V0IHdhc24ndCBhdmFpbGFibGUgYnV0IHdhcyBsYXR0ZXIgZGVmaW5lZFxuICAgIGlmICgoY2FjaGVkQ2xlYXJUaW1lb3V0ID09PSBkZWZhdWx0Q2xlYXJUaW1lb3V0IHx8ICFjYWNoZWRDbGVhclRpbWVvdXQpICYmIGNsZWFyVGltZW91dCkge1xuICAgICAgICBjYWNoZWRDbGVhclRpbWVvdXQgPSBjbGVhclRpbWVvdXQ7XG4gICAgICAgIHJldHVybiBjbGVhclRpbWVvdXQobWFya2VyKTtcbiAgICB9XG4gICAgdHJ5IHtcbiAgICAgICAgLy8gd2hlbiB3aGVuIHNvbWVib2R5IGhhcyBzY3Jld2VkIHdpdGggc2V0VGltZW91dCBidXQgbm8gSS5FLiBtYWRkbmVzc1xuICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0KG1hcmtlcik7XG4gICAgfSBjYXRjaCAoZSl7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICAvLyBXaGVuIHdlIGFyZSBpbiBJLkUuIGJ1dCB0aGUgc2NyaXB0IGhhcyBiZWVuIGV2YWxlZCBzbyBJLkUuIGRvZXNuJ3QgIHRydXN0IHRoZSBnbG9iYWwgb2JqZWN0IHdoZW4gY2FsbGVkIG5vcm1hbGx5XG4gICAgICAgICAgICByZXR1cm4gY2FjaGVkQ2xlYXJUaW1lb3V0LmNhbGwobnVsbCwgbWFya2VyKTtcbiAgICAgICAgfSBjYXRjaCAoZSl7XG4gICAgICAgICAgICAvLyBzYW1lIGFzIGFib3ZlIGJ1dCB3aGVuIGl0J3MgYSB2ZXJzaW9uIG9mIEkuRS4gdGhhdCBtdXN0IGhhdmUgdGhlIGdsb2JhbCBvYmplY3QgZm9yICd0aGlzJywgaG9wZnVsbHkgb3VyIGNvbnRleHQgY29ycmVjdCBvdGhlcndpc2UgaXQgd2lsbCB0aHJvdyBhIGdsb2JhbCBlcnJvci5cbiAgICAgICAgICAgIC8vIFNvbWUgdmVyc2lvbnMgb2YgSS5FLiBoYXZlIGRpZmZlcmVudCBydWxlcyBmb3IgY2xlYXJUaW1lb3V0IHZzIHNldFRpbWVvdXRcbiAgICAgICAgICAgIHJldHVybiBjYWNoZWRDbGVhclRpbWVvdXQuY2FsbCh0aGlzLCBtYXJrZXIpO1xuICAgICAgICB9XG4gICAgfVxuXG5cblxufVxudmFyIHF1ZXVlID0gW107XG52YXIgZHJhaW5pbmcgPSBmYWxzZTtcbnZhciBjdXJyZW50UXVldWU7XG52YXIgcXVldWVJbmRleCA9IC0xO1xuXG5mdW5jdGlvbiBjbGVhblVwTmV4dFRpY2soKSB7XG4gICAgaWYgKCFkcmFpbmluZyB8fCAhY3VycmVudFF1ZXVlKSB7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgZHJhaW5pbmcgPSBmYWxzZTtcbiAgICBpZiAoY3VycmVudFF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBxdWV1ZSA9IGN1cnJlbnRRdWV1ZS5jb25jYXQocXVldWUpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICB9XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCkge1xuICAgICAgICBkcmFpblF1ZXVlKCk7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBkcmFpblF1ZXVlKCkge1xuICAgIGlmIChkcmFpbmluZykge1xuICAgICAgICByZXR1cm47XG4gICAgfVxuICAgIHZhciB0aW1lb3V0ID0gcnVuVGltZW91dChjbGVhblVwTmV4dFRpY2spO1xuICAgIGRyYWluaW5nID0gdHJ1ZTtcblxuICAgIHZhciBsZW4gPSBxdWV1ZS5sZW5ndGg7XG4gICAgd2hpbGUobGVuKSB7XG4gICAgICAgIGN1cnJlbnRRdWV1ZSA9IHF1ZXVlO1xuICAgICAgICBxdWV1ZSA9IFtdO1xuICAgICAgICB3aGlsZSAoKytxdWV1ZUluZGV4IDwgbGVuKSB7XG4gICAgICAgICAgICBpZiAoY3VycmVudFF1ZXVlKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFF1ZXVlW3F1ZXVlSW5kZXhdLnJ1bigpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHF1ZXVlSW5kZXggPSAtMTtcbiAgICAgICAgbGVuID0gcXVldWUubGVuZ3RoO1xuICAgIH1cbiAgICBjdXJyZW50UXVldWUgPSBudWxsO1xuICAgIGRyYWluaW5nID0gZmFsc2U7XG4gICAgcnVuQ2xlYXJUaW1lb3V0KHRpbWVvdXQpO1xufVxuXG5wcm9jZXNzLm5leHRUaWNrID0gZnVuY3Rpb24gKGZ1bikge1xuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGggLSAxKTtcbiAgICBpZiAoYXJndW1lbnRzLmxlbmd0aCA+IDEpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGFyZ3NbaSAtIDFdID0gYXJndW1lbnRzW2ldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHF1ZXVlLnB1c2gobmV3IEl0ZW0oZnVuLCBhcmdzKSk7XG4gICAgaWYgKHF1ZXVlLmxlbmd0aCA9PT0gMSAmJiAhZHJhaW5pbmcpIHtcbiAgICAgICAgcnVuVGltZW91dChkcmFpblF1ZXVlKTtcbiAgICB9XG59O1xuXG4vLyB2OCBsaWtlcyBwcmVkaWN0aWJsZSBvYmplY3RzXG5mdW5jdGlvbiBJdGVtKGZ1biwgYXJyYXkpIHtcbiAgICB0aGlzLmZ1biA9IGZ1bjtcbiAgICB0aGlzLmFycmF5ID0gYXJyYXk7XG59XG5JdGVtLnByb3RvdHlwZS5ydW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgdGhpcy5mdW4uYXBwbHkobnVsbCwgdGhpcy5hcnJheSk7XG59O1xucHJvY2Vzcy50aXRsZSA9ICdicm93c2VyJztcbnByb2Nlc3MuYnJvd3NlciA9IHRydWU7XG5wcm9jZXNzLmVudiA9IHt9O1xucHJvY2Vzcy5hcmd2ID0gW107XG5wcm9jZXNzLnZlcnNpb24gPSAnJzsgLy8gZW1wdHkgc3RyaW5nIHRvIGF2b2lkIHJlZ2V4cCBpc3N1ZXNcbnByb2Nlc3MudmVyc2lvbnMgPSB7fTtcblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbnByb2Nlc3Mub24gPSBub29wO1xucHJvY2Vzcy5hZGRMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLm9uY2UgPSBub29wO1xucHJvY2Vzcy5vZmYgPSBub29wO1xucHJvY2Vzcy5yZW1vdmVMaXN0ZW5lciA9IG5vb3A7XG5wcm9jZXNzLnJlbW92ZUFsbExpc3RlbmVycyA9IG5vb3A7XG5wcm9jZXNzLmVtaXQgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kTGlzdGVuZXIgPSBub29wO1xucHJvY2Vzcy5wcmVwZW5kT25jZUxpc3RlbmVyID0gbm9vcDtcblxucHJvY2Vzcy5saXN0ZW5lcnMgPSBmdW5jdGlvbiAobmFtZSkgeyByZXR1cm4gW10gfVxuXG5wcm9jZXNzLmJpbmRpbmcgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5iaW5kaW5nIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbn07XG5cbnByb2Nlc3MuY3dkID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gJy8nIH07XG5wcm9jZXNzLmNoZGlyID0gZnVuY3Rpb24gKGRpcikge1xuICAgIHRocm93IG5ldyBFcnJvcigncHJvY2Vzcy5jaGRpciBpcyBub3Qgc3VwcG9ydGVkJyk7XG59O1xucHJvY2Vzcy51bWFzayA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gMDsgfTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9wcm9jZXNzL2Jyb3dzZXIuanMiLCJmdW5jdGlvbiBzZWxlY3QoZWxlbWVudCkge1xuICAgIHZhciBzZWxlY3RlZFRleHQ7XG5cbiAgICBpZiAoZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1NFTEVDVCcpIHtcbiAgICAgICAgZWxlbWVudC5mb2N1cygpO1xuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IGVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGVsc2UgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdJTlBVVCcgfHwgZWxlbWVudC5ub2RlTmFtZSA9PT0gJ1RFWFRBUkVBJykge1xuICAgICAgICB2YXIgaXNSZWFkT25seSA9IGVsZW1lbnQuaGFzQXR0cmlidXRlKCdyZWFkb25seScpO1xuXG4gICAgICAgIGlmICghaXNSZWFkT25seSkge1xuICAgICAgICAgICAgZWxlbWVudC5zZXRBdHRyaWJ1dGUoJ3JlYWRvbmx5JywgJycpO1xuICAgICAgICB9XG5cbiAgICAgICAgZWxlbWVudC5zZWxlY3QoKTtcbiAgICAgICAgZWxlbWVudC5zZXRTZWxlY3Rpb25SYW5nZSgwLCBlbGVtZW50LnZhbHVlLmxlbmd0aCk7XG5cbiAgICAgICAgaWYgKCFpc1JlYWRPbmx5KSB7XG4gICAgICAgICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZSgncmVhZG9ubHknKTtcbiAgICAgICAgfVxuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IGVsZW1lbnQudmFsdWU7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICBpZiAoZWxlbWVudC5oYXNBdHRyaWJ1dGUoJ2NvbnRlbnRlZGl0YWJsZScpKSB7XG4gICAgICAgICAgICBlbGVtZW50LmZvY3VzKCk7XG4gICAgICAgIH1cblxuICAgICAgICB2YXIgc2VsZWN0aW9uID0gd2luZG93LmdldFNlbGVjdGlvbigpO1xuICAgICAgICB2YXIgcmFuZ2UgPSBkb2N1bWVudC5jcmVhdGVSYW5nZSgpO1xuXG4gICAgICAgIHJhbmdlLnNlbGVjdE5vZGVDb250ZW50cyhlbGVtZW50KTtcbiAgICAgICAgc2VsZWN0aW9uLnJlbW92ZUFsbFJhbmdlcygpO1xuICAgICAgICBzZWxlY3Rpb24uYWRkUmFuZ2UocmFuZ2UpO1xuXG4gICAgICAgIHNlbGVjdGVkVGV4dCA9IHNlbGVjdGlvbi50b1N0cmluZygpO1xuICAgIH1cblxuICAgIHJldHVybiBzZWxlY3RlZFRleHQ7XG59XG5cbm1vZHVsZS5leHBvcnRzID0gc2VsZWN0O1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NlbGVjdC9zcmMvc2VsZWN0LmpzIiwiKGZ1bmN0aW9uIChnbG9iYWwsIHVuZGVmaW5lZCkge1xuICAgIFwidXNlIHN0cmljdFwiO1xuXG4gICAgaWYgKGdsb2JhbC5zZXRJbW1lZGlhdGUpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIHZhciBuZXh0SGFuZGxlID0gMTsgLy8gU3BlYyBzYXlzIGdyZWF0ZXIgdGhhbiB6ZXJvXG4gICAgdmFyIHRhc2tzQnlIYW5kbGUgPSB7fTtcbiAgICB2YXIgY3VycmVudGx5UnVubmluZ0FUYXNrID0gZmFsc2U7XG4gICAgdmFyIGRvYyA9IGdsb2JhbC5kb2N1bWVudDtcbiAgICB2YXIgcmVnaXN0ZXJJbW1lZGlhdGU7XG5cbiAgICBmdW5jdGlvbiBzZXRJbW1lZGlhdGUoY2FsbGJhY2spIHtcbiAgICAgIC8vIENhbGxiYWNrIGNhbiBlaXRoZXIgYmUgYSBmdW5jdGlvbiBvciBhIHN0cmluZ1xuICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIGNhbGxiYWNrID0gbmV3IEZ1bmN0aW9uKFwiXCIgKyBjYWxsYmFjayk7XG4gICAgICB9XG4gICAgICAvLyBDb3B5IGZ1bmN0aW9uIGFyZ3VtZW50c1xuICAgICAgdmFyIGFyZ3MgPSBuZXcgQXJyYXkoYXJndW1lbnRzLmxlbmd0aCAtIDEpO1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcmdzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgYXJnc1tpXSA9IGFyZ3VtZW50c1tpICsgMV07XG4gICAgICB9XG4gICAgICAvLyBTdG9yZSBhbmQgcmVnaXN0ZXIgdGhlIHRhc2tcbiAgICAgIHZhciB0YXNrID0geyBjYWxsYmFjazogY2FsbGJhY2ssIGFyZ3M6IGFyZ3MgfTtcbiAgICAgIHRhc2tzQnlIYW5kbGVbbmV4dEhhbmRsZV0gPSB0YXNrO1xuICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUobmV4dEhhbmRsZSk7XG4gICAgICByZXR1cm4gbmV4dEhhbmRsZSsrO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGNsZWFySW1tZWRpYXRlKGhhbmRsZSkge1xuICAgICAgICBkZWxldGUgdGFza3NCeUhhbmRsZVtoYW5kbGVdO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bih0YXNrKSB7XG4gICAgICAgIHZhciBjYWxsYmFjayA9IHRhc2suY2FsbGJhY2s7XG4gICAgICAgIHZhciBhcmdzID0gdGFzay5hcmdzO1xuICAgICAgICBzd2l0Y2ggKGFyZ3MubGVuZ3RoKSB7XG4gICAgICAgIGNhc2UgMDpcbiAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAyOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAzOlxuICAgICAgICAgICAgY2FsbGJhY2soYXJnc1swXSwgYXJnc1sxXSwgYXJnc1syXSk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIGNhbGxiYWNrLmFwcGx5KHVuZGVmaW5lZCwgYXJncyk7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHJ1bklmUHJlc2VudChoYW5kbGUpIHtcbiAgICAgICAgLy8gRnJvbSB0aGUgc3BlYzogXCJXYWl0IHVudGlsIGFueSBpbnZvY2F0aW9ucyBvZiB0aGlzIGFsZ29yaXRobSBzdGFydGVkIGJlZm9yZSB0aGlzIG9uZSBoYXZlIGNvbXBsZXRlZC5cIlxuICAgICAgICAvLyBTbyBpZiB3ZSdyZSBjdXJyZW50bHkgcnVubmluZyBhIHRhc2ssIHdlJ2xsIG5lZWQgdG8gZGVsYXkgdGhpcyBpbnZvY2F0aW9uLlxuICAgICAgICBpZiAoY3VycmVudGx5UnVubmluZ0FUYXNrKSB7XG4gICAgICAgICAgICAvLyBEZWxheSBieSBkb2luZyBhIHNldFRpbWVvdXQuIHNldEltbWVkaWF0ZSB3YXMgdHJpZWQgaW5zdGVhZCwgYnV0IGluIEZpcmVmb3ggNyBpdCBnZW5lcmF0ZWQgYVxuICAgICAgICAgICAgLy8gXCJ0b28gbXVjaCByZWN1cnNpb25cIiBlcnJvci5cbiAgICAgICAgICAgIHNldFRpbWVvdXQocnVuSWZQcmVzZW50LCAwLCBoYW5kbGUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgdmFyIHRhc2sgPSB0YXNrc0J5SGFuZGxlW2hhbmRsZV07XG4gICAgICAgICAgICBpZiAodGFzaykge1xuICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IHRydWU7XG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgcnVuKHRhc2spO1xuICAgICAgICAgICAgICAgIH0gZmluYWxseSB7XG4gICAgICAgICAgICAgICAgICAgIGNsZWFySW1tZWRpYXRlKGhhbmRsZSk7XG4gICAgICAgICAgICAgICAgICAgIGN1cnJlbnRseVJ1bm5pbmdBVGFzayA9IGZhbHNlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGluc3RhbGxOZXh0VGlja0ltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgcHJvY2Vzcy5uZXh0VGljayhmdW5jdGlvbiAoKSB7IHJ1bklmUHJlc2VudChoYW5kbGUpOyB9KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBjYW5Vc2VQb3N0TWVzc2FnZSgpIHtcbiAgICAgICAgLy8gVGhlIHRlc3QgYWdhaW5zdCBgaW1wb3J0U2NyaXB0c2AgcHJldmVudHMgdGhpcyBpbXBsZW1lbnRhdGlvbiBmcm9tIGJlaW5nIGluc3RhbGxlZCBpbnNpZGUgYSB3ZWIgd29ya2VyLFxuICAgICAgICAvLyB3aGVyZSBgZ2xvYmFsLnBvc3RNZXNzYWdlYCBtZWFucyBzb21ldGhpbmcgY29tcGxldGVseSBkaWZmZXJlbnQgYW5kIGNhbid0IGJlIHVzZWQgZm9yIHRoaXMgcHVycG9zZS5cbiAgICAgICAgaWYgKGdsb2JhbC5wb3N0TWVzc2FnZSAmJiAhZ2xvYmFsLmltcG9ydFNjcmlwdHMpIHtcbiAgICAgICAgICAgIHZhciBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBvbGRPbk1lc3NhZ2UgPSBnbG9iYWwub25tZXNzYWdlO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IGZ1bmN0aW9uKCkge1xuICAgICAgICAgICAgICAgIHBvc3RNZXNzYWdlSXNBc3luY2hyb25vdXMgPSBmYWxzZTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBnbG9iYWwucG9zdE1lc3NhZ2UoXCJcIiwgXCIqXCIpO1xuICAgICAgICAgICAgZ2xvYmFsLm9ubWVzc2FnZSA9IG9sZE9uTWVzc2FnZTtcbiAgICAgICAgICAgIHJldHVybiBwb3N0TWVzc2FnZUlzQXN5bmNocm9ub3VzO1xuICAgICAgICB9XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIC8vIEluc3RhbGxzIGFuIGV2ZW50IGhhbmRsZXIgb24gYGdsb2JhbGAgZm9yIHRoZSBgbWVzc2FnZWAgZXZlbnQ6IHNlZVxuICAgICAgICAvLyAqIGh0dHBzOi8vZGV2ZWxvcGVyLm1vemlsbGEub3JnL2VuL0RPTS93aW5kb3cucG9zdE1lc3NhZ2VcbiAgICAgICAgLy8gKiBodHRwOi8vd3d3LndoYXR3Zy5vcmcvc3BlY3Mvd2ViLWFwcHMvY3VycmVudC13b3JrL211bHRpcGFnZS9jb21tcy5odG1sI2Nyb3NzRG9jdW1lbnRNZXNzYWdlc1xuXG4gICAgICAgIHZhciBtZXNzYWdlUHJlZml4ID0gXCJzZXRJbW1lZGlhdGUkXCIgKyBNYXRoLnJhbmRvbSgpICsgXCIkXCI7XG4gICAgICAgIHZhciBvbkdsb2JhbE1lc3NhZ2UgPSBmdW5jdGlvbihldmVudCkge1xuICAgICAgICAgICAgaWYgKGV2ZW50LnNvdXJjZSA9PT0gZ2xvYmFsICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGV2ZW50LmRhdGEgPT09IFwic3RyaW5nXCIgJiZcbiAgICAgICAgICAgICAgICBldmVudC5kYXRhLmluZGV4T2YobWVzc2FnZVByZWZpeCkgPT09IDApIHtcbiAgICAgICAgICAgICAgICBydW5JZlByZXNlbnQoK2V2ZW50LmRhdGEuc2xpY2UobWVzc2FnZVByZWZpeC5sZW5ndGgpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoZ2xvYmFsLmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICAgIGdsb2JhbC5hZGRFdmVudExpc3RlbmVyKFwibWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UsIGZhbHNlKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIGdsb2JhbC5hdHRhY2hFdmVudChcIm9ubWVzc2FnZVwiLCBvbkdsb2JhbE1lc3NhZ2UpO1xuICAgICAgICB9XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGdsb2JhbC5wb3N0TWVzc2FnZShtZXNzYWdlUHJlZml4ICsgaGFuZGxlLCBcIipcIik7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gaW5zdGFsbE1lc3NhZ2VDaGFubmVsSW1wbGVtZW50YXRpb24oKSB7XG4gICAgICAgIHZhciBjaGFubmVsID0gbmV3IE1lc3NhZ2VDaGFubmVsKCk7XG4gICAgICAgIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZnVuY3Rpb24oZXZlbnQpIHtcbiAgICAgICAgICAgIHZhciBoYW5kbGUgPSBldmVudC5kYXRhO1xuICAgICAgICAgICAgcnVuSWZQcmVzZW50KGhhbmRsZSk7XG4gICAgICAgIH07XG5cbiAgICAgICAgcmVnaXN0ZXJJbW1lZGlhdGUgPSBmdW5jdGlvbihoYW5kbGUpIHtcbiAgICAgICAgICAgIGNoYW5uZWwucG9ydDIucG9zdE1lc3NhZ2UoaGFuZGxlKTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICB2YXIgaHRtbCA9IGRvYy5kb2N1bWVudEVsZW1lbnQ7XG4gICAgICAgIHJlZ2lzdGVySW1tZWRpYXRlID0gZnVuY3Rpb24oaGFuZGxlKSB7XG4gICAgICAgICAgICAvLyBDcmVhdGUgYSA8c2NyaXB0PiBlbGVtZW50OyBpdHMgcmVhZHlzdGF0ZWNoYW5nZSBldmVudCB3aWxsIGJlIGZpcmVkIGFzeW5jaHJvbm91c2x5IG9uY2UgaXQgaXMgaW5zZXJ0ZWRcbiAgICAgICAgICAgIC8vIGludG8gdGhlIGRvY3VtZW50LiBEbyBzbywgdGh1cyBxdWV1aW5nIHVwIHRoZSB0YXNrLiBSZW1lbWJlciB0byBjbGVhbiB1cCBvbmNlIGl0J3MgYmVlbiBjYWxsZWQuXG4gICAgICAgICAgICB2YXIgc2NyaXB0ID0gZG9jLmNyZWF0ZUVsZW1lbnQoXCJzY3JpcHRcIik7XG4gICAgICAgICAgICBzY3JpcHQub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJ1bklmUHJlc2VudChoYW5kbGUpO1xuICAgICAgICAgICAgICAgIHNjcmlwdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBudWxsO1xuICAgICAgICAgICAgICAgIGh0bWwucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgICAgICAgICBzY3JpcHQgPSBudWxsO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGh0bWwuYXBwZW5kQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgfTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBpbnN0YWxsU2V0VGltZW91dEltcGxlbWVudGF0aW9uKCkge1xuICAgICAgICByZWdpc3RlckltbWVkaWF0ZSA9IGZ1bmN0aW9uKGhhbmRsZSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChydW5JZlByZXNlbnQsIDAsIGhhbmRsZSk7XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gSWYgc3VwcG9ydGVkLCB3ZSBzaG91bGQgYXR0YWNoIHRvIHRoZSBwcm90b3R5cGUgb2YgZ2xvYmFsLCBzaW5jZSB0aGF0IGlzIHdoZXJlIHNldFRpbWVvdXQgZXQgYWwuIGxpdmUuXG4gICAgdmFyIGF0dGFjaFRvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mICYmIE9iamVjdC5nZXRQcm90b3R5cGVPZihnbG9iYWwpO1xuICAgIGF0dGFjaFRvID0gYXR0YWNoVG8gJiYgYXR0YWNoVG8uc2V0VGltZW91dCA/IGF0dGFjaFRvIDogZ2xvYmFsO1xuXG4gICAgLy8gRG9uJ3QgZ2V0IGZvb2xlZCBieSBlLmcuIGJyb3dzZXJpZnkgZW52aXJvbm1lbnRzLlxuICAgIGlmICh7fS50b1N0cmluZy5jYWxsKGdsb2JhbC5wcm9jZXNzKSA9PT0gXCJbb2JqZWN0IHByb2Nlc3NdXCIpIHtcbiAgICAgICAgLy8gRm9yIE5vZGUuanMgYmVmb3JlIDAuOVxuICAgICAgICBpbnN0YWxsTmV4dFRpY2tJbXBsZW1lbnRhdGlvbigpO1xuXG4gICAgfSBlbHNlIGlmIChjYW5Vc2VQb3N0TWVzc2FnZSgpKSB7XG4gICAgICAgIC8vIEZvciBub24tSUUxMCBtb2Rlcm4gYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFBvc3RNZXNzYWdlSW1wbGVtZW50YXRpb24oKTtcblxuICAgIH0gZWxzZSBpZiAoZ2xvYmFsLk1lc3NhZ2VDaGFubmVsKSB7XG4gICAgICAgIC8vIEZvciB3ZWIgd29ya2Vycywgd2hlcmUgc3VwcG9ydGVkXG4gICAgICAgIGluc3RhbGxNZXNzYWdlQ2hhbm5lbEltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2UgaWYgKGRvYyAmJiBcIm9ucmVhZHlzdGF0ZWNoYW5nZVwiIGluIGRvYy5jcmVhdGVFbGVtZW50KFwic2NyaXB0XCIpKSB7XG4gICAgICAgIC8vIEZvciBJRSA24oCTOFxuICAgICAgICBpbnN0YWxsUmVhZHlTdGF0ZUNoYW5nZUltcGxlbWVudGF0aW9uKCk7XG5cbiAgICB9IGVsc2Uge1xuICAgICAgICAvLyBGb3Igb2xkZXIgYnJvd3NlcnNcbiAgICAgICAgaW5zdGFsbFNldFRpbWVvdXRJbXBsZW1lbnRhdGlvbigpO1xuICAgIH1cblxuICAgIGF0dGFjaFRvLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbiAgICBhdHRhY2hUby5jbGVhckltbWVkaWF0ZSA9IGNsZWFySW1tZWRpYXRlO1xufSh0eXBlb2Ygc2VsZiA9PT0gXCJ1bmRlZmluZWRcIiA/IHR5cGVvZiBnbG9iYWwgPT09IFwidW5kZWZpbmVkXCIgPyB0aGlzIDogZ2xvYmFsIDogc2VsZikpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3NldGltbWVkaWF0ZS9zZXRJbW1lZGlhdGUuanMiLCIvKlxuXHRNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuXHRBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qL1xuXG52YXIgc3R5bGVzSW5Eb20gPSB7fTtcblxudmFyXHRtZW1vaXplID0gZnVuY3Rpb24gKGZuKSB7XG5cdHZhciBtZW1vO1xuXG5cdHJldHVybiBmdW5jdGlvbiAoKSB7XG5cdFx0aWYgKHR5cGVvZiBtZW1vID09PSBcInVuZGVmaW5lZFwiKSBtZW1vID0gZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcblx0XHRyZXR1cm4gbWVtbztcblx0fTtcbn07XG5cbnZhciBpc09sZElFID0gbWVtb2l6ZShmdW5jdGlvbiAoKSB7XG5cdC8vIFRlc3QgZm9yIElFIDw9IDkgYXMgcHJvcG9zZWQgYnkgQnJvd3NlcmhhY2tzXG5cdC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcblx0Ly8gVGVzdHMgZm9yIGV4aXN0ZW5jZSBvZiBzdGFuZGFyZCBnbG9iYWxzIGlzIHRvIGFsbG93IHN0eWxlLWxvYWRlclxuXHQvLyB0byBvcGVyYXRlIGNvcnJlY3RseSBpbnRvIG5vbi1zdGFuZGFyZCBlbnZpcm9ubWVudHNcblx0Ly8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG5cdHJldHVybiB3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYjtcbn0pO1xuXG52YXIgZ2V0RWxlbWVudCA9IChmdW5jdGlvbiAoZm4pIHtcblx0dmFyIG1lbW8gPSB7fTtcblxuXHRyZXR1cm4gZnVuY3Rpb24oc2VsZWN0b3IpIHtcblx0XHRpZiAodHlwZW9mIG1lbW9bc2VsZWN0b3JdID09PSBcInVuZGVmaW5lZFwiKSB7XG5cdFx0XHRtZW1vW3NlbGVjdG9yXSA9IGZuLmNhbGwodGhpcywgc2VsZWN0b3IpO1xuXHRcdH1cblxuXHRcdHJldHVybiBtZW1vW3NlbGVjdG9yXVxuXHR9O1xufSkoZnVuY3Rpb24gKHRhcmdldCkge1xuXHRyZXR1cm4gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpXG59KTtcblxudmFyIHNpbmdsZXRvbiA9IG51bGw7XG52YXJcdHNpbmdsZXRvbkNvdW50ZXIgPSAwO1xudmFyXHRzdHlsZXNJbnNlcnRlZEF0VG9wID0gW107XG5cbnZhclx0Zml4VXJscyA9IHJlcXVpcmUoXCIuL3VybHNcIik7XG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuXHRpZiAodHlwZW9mIERFQlVHICE9PSBcInVuZGVmaW5lZFwiICYmIERFQlVHKSB7XG5cdFx0aWYgKHR5cGVvZiBkb2N1bWVudCAhPT0gXCJvYmplY3RcIikgdGhyb3cgbmV3IEVycm9yKFwiVGhlIHN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50XCIpO1xuXHR9XG5cblx0b3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG5cblx0b3B0aW9ucy5hdHRycyA9IHR5cGVvZiBvcHRpb25zLmF0dHJzID09PSBcIm9iamVjdFwiID8gb3B0aW9ucy5hdHRycyA6IHt9O1xuXG5cdC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuXHQvLyB0YWdzIGl0IHdpbGwgYWxsb3cgb24gYSBwYWdlXG5cdGlmICghb3B0aW9ucy5zaW5nbGV0b24pIG9wdGlvbnMuc2luZ2xldG9uID0gaXNPbGRJRSgpO1xuXG5cdC8vIEJ5IGRlZmF1bHQsIGFkZCA8c3R5bGU+IHRhZ3MgdG8gdGhlIDxoZWFkPiBlbGVtZW50XG5cdGlmICghb3B0aW9ucy5pbnNlcnRJbnRvKSBvcHRpb25zLmluc2VydEludG8gPSBcImhlYWRcIjtcblxuXHQvLyBCeSBkZWZhdWx0LCBhZGQgPHN0eWxlPiB0YWdzIHRvIHRoZSBib3R0b20gb2YgdGhlIHRhcmdldFxuXHRpZiAoIW9wdGlvbnMuaW5zZXJ0QXQpIG9wdGlvbnMuaW5zZXJ0QXQgPSBcImJvdHRvbVwiO1xuXG5cdHZhciBzdHlsZXMgPSBsaXN0VG9TdHlsZXMobGlzdCwgb3B0aW9ucyk7XG5cblx0YWRkU3R5bGVzVG9Eb20oc3R5bGVzLCBvcHRpb25zKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlIChuZXdMaXN0KSB7XG5cdFx0dmFyIG1heVJlbW92ZSA9IFtdO1xuXG5cdFx0Zm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcblx0XHRcdHZhciBpdGVtID0gc3R5bGVzW2ldO1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRcdGRvbVN0eWxlLnJlZnMtLTtcblx0XHRcdG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKTtcblx0XHR9XG5cblx0XHRpZihuZXdMaXN0KSB7XG5cdFx0XHR2YXIgbmV3U3R5bGVzID0gbGlzdFRvU3R5bGVzKG5ld0xpc3QsIG9wdGlvbnMpO1xuXHRcdFx0YWRkU3R5bGVzVG9Eb20obmV3U3R5bGVzLCBvcHRpb25zKTtcblx0XHR9XG5cblx0XHRmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuXHRcdFx0dmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldO1xuXG5cdFx0XHRpZihkb21TdHlsZS5yZWZzID09PSAwKSB7XG5cdFx0XHRcdGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIGRvbVN0eWxlLnBhcnRzW2pdKCk7XG5cblx0XHRcdFx0ZGVsZXRlIHN0eWxlc0luRG9tW2RvbVN0eWxlLmlkXTtcblx0XHRcdH1cblx0XHR9XG5cdH07XG59O1xuXG5mdW5jdGlvbiBhZGRTdHlsZXNUb0RvbSAoc3R5bGVzLCBvcHRpb25zKSB7XG5cdGZvciAodmFyIGkgPSAwOyBpIDwgc3R5bGVzLmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBzdHlsZXNbaV07XG5cdFx0dmFyIGRvbVN0eWxlID0gc3R5bGVzSW5Eb21baXRlbS5pZF07XG5cblx0XHRpZihkb21TdHlsZSkge1xuXHRcdFx0ZG9tU3R5bGUucmVmcysrO1xuXG5cdFx0XHRmb3IodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0ZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSk7XG5cdFx0XHR9XG5cblx0XHRcdGZvcig7IGogPCBpdGVtLnBhcnRzLmxlbmd0aDsgaisrKSB7XG5cdFx0XHRcdGRvbVN0eWxlLnBhcnRzLnB1c2goYWRkU3R5bGUoaXRlbS5wYXJ0c1tqXSwgb3B0aW9ucykpO1xuXHRcdFx0fVxuXHRcdH0gZWxzZSB7XG5cdFx0XHR2YXIgcGFydHMgPSBbXTtcblxuXHRcdFx0Zm9yKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcblx0XHRcdFx0cGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdLCBvcHRpb25zKSk7XG5cdFx0XHR9XG5cblx0XHRcdHN0eWxlc0luRG9tW2l0ZW0uaWRdID0ge2lkOiBpdGVtLmlkLCByZWZzOiAxLCBwYXJ0czogcGFydHN9O1xuXHRcdH1cblx0fVxufVxuXG5mdW5jdGlvbiBsaXN0VG9TdHlsZXMgKGxpc3QsIG9wdGlvbnMpIHtcblx0dmFyIHN0eWxlcyA9IFtdO1xuXHR2YXIgbmV3U3R5bGVzID0ge307XG5cblx0Zm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG5cdFx0dmFyIGl0ZW0gPSBsaXN0W2ldO1xuXHRcdHZhciBpZCA9IG9wdGlvbnMuYmFzZSA/IGl0ZW1bMF0gKyBvcHRpb25zLmJhc2UgOiBpdGVtWzBdO1xuXHRcdHZhciBjc3MgPSBpdGVtWzFdO1xuXHRcdHZhciBtZWRpYSA9IGl0ZW1bMl07XG5cdFx0dmFyIHNvdXJjZU1hcCA9IGl0ZW1bM107XG5cdFx0dmFyIHBhcnQgPSB7Y3NzOiBjc3MsIG1lZGlhOiBtZWRpYSwgc291cmNlTWFwOiBzb3VyY2VNYXB9O1xuXG5cdFx0aWYoIW5ld1N0eWxlc1tpZF0pIHN0eWxlcy5wdXNoKG5ld1N0eWxlc1tpZF0gPSB7aWQ6IGlkLCBwYXJ0czogW3BhcnRdfSk7XG5cdFx0ZWxzZSBuZXdTdHlsZXNbaWRdLnBhcnRzLnB1c2gocGFydCk7XG5cdH1cblxuXHRyZXR1cm4gc3R5bGVzO1xufVxuXG5mdW5jdGlvbiBpbnNlcnRTdHlsZUVsZW1lbnQgKG9wdGlvbnMsIHN0eWxlKSB7XG5cdHZhciB0YXJnZXQgPSBnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0SW50bylcblxuXHRpZiAoIXRhcmdldCkge1xuXHRcdHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0SW50bycgcGFyYW1ldGVyIGlzIGludmFsaWQuXCIpO1xuXHR9XG5cblx0dmFyIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcFtzdHlsZXNJbnNlcnRlZEF0VG9wLmxlbmd0aCAtIDFdO1xuXG5cdGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcInRvcFwiKSB7XG5cdFx0aWYgKCFsYXN0U3R5bGVFbGVtZW50SW5zZXJ0ZWRBdFRvcCkge1xuXHRcdFx0dGFyZ2V0Lmluc2VydEJlZm9yZShzdHlsZSwgdGFyZ2V0LmZpcnN0Q2hpbGQpO1xuXHRcdH0gZWxzZSBpZiAobGFzdFN0eWxlRWxlbWVudEluc2VydGVkQXRUb3AubmV4dFNpYmxpbmcpIHtcblx0XHRcdHRhcmdldC5pbnNlcnRCZWZvcmUoc3R5bGUsIGxhc3RTdHlsZUVsZW1lbnRJbnNlcnRlZEF0VG9wLm5leHRTaWJsaW5nKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0XHR9XG5cdFx0c3R5bGVzSW5zZXJ0ZWRBdFRvcC5wdXNoKHN0eWxlKTtcblx0fSBlbHNlIGlmIChvcHRpb25zLmluc2VydEF0ID09PSBcImJvdHRvbVwiKSB7XG5cdFx0dGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcblx0fSBlbHNlIHtcblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJJbnZhbGlkIHZhbHVlIGZvciBwYXJhbWV0ZXIgJ2luc2VydEF0Jy4gTXVzdCBiZSAndG9wJyBvciAnYm90dG9tJy5cIik7XG5cdH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50IChzdHlsZSkge1xuXHRpZiAoc3R5bGUucGFyZW50Tm9kZSA9PT0gbnVsbCkgcmV0dXJuIGZhbHNlO1xuXHRzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcblxuXHR2YXIgaWR4ID0gc3R5bGVzSW5zZXJ0ZWRBdFRvcC5pbmRleE9mKHN0eWxlKTtcblx0aWYoaWR4ID49IDApIHtcblx0XHRzdHlsZXNJbnNlcnRlZEF0VG9wLnNwbGljZShpZHgsIDEpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0eWxlRWxlbWVudCAob3B0aW9ucykge1xuXHR2YXIgc3R5bGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwic3R5bGVcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXG5cdGFkZEF0dHJzKHN0eWxlLCBvcHRpb25zLmF0dHJzKTtcblx0aW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMsIHN0eWxlKTtcblxuXHRyZXR1cm4gc3R5bGU7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUxpbmtFbGVtZW50IChvcHRpb25zKSB7XG5cdHZhciBsaW5rID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImxpbmtcIik7XG5cblx0b3B0aW9ucy5hdHRycy50eXBlID0gXCJ0ZXh0L2Nzc1wiO1xuXHRvcHRpb25zLmF0dHJzLnJlbCA9IFwic3R5bGVzaGVldFwiO1xuXG5cdGFkZEF0dHJzKGxpbmssIG9wdGlvbnMuYXR0cnMpO1xuXHRpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucywgbGluayk7XG5cblx0cmV0dXJuIGxpbms7XG59XG5cbmZ1bmN0aW9uIGFkZEF0dHJzIChlbCwgYXR0cnMpIHtcblx0T2JqZWN0LmtleXMoYXR0cnMpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuXHRcdGVsLnNldEF0dHJpYnV0ZShrZXksIGF0dHJzW2tleV0pO1xuXHR9KTtcbn1cblxuZnVuY3Rpb24gYWRkU3R5bGUgKG9iaiwgb3B0aW9ucykge1xuXHR2YXIgc3R5bGUsIHVwZGF0ZSwgcmVtb3ZlLCByZXN1bHQ7XG5cblx0Ly8gSWYgYSB0cmFuc2Zvcm0gZnVuY3Rpb24gd2FzIGRlZmluZWQsIHJ1biBpdCBvbiB0aGUgY3NzXG5cdGlmIChvcHRpb25zLnRyYW5zZm9ybSAmJiBvYmouY3NzKSB7XG5cdCAgICByZXN1bHQgPSBvcHRpb25zLnRyYW5zZm9ybShvYmouY3NzKTtcblxuXHQgICAgaWYgKHJlc3VsdCkge1xuXHQgICAgXHQvLyBJZiB0cmFuc2Zvcm0gcmV0dXJucyBhIHZhbHVlLCB1c2UgdGhhdCBpbnN0ZWFkIG9mIHRoZSBvcmlnaW5hbCBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIHJ1bm5pbmcgcnVudGltZSB0cmFuc2Zvcm1hdGlvbnMgb24gdGhlIGNzcy5cblx0ICAgIFx0b2JqLmNzcyA9IHJlc3VsdDtcblx0ICAgIH0gZWxzZSB7XG5cdCAgICBcdC8vIElmIHRoZSB0cmFuc2Zvcm0gZnVuY3Rpb24gcmV0dXJucyBhIGZhbHN5IHZhbHVlLCBkb24ndCBhZGQgdGhpcyBjc3MuXG5cdCAgICBcdC8vIFRoaXMgYWxsb3dzIGNvbmRpdGlvbmFsIGxvYWRpbmcgb2YgY3NzXG5cdCAgICBcdHJldHVybiBmdW5jdGlvbigpIHtcblx0ICAgIFx0XHQvLyBub29wXG5cdCAgICBcdH07XG5cdCAgICB9XG5cdH1cblxuXHRpZiAob3B0aW9ucy5zaW5nbGV0b24pIHtcblx0XHR2YXIgc3R5bGVJbmRleCA9IHNpbmdsZXRvbkNvdW50ZXIrKztcblxuXHRcdHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuXG5cdFx0dXBkYXRlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCBmYWxzZSk7XG5cdFx0cmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcblxuXHR9IGVsc2UgaWYgKFxuXHRcdG9iai5zb3VyY2VNYXAgJiZcblx0XHR0eXBlb2YgVVJMID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgVVJMLmNyZWF0ZU9iamVjdFVSTCA9PT0gXCJmdW5jdGlvblwiICYmXG5cdFx0dHlwZW9mIFVSTC5yZXZva2VPYmplY3RVUkwgPT09IFwiZnVuY3Rpb25cIiAmJlxuXHRcdHR5cGVvZiBCbG9iID09PSBcImZ1bmN0aW9uXCIgJiZcblx0XHR0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiXG5cdCkge1xuXHRcdHN0eWxlID0gY3JlYXRlTGlua0VsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gdXBkYXRlTGluay5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXG5cdFx0XHRpZihzdHlsZS5ocmVmKSBVUkwucmV2b2tlT2JqZWN0VVJMKHN0eWxlLmhyZWYpO1xuXHRcdH07XG5cdH0gZWxzZSB7XG5cdFx0c3R5bGUgPSBjcmVhdGVTdHlsZUVsZW1lbnQob3B0aW9ucyk7XG5cdFx0dXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlKTtcblx0XHRyZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG5cdFx0XHRyZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuXHRcdH07XG5cdH1cblxuXHR1cGRhdGUob2JqKTtcblxuXHRyZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaikge1xuXHRcdGlmIChuZXdPYmopIHtcblx0XHRcdGlmIChcblx0XHRcdFx0bmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuXHRcdFx0XHRuZXdPYmoubWVkaWEgPT09IG9iai5tZWRpYSAmJlxuXHRcdFx0XHRuZXdPYmouc291cmNlTWFwID09PSBvYmouc291cmNlTWFwXG5cdFx0XHQpIHtcblx0XHRcdFx0cmV0dXJuO1xuXHRcdFx0fVxuXG5cdFx0XHR1cGRhdGUob2JqID0gbmV3T2JqKTtcblx0XHR9IGVsc2Uge1xuXHRcdFx0cmVtb3ZlKCk7XG5cdFx0fVxuXHR9O1xufVxuXG52YXIgcmVwbGFjZVRleHQgPSAoZnVuY3Rpb24gKCkge1xuXHR2YXIgdGV4dFN0b3JlID0gW107XG5cblx0cmV0dXJuIGZ1bmN0aW9uIChpbmRleCwgcmVwbGFjZW1lbnQpIHtcblx0XHR0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG5cblx0XHRyZXR1cm4gdGV4dFN0b3JlLmZpbHRlcihCb29sZWFuKS5qb2luKCdcXG4nKTtcblx0fTtcbn0pKCk7XG5cbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcgKHN0eWxlLCBpbmRleCwgcmVtb3ZlLCBvYmopIHtcblx0dmFyIGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmouY3NzO1xuXG5cdGlmIChzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG5cdH0gZWxzZSB7XG5cdFx0dmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpO1xuXHRcdHZhciBjaGlsZE5vZGVzID0gc3R5bGUuY2hpbGROb2RlcztcblxuXHRcdGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGUucmVtb3ZlQ2hpbGQoY2hpbGROb2Rlc1tpbmRleF0pO1xuXG5cdFx0aWYgKGNoaWxkTm9kZXMubGVuZ3RoKSB7XG5cdFx0XHRzdHlsZS5pbnNlcnRCZWZvcmUoY3NzTm9kZSwgY2hpbGROb2Rlc1tpbmRleF0pO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcblx0XHR9XG5cdH1cbn1cblxuZnVuY3Rpb24gYXBwbHlUb1RhZyAoc3R5bGUsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIG1lZGlhID0gb2JqLm1lZGlhO1xuXG5cdGlmKG1lZGlhKSB7XG5cdFx0c3R5bGUuc2V0QXR0cmlidXRlKFwibWVkaWFcIiwgbWVkaWEpXG5cdH1cblxuXHRpZihzdHlsZS5zdHlsZVNoZWV0KSB7XG5cdFx0c3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gY3NzO1xuXHR9IGVsc2Uge1xuXHRcdHdoaWxlKHN0eWxlLmZpcnN0Q2hpbGQpIHtcblx0XHRcdHN0eWxlLnJlbW92ZUNoaWxkKHN0eWxlLmZpcnN0Q2hpbGQpO1xuXHRcdH1cblxuXHRcdHN0eWxlLmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpO1xuXHR9XG59XG5cbmZ1bmN0aW9uIHVwZGF0ZUxpbmsgKGxpbmssIG9wdGlvbnMsIG9iaikge1xuXHR2YXIgY3NzID0gb2JqLmNzcztcblx0dmFyIHNvdXJjZU1hcCA9IG9iai5zb3VyY2VNYXA7XG5cblx0Lypcblx0XHRJZiBjb252ZXJ0VG9BYnNvbHV0ZVVybHMgaXNuJ3QgZGVmaW5lZCwgYnV0IHNvdXJjZW1hcHMgYXJlIGVuYWJsZWRcblx0XHRhbmQgdGhlcmUgaXMgbm8gcHVibGljUGF0aCBkZWZpbmVkIHRoZW4gbGV0cyB0dXJuIGNvbnZlcnRUb0Fic29sdXRlVXJsc1xuXHRcdG9uIGJ5IGRlZmF1bHQuICBPdGhlcndpc2UgZGVmYXVsdCB0byB0aGUgY29udmVydFRvQWJzb2x1dGVVcmxzIG9wdGlvblxuXHRcdGRpcmVjdGx5XG5cdCovXG5cdHZhciBhdXRvRml4VXJscyA9IG9wdGlvbnMuY29udmVydFRvQWJzb2x1dGVVcmxzID09PSB1bmRlZmluZWQgJiYgc291cmNlTWFwO1xuXG5cdGlmIChvcHRpb25zLmNvbnZlcnRUb0Fic29sdXRlVXJscyB8fCBhdXRvRml4VXJscykge1xuXHRcdGNzcyA9IGZpeFVybHMoY3NzKTtcblx0fVxuXG5cdGlmIChzb3VyY2VNYXApIHtcblx0XHQvLyBodHRwOi8vc3RhY2tvdmVyZmxvdy5jb20vYS8yNjYwMzg3NVxuXHRcdGNzcyArPSBcIlxcbi8qIyBzb3VyY2VNYXBwaW5nVVJMPWRhdGE6YXBwbGljYXRpb24vanNvbjtiYXNlNjQsXCIgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgXCIgKi9cIjtcblx0fVxuXG5cdHZhciBibG9iID0gbmV3IEJsb2IoW2Nzc10sIHsgdHlwZTogXCJ0ZXh0L2Nzc1wiIH0pO1xuXG5cdHZhciBvbGRTcmMgPSBsaW5rLmhyZWY7XG5cblx0bGluay5ocmVmID0gVVJMLmNyZWF0ZU9iamVjdFVSTChibG9iKTtcblxuXHRpZihvbGRTcmMpIFVSTC5yZXZva2VPYmplY3RVUkwob2xkU3JjKTtcbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3N0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzLmpzXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJcbi8qKlxuICogV2hlbiBzb3VyY2UgbWFwcyBhcmUgZW5hYmxlZCwgYHN0eWxlLWxvYWRlcmAgdXNlcyBhIGxpbmsgZWxlbWVudCB3aXRoIGEgZGF0YS11cmkgdG9cbiAqIGVtYmVkIHRoZSBjc3Mgb24gdGhlIHBhZ2UuIFRoaXMgYnJlYWtzIGFsbCByZWxhdGl2ZSB1cmxzIGJlY2F1c2Ugbm93IHRoZXkgYXJlIHJlbGF0aXZlIHRvIGFcbiAqIGJ1bmRsZSBpbnN0ZWFkIG9mIHRoZSBjdXJyZW50IHBhZ2UuXG4gKlxuICogT25lIHNvbHV0aW9uIGlzIHRvIG9ubHkgdXNlIGZ1bGwgdXJscywgYnV0IHRoYXQgbWF5IGJlIGltcG9zc2libGUuXG4gKlxuICogSW5zdGVhZCwgdGhpcyBmdW5jdGlvbiBcImZpeGVzXCIgdGhlIHJlbGF0aXZlIHVybHMgdG8gYmUgYWJzb2x1dGUgYWNjb3JkaW5nIHRvIHRoZSBjdXJyZW50IHBhZ2UgbG9jYXRpb24uXG4gKlxuICogQSBydWRpbWVudGFyeSB0ZXN0IHN1aXRlIGlzIGxvY2F0ZWQgYXQgYHRlc3QvZml4VXJscy5qc2AgYW5kIGNhbiBiZSBydW4gdmlhIHRoZSBgbnBtIHRlc3RgIGNvbW1hbmQuXG4gKlxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gKGNzcykge1xuICAvLyBnZXQgY3VycmVudCBsb2NhdGlvblxuICB2YXIgbG9jYXRpb24gPSB0eXBlb2Ygd2luZG93ICE9PSBcInVuZGVmaW5lZFwiICYmIHdpbmRvdy5sb2NhdGlvbjtcblxuICBpZiAoIWxvY2F0aW9uKSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZml4VXJscyByZXF1aXJlcyB3aW5kb3cubG9jYXRpb25cIik7XG4gIH1cblxuXHQvLyBibGFuayBvciBudWxsP1xuXHRpZiAoIWNzcyB8fCB0eXBlb2YgY3NzICE9PSBcInN0cmluZ1wiKSB7XG5cdCAgcmV0dXJuIGNzcztcbiAgfVxuXG4gIHZhciBiYXNlVXJsID0gbG9jYXRpb24ucHJvdG9jb2wgKyBcIi8vXCIgKyBsb2NhdGlvbi5ob3N0O1xuICB2YXIgY3VycmVudERpciA9IGJhc2VVcmwgKyBsb2NhdGlvbi5wYXRobmFtZS5yZXBsYWNlKC9cXC9bXlxcL10qJC8sIFwiL1wiKTtcblxuXHQvLyBjb252ZXJ0IGVhY2ggdXJsKC4uLilcblx0Lypcblx0VGhpcyByZWd1bGFyIGV4cHJlc3Npb24gaXMganVzdCBhIHdheSB0byByZWN1cnNpdmVseSBtYXRjaCBicmFja2V0cyB3aXRoaW5cblx0YSBzdHJpbmcuXG5cblx0IC91cmxcXHMqXFwoICA9IE1hdGNoIG9uIHRoZSB3b3JkIFwidXJsXCIgd2l0aCBhbnkgd2hpdGVzcGFjZSBhZnRlciBpdCBhbmQgdGhlbiBhIHBhcmVuc1xuXHQgICAoICA9IFN0YXJ0IGEgY2FwdHVyaW5nIGdyb3VwXG5cdCAgICAgKD86ICA9IFN0YXJ0IGEgbm9uLWNhcHR1cmluZyBncm91cFxuXHQgICAgICAgICBbXikoXSAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICBcXCggID0gTWF0Y2ggYSBzdGFydCBwYXJlbnRoZXNlc1xuXHQgICAgICAgICAgICAgKD86ICA9IFN0YXJ0IGFub3RoZXIgbm9uLWNhcHR1cmluZyBncm91cHNcblx0ICAgICAgICAgICAgICAgICBbXikoXSsgID0gTWF0Y2ggYW55dGhpbmcgdGhhdCBpc24ndCBhIHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgfCAgPSBPUlxuXHQgICAgICAgICAgICAgICAgIFxcKCAgPSBNYXRjaCBhIHN0YXJ0IHBhcmVudGhlc2VzXG5cdCAgICAgICAgICAgICAgICAgICAgIFteKShdKiAgPSBNYXRjaCBhbnl0aGluZyB0aGF0IGlzbid0IGEgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICAgICBcXCkgID0gTWF0Y2ggYSBlbmQgcGFyZW50aGVzZXNcblx0ICAgICAgICAgICAgICkgID0gRW5kIEdyb3VwXG4gICAgICAgICAgICAgICpcXCkgPSBNYXRjaCBhbnl0aGluZyBhbmQgdGhlbiBhIGNsb3NlIHBhcmVuc1xuICAgICAgICAgICkgID0gQ2xvc2Ugbm9uLWNhcHR1cmluZyBncm91cFxuICAgICAgICAgICogID0gTWF0Y2ggYW55dGhpbmdcbiAgICAgICApICA9IENsb3NlIGNhcHR1cmluZyBncm91cFxuXHQgXFwpICA9IE1hdGNoIGEgY2xvc2UgcGFyZW5zXG5cblx0IC9naSAgPSBHZXQgYWxsIG1hdGNoZXMsIG5vdCB0aGUgZmlyc3QuICBCZSBjYXNlIGluc2Vuc2l0aXZlLlxuXHQgKi9cblx0dmFyIGZpeGVkQ3NzID0gY3NzLnJlcGxhY2UoL3VybFxccypcXCgoKD86W14pKF18XFwoKD86W14pKF0rfFxcKFteKShdKlxcKSkqXFwpKSopXFwpL2dpLCBmdW5jdGlvbihmdWxsTWF0Y2gsIG9yaWdVcmwpIHtcblx0XHQvLyBzdHJpcCBxdW90ZXMgKGlmIHRoZXkgZXhpc3QpXG5cdFx0dmFyIHVucXVvdGVkT3JpZ1VybCA9IG9yaWdVcmxcblx0XHRcdC50cmltKClcblx0XHRcdC5yZXBsYWNlKC9eXCIoLiopXCIkLywgZnVuY3Rpb24obywgJDEpeyByZXR1cm4gJDE7IH0pXG5cdFx0XHQucmVwbGFjZSgvXicoLiopJyQvLCBmdW5jdGlvbihvLCAkMSl7IHJldHVybiAkMTsgfSk7XG5cblx0XHQvLyBhbHJlYWR5IGEgZnVsbCB1cmw/IG5vIGNoYW5nZVxuXHRcdGlmICgvXigjfGRhdGE6fGh0dHA6XFwvXFwvfGh0dHBzOlxcL1xcL3xmaWxlOlxcL1xcL1xcLykvaS50ZXN0KHVucXVvdGVkT3JpZ1VybCkpIHtcblx0XHQgIHJldHVybiBmdWxsTWF0Y2g7XG5cdFx0fVxuXG5cdFx0Ly8gY29udmVydCB0aGUgdXJsIHRvIGEgZnVsbCB1cmxcblx0XHR2YXIgbmV3VXJsO1xuXG5cdFx0aWYgKHVucXVvdGVkT3JpZ1VybC5pbmRleE9mKFwiLy9cIikgPT09IDApIHtcblx0XHQgIFx0Ly9UT0RPOiBzaG91bGQgd2UgYWRkIHByb3RvY29sP1xuXHRcdFx0bmV3VXJsID0gdW5xdW90ZWRPcmlnVXJsO1xuXHRcdH0gZWxzZSBpZiAodW5xdW90ZWRPcmlnVXJsLmluZGV4T2YoXCIvXCIpID09PSAwKSB7XG5cdFx0XHQvLyBwYXRoIHNob3VsZCBiZSByZWxhdGl2ZSB0byB0aGUgYmFzZSB1cmxcblx0XHRcdG5ld1VybCA9IGJhc2VVcmwgKyB1bnF1b3RlZE9yaWdVcmw7IC8vIGFscmVhZHkgc3RhcnRzIHdpdGggJy8nXG5cdFx0fSBlbHNlIHtcblx0XHRcdC8vIHBhdGggc2hvdWxkIGJlIHJlbGF0aXZlIHRvIGN1cnJlbnQgZGlyZWN0b3J5XG5cdFx0XHRuZXdVcmwgPSBjdXJyZW50RGlyICsgdW5xdW90ZWRPcmlnVXJsLnJlcGxhY2UoL15cXC5cXC8vLCBcIlwiKTsgLy8gU3RyaXAgbGVhZGluZyAnLi8nXG5cdFx0fVxuXG5cdFx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCB1cmwoLi4uKVxuXHRcdHJldHVybiBcInVybChcIiArIEpTT04uc3RyaW5naWZ5KG5ld1VybCkgKyBcIilcIjtcblx0fSk7XG5cblx0Ly8gc2VuZCBiYWNrIHRoZSBmaXhlZCBjc3Ncblx0cmV0dXJuIGZpeGVkQ3NzO1xufTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy9zdHlsZS1sb2FkZXIvbGliL3VybHMuanMiLCJ2YXIgYXBwbHkgPSBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHk7XG5cbi8vIERPTSBBUElzLCBmb3IgY29tcGxldGVuZXNzXG5cbmV4cG9ydHMuc2V0VGltZW91dCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRUaW1lb3V0LCB3aW5kb3csIGFyZ3VtZW50cyksIGNsZWFyVGltZW91dCk7XG59O1xuZXhwb3J0cy5zZXRJbnRlcnZhbCA9IGZ1bmN0aW9uKCkge1xuICByZXR1cm4gbmV3IFRpbWVvdXQoYXBwbHkuY2FsbChzZXRJbnRlcnZhbCwgd2luZG93LCBhcmd1bWVudHMpLCBjbGVhckludGVydmFsKTtcbn07XG5leHBvcnRzLmNsZWFyVGltZW91dCA9XG5leHBvcnRzLmNsZWFySW50ZXJ2YWwgPSBmdW5jdGlvbih0aW1lb3V0KSB7XG4gIGlmICh0aW1lb3V0KSB7XG4gICAgdGltZW91dC5jbG9zZSgpO1xuICB9XG59O1xuXG5mdW5jdGlvbiBUaW1lb3V0KGlkLCBjbGVhckZuKSB7XG4gIHRoaXMuX2lkID0gaWQ7XG4gIHRoaXMuX2NsZWFyRm4gPSBjbGVhckZuO1xufVxuVGltZW91dC5wcm90b3R5cGUudW5yZWYgPSBUaW1lb3V0LnByb3RvdHlwZS5yZWYgPSBmdW5jdGlvbigpIHt9O1xuVGltZW91dC5wcm90b3R5cGUuY2xvc2UgPSBmdW5jdGlvbigpIHtcbiAgdGhpcy5fY2xlYXJGbi5jYWxsKHdpbmRvdywgdGhpcy5faWQpO1xufTtcblxuLy8gRG9lcyBub3Qgc3RhcnQgdGhlIHRpbWUsIGp1c3Qgc2V0cyB1cCB0aGUgbWVtYmVycyBuZWVkZWQuXG5leHBvcnRzLmVucm9sbCA9IGZ1bmN0aW9uKGl0ZW0sIG1zZWNzKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSBtc2Vjcztcbn07XG5cbmV4cG9ydHMudW5lbnJvbGwgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcbiAgaXRlbS5faWRsZVRpbWVvdXQgPSAtMTtcbn07XG5cbmV4cG9ydHMuX3VucmVmQWN0aXZlID0gZXhwb3J0cy5hY3RpdmUgPSBmdW5jdGlvbihpdGVtKSB7XG4gIGNsZWFyVGltZW91dChpdGVtLl9pZGxlVGltZW91dElkKTtcblxuICB2YXIgbXNlY3MgPSBpdGVtLl9pZGxlVGltZW91dDtcbiAgaWYgKG1zZWNzID49IDApIHtcbiAgICBpdGVtLl9pZGxlVGltZW91dElkID0gc2V0VGltZW91dChmdW5jdGlvbiBvblRpbWVvdXQoKSB7XG4gICAgICBpZiAoaXRlbS5fb25UaW1lb3V0KVxuICAgICAgICBpdGVtLl9vblRpbWVvdXQoKTtcbiAgICB9LCBtc2Vjcyk7XG4gIH1cbn07XG5cbi8vIHNldGltbWVkaWF0ZSBhdHRhY2hlcyBpdHNlbGYgdG8gdGhlIGdsb2JhbCBvYmplY3RcbnJlcXVpcmUoXCJzZXRpbW1lZGlhdGVcIik7XG5leHBvcnRzLnNldEltbWVkaWF0ZSA9IHNldEltbWVkaWF0ZTtcbmV4cG9ydHMuY2xlYXJJbW1lZGlhdGUgPSBjbGVhckltbWVkaWF0ZTtcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy90aW1lcnMtYnJvd3NlcmlmeS9tYWluLmpzIiwiZnVuY3Rpb24gRSAoKSB7XG4gIC8vIEtlZXAgdGhpcyBlbXB0eSBzbyBpdCdzIGVhc2llciB0byBpbmhlcml0IGZyb21cbiAgLy8gKHZpYSBodHRwczovL2dpdGh1Yi5jb20vbGlwc21hY2sgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2lzc3Vlcy8zKVxufVxuXG5FLnByb3RvdHlwZSA9IHtcbiAgb246IGZ1bmN0aW9uIChuYW1lLCBjYWxsYmFjaywgY3R4KSB7XG4gICAgdmFyIGUgPSB0aGlzLmUgfHwgKHRoaXMuZSA9IHt9KTtcblxuICAgIChlW25hbWVdIHx8IChlW25hbWVdID0gW10pKS5wdXNoKHtcbiAgICAgIGZuOiBjYWxsYmFjayxcbiAgICAgIGN0eDogY3R4XG4gICAgfSk7XG5cbiAgICByZXR1cm4gdGhpcztcbiAgfSxcblxuICBvbmNlOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2ssIGN0eCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiBsaXN0ZW5lciAoKSB7XG4gICAgICBzZWxmLm9mZihuYW1lLCBsaXN0ZW5lcik7XG4gICAgICBjYWxsYmFjay5hcHBseShjdHgsIGFyZ3VtZW50cyk7XG4gICAgfTtcblxuICAgIGxpc3RlbmVyLl8gPSBjYWxsYmFja1xuICAgIHJldHVybiB0aGlzLm9uKG5hbWUsIGxpc3RlbmVyLCBjdHgpO1xuICB9LFxuXG4gIGVtaXQ6IGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgdmFyIGRhdGEgPSBbXS5zbGljZS5jYWxsKGFyZ3VtZW50cywgMSk7XG4gICAgdmFyIGV2dEFyciA9ICgodGhpcy5lIHx8ICh0aGlzLmUgPSB7fSkpW25hbWVdIHx8IFtdKS5zbGljZSgpO1xuICAgIHZhciBpID0gMDtcbiAgICB2YXIgbGVuID0gZXZ0QXJyLmxlbmd0aDtcblxuICAgIGZvciAoaTsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICBldnRBcnJbaV0uZm4uYXBwbHkoZXZ0QXJyW2ldLmN0eCwgZGF0YSk7XG4gICAgfVxuXG4gICAgcmV0dXJuIHRoaXM7XG4gIH0sXG5cbiAgb2ZmOiBmdW5jdGlvbiAobmFtZSwgY2FsbGJhY2spIHtcbiAgICB2YXIgZSA9IHRoaXMuZSB8fCAodGhpcy5lID0ge30pO1xuICAgIHZhciBldnRzID0gZVtuYW1lXTtcbiAgICB2YXIgbGl2ZUV2ZW50cyA9IFtdO1xuXG4gICAgaWYgKGV2dHMgJiYgY2FsbGJhY2spIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsZW4gPSBldnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgIGlmIChldnRzW2ldLmZuICE9PSBjYWxsYmFjayAmJiBldnRzW2ldLmZuLl8gIT09IGNhbGxiYWNrKVxuICAgICAgICAgIGxpdmVFdmVudHMucHVzaChldnRzW2ldKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBSZW1vdmUgZXZlbnQgZnJvbSBxdWV1ZSB0byBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgLy8gU3VnZ2VzdGVkIGJ5IGh0dHBzOi8vZ2l0aHViLmNvbS9sYXpkXG4gICAgLy8gUmVmOiBodHRwczovL2dpdGh1Yi5jb20vc2NvdHRjb3JnYW4vdGlueS1lbWl0dGVyL2NvbW1pdC9jNmViZmFhOWJjOTczYjMzZDExMGE4NGEzMDc3NDJiN2NmOTRjOTUzI2NvbW1pdGNvbW1lbnQtNTAyNDkxMFxuXG4gICAgKGxpdmVFdmVudHMubGVuZ3RoKVxuICAgICAgPyBlW25hbWVdID0gbGl2ZUV2ZW50c1xuICAgICAgOiBkZWxldGUgZVtuYW1lXTtcblxuICAgIHJldHVybiB0aGlzO1xuICB9XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IEU7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdGlueS1lbWl0dGVyL2luZGV4LmpzIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanMhLi90aXBweS5jc3NcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbi8vIFByZXBhcmUgY3NzVHJhbnNmb3JtYXRpb25cbnZhciB0cmFuc2Zvcm07XG5cbnZhciBvcHRpb25zID0ge31cbm9wdGlvbnMudHJhbnNmb3JtID0gdHJhbnNmb3JtXG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi9zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlcy5qc1wiKShjb250ZW50LCBvcHRpb25zKTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuXHQvLyBXaGVuIHRoZSBzdHlsZXMgY2hhbmdlLCB1cGRhdGUgdGhlIDxzdHlsZT4gdGFnc1xuXHRpZighY29udGVudC5sb2NhbHMpIHtcblx0XHRtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3RpcHB5LmNzc1wiLCBmdW5jdGlvbigpIHtcblx0XHRcdHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcyEuL3RpcHB5LmNzc1wiKTtcblx0XHRcdGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuXHRcdFx0dXBkYXRlKG5ld0NvbnRlbnQpO1xuXHRcdH0pO1xuXHR9XG5cdC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3Ncblx0bW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdGlwcHkuanMvZGlzdC90aXBweS5jc3Ncbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuY3NzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbC50aXBweSA9IGZhY3RvcnkoKSk7XG59KHRoaXMsIChmdW5jdGlvbiAoKSB7ICd1c2Ugc3RyaWN0JztcblxudmFyIEJyb3dzZXIgPSB7fTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIEJyb3dzZXIuU1VQUE9SVEVEID0gJ3JlcXVlc3RBbmltYXRpb25GcmFtZScgaW4gd2luZG93O1xuICBCcm93c2VyLlNVUFBPUlRTX1RPVUNIID0gJ29udG91Y2hzdGFydCcgaW4gd2luZG93O1xuICBCcm93c2VyLnRvdWNoID0gZmFsc2U7XG4gIEJyb3dzZXIuZHluYW1pY0lucHV0RGV0ZWN0aW9uID0gdHJ1ZTtcbiAgLy8gQ2hyb21lIGRldmljZS90b3VjaCBlbXVsYXRpb24gY2FuIG1ha2UgdGhpcyBkeW5hbWljXG4gIEJyb3dzZXIuaU9TID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiAoL2lQaG9uZXxpUGFkfGlQb2QvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudCkgJiYgIXdpbmRvdy5NU1N0cmVhbVxuICAgICk7XG4gIH07XG59XG5cbi8qKlxuKiBUaGUgZ2xvYmFsIHN0b3JhZ2UgYXJyYXkgd2hpY2ggaG9sZHMgYWxsIGRhdGEgcmVmZXJlbmNlIG9iamVjdHNcbiogZnJvbSBldmVyeSBpbnN0YW5jZVxuKiBUaGlzIGFsbG93cyB1cyB0byBoaWRlIHRvb2x0aXBzIGZyb20gYWxsIGluc3RhbmNlcywgZmluZGluZyB0aGUgcmVmIHdoZW5cbiogY2xpY2tpbmcgb24gdGhlIGJvZHksIGFuZCBmb3IgZm9sbG93Q3Vyc29yXG4qL1xudmFyIFN0b3JlID0gW107XG5cbi8qKlxuKiBTZWxlY3RvciBjb25zdGFudHMgdXNlZCBmb3IgZ3JhYmJpbmcgZWxlbWVudHNcbiovXG52YXIgU2VsZWN0b3JzID0ge1xuICBQT1BQRVI6ICcudGlwcHktcG9wcGVyJyxcbiAgVE9PTFRJUDogJy50aXBweS10b29sdGlwJyxcbiAgQ09OVEVOVDogJy50aXBweS10b29sdGlwLWNvbnRlbnQnLFxuICBDSVJDTEU6ICdbeC1jaXJjbGVdJyxcbiAgQVJST1c6ICdbeC1hcnJvd10nLFxuICBUT09MVElQUEVEX0VMOiAnW2RhdGEtdG9vbHRpcHBlZF0nLFxuICBDT05UUk9MTEVSOiAnW2RhdGEtdGlwcHktY29udHJvbGxlcl0nXG5cbiAgLyoqXG4gICogVGhlIGRlZmF1bHQgc2V0dGluZ3MgYXBwbGllZCB0byBlYWNoIGluc3RhbmNlXG4gICovXG59O3ZhciBEZWZhdWx0cyA9IHtcbiAgaHRtbDogZmFsc2UsXG4gIHBvc2l0aW9uOiAndG9wJyxcbiAgYW5pbWF0aW9uOiAnc2hpZnQnLFxuICBhbmltYXRlRmlsbDogdHJ1ZSxcbiAgYXJyb3c6IGZhbHNlLFxuICBhcnJvd1NpemU6ICdyZWd1bGFyJyxcbiAgZGVsYXk6IDAsXG4gIHRyaWdnZXI6ICdtb3VzZWVudGVyIGZvY3VzJyxcbiAgZHVyYXRpb246IDM1MCxcbiAgaW50ZXJhY3RpdmU6IGZhbHNlLFxuICBpbnRlcmFjdGl2ZUJvcmRlcjogMixcbiAgdGhlbWU6ICdkYXJrJyxcbiAgc2l6ZTogJ3JlZ3VsYXInLFxuICBkaXN0YW5jZTogMTAsXG4gIG9mZnNldDogMCxcbiAgaGlkZU9uQ2xpY2s6IHRydWUsXG4gIG11bHRpcGxlOiBmYWxzZSxcbiAgZm9sbG93Q3Vyc29yOiBmYWxzZSxcbiAgaW5lcnRpYTogZmFsc2UsXG4gIGZsaXBEdXJhdGlvbjogMzUwLFxuICBzdGlja3k6IGZhbHNlLFxuICBzdGlja3lEdXJhdGlvbjogMjAwLFxuICBhcHBlbmRUbzogZnVuY3Rpb24gYXBwZW5kVG8oKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmJvZHk7XG4gIH0sXG4gIHpJbmRleDogOTk5OSxcbiAgdG91Y2hIb2xkOiBmYWxzZSxcbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuICBkeW5hbWljVGl0bGU6IGZhbHNlLFxuICBwb3BwZXJPcHRpb25zOiB7fVxuXG4gIC8qKlxuICAqIFRoZSBrZXlzIG9mIHRoZSBkZWZhdWx0cyBvYmplY3QgZm9yIHJlZHVjaW5nIGRvd24gaW50byBhIG5ldyBvYmplY3RcbiAgKiBVc2VkIGluIGBnZXRJbmRpdmlkdWFsU2V0dGluZ3MoKWBcbiAgKi9cbn07dmFyIERlZmF1bHRzS2V5cyA9IEJyb3dzZXIuU1VQUE9SVEVEICYmIE9iamVjdC5rZXlzKERlZmF1bHRzKTtcblxuLyoqXG4qIEhpZGVzIGFsbCBwb3BwZXJzXG4qIEBwYXJhbSB7T2JqZWN0fSBleGNsdWRlIC0gcmVmRGF0YSB0byBleGNsdWRlIGlmIG5lZWRlZFxuKi9cbmZ1bmN0aW9uIGhpZGVBbGxQb3BwZXJzKGV4Y2x1ZGUpIHtcbiAgU3RvcmUuZm9yRWFjaChmdW5jdGlvbiAocmVmRGF0YSkge1xuICAgIHZhciBwb3BwZXIgPSByZWZEYXRhLnBvcHBlcixcbiAgICAgICAgdGlwcHlJbnN0YW5jZSA9IHJlZkRhdGEudGlwcHlJbnN0YW5jZSxcbiAgICAgICAgX3JlZkRhdGEkc2V0dGluZ3MgPSByZWZEYXRhLnNldHRpbmdzLFxuICAgICAgICBhcHBlbmRUbyA9IF9yZWZEYXRhJHNldHRpbmdzLmFwcGVuZFRvLFxuICAgICAgICBoaWRlT25DbGljayA9IF9yZWZEYXRhJHNldHRpbmdzLmhpZGVPbkNsaWNrLFxuICAgICAgICB0cmlnZ2VyID0gX3JlZkRhdGEkc2V0dGluZ3MudHJpZ2dlcjtcblxuICAgIC8vIERvbid0IGhpZGUgYWxyZWFkeSBoaWRkZW4gb25lc1xuXG4gICAgaWYgKCFhcHBlbmRUby5jb250YWlucyhwb3BwZXIpKSByZXR1cm47XG5cbiAgICAvLyBoaWRlT25DbGljayBjYW4gaGF2ZSB0aGUgdHJ1dGh5IHZhbHVlIG9mICdwZXJzaXN0ZW50Jywgc28gc3RyaWN0IGNoZWNrIGlzIG5lZWRlZFxuICAgIHZhciBpc0hpZGVPbkNsaWNrID0gaGlkZU9uQ2xpY2sgPT09IHRydWUgfHwgdHJpZ2dlci5pbmRleE9mKCdmb2N1cycpICE9PSAtMTtcbiAgICB2YXIgaXNOb3RDdXJyZW50UmVmID0gIWV4Y2x1ZGUgfHwgcG9wcGVyICE9PSBleGNsdWRlLnBvcHBlcjtcblxuICAgIGlmIChpc0hpZGVPbkNsaWNrICYmIGlzTm90Q3VycmVudFJlZikge1xuICAgICAgdGlwcHlJbnN0YW5jZS5oaWRlKHBvcHBlcik7XG4gICAgfVxuICB9KTtcbn1cblxudmFyIG1hdGNoZXMgPSB7fTtcblxuaWYgKHR5cGVvZiBFbGVtZW50ICE9PSAndW5kZWZpbmVkJykge1xuICB2YXIgZSA9IEVsZW1lbnQucHJvdG90eXBlO1xuICBtYXRjaGVzID0gZS5tYXRjaGVzIHx8IGUubWF0Y2hlc1NlbGVjdG9yIHx8IGUud2Via2l0TWF0Y2hlc1NlbGVjdG9yIHx8IGUubW96TWF0Y2hlc1NlbGVjdG9yIHx8IGUubXNNYXRjaGVzU2VsZWN0b3IgfHwgZnVuY3Rpb24gKHMpIHtcbiAgICB2YXIgbWF0Y2hlcyA9ICh0aGlzLmRvY3VtZW50IHx8IHRoaXMub3duZXJEb2N1bWVudCkucXVlcnlTZWxlY3RvckFsbChzKSxcbiAgICAgICAgaSA9IG1hdGNoZXMubGVuZ3RoO1xuICAgIHdoaWxlICgtLWkgPj0gMCAmJiBtYXRjaGVzLml0ZW0oaSkgIT09IHRoaXMpIHt9XG4gICAgcmV0dXJuIGkgPiAtMTtcbiAgfTtcbn1cblxudmFyIG1hdGNoZXMkMSA9IG1hdGNoZXM7XG5cbi8qKlxuKiBQb255ZmlsbCB0byBnZXQgdGhlIGNsb3Nlc3QgcGFyZW50IGVsZW1lbnRcbiogQHBhcmFtIHtFbGVtZW50fSBlbGVtZW50IC0gY2hpbGQgb2YgcGFyZW50IHRvIGJlIHJldHVybmVkXG4qIEBwYXJhbSB7U3RyaW5nfSBwYXJlbnRTZWxlY3RvciAtIHNlbGVjdG9yIHRvIG1hdGNoIHRoZSBwYXJlbnQgaWYgZm91bmRcbiogQHJldHVybiB7RWxlbWVudH1cbiovXG5mdW5jdGlvbiBjbG9zZXN0KGVsZW1lbnQsIHBhcmVudFNlbGVjdG9yKSB7XG4gIHZhciBfY2xvc2VzdCA9IEVsZW1lbnQucHJvdG90eXBlLmNsb3Nlc3QgfHwgZnVuY3Rpb24gKHNlbGVjdG9yKSB7XG4gICAgdmFyIGVsID0gdGhpcztcbiAgICB3aGlsZSAoZWwpIHtcbiAgICAgIGlmIChtYXRjaGVzJDEuY2FsbChlbCwgc2VsZWN0b3IpKSB7XG4gICAgICAgIHJldHVybiBlbDtcbiAgICAgIH1cbiAgICAgIGVsID0gZWwucGFyZW50RWxlbWVudDtcbiAgICB9XG4gIH07XG5cbiAgcmV0dXJuIF9jbG9zZXN0LmNhbGwoZWxlbWVudCwgcGFyZW50U2VsZWN0b3IpO1xufVxuXG4vKipcbiogUG9ueWZpbGwgZm9yIEFycmF5LnByb3RvdHlwZS5maW5kXG4qIEBwYXJhbSB7QXJyYXl9IGFyclxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjaGVja0ZuXG4qIEByZXR1cm4gaXRlbSBpbiB0aGUgYXJyYXlcbiovXG5mdW5jdGlvbiBmaW5kKGFyciwgY2hlY2tGbikge1xuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2tGbik7XG4gIH1cblxuICAvLyB1c2UgYGZpbHRlcmAgYXMgZmFsbGJhY2tcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2tGbilbMF07XG59XG5cbi8qKlxuKiBBZGRzIHRoZSBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzXG4qL1xuZnVuY3Rpb24gYmluZEV2ZW50TGlzdGVuZXJzKCkge1xuICB2YXIgdG91Y2hIYW5kbGVyID0gZnVuY3Rpb24gdG91Y2hIYW5kbGVyKCkge1xuICAgIEJyb3dzZXIudG91Y2ggPSB0cnVlO1xuXG4gICAgaWYgKEJyb3dzZXIuaU9TKCkpIHtcbiAgICAgIGRvY3VtZW50LmJvZHkuY2xhc3NMaXN0LmFkZCgndGlwcHktdG91Y2gnKTtcbiAgICB9XG5cbiAgICBpZiAoQnJvd3Nlci5keW5hbWljSW5wdXREZXRlY3Rpb24gJiYgd2luZG93LnBlcmZvcm1hbmNlKSB7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBtb3VzZW1vdmVIYW5kbGVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIG1vdXNlbW92ZUhhbmRsZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHRpbWUgPSB2b2lkIDA7XG5cbiAgICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5vdyA9IHBlcmZvcm1hbmNlLm5vdygpO1xuXG4gICAgICAvLyBDaHJvbWUgNjArIGlzIDEgbW91c2Vtb3ZlIHBlciByQUYsIHVzZSAyMG1zIHRpbWUgZGlmZmVyZW5jZVxuICAgICAgaWYgKG5vdyAtIHRpbWUgPCAyMCkge1xuICAgICAgICBCcm93c2VyLnRvdWNoID0gZmFsc2U7XG4gICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIG1vdXNlbW92ZUhhbmRsZXIpO1xuICAgICAgICBpZiAoIUJyb3dzZXIuaU9TKCkpIHtcbiAgICAgICAgICBkb2N1bWVudC5ib2R5LmNsYXNzTGlzdC5yZW1vdmUoJ3RpcHB5LXRvdWNoJyk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgdGltZSA9IG5vdztcbiAgICB9O1xuICB9KCk7XG5cbiAgdmFyIGNsaWNrSGFuZGxlciA9IGZ1bmN0aW9uIGNsaWNrSGFuZGxlcihldmVudCkge1xuICAgIC8vIFNpbXVsYXRlZCBldmVudHMgZGlzcGF0Y2hlZCBvbiB0aGUgZG9jdW1lbnRcbiAgICBpZiAoIShldmVudC50YXJnZXQgaW5zdGFuY2VvZiBFbGVtZW50KSkge1xuICAgICAgcmV0dXJuIGhpZGVBbGxQb3BwZXJzKCk7XG4gICAgfVxuXG4gICAgdmFyIGVsID0gY2xvc2VzdChldmVudC50YXJnZXQsIFNlbGVjdG9ycy5UT09MVElQUEVEX0VMKTtcbiAgICB2YXIgcG9wcGVyID0gY2xvc2VzdChldmVudC50YXJnZXQsIFNlbGVjdG9ycy5QT1BQRVIpO1xuXG4gICAgaWYgKHBvcHBlcikge1xuICAgICAgdmFyIHJlZiA9IGZpbmQoU3RvcmUsIGZ1bmN0aW9uIChyZWYpIHtcbiAgICAgICAgcmV0dXJuIHJlZi5wb3BwZXIgPT09IHBvcHBlcjtcbiAgICAgIH0pO1xuICAgICAgdmFyIGludGVyYWN0aXZlID0gcmVmLnNldHRpbmdzLmludGVyYWN0aXZlO1xuXG4gICAgICBpZiAoaW50ZXJhY3RpdmUpIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoZWwpIHtcbiAgICAgIHZhciBfcmVmID0gZmluZChTdG9yZSwgZnVuY3Rpb24gKHJlZikge1xuICAgICAgICByZXR1cm4gcmVmLmVsID09PSBlbDtcbiAgICAgIH0pO1xuICAgICAgdmFyIF9yZWYkc2V0dGluZ3MgPSBfcmVmLnNldHRpbmdzLFxuICAgICAgICAgIGhpZGVPbkNsaWNrID0gX3JlZiRzZXR0aW5ncy5oaWRlT25DbGljayxcbiAgICAgICAgICBtdWx0aXBsZSA9IF9yZWYkc2V0dGluZ3MubXVsdGlwbGUsXG4gICAgICAgICAgdHJpZ2dlciA9IF9yZWYkc2V0dGluZ3MudHJpZ2dlcjtcblxuICAgICAgLy8gSGlkZSBhbGwgcG9wcGVycyBleGNlcHQgdGhlIG9uZSBiZWxvbmdpbmcgdG8gdGhlIGVsZW1lbnQgdGhhdCB3YXMgY2xpY2tlZCBJRlxuICAgICAgLy8gYG11bHRpcGxlYCBpcyBmYWxzZSBBTkQgdGhleSBhcmUgYSB0b3VjaCB1c2VyLCBPUlxuICAgICAgLy8gYG11bHRpcGxlYCBpcyBmYWxzZSBBTkQgaXQncyB0cmlnZ2VyZWQgYnkgYSBjbGlja1xuXG4gICAgICBpZiAoIW11bHRpcGxlICYmIEJyb3dzZXIudG91Y2ggfHwgIW11bHRpcGxlICYmIHRyaWdnZXIuaW5kZXhPZignY2xpY2snKSAhPT0gLTEpIHtcbiAgICAgICAgcmV0dXJuIGhpZGVBbGxQb3BwZXJzKF9yZWYpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBoaWRlT25DbGljayBpcyBub3Qgc3RyaWN0bHkgdHJ1ZSBvciB0cmlnZ2VyZWQgYnkgYSBjbGljayBkb24ndCBoaWRlIHBvcHBlcnNcbiAgICAgIGlmIChoaWRlT25DbGljayAhPT0gdHJ1ZSB8fCB0cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xKSByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gRG9uJ3QgdHJpZ2dlciBhIGhpZGUgZm9yIHRpcHB5IGNvbnRyb2xsZXJzLCBhbmQgZG9uJ3QgbmVlZGxlc3NseSBydW4gbG9vcFxuICAgIGlmIChjbG9zZXN0KGV2ZW50LnRhcmdldCwgU2VsZWN0b3JzLkNPTlRST0xMRVIpIHx8ICFkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFNlbGVjdG9ycy5QT1BQRVIpKSByZXR1cm47XG5cbiAgICBoaWRlQWxsUG9wcGVycygpO1xuICB9O1xuXG4gIHZhciBibHVySGFuZGxlciA9IGZ1bmN0aW9uIGJsdXJIYW5kbGVyKGV2ZW50KSB7XG4gICAgdmFyIF9kb2N1bWVudCA9IGRvY3VtZW50LFxuICAgICAgICBlbCA9IF9kb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuXG4gICAgaWYgKGVsICYmIGVsLmJsdXIgJiYgbWF0Y2hlcyQxLmNhbGwoZWwsIFNlbGVjdG9ycy5UT09MVElQUEVEX0VMKSkge1xuICAgICAgZWwuYmx1cigpO1xuICAgIH1cbiAgfTtcblxuICAvLyBIb29rIGV2ZW50c1xuICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdjbGljaycsIGNsaWNrSGFuZGxlcik7XG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3RvdWNoc3RhcnQnLCB0b3VjaEhhbmRsZXIpO1xuICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGJsdXJIYW5kbGVyKTtcblxuICBpZiAoIUJyb3dzZXIuU1VQUE9SVFNfVE9VQ0ggJiYgKG5hdmlnYXRvci5tYXhUb3VjaFBvaW50cyA+IDAgfHwgbmF2aWdhdG9yLm1zTWF4VG91Y2hQb2ludHMgPiAwKSkge1xuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3BvaW50ZXJkb3duJywgdG91Y2hIYW5kbGVyKTtcbiAgfVxufVxuXG4vKipcbiogVG8gcnVuIGEgc2luZ2xlIHRpbWUsIG9uY2UgRE9NIGlzIHByZXN1bWVkIHRvIGJlIHJlYWR5XG4qIEByZXR1cm4ge0Jvb2xlYW59IHdoZXRoZXIgdGhlIGZ1bmN0aW9uIGhhcyBydW4gb3Igbm90XG4qL1xuZnVuY3Rpb24gaW5pdCgpIHtcbiAgaWYgKGluaXQuZG9uZSkgcmV0dXJuIGZhbHNlO1xuICBpbml0LmRvbmUgPSB0cnVlO1xuXG4gIGJpbmRFdmVudExpc3RlbmVycygpO1xuXG4gIHJldHVybiB0cnVlO1xufVxuXG4vKipcbiogV2FpdHMgdW50aWwgbmV4dCByZXBhaW50IHRvIGV4ZWN1dGUgYSBmblxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBmblxuKi9cbmZ1bmN0aW9uIGRlZmVyKGZuKSB7XG4gIHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUoZnVuY3Rpb24gKCkge1xuICAgIHNldFRpbWVvdXQoZm4sIDApO1xuICB9KTtcbn1cblxuLyoqXG4qIFJldHVybnMgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCBwcm9wZXJ0eSAtIG9ubHkgYHdlYmtpdGAgaXMgbmVlZGVkLCBgbW96YCwgYG1zYCBhbmQgYG9gIGFyZSBvYnNvbGV0ZVxuKiBAcGFyYW0ge1N0cmluZ30gcHJvcGVydHlcbiogQHJldHVybiB7U3RyaW5nfSAtIGJyb3dzZXIgc3VwcG9ydGVkIHByZWZpeGVkIHByb3BlcnR5XG4qL1xuZnVuY3Rpb24gcHJlZml4KHByb3BlcnR5KSB7XG4gIHZhciBwcmVmaXhlcyA9IFtmYWxzZSwgJ3dlYmtpdCddO1xuICB2YXIgdXBwZXJQcm9wID0gcHJvcGVydHkuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wZXJ0eS5zbGljZSgxKTtcblxuICBmb3IgKHZhciBpID0gMDsgaSA8IHByZWZpeGVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIF9wcmVmaXggPSBwcmVmaXhlc1tpXTtcbiAgICB2YXIgcHJlZml4ZWRQcm9wID0gX3ByZWZpeCA/ICcnICsgX3ByZWZpeCArIHVwcGVyUHJvcCA6IHByb3BlcnR5O1xuICAgIGlmICh0eXBlb2Ygd2luZG93LmRvY3VtZW50LmJvZHkuc3R5bGVbcHJlZml4ZWRQcm9wXSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIHJldHVybiBwcmVmaXhlZFByb3A7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuKiBQb255ZmlsbCBmb3IgQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleFxuKiBAcGFyYW0ge0FycmF5fSBhcnJcbiogQHBhcmFtIHtGdW5jdGlvbn0gY2hlY2tGblxuKiBAcmV0dXJuIGluZGV4IG9mIHRoZSBpdGVtIGluIHRoZSBhcnJheVxuKi9cbmZ1bmN0aW9uIGZpbmRJbmRleChhcnIsIGNoZWNrRm4pIHtcbiAgaWYgKEFycmF5LnByb3RvdHlwZS5maW5kSW5kZXgpIHtcbiAgICByZXR1cm4gYXJyLmZpbmRJbmRleChjaGVja0ZuKTtcbiAgfVxuXG4gIC8vIGZhbGxiYWNrXG4gIHJldHVybiBhcnIuaW5kZXhPZihmaW5kKGFyciwgY2hlY2tGbikpO1xufVxuXG4vKipcbiogUmVtb3ZlcyB0aGUgdGl0bGUgZnJvbSB0aGUgdG9vbHRpcHBlZCBlbGVtZW50LCBzZXR0aW5nIGBkYXRhLW9yaWdpbmFsLXRpdGxlYFxuKiBhcHByb3ByaWF0ZWx5XG4qIEBwYXJhbSB7RWxlbWVudH0gZWxcbiovXG5mdW5jdGlvbiByZW1vdmVUaXRsZShlbCkge1xuICB2YXIgdGl0bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG5cbiAgLy8gT25seSBzZXQgYGRhdGEtb3JpZ2luYWwtdGl0bGVgIGF0dHIgaWYgdGhlcmUgaXMgYSB0aXRsZVxuICBpZiAodGl0bGUpIHtcbiAgICBlbC5zZXRBdHRyaWJ1dGUoJ2RhdGEtb3JpZ2luYWwtdGl0bGUnLCB0aXRsZSk7XG4gIH1cblxuICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ3RpdGxlJyk7XG59XG5cbi8qKlxuKiBEZXRlcm1pbmVzIGlmIGFuIGVsZW1lbnQgaXMgdmlzaWJsZSBpbiB0aGUgdmlld3BvcnRcbiogQHBhcmFtIHtFbGVtZW50fSBlbFxuKiBAcmV0dXJuIHtCb29sZWFufVxuKi9cbmZ1bmN0aW9uIGVsZW1lbnRJc0luVmlld3BvcnQoZWwpIHtcbiAgdmFyIHJlY3QgPSBlbC5nZXRCb3VuZGluZ0NsaWVudFJlY3QoKTtcblxuICByZXR1cm4gcmVjdC50b3AgPj0gMCAmJiByZWN0LmxlZnQgPj0gMCAmJiByZWN0LmJvdHRvbSA8PSAod2luZG93LmlubmVySGVpZ2h0IHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRIZWlnaHQpICYmIHJlY3QucmlnaHQgPD0gKHdpbmRvdy5pbm5lcldpZHRoIHx8IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudC5jbGllbnRXaWR0aCk7XG59XG5cbi8qKlxuKiBUcmlnZ2VycyBhIGRvY3VtZW50IHJlcGFpbnQgb3IgcmVmbG93IGZvciBDU1MgdHJhbnNpdGlvblxuKiBAcGFyYW0ge0VsZW1lbnR9IHRvb2x0aXBcbiogQHBhcmFtIHtFbGVtZW50fSBjaXJjbGVcbiovXG5mdW5jdGlvbiB0cmlnZ2VyUmVmbG93KHRvb2x0aXAsIGNpcmNsZSkge1xuICAvLyBTYWZhcmkgbmVlZHMgdGhlIHNwZWNpZmljICd0cmFuc2Zvcm0nIHByb3BlcnR5IHRvIGJlIGFjY2Vzc2VkXG4gIGNpcmNsZSA/IHdpbmRvdy5nZXRDb21wdXRlZFN0eWxlKGNpcmNsZSlbcHJlZml4KCd0cmFuc2Zvcm0nKV0gOiB3aW5kb3cuZ2V0Q29tcHV0ZWRTdHlsZSh0b29sdGlwKS5vcGFjaXR5O1xufVxuXG4vKipcbiogTW9kaWZpZXMgZWxlbWVudHMnIGNsYXNzIGxpc3RzXG4qIEBwYXJhbSB7RWxlbWVudFtdfSBlbHMgLSBBcnJheSBvZiBlbGVtZW50c1xuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuKi9cbmZ1bmN0aW9uIG1vZGlmeUNsYXNzTGlzdChlbHMsIGNhbGxiYWNrKSB7XG4gIGVscy5mb3JFYWNoKGZ1bmN0aW9uIChlbCkge1xuICAgIGlmICghZWwpIHJldHVybjtcbiAgICBjYWxsYmFjayhlbC5jbGFzc0xpc3QpO1xuICB9KTtcbn1cblxuLyoqXG4qIFJldHVybnMgaW5uZXIgZWxlbWVudHMgb2YgdGhlIHBvcHBlciBlbGVtZW50XG4qIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyXG4qIEByZXR1cm4ge09iamVjdH1cbiovXG5mdW5jdGlvbiBnZXRJbm5lckVsZW1lbnRzKHBvcHBlcikge1xuICByZXR1cm4ge1xuICAgIHRvb2x0aXA6IHBvcHBlci5xdWVyeVNlbGVjdG9yKFNlbGVjdG9ycy5UT09MVElQKSxcbiAgICBjaXJjbGU6IHBvcHBlci5xdWVyeVNlbGVjdG9yKFNlbGVjdG9ycy5DSVJDTEUpLFxuICAgIGNvbnRlbnQ6IHBvcHBlci5xdWVyeVNlbGVjdG9yKFNlbGVjdG9ycy5DT05URU5UKVxuICB9O1xufVxuXG4vKipcbiogQXBwbGllcyB0aGUgdHJhbnNpdGlvbiBkdXJhdGlvbiB0byBlYWNoIGVsZW1lbnRcbiogQHBhcmFtIHtFbGVtZW50W119IGVscyAtIEFycmF5IG9mIGVsZW1lbnRzXG4qIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuKi9cbmZ1bmN0aW9uIGFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uKGVscywgZHVyYXRpb24pIHtcbiAgZWxzLmZvckVhY2goZnVuY3Rpb24gKGVsKSB7XG4gICAgaWYgKCFlbCkgcmV0dXJuO1xuXG4gICAgdmFyIGlzQ29udGVudCA9IG1hdGNoZXMkMS5jYWxsKGVsLCBTZWxlY3RvcnMuQ09OVEVOVCk7XG5cbiAgICB2YXIgX2R1cmF0aW9uID0gaXNDb250ZW50ID8gTWF0aC5yb3VuZChkdXJhdGlvbiAvIDEuMykgOiBkdXJhdGlvbjtcblxuICAgIGVsLnN0eWxlW3ByZWZpeCgndHJhbnNpdGlvbkR1cmF0aW9uJyldID0gX2R1cmF0aW9uICsgJ21zJztcbiAgfSk7XG59XG5cbi8qKlxuKiBEZXRlcm1pbmVzIGlmIGEgcG9wcGVyIGlzIGN1cnJlbnRseSB2aXNpYmxlXG4qIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyXG4qIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xuZnVuY3Rpb24gaXNWaXNpYmxlKHBvcHBlcikge1xuICByZXR1cm4gcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPT09ICd2aXNpYmxlJztcbn1cblxuZnVuY3Rpb24gbm9vcCgpIHt9XG5cbmZ1bmN0aW9uIGlzT2JqZWN0TGl0ZXJhbChpbnB1dCkge1xuICByZXR1cm4gISFpbnB1dCAmJiBpbnB1dC50b1N0cmluZygpID09PSAnW29iamVjdCBPYmplY3RdJztcbn1cblxuLyoqXG4qIFJldHVybnMgdGhlIG5vbi1zaGlmdGVkIHBsYWNlbWVudCAoZS5nLiwgJ2JvdHRvbS1zdGFydCcgPT4gJ2JvdHRvbScpXG4qIEBwYXJhbSB7U3RyaW5nfSBwbGFjZW1lbnRcbiogQHJldHVybiB7U3RyaW5nfVxuKi9cbmZ1bmN0aW9uIGdldENvcmVQbGFjZW1lbnQocGxhY2VtZW50KSB7XG4gIHJldHVybiBwbGFjZW1lbnQucmVwbGFjZSgvLS4rLywgJycpO1xufVxuXG4vKipcbiogTW91c2Vtb3ZlIGV2ZW50IGxpc3RlbmVyIGNhbGxiYWNrIG1ldGhvZCBmb3IgZm9sbG93IGN1cnNvciBzZXR0aW5nXG4qIEBwYXJhbSB7TW91c2VFdmVudH0gZVxuKi9cbmZ1bmN0aW9uIGZvbGxvd0N1cnNvckhhbmRsZXIoZSkge1xuICB2YXIgX3RoaXMgPSB0aGlzO1xuXG4gIHZhciBkYXRhID0gZmluZChTdG9yZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICByZXR1cm4gZGF0YS5lbCA9PT0gX3RoaXM7XG4gIH0pO1xuXG4gIHZhciBwb3BwZXIgPSBkYXRhLnBvcHBlcixcbiAgICAgIG9mZnNldCA9IGRhdGEuc2V0dGluZ3Mub2Zmc2V0O1xuXG5cbiAgdmFyIHBvc2l0aW9uID0gZ2V0Q29yZVBsYWNlbWVudChwb3BwZXIuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpKTtcbiAgdmFyIGhhbGZQb3BwZXJXaWR0aCA9IE1hdGgucm91bmQocG9wcGVyLm9mZnNldFdpZHRoIC8gMik7XG4gIHZhciBoYWxmUG9wcGVySGVpZ2h0ID0gTWF0aC5yb3VuZChwb3BwZXIub2Zmc2V0SGVpZ2h0IC8gMik7XG4gIHZhciB2aWV3cG9ydFBhZGRpbmcgPSA1O1xuICB2YXIgcGFnZVdpZHRoID0gZG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50Lm9mZnNldFdpZHRoIHx8IGRvY3VtZW50LmJvZHkub2Zmc2V0V2lkdGg7XG5cbiAgdmFyIHBhZ2VYID0gZS5wYWdlWCxcbiAgICAgIHBhZ2VZID0gZS5wYWdlWTtcblxuXG4gIHZhciB4ID0gdm9pZCAwLFxuICAgICAgeSA9IHZvaWQgMDtcblxuICBzd2l0Y2ggKHBvc2l0aW9uKSB7XG4gICAgY2FzZSAndG9wJzpcbiAgICAgIHggPSBwYWdlWCAtIGhhbGZQb3BwZXJXaWR0aCArIG9mZnNldDtcbiAgICAgIHkgPSBwYWdlWSAtIDIgKiBoYWxmUG9wcGVySGVpZ2h0O1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm90dG9tJzpcbiAgICAgIHggPSBwYWdlWCAtIGhhbGZQb3BwZXJXaWR0aCArIG9mZnNldDtcbiAgICAgIHkgPSBwYWdlWSArIDEwO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnbGVmdCc6XG4gICAgICB4ID0gcGFnZVggLSAyICogaGFsZlBvcHBlcldpZHRoO1xuICAgICAgeSA9IHBhZ2VZIC0gaGFsZlBvcHBlckhlaWdodCArIG9mZnNldDtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3JpZ2h0JzpcbiAgICAgIHggPSBwYWdlWCArIDU7XG4gICAgICB5ID0gcGFnZVkgLSBoYWxmUG9wcGVySGVpZ2h0ICsgb2Zmc2V0O1xuICAgICAgYnJlYWs7XG4gIH1cblxuICB2YXIgaXNSaWdodE92ZXJmbG93aW5nID0gcGFnZVggKyB2aWV3cG9ydFBhZGRpbmcgKyBoYWxmUG9wcGVyV2lkdGggKyBvZmZzZXQgPiBwYWdlV2lkdGg7XG4gIHZhciBpc0xlZnRPdmVyZmxvd2luZyA9IHBhZ2VYIC0gdmlld3BvcnRQYWRkaW5nIC0gaGFsZlBvcHBlcldpZHRoICsgb2Zmc2V0IDwgMDtcblxuICAvLyBQcmV2ZW50IGxlZnQvcmlnaHQgb3ZlcmZsb3dcbiAgaWYgKHBvc2l0aW9uID09PSAndG9wJyB8fCBwb3NpdGlvbiA9PT0gJ2JvdHRvbScpIHtcbiAgICBpZiAoaXNSaWdodE92ZXJmbG93aW5nKSB7XG4gICAgICB4ID0gcGFnZVdpZHRoIC0gdmlld3BvcnRQYWRkaW5nIC0gMiAqIGhhbGZQb3BwZXJXaWR0aDtcbiAgICB9XG5cbiAgICBpZiAoaXNMZWZ0T3ZlcmZsb3dpbmcpIHtcbiAgICAgIHggPSB2aWV3cG9ydFBhZGRpbmc7XG4gICAgfVxuICB9XG5cbiAgcG9wcGVyLnN0eWxlW3ByZWZpeCgndHJhbnNmb3JtJyldID0gJ3RyYW5zbGF0ZTNkKCcgKyB4ICsgJ3B4LCAnICsgeSArICdweCwgMCknO1xufVxuXG4vKipcbiogUmV0dXJucyBhbiBhcnJheSBvZiBlbGVtZW50cyBiYXNlZCBvbiB0aGUgc2VsZWN0b3IgaW5wdXRcbiogQHBhcmFtIHtTdHJpbmd8RWxlbWVudHxFbGVtZW50W119IHNlbGVjdG9yXG4qIEByZXR1cm4ge0VsZW1lbnRbXX1cbiovXG5mdW5jdGlvbiBnZXRBcnJheU9mRWxlbWVudHMoc2VsZWN0b3IpIHtcbiAgaWYgKHNlbGVjdG9yIGluc3RhbmNlb2YgRWxlbWVudCB8fCBpc09iamVjdExpdGVyYWwoc2VsZWN0b3IpKSB7XG4gICAgcmV0dXJuIFtzZWxlY3Rvcl07XG4gIH1cblxuICBpZiAoc2VsZWN0b3IgaW5zdGFuY2VvZiBOb2RlTGlzdCkge1xuICAgIHJldHVybiBbXS5zbGljZS5jYWxsKHNlbGVjdG9yKTtcbiAgfVxuXG4gIGlmIChBcnJheS5pc0FycmF5KHNlbGVjdG9yKSkge1xuICAgIHJldHVybiBzZWxlY3RvcjtcbiAgfVxuXG4gIHRyeSB7XG4gICAgcmV0dXJuIFtdLnNsaWNlLmNhbGwoZG9jdW1lbnQucXVlcnlTZWxlY3RvckFsbChzZWxlY3RvcikpO1xuICB9IGNhdGNoIChfKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG59XG5cbi8qKlxuKiBQcmVwYXJlcyB0aGUgY2FsbGJhY2sgZnVuY3Rpb25zIGZvciBgc2hvd2AgYW5kIGBoaWRlYCBtZXRob2RzXG4qIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4qIEBwYXJhbSB7TnVtYmVyfSBkdXJhdGlvblxuKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFjayAtIGNhbGxiYWNrIGZ1bmN0aW9uIHRvIGZpcmUgb25jZSB0cmFuc2l0aW9ucyBjb21wbGV0ZVxuKi9cbmZ1bmN0aW9uIG9uVHJhbnNpdGlvbkVuZChkYXRhLCBkdXJhdGlvbiwgY2FsbGJhY2spIHtcbiAgLy8gTWFrZSBjYWxsYmFjayBzeW5jaHJvbm91cyBpZiBkdXJhdGlvbiBpcyAwXG4gIGlmICghZHVyYXRpb24pIHtcbiAgICByZXR1cm4gY2FsbGJhY2soKTtcbiAgfVxuXG4gIHZhciBfZ2V0SW5uZXJFbGVtZW50cyA9IGdldElubmVyRWxlbWVudHMoZGF0YS5wb3BwZXIpLFxuICAgICAgdG9vbHRpcCA9IF9nZXRJbm5lckVsZW1lbnRzLnRvb2x0aXA7XG5cbiAgdmFyIHRyYW5zaXRpb25lbmRGaXJlZCA9IGZhbHNlO1xuXG4gIHZhciBsaXN0ZW5lcnMgPSBmdW5jdGlvbiBsaXN0ZW5lcnMoYWN0aW9uKSB7XG4gICAgdG9vbHRpcFthY3Rpb24gKyAnRXZlbnRMaXN0ZW5lciddKCd3ZWJraXRUcmFuc2l0aW9uRW5kJywgbGlzdGVuZXJDYWxsYmFjayk7XG4gICAgdG9vbHRpcFthY3Rpb24gKyAnRXZlbnRMaXN0ZW5lciddKCd0cmFuc2l0aW9uZW5kJywgbGlzdGVuZXJDYWxsYmFjayk7XG4gIH07XG5cbiAgdmFyIGxpc3RlbmVyQ2FsbGJhY2sgPSBmdW5jdGlvbiBsaXN0ZW5lckNhbGxiYWNrKGUpIHtcbiAgICBpZiAoZS50YXJnZXQgPT09IHRvb2x0aXAgJiYgIXRyYW5zaXRpb25lbmRGaXJlZCkge1xuICAgICAgdHJhbnNpdGlvbmVuZEZpcmVkID0gdHJ1ZTtcbiAgICAgIGxpc3RlbmVycygncmVtb3ZlJyk7XG4gICAgICBjYWxsYmFjaygpO1xuICAgIH1cbiAgfTtcblxuICAvLyBGaXJlIGNhbGxiYWNrIHVwb24gdHJhbnNpdGlvbiBjb21wbGV0aW9uXG4gIGxpc3RlbmVycygnYWRkJyk7XG5cbiAgLy8gRmFsbGJhY2s6IHRyYW5zaXRpb25lbmQgbGlzdGVuZXIgc29tZXRpbWVzIG1heSBub3QgZmlyZVxuICBjbGVhclRpbWVvdXQoZGF0YS5fdHJhbnNpdGlvbmVuZFRpbWVvdXQpO1xuICBkYXRhLl90cmFuc2l0aW9uZW5kVGltZW91dCA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgIGlmICghdHJhbnNpdGlvbmVuZEZpcmVkKSB7XG4gICAgICBsaXN0ZW5lcnMoJ3JlbW92ZScpO1xuICAgICAgY2FsbGJhY2soKTtcbiAgICB9XG4gIH0sIGR1cmF0aW9uKTtcbn1cblxuLyoqIVxuICogQGZpbGVPdmVydmlldyBLaWNrYXNzIGxpYnJhcnkgdG8gY3JlYXRlIGFuZCBwbGFjZSBwb3BwZXJzIG5lYXIgdGhlaXIgcmVmZXJlbmNlIGVsZW1lbnRzLlxuICogQHZlcnNpb24gMS4xMi45XG4gKiBAbGljZW5zZVxuICogQ29weXJpZ2h0IChjKSAyMDE2IEZlZGVyaWNvIFppdm9sbyBhbmQgY29udHJpYnV0b3JzXG4gKlxuICogUGVybWlzc2lvbiBpcyBoZXJlYnkgZ3JhbnRlZCwgZnJlZSBvZiBjaGFyZ2UsIHRvIGFueSBwZXJzb24gb2J0YWluaW5nIGEgY29weVxuICogb2YgdGhpcyBzb2Z0d2FyZSBhbmQgYXNzb2NpYXRlZCBkb2N1bWVudGF0aW9uIGZpbGVzICh0aGUgXCJTb2Z0d2FyZVwiKSwgdG8gZGVhbFxuICogaW4gdGhlIFNvZnR3YXJlIHdpdGhvdXQgcmVzdHJpY3Rpb24sIGluY2x1ZGluZyB3aXRob3V0IGxpbWl0YXRpb24gdGhlIHJpZ2h0c1xuICogdG8gdXNlLCBjb3B5LCBtb2RpZnksIG1lcmdlLCBwdWJsaXNoLCBkaXN0cmlidXRlLCBzdWJsaWNlbnNlLCBhbmQvb3Igc2VsbFxuICogY29waWVzIG9mIHRoZSBTb2Z0d2FyZSwgYW5kIHRvIHBlcm1pdCBwZXJzb25zIHRvIHdob20gdGhlIFNvZnR3YXJlIGlzXG4gKiBmdXJuaXNoZWQgdG8gZG8gc28sIHN1YmplY3QgdG8gdGhlIGZvbGxvd2luZyBjb25kaXRpb25zOlxuICpcbiAqIFRoZSBhYm92ZSBjb3B5cmlnaHQgbm90aWNlIGFuZCB0aGlzIHBlcm1pc3Npb24gbm90aWNlIHNoYWxsIGJlIGluY2x1ZGVkIGluIGFsbFxuICogY29waWVzIG9yIHN1YnN0YW50aWFsIHBvcnRpb25zIG9mIHRoZSBTb2Z0d2FyZS5cbiAqXG4gKiBUSEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiLCBXSVRIT1VUIFdBUlJBTlRZIE9GIEFOWSBLSU5ELCBFWFBSRVNTIE9SXG4gKiBJTVBMSUVELCBJTkNMVURJTkcgQlVUIE5PVCBMSU1JVEVEIFRPIFRIRSBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWSxcbiAqIEZJVE5FU1MgRk9SIEEgUEFSVElDVUxBUiBQVVJQT1NFIEFORCBOT05JTkZSSU5HRU1FTlQuIElOIE5PIEVWRU5UIFNIQUxMIFRIRVxuICogQVVUSE9SUyBPUiBDT1BZUklHSFQgSE9MREVSUyBCRSBMSUFCTEUgRk9SIEFOWSBDTEFJTSwgREFNQUdFUyBPUiBPVEhFUlxuICogTElBQklMSVRZLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgVE9SVCBPUiBPVEhFUldJU0UsIEFSSVNJTkcgRlJPTSxcbiAqIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFNPRlRXQVJFIE9SIFRIRSBVU0UgT1IgT1RIRVIgREVBTElOR1MgSU4gVEhFXG4gKiBTT0ZUV0FSRS5cbiAqL1xudmFyIGlzQnJvd3NlciA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgbG9uZ2VyVGltZW91dEJyb3dzZXJzID0gWydFZGdlJywgJ1RyaWRlbnQnLCAnRmlyZWZveCddO1xudmFyIHRpbWVvdXREdXJhdGlvbiA9IDA7XG5mb3IgKHZhciBpID0gMDsgaSA8IGxvbmdlclRpbWVvdXRCcm93c2Vycy5sZW5ndGg7IGkgKz0gMSkge1xuICBpZiAoaXNCcm93c2VyICYmIG5hdmlnYXRvci51c2VyQWdlbnQuaW5kZXhPZihsb25nZXJUaW1lb3V0QnJvd3NlcnNbaV0pID49IDApIHtcbiAgICB0aW1lb3V0RHVyYXRpb24gPSAxO1xuICAgIGJyZWFrO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1pY3JvdGFza0RlYm91bmNlKGZuKSB7XG4gIHZhciBjYWxsZWQgPSBmYWxzZTtcbiAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICBpZiAoY2FsbGVkKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuICAgIGNhbGxlZCA9IHRydWU7XG4gICAgd2luZG93LlByb21pc2UucmVzb2x2ZSgpLnRoZW4oZnVuY3Rpb24gKCkge1xuICAgICAgY2FsbGVkID0gZmFsc2U7XG4gICAgICBmbigpO1xuICAgIH0pO1xuICB9O1xufVxuXG5mdW5jdGlvbiB0YXNrRGVib3VuY2UoZm4pIHtcbiAgdmFyIHNjaGVkdWxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghc2NoZWR1bGVkKSB7XG4gICAgICBzY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIHNjaGVkdWxlZCA9IGZhbHNlO1xuICAgICAgICBmbigpO1xuICAgICAgfSwgdGltZW91dER1cmF0aW9uKTtcbiAgICB9XG4gIH07XG59XG5cbnZhciBzdXBwb3J0c01pY3JvVGFza3MgPSBpc0Jyb3dzZXIgJiYgd2luZG93LlByb21pc2U7XG5cbi8qKlxuKiBDcmVhdGUgYSBkZWJvdW5jZWQgdmVyc2lvbiBvZiBhIG1ldGhvZCwgdGhhdCdzIGFzeW5jaHJvbm91c2x5IGRlZmVycmVkXG4qIGJ1dCBjYWxsZWQgaW4gdGhlIG1pbmltdW0gdGltZSBwb3NzaWJsZS5cbipcbiogQG1ldGhvZFxuKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4qIEBhcmd1bWVudCB7RnVuY3Rpb259IGZuXG4qIEByZXR1cm5zIHtGdW5jdGlvbn1cbiovXG52YXIgZGVib3VuY2UgPSBzdXBwb3J0c01pY3JvVGFza3MgPyBtaWNyb3Rhc2tEZWJvdW5jZSA6IHRhc2tEZWJvdW5jZTtcblxuLyoqXG4gKiBDaGVjayBpZiB0aGUgZ2l2ZW4gdmFyaWFibGUgaXMgYSBmdW5jdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBbnl9IGZ1bmN0aW9uVG9DaGVjayAtIHZhcmlhYmxlIHRvIGNoZWNrXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvOiBpcyBhIGZ1bmN0aW9uP1xuICovXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKGZ1bmN0aW9uVG9DaGVjaykge1xuICB2YXIgZ2V0VHlwZSA9IHt9O1xuICByZXR1cm4gZnVuY3Rpb25Ub0NoZWNrICYmIGdldFR5cGUudG9TdHJpbmcuY2FsbChmdW5jdGlvblRvQ2hlY2spID09PSAnW29iamVjdCBGdW5jdGlvbl0nO1xufVxuXG4vKipcbiAqIEdldCBDU1MgY29tcHV0ZWQgcHJvcGVydHkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWVtZW50fSBlbGVtZW50XG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHlcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsIHByb3BlcnR5KSB7XG4gIGlmIChlbGVtZW50Lm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuIFtdO1xuICB9XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBjc3MgPSBnZXRDb21wdXRlZFN0eWxlKGVsZW1lbnQsIG51bGwpO1xuICByZXR1cm4gcHJvcGVydHkgPyBjc3NbcHJvcGVydHldIDogY3NzO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHBhcmVudE5vZGUgb3IgdGhlIGhvc3Qgb2YgdGhlIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHBhcmVudFxuICovXG5mdW5jdGlvbiBnZXRQYXJlbnROb2RlKGVsZW1lbnQpIHtcbiAgaWYgKGVsZW1lbnQubm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG4gIHJldHVybiBlbGVtZW50LnBhcmVudE5vZGUgfHwgZWxlbWVudC5ob3N0O1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIHNjcm9sbGluZyBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IHNjcm9sbCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0U2Nyb2xsUGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gUmV0dXJuIGJvZHksIGBnZXRTY3JvbGxgIHdpbGwgdGFrZSBjYXJlIHRvIGdldCB0aGUgY29ycmVjdCBgc2Nyb2xsVG9wYCBmcm9tIGl0XG4gIGlmICghZWxlbWVudCkge1xuICAgIHJldHVybiBkb2N1bWVudC5ib2R5O1xuICB9XG5cbiAgc3dpdGNoIChlbGVtZW50Lm5vZGVOYW1lKSB7XG4gICAgY2FzZSAnSFRNTCc6XG4gICAgY2FzZSAnQk9EWSc6XG4gICAgICByZXR1cm4gZWxlbWVudC5vd25lckRvY3VtZW50LmJvZHk7XG4gICAgY2FzZSAnI2RvY3VtZW50JzpcbiAgICAgIHJldHVybiBlbGVtZW50LmJvZHk7XG4gIH1cblxuICAvLyBGaXJlZm94IHdhbnQgdXMgdG8gY2hlY2sgYC14YCBhbmQgYC15YCB2YXJpYXRpb25zIGFzIHdlbGxcblxuICB2YXIgX2dldFN0eWxlQ29tcHV0ZWRQcm9wID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpLFxuICAgICAgb3ZlcmZsb3cgPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3csXG4gICAgICBvdmVyZmxvd1ggPSBfZ2V0U3R5bGVDb21wdXRlZFByb3Aub3ZlcmZsb3dYLFxuICAgICAgb3ZlcmZsb3dZID0gX2dldFN0eWxlQ29tcHV0ZWRQcm9wLm92ZXJmbG93WTtcblxuICBpZiAoLyhhdXRvfHNjcm9sbCkvLnRlc3Qob3ZlcmZsb3cgKyBvdmVyZmxvd1kgKyBvdmVyZmxvd1gpKSB7XG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cblxuICByZXR1cm4gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUoZWxlbWVudCkpO1xufVxuXG4vKipcbiAqIFJldHVybnMgdGhlIG9mZnNldCBwYXJlbnQgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge0VsZW1lbnR9IG9mZnNldCBwYXJlbnRcbiAqL1xuZnVuY3Rpb24gZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQpIHtcbiAgLy8gTk9URTogMSBET00gYWNjZXNzIGhlcmVcbiAgdmFyIG9mZnNldFBhcmVudCA9IGVsZW1lbnQgJiYgZWxlbWVudC5vZmZzZXRQYXJlbnQ7XG4gIHZhciBub2RlTmFtZSA9IG9mZnNldFBhcmVudCAmJiBvZmZzZXRQYXJlbnQubm9kZU5hbWU7XG5cbiAgaWYgKCFub2RlTmFtZSB8fCBub2RlTmFtZSA9PT0gJ0JPRFknIHx8IG5vZGVOYW1lID09PSAnSFRNTCcpIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgcmV0dXJuIGVsZW1lbnQub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfVxuXG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIC5vZmZzZXRQYXJlbnQgd2lsbCByZXR1cm4gdGhlIGNsb3Nlc3QgVEQgb3IgVEFCTEUgaW4gY2FzZVxuICAvLyBubyBvZmZzZXRQYXJlbnQgaXMgcHJlc2VudCwgSSBoYXRlIHRoaXMgam9iLi4uXG4gIGlmIChbJ1REJywgJ1RBQkxFJ10uaW5kZXhPZihvZmZzZXRQYXJlbnQubm9kZU5hbWUpICE9PSAtMSAmJiBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkob2Zmc2V0UGFyZW50LCAncG9zaXRpb24nKSA9PT0gJ3N0YXRpYycpIHtcbiAgICByZXR1cm4gZ2V0T2Zmc2V0UGFyZW50KG9mZnNldFBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0UGFyZW50O1xufVxuXG5mdW5jdGlvbiBpc09mZnNldENvbnRhaW5lcihlbGVtZW50KSB7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScpIHtcbiAgICByZXR1cm4gZmFsc2U7XG4gIH1cbiAgcmV0dXJuIG5vZGVOYW1lID09PSAnSFRNTCcgfHwgZ2V0T2Zmc2V0UGFyZW50KGVsZW1lbnQuZmlyc3RFbGVtZW50Q2hpbGQpID09PSBlbGVtZW50O1xufVxuXG4vKipcbiAqIEZpbmRzIHRoZSByb290IG5vZGUgKGRvY3VtZW50LCBzaGFkb3dET00gcm9vdCkgb2YgdGhlIGdpdmVuIGVsZW1lbnRcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gbm9kZVxuICogQHJldHVybnMge0VsZW1lbnR9IHJvb3Qgbm9kZVxuICovXG5mdW5jdGlvbiBnZXRSb290KG5vZGUpIHtcbiAgaWYgKG5vZGUucGFyZW50Tm9kZSAhPT0gbnVsbCkge1xuICAgIHJldHVybiBnZXRSb290KG5vZGUucGFyZW50Tm9kZSk7XG4gIH1cblxuICByZXR1cm4gbm9kZTtcbn1cblxuLyoqXG4gKiBGaW5kcyB0aGUgb2Zmc2V0IHBhcmVudCBjb21tb24gdG8gdGhlIHR3byBwcm92aWRlZCBub2Rlc1xuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MVxuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50MlxuICogQHJldHVybnMge0VsZW1lbnR9IGNvbW1vbiBvZmZzZXQgcGFyZW50XG4gKi9cbmZ1bmN0aW9uIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGVsZW1lbnQyKSB7XG4gIC8vIFRoaXMgY2hlY2sgaXMgbmVlZGVkIHRvIGF2b2lkIGVycm9ycyBpbiBjYXNlIG9uZSBvZiB0aGUgZWxlbWVudHMgaXNuJ3QgZGVmaW5lZCBmb3IgYW55IHJlYXNvblxuICBpZiAoIWVsZW1lbnQxIHx8ICFlbGVtZW50MS5ub2RlVHlwZSB8fCAhZWxlbWVudDIgfHwgIWVsZW1lbnQyLm5vZGVUeXBlKSB7XG4gICAgcmV0dXJuIGRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgfVxuXG4gIC8vIEhlcmUgd2UgbWFrZSBzdXJlIHRvIGdpdmUgYXMgXCJzdGFydFwiIHRoZSBlbGVtZW50IHRoYXQgY29tZXMgZmlyc3QgaW4gdGhlIERPTVxuICB2YXIgb3JkZXIgPSBlbGVtZW50MS5jb21wYXJlRG9jdW1lbnRQb3NpdGlvbihlbGVtZW50MikgJiBOb2RlLkRPQ1VNRU5UX1BPU0lUSU9OX0ZPTExPV0lORztcbiAgdmFyIHN0YXJ0ID0gb3JkZXIgPyBlbGVtZW50MSA6IGVsZW1lbnQyO1xuICB2YXIgZW5kID0gb3JkZXIgPyBlbGVtZW50MiA6IGVsZW1lbnQxO1xuXG4gIC8vIEdldCBjb21tb24gYW5jZXN0b3IgY29udGFpbmVyXG4gIHZhciByYW5nZSA9IGRvY3VtZW50LmNyZWF0ZVJhbmdlKCk7XG4gIHJhbmdlLnNldFN0YXJ0KHN0YXJ0LCAwKTtcbiAgcmFuZ2Uuc2V0RW5kKGVuZCwgMCk7XG4gIHZhciBjb21tb25BbmNlc3RvckNvbnRhaW5lciA9IHJhbmdlLmNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuXG4gIC8vIEJvdGggbm9kZXMgYXJlIGluc2lkZSAjZG9jdW1lbnRcblxuICBpZiAoZWxlbWVudDEgIT09IGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyICYmIGVsZW1lbnQyICE9PSBjb21tb25BbmNlc3RvckNvbnRhaW5lciB8fCBzdGFydC5jb250YWlucyhlbmQpKSB7XG4gICAgaWYgKGlzT2Zmc2V0Q29udGFpbmVyKGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyKSkge1xuICAgICAgcmV0dXJuIGNvbW1vbkFuY2VzdG9yQ29udGFpbmVyO1xuICAgIH1cblxuICAgIHJldHVybiBnZXRPZmZzZXRQYXJlbnQoY29tbW9uQW5jZXN0b3JDb250YWluZXIpO1xuICB9XG5cbiAgLy8gb25lIG9mIHRoZSBub2RlcyBpcyBpbnNpZGUgc2hhZG93RE9NLCBmaW5kIHdoaWNoIG9uZVxuICB2YXIgZWxlbWVudDFyb290ID0gZ2V0Um9vdChlbGVtZW50MSk7XG4gIGlmIChlbGVtZW50MXJvb3QuaG9zdCkge1xuICAgIHJldHVybiBmaW5kQ29tbW9uT2Zmc2V0UGFyZW50KGVsZW1lbnQxcm9vdC5ob3N0LCBlbGVtZW50Mik7XG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZpbmRDb21tb25PZmZzZXRQYXJlbnQoZWxlbWVudDEsIGdldFJvb3QoZWxlbWVudDIpLmhvc3QpO1xuICB9XG59XG5cbi8qKlxuICogR2V0cyB0aGUgc2Nyb2xsIHZhbHVlIG9mIHRoZSBnaXZlbiBlbGVtZW50IGluIHRoZSBnaXZlbiBzaWRlICh0b3AgYW5kIGxlZnQpXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBzaWRlIGB0b3BgIG9yIGBsZWZ0YFxuICogQHJldHVybnMge251bWJlcn0gYW1vdW50IG9mIHNjcm9sbGVkIHBpeGVsc1xuICovXG5mdW5jdGlvbiBnZXRTY3JvbGwoZWxlbWVudCkge1xuICB2YXIgc2lkZSA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogJ3RvcCc7XG5cbiAgdmFyIHVwcGVyU2lkZSA9IHNpZGUgPT09ICd0b3AnID8gJ3Njcm9sbFRvcCcgOiAnc2Nyb2xsTGVmdCc7XG4gIHZhciBub2RlTmFtZSA9IGVsZW1lbnQubm9kZU5hbWU7XG5cbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHZhciBodG1sID0gZWxlbWVudC5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICB2YXIgc2Nyb2xsaW5nRWxlbWVudCA9IGVsZW1lbnQub3duZXJEb2N1bWVudC5zY3JvbGxpbmdFbGVtZW50IHx8IGh0bWw7XG4gICAgcmV0dXJuIHNjcm9sbGluZ0VsZW1lbnRbdXBwZXJTaWRlXTtcbiAgfVxuXG4gIHJldHVybiBlbGVtZW50W3VwcGVyU2lkZV07XG59XG5cbi8qXG4gKiBTdW0gb3Igc3VidHJhY3QgdGhlIGVsZW1lbnQgc2Nyb2xsIHZhbHVlcyAobGVmdCBhbmQgdG9wKSBmcm9tIGEgZ2l2ZW4gcmVjdCBvYmplY3RcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7T2JqZWN0fSByZWN0IC0gUmVjdCBvYmplY3QgeW91IHdhbnQgdG8gY2hhbmdlXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBlbGVtZW50IC0gVGhlIGVsZW1lbnQgZnJvbSB0aGUgZnVuY3Rpb24gcmVhZHMgdGhlIHNjcm9sbCB2YWx1ZXNcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gc3VidHJhY3QgLSBzZXQgdG8gdHJ1ZSBpZiB5b3Ugd2FudCB0byBzdWJ0cmFjdCB0aGUgc2Nyb2xsIHZhbHVlc1xuICogQHJldHVybiB7T2JqZWN0fSByZWN0IC0gVGhlIG1vZGlmaWVyIHJlY3Qgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGluY2x1ZGVTY3JvbGwocmVjdCwgZWxlbWVudCkge1xuICB2YXIgc3VidHJhY3QgPSBhcmd1bWVudHMubGVuZ3RoID4gMiAmJiBhcmd1bWVudHNbMl0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1syXSA6IGZhbHNlO1xuXG4gIHZhciBzY3JvbGxUb3AgPSBnZXRTY3JvbGwoZWxlbWVudCwgJ3RvcCcpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChlbGVtZW50LCAnbGVmdCcpO1xuICB2YXIgbW9kaWZpZXIgPSBzdWJ0cmFjdCA/IC0xIDogMTtcbiAgcmVjdC50b3AgKz0gc2Nyb2xsVG9wICogbW9kaWZpZXI7XG4gIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcCAqIG1vZGlmaWVyO1xuICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdCAqIG1vZGlmaWVyO1xuICByZWN0LnJpZ2h0ICs9IHNjcm9sbExlZnQgKiBtb2RpZmllcjtcbiAgcmV0dXJuIHJlY3Q7XG59XG5cbi8qXG4gKiBIZWxwZXIgdG8gZGV0ZWN0IGJvcmRlcnMgb2YgYSBnaXZlbiBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0NTU1N0eWxlRGVjbGFyYXRpb259IHN0eWxlc1xuICogUmVzdWx0IG9mIGBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHlgIG9uIHRoZSBnaXZlbiBlbGVtZW50XG4gKiBAcGFyYW0ge1N0cmluZ30gYXhpcyAtIGB4YCBvciBgeWBcbiAqIEByZXR1cm4ge251bWJlcn0gYm9yZGVycyAtIFRoZSBib3JkZXJzIHNpemUgb2YgdGhlIGdpdmVuIGF4aXNcbiAqL1xuXG5mdW5jdGlvbiBnZXRCb3JkZXJzU2l6ZShzdHlsZXMsIGF4aXMpIHtcbiAgdmFyIHNpZGVBID0gYXhpcyA9PT0gJ3gnID8gJ0xlZnQnIDogJ1RvcCc7XG4gIHZhciBzaWRlQiA9IHNpZGVBID09PSAnTGVmdCcgPyAnUmlnaHQnIDogJ0JvdHRvbSc7XG5cbiAgcmV0dXJuIHBhcnNlRmxvYXQoc3R5bGVzWydib3JkZXInICsgc2lkZUEgKyAnV2lkdGgnXSwgMTApICsgcGFyc2VGbG9hdChzdHlsZXNbJ2JvcmRlcicgKyBzaWRlQiArICdXaWR0aCddLCAxMCk7XG59XG5cbi8qKlxuICogVGVsbHMgaWYgeW91IGFyZSBydW5uaW5nIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gaXNJRTEwXG4gKi9cbnZhciBpc0lFMTAgPSB1bmRlZmluZWQ7XG5cbnZhciBpc0lFMTAkMSA9IGZ1bmN0aW9uIGlzSUUxMCQxKCkge1xuICBpZiAoaXNJRTEwID09PSB1bmRlZmluZWQpIHtcbiAgICBpc0lFMTAgPSBuYXZpZ2F0b3IuYXBwVmVyc2lvbi5pbmRleE9mKCdNU0lFIDEwJykgIT09IC0xO1xuICB9XG4gIHJldHVybiBpc0lFMTA7XG59O1xuXG5mdW5jdGlvbiBnZXRTaXplKGF4aXMsIGJvZHksIGh0bWwsIGNvbXB1dGVkU3R5bGUpIHtcbiAgcmV0dXJuIE1hdGgubWF4KGJvZHlbJ29mZnNldCcgKyBheGlzXSwgYm9keVsnc2Nyb2xsJyArIGF4aXNdLCBodG1sWydjbGllbnQnICsgYXhpc10sIGh0bWxbJ29mZnNldCcgKyBheGlzXSwgaHRtbFsnc2Nyb2xsJyArIGF4aXNdLCBpc0lFMTAkMSgpID8gaHRtbFsnb2Zmc2V0JyArIGF4aXNdICsgY29tcHV0ZWRTdHlsZVsnbWFyZ2luJyArIChheGlzID09PSAnSGVpZ2h0JyA/ICdUb3AnIDogJ0xlZnQnKV0gKyBjb21wdXRlZFN0eWxlWydtYXJnaW4nICsgKGF4aXMgPT09ICdIZWlnaHQnID8gJ0JvdHRvbScgOiAnUmlnaHQnKV0gOiAwKTtcbn1cblxuZnVuY3Rpb24gZ2V0V2luZG93U2l6ZXMoKSB7XG4gIHZhciBib2R5ID0gZG9jdW1lbnQuYm9keTtcbiAgdmFyIGh0bWwgPSBkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gIHZhciBjb21wdXRlZFN0eWxlID0gaXNJRTEwJDEoKSAmJiBnZXRDb21wdXRlZFN0eWxlKGh0bWwpO1xuXG4gIHJldHVybiB7XG4gICAgaGVpZ2h0OiBnZXRTaXplKCdIZWlnaHQnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKSxcbiAgICB3aWR0aDogZ2V0U2l6ZSgnV2lkdGgnLCBib2R5LCBodG1sLCBjb21wdXRlZFN0eWxlKVxuICB9O1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiBjbGFzc0NhbGxDaGVjayhpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIGRlZmluZVByb3BlcnRpZXModGFyZ2V0LCBwcm9wcykge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBkZXNjcmlwdG9yID0gcHJvcHNbaV07XG4gICAgICBkZXNjcmlwdG9yLmVudW1lcmFibGUgPSBkZXNjcmlwdG9yLmVudW1lcmFibGUgfHwgZmFsc2U7XG4gICAgICBkZXNjcmlwdG9yLmNvbmZpZ3VyYWJsZSA9IHRydWU7XG4gICAgICBpZiAoXCJ2YWx1ZVwiIGluIGRlc2NyaXB0b3IpIGRlc2NyaXB0b3Iud3JpdGFibGUgPSB0cnVlO1xuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwgZGVzY3JpcHRvci5rZXksIGRlc2NyaXB0b3IpO1xuICAgIH1cbiAgfVxuXG4gIHJldHVybiBmdW5jdGlvbiAoQ29uc3RydWN0b3IsIHByb3RvUHJvcHMsIHN0YXRpY1Byb3BzKSB7XG4gICAgaWYgKHByb3RvUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IucHJvdG90eXBlLCBwcm90b1Byb3BzKTtcbiAgICBpZiAoc3RhdGljUHJvcHMpIGRlZmluZVByb3BlcnRpZXMoQ29uc3RydWN0b3IsIHN0YXRpY1Byb3BzKTtcbiAgICByZXR1cm4gQ29uc3RydWN0b3I7XG4gIH07XG59KCk7XG5cbnZhciBkZWZpbmVQcm9wZXJ0eSA9IGZ1bmN0aW9uIGRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xuICBpZiAoa2V5IGluIG9iaikge1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH0gZWxzZSB7XG4gICAgb2JqW2tleV0gPSB2YWx1ZTtcbiAgfVxuXG4gIHJldHVybiBvYmo7XG59O1xuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4gKiBHaXZlbiBlbGVtZW50IG9mZnNldHMsIGdlbmVyYXRlIGFuIG91dHB1dCBzaW1pbGFyIHRvIGdldEJvdW5kaW5nQ2xpZW50UmVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IG9mZnNldHNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENsaWVudFJlY3QgbGlrZSBvdXRwdXRcbiAqL1xuZnVuY3Rpb24gZ2V0Q2xpZW50UmVjdChvZmZzZXRzKSB7XG4gIHJldHVybiBfZXh0ZW5kcyh7fSwgb2Zmc2V0cywge1xuICAgIHJpZ2h0OiBvZmZzZXRzLmxlZnQgKyBvZmZzZXRzLndpZHRoLFxuICAgIGJvdHRvbTogb2Zmc2V0cy50b3AgKyBvZmZzZXRzLmhlaWdodFxuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgYm91bmRpbmcgY2xpZW50IHJlY3Qgb2YgZ2l2ZW4gZWxlbWVudFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybiB7T2JqZWN0fSBjbGllbnQgcmVjdFxuICovXG5mdW5jdGlvbiBnZXRCb3VuZGluZ0NsaWVudFJlY3QoZWxlbWVudCkge1xuICB2YXIgcmVjdCA9IHt9O1xuXG4gIC8vIElFMTAgMTAgRklYOiBQbGVhc2UsIGRvbid0IGFzaywgdGhlIGVsZW1lbnQgaXNuJ3RcbiAgLy8gY29uc2lkZXJlZCBpbiBET00gaW4gc29tZSBjaXJjdW1zdGFuY2VzLi4uXG4gIC8vIFRoaXMgaXNuJ3QgcmVwcm9kdWNpYmxlIGluIElFMTAgY29tcGF0aWJpbGl0eSBtb2RlIG9mIElFMTFcbiAgaWYgKGlzSUUxMCQxKCkpIHtcbiAgICB0cnkge1xuICAgICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICd0b3AnKTtcbiAgICAgIHZhciBzY3JvbGxMZWZ0ID0gZ2V0U2Nyb2xsKGVsZW1lbnQsICdsZWZ0Jyk7XG4gICAgICByZWN0LnRvcCArPSBzY3JvbGxUb3A7XG4gICAgICByZWN0LmxlZnQgKz0gc2Nyb2xsTGVmdDtcbiAgICAgIHJlY3QuYm90dG9tICs9IHNjcm9sbFRvcDtcbiAgICAgIHJlY3QucmlnaHQgKz0gc2Nyb2xsTGVmdDtcbiAgICB9IGNhdGNoIChlcnIpIHt9XG4gIH0gZWxzZSB7XG4gICAgcmVjdCA9IGVsZW1lbnQuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIH1cblxuICB2YXIgcmVzdWx0ID0ge1xuICAgIGxlZnQ6IHJlY3QubGVmdCxcbiAgICB0b3A6IHJlY3QudG9wLFxuICAgIHdpZHRoOiByZWN0LnJpZ2h0IC0gcmVjdC5sZWZ0LFxuICAgIGhlaWdodDogcmVjdC5ib3R0b20gLSByZWN0LnRvcFxuICB9O1xuXG4gIC8vIHN1YnRyYWN0IHNjcm9sbGJhciBzaXplIGZyb20gc2l6ZXNcbiAgdmFyIHNpemVzID0gZWxlbWVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnID8gZ2V0V2luZG93U2l6ZXMoKSA6IHt9O1xuICB2YXIgd2lkdGggPSBzaXplcy53aWR0aCB8fCBlbGVtZW50LmNsaWVudFdpZHRoIHx8IHJlc3VsdC5yaWdodCAtIHJlc3VsdC5sZWZ0O1xuICB2YXIgaGVpZ2h0ID0gc2l6ZXMuaGVpZ2h0IHx8IGVsZW1lbnQuY2xpZW50SGVpZ2h0IHx8IHJlc3VsdC5ib3R0b20gLSByZXN1bHQudG9wO1xuXG4gIHZhciBob3JpelNjcm9sbGJhciA9IGVsZW1lbnQub2Zmc2V0V2lkdGggLSB3aWR0aDtcbiAgdmFyIHZlcnRTY3JvbGxiYXIgPSBlbGVtZW50Lm9mZnNldEhlaWdodCAtIGhlaWdodDtcblxuICAvLyBpZiBhbiBoeXBvdGhldGljYWwgc2Nyb2xsYmFyIGlzIGRldGVjdGVkLCB3ZSBtdXN0IGJlIHN1cmUgaXQncyBub3QgYSBgYm9yZGVyYFxuICAvLyB3ZSBtYWtlIHRoaXMgY2hlY2sgY29uZGl0aW9uYWwgZm9yIHBlcmZvcm1hbmNlIHJlYXNvbnNcbiAgaWYgKGhvcml6U2Nyb2xsYmFyIHx8IHZlcnRTY3JvbGxiYXIpIHtcbiAgICB2YXIgc3R5bGVzID0gZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQpO1xuICAgIGhvcml6U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3gnKTtcbiAgICB2ZXJ0U2Nyb2xsYmFyIC09IGdldEJvcmRlcnNTaXplKHN0eWxlcywgJ3knKTtcblxuICAgIHJlc3VsdC53aWR0aCAtPSBob3JpelNjcm9sbGJhcjtcbiAgICByZXN1bHQuaGVpZ2h0IC09IHZlcnRTY3JvbGxiYXI7XG4gIH1cblxuICByZXR1cm4gZ2V0Q2xpZW50UmVjdChyZXN1bHQpO1xufVxuXG5mdW5jdGlvbiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoY2hpbGRyZW4sIHBhcmVudCkge1xuICB2YXIgaXNJRTEwID0gaXNJRTEwJDEoKTtcbiAgdmFyIGlzSFRNTCA9IHBhcmVudC5ub2RlTmFtZSA9PT0gJ0hUTUwnO1xuICB2YXIgY2hpbGRyZW5SZWN0ID0gZ2V0Qm91bmRpbmdDbGllbnRSZWN0KGNoaWxkcmVuKTtcbiAgdmFyIHBhcmVudFJlY3QgPSBnZXRCb3VuZGluZ0NsaWVudFJlY3QocGFyZW50KTtcbiAgdmFyIHNjcm9sbFBhcmVudCA9IGdldFNjcm9sbFBhcmVudChjaGlsZHJlbik7XG5cbiAgdmFyIHN0eWxlcyA9IGdldFN0eWxlQ29tcHV0ZWRQcm9wZXJ0eShwYXJlbnQpO1xuICB2YXIgYm9yZGVyVG9wV2lkdGggPSBwYXJzZUZsb2F0KHN0eWxlcy5ib3JkZXJUb3BXaWR0aCwgMTApO1xuICB2YXIgYm9yZGVyTGVmdFdpZHRoID0gcGFyc2VGbG9hdChzdHlsZXMuYm9yZGVyTGVmdFdpZHRoLCAxMCk7XG5cbiAgdmFyIG9mZnNldHMgPSBnZXRDbGllbnRSZWN0KHtcbiAgICB0b3A6IGNoaWxkcmVuUmVjdC50b3AgLSBwYXJlbnRSZWN0LnRvcCAtIGJvcmRlclRvcFdpZHRoLFxuICAgIGxlZnQ6IGNoaWxkcmVuUmVjdC5sZWZ0IC0gcGFyZW50UmVjdC5sZWZ0IC0gYm9yZGVyTGVmdFdpZHRoLFxuICAgIHdpZHRoOiBjaGlsZHJlblJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBjaGlsZHJlblJlY3QuaGVpZ2h0XG4gIH0pO1xuICBvZmZzZXRzLm1hcmdpblRvcCA9IDA7XG4gIG9mZnNldHMubWFyZ2luTGVmdCA9IDA7XG5cbiAgLy8gU3VidHJhY3QgbWFyZ2lucyBvZiBkb2N1bWVudEVsZW1lbnQgaW4gY2FzZSBpdCdzIGJlaW5nIHVzZWQgYXMgcGFyZW50XG4gIC8vIHdlIGRvIHRoaXMgb25seSBvbiBIVE1MIGJlY2F1c2UgaXQncyB0aGUgb25seSBlbGVtZW50IHRoYXQgYmVoYXZlc1xuICAvLyBkaWZmZXJlbnRseSB3aGVuIG1hcmdpbnMgYXJlIGFwcGxpZWQgdG8gaXQuIFRoZSBtYXJnaW5zIGFyZSBpbmNsdWRlZCBpblxuICAvLyB0aGUgYm94IG9mIHRoZSBkb2N1bWVudEVsZW1lbnQsIGluIHRoZSBvdGhlciBjYXNlcyBub3QuXG4gIGlmICghaXNJRTEwICYmIGlzSFRNTCkge1xuICAgIHZhciBtYXJnaW5Ub3AgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3AsIDEwKTtcbiAgICB2YXIgbWFyZ2luTGVmdCA9IHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpbkxlZnQsIDEwKTtcblxuICAgIG9mZnNldHMudG9wIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMuYm90dG9tIC09IGJvcmRlclRvcFdpZHRoIC0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubGVmdCAtPSBib3JkZXJMZWZ0V2lkdGggLSBtYXJnaW5MZWZ0O1xuICAgIG9mZnNldHMucmlnaHQgLT0gYm9yZGVyTGVmdFdpZHRoIC0gbWFyZ2luTGVmdDtcblxuICAgIC8vIEF0dGFjaCBtYXJnaW5Ub3AgYW5kIG1hcmdpbkxlZnQgYmVjYXVzZSBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2UgbWF5IG5lZWQgdGhlbVxuICAgIG9mZnNldHMubWFyZ2luVG9wID0gbWFyZ2luVG9wO1xuICAgIG9mZnNldHMubWFyZ2luTGVmdCA9IG1hcmdpbkxlZnQ7XG4gIH1cblxuICBpZiAoaXNJRTEwID8gcGFyZW50LmNvbnRhaW5zKHNjcm9sbFBhcmVudCkgOiBwYXJlbnQgPT09IHNjcm9sbFBhcmVudCAmJiBzY3JvbGxQYXJlbnQubm9kZU5hbWUgIT09ICdCT0RZJykge1xuICAgIG9mZnNldHMgPSBpbmNsdWRlU2Nyb2xsKG9mZnNldHMsIHBhcmVudCk7XG4gIH1cblxuICByZXR1cm4gb2Zmc2V0cztcbn1cblxuZnVuY3Rpb24gZ2V0Vmlld3BvcnRPZmZzZXRSZWN0UmVsYXRpdmVUb0FydGJpdHJhcnlOb2RlKGVsZW1lbnQpIHtcbiAgdmFyIGh0bWwgPSBlbGVtZW50Lm93bmVyRG9jdW1lbnQuZG9jdW1lbnRFbGVtZW50O1xuICB2YXIgcmVsYXRpdmVPZmZzZXQgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoZWxlbWVudCwgaHRtbCk7XG4gIHZhciB3aWR0aCA9IE1hdGgubWF4KGh0bWwuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoaHRtbC5jbGllbnRIZWlnaHQsIHdpbmRvdy5pbm5lckhlaWdodCB8fCAwKTtcblxuICB2YXIgc2Nyb2xsVG9wID0gZ2V0U2Nyb2xsKGh0bWwpO1xuICB2YXIgc2Nyb2xsTGVmdCA9IGdldFNjcm9sbChodG1sLCAnbGVmdCcpO1xuXG4gIHZhciBvZmZzZXQgPSB7XG4gICAgdG9wOiBzY3JvbGxUb3AgLSByZWxhdGl2ZU9mZnNldC50b3AgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5Ub3AsXG4gICAgbGVmdDogc2Nyb2xsTGVmdCAtIHJlbGF0aXZlT2Zmc2V0LmxlZnQgKyByZWxhdGl2ZU9mZnNldC5tYXJnaW5MZWZ0LFxuICAgIHdpZHRoOiB3aWR0aCxcbiAgICBoZWlnaHQ6IGhlaWdodFxuICB9O1xuXG4gIHJldHVybiBnZXRDbGllbnRSZWN0KG9mZnNldCk7XG59XG5cbi8qKlxuICogQ2hlY2sgaWYgdGhlIGdpdmVuIGVsZW1lbnQgaXMgZml4ZWQgb3IgaXMgaW5zaWRlIGEgZml4ZWQgcGFyZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gY3VzdG9tQ29udGFpbmVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn0gYW5zd2VyIHRvIFwiaXNGaXhlZD9cIlxuICovXG5mdW5jdGlvbiBpc0ZpeGVkKGVsZW1lbnQpIHtcbiAgdmFyIG5vZGVOYW1lID0gZWxlbWVudC5ub2RlTmFtZTtcbiAgaWYgKG5vZGVOYW1lID09PSAnQk9EWScgfHwgbm9kZU5hbWUgPT09ICdIVE1MJykge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxuICBpZiAoZ2V0U3R5bGVDb21wdXRlZFByb3BlcnR5KGVsZW1lbnQsICdwb3NpdGlvbicpID09PSAnZml4ZWQnKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cbiAgcmV0dXJuIGlzRml4ZWQoZ2V0UGFyZW50Tm9kZShlbGVtZW50KSk7XG59XG5cbi8qKlxuICogQ29tcHV0ZWQgdGhlIGJvdW5kYXJpZXMgbGltaXRzIGFuZCByZXR1cm4gdGhlbVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2VcbiAqIEBwYXJhbSB7bnVtYmVyfSBwYWRkaW5nXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBib3VuZGFyaWVzRWxlbWVudCAtIEVsZW1lbnQgdXNlZCB0byBkZWZpbmUgdGhlIGJvdW5kYXJpZXNcbiAqIEByZXR1cm5zIHtPYmplY3R9IENvb3JkaW5hdGVzIG9mIHRoZSBib3VuZGFyaWVzXG4gKi9cbmZ1bmN0aW9uIGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIC8vIE5PVEU6IDEgRE9NIGFjY2VzcyBoZXJlXG4gIHZhciBib3VuZGFyaWVzID0geyB0b3A6IDAsIGxlZnQ6IDAgfTtcbiAgdmFyIG9mZnNldFBhcmVudCA9IGZpbmRDb21tb25PZmZzZXRQYXJlbnQocG9wcGVyLCByZWZlcmVuY2UpO1xuXG4gIC8vIEhhbmRsZSB2aWV3cG9ydCBjYXNlXG4gIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3ZpZXdwb3J0Jykge1xuICAgIGJvdW5kYXJpZXMgPSBnZXRWaWV3cG9ydE9mZnNldFJlY3RSZWxhdGl2ZVRvQXJ0Yml0cmFyeU5vZGUob2Zmc2V0UGFyZW50KTtcbiAgfSBlbHNlIHtcbiAgICAvLyBIYW5kbGUgb3RoZXIgY2FzZXMgYmFzZWQgb24gRE9NIGVsZW1lbnQgdXNlZCBhcyBib3VuZGFyaWVzXG4gICAgdmFyIGJvdW5kYXJpZXNOb2RlID0gdm9pZCAwO1xuICAgIGlmIChib3VuZGFyaWVzRWxlbWVudCA9PT0gJ3Njcm9sbFBhcmVudCcpIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gZ2V0U2Nyb2xsUGFyZW50KGdldFBhcmVudE5vZGUocmVmZXJlbmNlKSk7XG4gICAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdCT0RZJykge1xuICAgICAgICBib3VuZGFyaWVzTm9kZSA9IHBvcHBlci5vd25lckRvY3VtZW50LmRvY3VtZW50RWxlbWVudDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGJvdW5kYXJpZXNFbGVtZW50ID09PSAnd2luZG93Jykge1xuICAgICAgYm91bmRhcmllc05vZGUgPSBwb3BwZXIub3duZXJEb2N1bWVudC5kb2N1bWVudEVsZW1lbnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIGJvdW5kYXJpZXNOb2RlID0gYm91bmRhcmllc0VsZW1lbnQ7XG4gICAgfVxuXG4gICAgdmFyIG9mZnNldHMgPSBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUoYm91bmRhcmllc05vZGUsIG9mZnNldFBhcmVudCk7XG5cbiAgICAvLyBJbiBjYXNlIG9mIEhUTUwsIHdlIG5lZWQgYSBkaWZmZXJlbnQgY29tcHV0YXRpb25cbiAgICBpZiAoYm91bmRhcmllc05vZGUubm9kZU5hbWUgPT09ICdIVE1MJyAmJiAhaXNGaXhlZChvZmZzZXRQYXJlbnQpKSB7XG4gICAgICB2YXIgX2dldFdpbmRvd1NpemVzID0gZ2V0V2luZG93U2l6ZXMoKSxcbiAgICAgICAgICBoZWlnaHQgPSBfZ2V0V2luZG93U2l6ZXMuaGVpZ2h0LFxuICAgICAgICAgIHdpZHRoID0gX2dldFdpbmRvd1NpemVzLndpZHRoO1xuXG4gICAgICBib3VuZGFyaWVzLnRvcCArPSBvZmZzZXRzLnRvcCAtIG9mZnNldHMubWFyZ2luVG9wO1xuICAgICAgYm91bmRhcmllcy5ib3R0b20gPSBoZWlnaHQgKyBvZmZzZXRzLnRvcDtcbiAgICAgIGJvdW5kYXJpZXMubGVmdCArPSBvZmZzZXRzLmxlZnQgLSBvZmZzZXRzLm1hcmdpbkxlZnQ7XG4gICAgICBib3VuZGFyaWVzLnJpZ2h0ID0gd2lkdGggKyBvZmZzZXRzLmxlZnQ7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciBhbGwgdGhlIG90aGVyIERPTSBlbGVtZW50cywgdGhpcyBvbmUgaXMgZ29vZFxuICAgICAgYm91bmRhcmllcyA9IG9mZnNldHM7XG4gICAgfVxuICB9XG5cbiAgLy8gQWRkIHBhZGRpbmdzXG4gIGJvdW5kYXJpZXMubGVmdCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnRvcCArPSBwYWRkaW5nO1xuICBib3VuZGFyaWVzLnJpZ2h0IC09IHBhZGRpbmc7XG4gIGJvdW5kYXJpZXMuYm90dG9tIC09IHBhZGRpbmc7XG5cbiAgcmV0dXJuIGJvdW5kYXJpZXM7XG59XG5cbmZ1bmN0aW9uIGdldEFyZWEoX3JlZikge1xuICB2YXIgd2lkdGggPSBfcmVmLndpZHRoLFxuICAgICAgaGVpZ2h0ID0gX3JlZi5oZWlnaHQ7XG5cbiAgcmV0dXJuIHdpZHRoICogaGVpZ2h0O1xufVxuXG4vKipcbiAqIFV0aWxpdHkgdXNlZCB0byB0cmFuc2Zvcm0gdGhlIGBhdXRvYCBwbGFjZW1lbnQgdG8gdGhlIHBsYWNlbWVudCB3aXRoIG1vcmVcbiAqIGF2YWlsYWJsZSBzcGFjZS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGNvbXB1dGVBdXRvUGxhY2VtZW50KHBsYWNlbWVudCwgcmVmUmVjdCwgcG9wcGVyLCByZWZlcmVuY2UsIGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gIHZhciBwYWRkaW5nID0gYXJndW1lbnRzLmxlbmd0aCA+IDUgJiYgYXJndW1lbnRzWzVdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbNV0gOiAwO1xuXG4gIGlmIChwbGFjZW1lbnQuaW5kZXhPZignYXV0bycpID09PSAtMSkge1xuICAgIHJldHVybiBwbGFjZW1lbnQ7XG4gIH1cblxuICB2YXIgYm91bmRhcmllcyA9IGdldEJvdW5kYXJpZXMocG9wcGVyLCByZWZlcmVuY2UsIHBhZGRpbmcsIGJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcmVjdHMgPSB7XG4gICAgdG9wOiB7XG4gICAgICB3aWR0aDogYm91bmRhcmllcy53aWR0aCxcbiAgICAgIGhlaWdodDogcmVmUmVjdC50b3AgLSBib3VuZGFyaWVzLnRvcFxuICAgIH0sXG4gICAgcmlnaHQ6IHtcbiAgICAgIHdpZHRoOiBib3VuZGFyaWVzLnJpZ2h0IC0gcmVmUmVjdC5yaWdodCxcbiAgICAgIGhlaWdodDogYm91bmRhcmllcy5oZWlnaHRcbiAgICB9LFxuICAgIGJvdHRvbToge1xuICAgICAgd2lkdGg6IGJvdW5kYXJpZXMud2lkdGgsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuYm90dG9tIC0gcmVmUmVjdC5ib3R0b21cbiAgICB9LFxuICAgIGxlZnQ6IHtcbiAgICAgIHdpZHRoOiByZWZSZWN0LmxlZnQgLSBib3VuZGFyaWVzLmxlZnQsXG4gICAgICBoZWlnaHQ6IGJvdW5kYXJpZXMuaGVpZ2h0XG4gICAgfVxuICB9O1xuXG4gIHZhciBzb3J0ZWRBcmVhcyA9IE9iamVjdC5rZXlzKHJlY3RzKS5tYXAoZnVuY3Rpb24gKGtleSkge1xuICAgIHJldHVybiBfZXh0ZW5kcyh7XG4gICAgICBrZXk6IGtleVxuICAgIH0sIHJlY3RzW2tleV0sIHtcbiAgICAgIGFyZWE6IGdldEFyZWEocmVjdHNba2V5XSlcbiAgICB9KTtcbiAgfSkuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgIHJldHVybiBiLmFyZWEgLSBhLmFyZWE7XG4gIH0pO1xuXG4gIHZhciBmaWx0ZXJlZEFyZWFzID0gc29ydGVkQXJlYXMuZmlsdGVyKGZ1bmN0aW9uIChfcmVmMikge1xuICAgIHZhciB3aWR0aCA9IF9yZWYyLndpZHRoLFxuICAgICAgICBoZWlnaHQgPSBfcmVmMi5oZWlnaHQ7XG4gICAgcmV0dXJuIHdpZHRoID49IHBvcHBlci5jbGllbnRXaWR0aCAmJiBoZWlnaHQgPj0gcG9wcGVyLmNsaWVudEhlaWdodDtcbiAgfSk7XG5cbiAgdmFyIGNvbXB1dGVkUGxhY2VtZW50ID0gZmlsdGVyZWRBcmVhcy5sZW5ndGggPiAwID8gZmlsdGVyZWRBcmVhc1swXS5rZXkgOiBzb3J0ZWRBcmVhc1swXS5rZXk7XG5cbiAgdmFyIHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIHJldHVybiBjb21wdXRlZFBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHJlZmVyZW5jZSBlbGVtZW50XG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge09iamVjdH0gc3RhdGVcbiAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge0VsZW1lbnR9IHJlZmVyZW5jZSAtIHRoZSByZWZlcmVuY2UgZWxlbWVudCAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBBbiBvYmplY3QgY29udGFpbmluZyB0aGUgb2Zmc2V0cyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlclxuICovXG5mdW5jdGlvbiBnZXRSZWZlcmVuY2VPZmZzZXRzKHN0YXRlLCBwb3BwZXIsIHJlZmVyZW5jZSkge1xuICB2YXIgY29tbW9uT2Zmc2V0UGFyZW50ID0gZmluZENvbW1vbk9mZnNldFBhcmVudChwb3BwZXIsIHJlZmVyZW5jZSk7XG4gIHJldHVybiBnZXRPZmZzZXRSZWN0UmVsYXRpdmVUb0FyYml0cmFyeU5vZGUocmVmZXJlbmNlLCBjb21tb25PZmZzZXRQYXJlbnQpO1xufVxuXG4vKipcbiAqIEdldCB0aGUgb3V0ZXIgc2l6ZXMgb2YgdGhlIGdpdmVuIGVsZW1lbnQgKG9mZnNldCBzaXplICsgbWFyZ2lucylcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7RWxlbWVudH0gZWxlbWVudFxuICogQHJldHVybnMge09iamVjdH0gb2JqZWN0IGNvbnRhaW5pbmcgd2lkdGggYW5kIGhlaWdodCBwcm9wZXJ0aWVzXG4gKi9cbmZ1bmN0aW9uIGdldE91dGVyU2l6ZXMoZWxlbWVudCkge1xuICB2YXIgc3R5bGVzID0gZ2V0Q29tcHV0ZWRTdHlsZShlbGVtZW50KTtcbiAgdmFyIHggPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5Ub3ApICsgcGFyc2VGbG9hdChzdHlsZXMubWFyZ2luQm90dG9tKTtcbiAgdmFyIHkgPSBwYXJzZUZsb2F0KHN0eWxlcy5tYXJnaW5MZWZ0KSArIHBhcnNlRmxvYXQoc3R5bGVzLm1hcmdpblJpZ2h0KTtcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICB3aWR0aDogZWxlbWVudC5vZmZzZXRXaWR0aCArIHksXG4gICAgaGVpZ2h0OiBlbGVtZW50Lm9mZnNldEhlaWdodCArIHhcbiAgfTtcbiAgcmV0dXJuIHJlc3VsdDtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCBvZiB0aGUgZ2l2ZW4gb25lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcGxhY2VtZW50XG4gKiBAcmV0dXJucyB7U3RyaW5nfSBmbGlwcGVkIHBsYWNlbWVudFxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpIHtcbiAgdmFyIGhhc2ggPSB7IGxlZnQ6ICdyaWdodCcsIHJpZ2h0OiAnbGVmdCcsIGJvdHRvbTogJ3RvcCcsIHRvcDogJ2JvdHRvbScgfTtcbiAgcmV0dXJuIHBsYWNlbWVudC5yZXBsYWNlKC9sZWZ0fHJpZ2h0fGJvdHRvbXx0b3AvZywgZnVuY3Rpb24gKG1hdGNoZWQpIHtcbiAgICByZXR1cm4gaGFzaFttYXRjaGVkXTtcbiAgfSk7XG59XG5cbi8qKlxuICogR2V0IG9mZnNldHMgdG8gdGhlIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHBhcmFtIHtPYmplY3R9IHBvc2l0aW9uIC0gQ1NTIHBvc2l0aW9uIHRoZSBQb3BwZXIgd2lsbCBnZXQgYXBwbGllZFxuICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gdGhlIHBvcHBlciBlbGVtZW50XG4gKiBAcGFyYW0ge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0cyAtIHRoZSByZWZlcmVuY2Ugb2Zmc2V0cyAodGhlIHBvcHBlciB3aWxsIGJlIHJlbGF0aXZlIHRvIHRoaXMpXG4gKiBAcGFyYW0ge1N0cmluZ30gcGxhY2VtZW50IC0gb25lIG9mIHRoZSB2YWxpZCBwbGFjZW1lbnQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gcG9wcGVyT2Zmc2V0cyAtIEFuIG9iamVjdCBjb250YWluaW5nIHRoZSBvZmZzZXRzIHdoaWNoIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGdldFBvcHBlck9mZnNldHMocG9wcGVyLCByZWZlcmVuY2VPZmZzZXRzLCBwbGFjZW1lbnQpIHtcbiAgcGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG5cbiAgLy8gR2V0IHBvcHBlciBub2RlIHNpemVzXG4gIHZhciBwb3BwZXJSZWN0ID0gZ2V0T3V0ZXJTaXplcyhwb3BwZXIpO1xuXG4gIC8vIEFkZCBwb3NpdGlvbiwgd2lkdGggYW5kIGhlaWdodCB0byBvdXIgb2Zmc2V0cyBvYmplY3RcbiAgdmFyIHBvcHBlck9mZnNldHMgPSB7XG4gICAgd2lkdGg6IHBvcHBlclJlY3Qud2lkdGgsXG4gICAgaGVpZ2h0OiBwb3BwZXJSZWN0LmhlaWdodFxuICB9O1xuXG4gIC8vIGRlcGVuZGluZyBieSB0aGUgcG9wcGVyIHBsYWNlbWVudCB3ZSBoYXZlIHRvIGNvbXB1dGUgaXRzIG9mZnNldHMgc2xpZ2h0bHkgZGlmZmVyZW50bHlcbiAgdmFyIGlzSG9yaXogPSBbJ3JpZ2h0JywgJ2xlZnQnXS5pbmRleE9mKHBsYWNlbWVudCkgIT09IC0xO1xuICB2YXIgbWFpblNpZGUgPSBpc0hvcml6ID8gJ3RvcCcgOiAnbGVmdCc7XG4gIHZhciBzZWNvbmRhcnlTaWRlID0gaXNIb3JpeiA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc0hvcml6ID8gJ2hlaWdodCcgOiAnd2lkdGgnO1xuICB2YXIgc2Vjb25kYXJ5TWVhc3VyZW1lbnQgPSAhaXNIb3JpeiA/ICdoZWlnaHQnIDogJ3dpZHRoJztcblxuICBwb3BwZXJPZmZzZXRzW21haW5TaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbbWFpblNpZGVdICsgcmVmZXJlbmNlT2Zmc2V0c1ttZWFzdXJlbWVudF0gLyAyIC0gcG9wcGVyUmVjdFttZWFzdXJlbWVudF0gLyAyO1xuICBpZiAocGxhY2VtZW50ID09PSBzZWNvbmRhcnlTaWRlKSB7XG4gICAgcG9wcGVyT2Zmc2V0c1tzZWNvbmRhcnlTaWRlXSA9IHJlZmVyZW5jZU9mZnNldHNbc2Vjb25kYXJ5U2lkZV0gLSBwb3BwZXJSZWN0W3NlY29uZGFyeU1lYXN1cmVtZW50XTtcbiAgfSBlbHNlIHtcbiAgICBwb3BwZXJPZmZzZXRzW3NlY29uZGFyeVNpZGVdID0gcmVmZXJlbmNlT2Zmc2V0c1tnZXRPcHBvc2l0ZVBsYWNlbWVudChzZWNvbmRhcnlTaWRlKV07XG4gIH1cblxuICByZXR1cm4gcG9wcGVyT2Zmc2V0cztcbn1cblxuLyoqXG4gKiBNaW1pY3MgdGhlIGBmaW5kYCBtZXRob2Qgb2YgQXJyYXlcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7QXJyYXl9IGFyclxuICogQGFyZ3VtZW50IHByb3BcbiAqIEBhcmd1bWVudCB2YWx1ZVxuICogQHJldHVybnMgaW5kZXggb3IgLTFcbiAqL1xuZnVuY3Rpb24gZmluZCQxKGFyciwgY2hlY2spIHtcbiAgLy8gdXNlIG5hdGl2ZSBmaW5kIGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmQpIHtcbiAgICByZXR1cm4gYXJyLmZpbmQoY2hlY2spO1xuICB9XG5cbiAgLy8gdXNlIGBmaWx0ZXJgIHRvIG9idGFpbiB0aGUgc2FtZSBiZWhhdmlvciBvZiBgZmluZGBcbiAgcmV0dXJuIGFyci5maWx0ZXIoY2hlY2spWzBdO1xufVxuXG4vKipcbiAqIFJldHVybiB0aGUgaW5kZXggb2YgdGhlIG1hdGNoaW5nIG9iamVjdFxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtBcnJheX0gYXJyXG4gKiBAYXJndW1lbnQgcHJvcFxuICogQGFyZ3VtZW50IHZhbHVlXG4gKiBAcmV0dXJucyBpbmRleCBvciAtMVxuICovXG5mdW5jdGlvbiBmaW5kSW5kZXgkMShhcnIsIHByb3AsIHZhbHVlKSB7XG4gIC8vIHVzZSBuYXRpdmUgZmluZEluZGV4IGlmIHN1cHBvcnRlZFxuICBpZiAoQXJyYXkucHJvdG90eXBlLmZpbmRJbmRleCkge1xuICAgIHJldHVybiBhcnIuZmluZEluZGV4KGZ1bmN0aW9uIChjdXIpIHtcbiAgICAgIHJldHVybiBjdXJbcHJvcF0gPT09IHZhbHVlO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gdXNlIGBmaW5kYCArIGBpbmRleE9mYCBpZiBgZmluZEluZGV4YCBpc24ndCBzdXBwb3J0ZWRcbiAgdmFyIG1hdGNoID0gZmluZCQxKGFyciwgZnVuY3Rpb24gKG9iaikge1xuICAgIHJldHVybiBvYmpbcHJvcF0gPT09IHZhbHVlO1xuICB9KTtcbiAgcmV0dXJuIGFyci5pbmRleE9mKG1hdGNoKTtcbn1cblxuLyoqXG4gKiBMb29wIHRyb3VnaCB0aGUgbGlzdCBvZiBtb2RpZmllcnMgYW5kIHJ1biB0aGVtIGluIG9yZGVyLFxuICogZWFjaCBvZiB0aGVtIHdpbGwgdGhlbiBlZGl0IHRoZSBkYXRhIG9iamVjdC5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7ZGF0YU9iamVjdH0gZGF0YVxuICogQHBhcmFtIHtBcnJheX0gbW9kaWZpZXJzXG4gKiBAcGFyYW0ge1N0cmluZ30gZW5kcyAtIE9wdGlvbmFsIG1vZGlmaWVyIG5hbWUgdXNlZCBhcyBzdG9wcGVyXG4gKiBAcmV0dXJucyB7ZGF0YU9iamVjdH1cbiAqL1xuZnVuY3Rpb24gcnVuTW9kaWZpZXJzKG1vZGlmaWVycywgZGF0YSwgZW5kcykge1xuICB2YXIgbW9kaWZpZXJzVG9SdW4gPSBlbmRzID09PSB1bmRlZmluZWQgPyBtb2RpZmllcnMgOiBtb2RpZmllcnMuc2xpY2UoMCwgZmluZEluZGV4JDEobW9kaWZpZXJzLCAnbmFtZScsIGVuZHMpKTtcblxuICBtb2RpZmllcnNUb1J1bi5mb3JFYWNoKGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIGlmIChtb2RpZmllclsnZnVuY3Rpb24nXSkge1xuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbGluZSBkb3Qtbm90YXRpb25cbiAgICAgIGNvbnNvbGUud2FybignYG1vZGlmaWVyLmZ1bmN0aW9uYCBpcyBkZXByZWNhdGVkLCB1c2UgYG1vZGlmaWVyLmZuYCEnKTtcbiAgICB9XG4gICAgdmFyIGZuID0gbW9kaWZpZXJbJ2Z1bmN0aW9uJ10gfHwgbW9kaWZpZXIuZm47IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgZG90LW5vdGF0aW9uXG4gICAgaWYgKG1vZGlmaWVyLmVuYWJsZWQgJiYgaXNGdW5jdGlvbihmbikpIHtcbiAgICAgIC8vIEFkZCBwcm9wZXJ0aWVzIHRvIG9mZnNldHMgdG8gbWFrZSB0aGVtIGEgY29tcGxldGUgY2xpZW50UmVjdCBvYmplY3RcbiAgICAgIC8vIHdlIGRvIHRoaXMgYmVmb3JlIGVhY2ggbW9kaWZpZXIgdG8gbWFrZSBzdXJlIHRoZSBwcmV2aW91cyBvbmUgZG9lc24ndFxuICAgICAgLy8gbWVzcyB3aXRoIHRoZXNlIHZhbHVlc1xuICAgICAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG4gICAgICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0Q2xpZW50UmVjdChkYXRhLm9mZnNldHMucmVmZXJlbmNlKTtcblxuICAgICAgZGF0YSA9IGZuKGRhdGEsIG1vZGlmaWVyKTtcbiAgICB9XG4gIH0pO1xuXG4gIHJldHVybiBkYXRhO1xufVxuXG4vKipcbiAqIFVwZGF0ZXMgdGhlIHBvc2l0aW9uIG9mIHRoZSBwb3BwZXIsIGNvbXB1dGluZyB0aGUgbmV3IG9mZnNldHMgYW5kIGFwcGx5aW5nXG4gKiB0aGUgbmV3IHN0eWxlLjxiciAvPlxuICogUHJlZmVyIGBzY2hlZHVsZVVwZGF0ZWAgb3ZlciBgdXBkYXRlYCBiZWNhdXNlIG9mIHBlcmZvcm1hbmNlIHJlYXNvbnMuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIHVwZGF0ZSgpIHtcbiAgLy8gaWYgcG9wcGVyIGlzIGRlc3Ryb3llZCwgZG9uJ3QgcGVyZm9ybSBhbnkgZnVydGhlciB1cGRhdGVcbiAgaWYgKHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQpIHtcbiAgICByZXR1cm47XG4gIH1cblxuICB2YXIgZGF0YSA9IHtcbiAgICBpbnN0YW5jZTogdGhpcyxcbiAgICBzdHlsZXM6IHt9LFxuICAgIGFycm93U3R5bGVzOiB7fSxcbiAgICBhdHRyaWJ1dGVzOiB7fSxcbiAgICBmbGlwcGVkOiBmYWxzZSxcbiAgICBvZmZzZXRzOiB7fVxuICB9O1xuXG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICBkYXRhLm9mZnNldHMucmVmZXJlbmNlID0gZ2V0UmVmZXJlbmNlT2Zmc2V0cyh0aGlzLnN0YXRlLCB0aGlzLnBvcHBlciwgdGhpcy5yZWZlcmVuY2UpO1xuXG4gIC8vIGNvbXB1dGUgYXV0byBwbGFjZW1lbnQsIHN0b3JlIHBsYWNlbWVudCBpbnNpZGUgdGhlIGRhdGEgb2JqZWN0LFxuICAvLyBtb2RpZmllcnMgd2lsbCBiZSBhYmxlIHRvIGVkaXQgYHBsYWNlbWVudGAgaWYgbmVlZGVkXG4gIC8vIGFuZCByZWZlciB0byBvcmlnaW5hbFBsYWNlbWVudCB0byBrbm93IHRoZSBvcmlnaW5hbCB2YWx1ZVxuICBkYXRhLnBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KHRoaXMub3B0aW9ucy5wbGFjZW1lbnQsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIHRoaXMucG9wcGVyLCB0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLm1vZGlmaWVycy5mbGlwLmJvdW5kYXJpZXNFbGVtZW50LCB0aGlzLm9wdGlvbnMubW9kaWZpZXJzLmZsaXAucGFkZGluZyk7XG5cbiAgLy8gc3RvcmUgdGhlIGNvbXB1dGVkIHBsYWNlbWVudCBpbnNpZGUgYG9yaWdpbmFsUGxhY2VtZW50YFxuICBkYXRhLm9yaWdpbmFsUGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG5cbiAgLy8gY29tcHV0ZSB0aGUgcG9wcGVyIG9mZnNldHNcbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldFBvcHBlck9mZnNldHModGhpcy5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KTtcbiAgZGF0YS5vZmZzZXRzLnBvcHBlci5wb3NpdGlvbiA9ICdhYnNvbHV0ZSc7XG5cbiAgLy8gcnVuIHRoZSBtb2RpZmllcnNcbiAgZGF0YSA9IHJ1bk1vZGlmaWVycyh0aGlzLm1vZGlmaWVycywgZGF0YSk7XG5cbiAgLy8gdGhlIGZpcnN0IGB1cGRhdGVgIHdpbGwgY2FsbCBgb25DcmVhdGVgIGNhbGxiYWNrXG4gIC8vIHRoZSBvdGhlciBvbmVzIHdpbGwgY2FsbCBgb25VcGRhdGVgIGNhbGxiYWNrXG4gIGlmICghdGhpcy5zdGF0ZS5pc0NyZWF0ZWQpIHtcbiAgICB0aGlzLnN0YXRlLmlzQ3JlYXRlZCA9IHRydWU7XG4gICAgdGhpcy5vcHRpb25zLm9uQ3JlYXRlKGRhdGEpO1xuICB9IGVsc2Uge1xuICAgIHRoaXMub3B0aW9ucy5vblVwZGF0ZShkYXRhKTtcbiAgfVxufVxuXG4vKipcbiAqIEhlbHBlciB1c2VkIHRvIGtub3cgaWYgdGhlIGdpdmVuIG1vZGlmaWVyIGlzIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllckVuYWJsZWQobW9kaWZpZXJzLCBtb2RpZmllck5hbWUpIHtcbiAgcmV0dXJuIG1vZGlmaWVycy5zb21lKGZ1bmN0aW9uIChfcmVmKSB7XG4gICAgdmFyIG5hbWUgPSBfcmVmLm5hbWUsXG4gICAgICAgIGVuYWJsZWQgPSBfcmVmLmVuYWJsZWQ7XG4gICAgcmV0dXJuIGVuYWJsZWQgJiYgbmFtZSA9PT0gbW9kaWZpZXJOYW1lO1xuICB9KTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIHByZWZpeGVkIHN1cHBvcnRlZCBwcm9wZXJ0eSBuYW1lXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge1N0cmluZ30gcHJvcGVydHkgKGNhbWVsQ2FzZSlcbiAqIEByZXR1cm5zIHtTdHJpbmd9IHByZWZpeGVkIHByb3BlcnR5IChjYW1lbENhc2Ugb3IgUGFzY2FsQ2FzZSwgZGVwZW5kaW5nIG9uIHRoZSB2ZW5kb3IgcHJlZml4KVxuICovXG5mdW5jdGlvbiBnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUocHJvcGVydHkpIHtcbiAgdmFyIHByZWZpeGVzID0gW2ZhbHNlLCAnbXMnLCAnV2Via2l0JywgJ01veicsICdPJ107XG4gIHZhciB1cHBlclByb3AgPSBwcm9wZXJ0eS5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHByb3BlcnR5LnNsaWNlKDEpO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlZml4ZXMubGVuZ3RoIC0gMTsgaSsrKSB7XG4gICAgdmFyIHByZWZpeCA9IHByZWZpeGVzW2ldO1xuICAgIHZhciB0b0NoZWNrID0gcHJlZml4ID8gJycgKyBwcmVmaXggKyB1cHBlclByb3AgOiBwcm9wZXJ0eTtcbiAgICBpZiAodHlwZW9mIGRvY3VtZW50LmJvZHkuc3R5bGVbdG9DaGVja10gIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICByZXR1cm4gdG9DaGVjaztcbiAgICB9XG4gIH1cbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogRGVzdHJveSB0aGUgcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbmZ1bmN0aW9uIGRlc3Ryb3koKSB7XG4gIHRoaXMuc3RhdGUuaXNEZXN0cm95ZWQgPSB0cnVlO1xuXG4gIC8vIHRvdWNoIERPTSBvbmx5IGlmIGBhcHBseVN0eWxlYCBtb2RpZmllciBpcyBlbmFibGVkXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZCh0aGlzLm1vZGlmaWVycywgJ2FwcGx5U3R5bGUnKSkge1xuICAgIHRoaXMucG9wcGVyLnJlbW92ZUF0dHJpYnV0ZSgneC1wbGFjZW1lbnQnKTtcbiAgICB0aGlzLnBvcHBlci5zdHlsZS5sZWZ0ID0gJyc7XG4gICAgdGhpcy5wb3BwZXIuc3R5bGUucG9zaXRpb24gPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZS50b3AgPSAnJztcbiAgICB0aGlzLnBvcHBlci5zdHlsZVtnZXRTdXBwb3J0ZWRQcm9wZXJ0eU5hbWUoJ3RyYW5zZm9ybScpXSA9ICcnO1xuICB9XG5cbiAgdGhpcy5kaXNhYmxlRXZlbnRMaXN0ZW5lcnMoKTtcblxuICAvLyByZW1vdmUgdGhlIHBvcHBlciBpZiB1c2VyIGV4cGxpY2l0eSBhc2tlZCBmb3IgdGhlIGRlbGV0aW9uIG9uIGRlc3Ryb3lcbiAgLy8gZG8gbm90IHVzZSBgcmVtb3ZlYCBiZWNhdXNlIElFMTEgZG9lc24ndCBzdXBwb3J0IGl0XG4gIGlmICh0aGlzLm9wdGlvbnMucmVtb3ZlT25EZXN0cm95KSB7XG4gICAgdGhpcy5wb3BwZXIucGFyZW50Tm9kZS5yZW1vdmVDaGlsZCh0aGlzLnBvcHBlcik7XG4gIH1cbiAgcmV0dXJuIHRoaXM7XG59XG5cbi8qKlxuICogR2V0IHRoZSB3aW5kb3cgYXNzb2NpYXRlZCB3aXRoIHRoZSBlbGVtZW50XG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnRcbiAqIEByZXR1cm5zIHtXaW5kb3d9XG4gKi9cbmZ1bmN0aW9uIGdldFdpbmRvdyhlbGVtZW50KSB7XG4gIHZhciBvd25lckRvY3VtZW50ID0gZWxlbWVudC5vd25lckRvY3VtZW50O1xuICByZXR1cm4gb3duZXJEb2N1bWVudCA/IG93bmVyRG9jdW1lbnQuZGVmYXVsdFZpZXcgOiB3aW5kb3c7XG59XG5cbmZ1bmN0aW9uIGF0dGFjaFRvU2Nyb2xsUGFyZW50cyhzY3JvbGxQYXJlbnQsIGV2ZW50LCBjYWxsYmFjaywgc2Nyb2xsUGFyZW50cykge1xuICB2YXIgaXNCb2R5ID0gc2Nyb2xsUGFyZW50Lm5vZGVOYW1lID09PSAnQk9EWSc7XG4gIHZhciB0YXJnZXQgPSBpc0JvZHkgPyBzY3JvbGxQYXJlbnQub3duZXJEb2N1bWVudC5kZWZhdWx0VmlldyA6IHNjcm9sbFBhcmVudDtcbiAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnQsIGNhbGxiYWNrLCB7IHBhc3NpdmU6IHRydWUgfSk7XG5cbiAgaWYgKCFpc0JvZHkpIHtcbiAgICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoZ2V0U2Nyb2xsUGFyZW50KHRhcmdldC5wYXJlbnROb2RlKSwgZXZlbnQsIGNhbGxiYWNrLCBzY3JvbGxQYXJlbnRzKTtcbiAgfVxuICBzY3JvbGxQYXJlbnRzLnB1c2godGFyZ2V0KTtcbn1cblxuLyoqXG4gKiBTZXR1cCBuZWVkZWQgZXZlbnQgbGlzdGVuZXJzIHVzZWQgdG8gdXBkYXRlIHRoZSBwb3BwZXIgcG9zaXRpb25cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwcml2YXRlXG4gKi9cbmZ1bmN0aW9uIHNldHVwRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBvcHRpb25zLCBzdGF0ZSwgdXBkYXRlQm91bmQpIHtcbiAgLy8gUmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBzdGF0ZS51cGRhdGVCb3VuZCA9IHVwZGF0ZUJvdW5kO1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5hZGRFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCwgeyBwYXNzaXZlOiB0cnVlIH0pO1xuXG4gIC8vIFNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICB2YXIgc2Nyb2xsRWxlbWVudCA9IGdldFNjcm9sbFBhcmVudChyZWZlcmVuY2UpO1xuICBhdHRhY2hUb1Njcm9sbFBhcmVudHMoc2Nyb2xsRWxlbWVudCwgJ3Njcm9sbCcsIHN0YXRlLnVwZGF0ZUJvdW5kLCBzdGF0ZS5zY3JvbGxQYXJlbnRzKTtcbiAgc3RhdGUuc2Nyb2xsRWxlbWVudCA9IHNjcm9sbEVsZW1lbnQ7XG4gIHN0YXRlLmV2ZW50c0VuYWJsZWQgPSB0cnVlO1xuXG4gIHJldHVybiBzdGF0ZTtcbn1cblxuLyoqXG4gKiBJdCB3aWxsIGFkZCByZXNpemUvc2Nyb2xsIGV2ZW50cyBhbmQgc3RhcnQgcmVjYWxjdWxhdGluZ1xuICogcG9zaXRpb24gb2YgdGhlIHBvcHBlciBlbGVtZW50IHdoZW4gdGhleSBhcmUgdHJpZ2dlcmVkLlxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlclxuICovXG5mdW5jdGlvbiBlbmFibGVFdmVudExpc3RlbmVycygpIHtcbiAgaWYgKCF0aGlzLnN0YXRlLmV2ZW50c0VuYWJsZWQpIHtcbiAgICB0aGlzLnN0YXRlID0gc2V0dXBFdmVudExpc3RlbmVycyh0aGlzLnJlZmVyZW5jZSwgdGhpcy5vcHRpb25zLCB0aGlzLnN0YXRlLCB0aGlzLnNjaGVkdWxlVXBkYXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBldmVudCBsaXN0ZW5lcnMgdXNlZCB0byB1cGRhdGUgdGhlIHBvcHBlciBwb3NpdGlvblxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQHByaXZhdGVcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlRXZlbnRMaXN0ZW5lcnMocmVmZXJlbmNlLCBzdGF0ZSkge1xuICAvLyBSZW1vdmUgcmVzaXplIGV2ZW50IGxpc3RlbmVyIG9uIHdpbmRvd1xuICBnZXRXaW5kb3cocmVmZXJlbmNlKS5yZW1vdmVFdmVudExpc3RlbmVyKCdyZXNpemUnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG5cbiAgLy8gUmVtb3ZlIHNjcm9sbCBldmVudCBsaXN0ZW5lciBvbiBzY3JvbGwgcGFyZW50c1xuICBzdGF0ZS5zY3JvbGxQYXJlbnRzLmZvckVhY2goZnVuY3Rpb24gKHRhcmdldCkge1xuICAgIHRhcmdldC5yZW1vdmVFdmVudExpc3RlbmVyKCdzY3JvbGwnLCBzdGF0ZS51cGRhdGVCb3VuZCk7XG4gIH0pO1xuXG4gIC8vIFJlc2V0IHN0YXRlXG4gIHN0YXRlLnVwZGF0ZUJvdW5kID0gbnVsbDtcbiAgc3RhdGUuc2Nyb2xsUGFyZW50cyA9IFtdO1xuICBzdGF0ZS5zY3JvbGxFbGVtZW50ID0gbnVsbDtcbiAgc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGZhbHNlO1xuICByZXR1cm4gc3RhdGU7XG59XG5cbi8qKlxuICogSXQgd2lsbCByZW1vdmUgcmVzaXplL3Njcm9sbCBldmVudHMgYW5kIHdvbid0IHJlY2FsY3VsYXRlIHBvcHBlciBwb3NpdGlvblxuICogd2hlbiB0aGV5IGFyZSB0cmlnZ2VyZWQuIEl0IGFsc28gd29uJ3QgdHJpZ2dlciBvblVwZGF0ZSBjYWxsYmFjayBhbnltb3JlLFxuICogdW5sZXNzIHlvdSBjYWxsIGB1cGRhdGVgIG1ldGhvZCBtYW51YWxseS5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xuZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCkge1xuICBpZiAodGhpcy5zdGF0ZS5ldmVudHNFbmFibGVkKSB7XG4gICAgY2FuY2VsQW5pbWF0aW9uRnJhbWUodGhpcy5zY2hlZHVsZVVwZGF0ZSk7XG4gICAgdGhpcy5zdGF0ZSA9IHJlbW92ZUV2ZW50TGlzdGVuZXJzKHRoaXMucmVmZXJlbmNlLCB0aGlzLnN0YXRlKTtcbiAgfVxufVxuXG4vKipcbiAqIFRlbGxzIGlmIGEgZ2l2ZW4gaW5wdXQgaXMgYSBudW1iZXJcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBwYXJhbSB7Kn0gaW5wdXQgdG8gY2hlY2tcbiAqIEByZXR1cm4ge0Jvb2xlYW59XG4gKi9cbmZ1bmN0aW9uIGlzTnVtZXJpYyhuKSB7XG4gIHJldHVybiBuICE9PSAnJyAmJiAhaXNOYU4ocGFyc2VGbG9hdChuKSkgJiYgaXNGaW5pdGUobik7XG59XG5cbi8qKlxuICogU2V0IHRoZSBzdHlsZSB0byB0aGUgZ2l2ZW4gcG9wcGVyXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAYXJndW1lbnQge0VsZW1lbnR9IGVsZW1lbnQgLSBFbGVtZW50IHRvIGFwcGx5IHRoZSBzdHlsZSB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0U3R5bGVzKGVsZW1lbnQsIHN0eWxlcykge1xuICBPYmplY3Qua2V5cyhzdHlsZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdW5pdCA9ICcnO1xuICAgIC8vIGFkZCB1bml0IGlmIHRoZSB2YWx1ZSBpcyBudW1lcmljIGFuZCBpcyBvbmUgb2YgdGhlIGZvbGxvd2luZ1xuICAgIGlmIChbJ3dpZHRoJywgJ2hlaWdodCcsICd0b3AnLCAncmlnaHQnLCAnYm90dG9tJywgJ2xlZnQnXS5pbmRleE9mKHByb3ApICE9PSAtMSAmJiBpc051bWVyaWMoc3R5bGVzW3Byb3BdKSkge1xuICAgICAgdW5pdCA9ICdweCc7XG4gICAgfVxuICAgIGVsZW1lbnQuc3R5bGVbcHJvcF0gPSBzdHlsZXNbcHJvcF0gKyB1bml0O1xuICB9KTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIGF0dHJpYnV0ZXMgdG8gdGhlIGdpdmVuIHBvcHBlclxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtFbGVtZW50fSBlbGVtZW50IC0gRWxlbWVudCB0byBhcHBseSB0aGUgYXR0cmlidXRlcyB0b1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHN0eWxlc1xuICogT2JqZWN0IHdpdGggYSBsaXN0IG9mIHByb3BlcnRpZXMgYW5kIHZhbHVlcyB3aGljaCB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIGVsZW1lbnRcbiAqL1xuZnVuY3Rpb24gc2V0QXR0cmlidXRlcyhlbGVtZW50LCBhdHRyaWJ1dGVzKSB7XG4gIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24gKHByb3ApIHtcbiAgICB2YXIgdmFsdWUgPSBhdHRyaWJ1dGVzW3Byb3BdO1xuICAgIGlmICh2YWx1ZSAhPT0gZmFsc2UpIHtcbiAgICAgIGVsZW1lbnQuc2V0QXR0cmlidXRlKHByb3AsIGF0dHJpYnV0ZXNbcHJvcF0pO1xuICAgIH0gZWxzZSB7XG4gICAgICBlbGVtZW50LnJlbW92ZUF0dHJpYnV0ZShwcm9wKTtcbiAgICB9XG4gIH0pO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEuc3R5bGVzIC0gTGlzdCBvZiBzdHlsZSBwcm9wZXJ0aWVzIC0gdmFsdWVzIHRvIGFwcGx5IHRvIHBvcHBlciBlbGVtZW50XG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YS5hdHRyaWJ1dGVzIC0gTGlzdCBvZiBhdHRyaWJ1dGUgcHJvcGVydGllcyAtIHZhbHVlcyB0byBhcHBseSB0byBwb3BwZXIgZWxlbWVudFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIHNhbWUgZGF0YSBvYmplY3RcbiAqL1xuZnVuY3Rpb24gYXBwbHlTdHlsZShkYXRhKSB7XG4gIC8vIGFueSBwcm9wZXJ0eSBwcmVzZW50IGluIGBkYXRhLnN0eWxlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIGluIHRoaXMgd2F5IHdlIGNhbiBtYWtlIHRoZSAzcmQgcGFydHkgbW9kaWZpZXJzIGFkZCBjdXN0b20gc3R5bGVzIHRvIGl0XG4gIC8vIEJlIGF3YXJlLCBtb2RpZmllcnMgY291bGQgb3ZlcnJpZGUgdGhlIHByb3BlcnRpZXMgZGVmaW5lZCBpbiB0aGUgcHJldmlvdXNcbiAgLy8gbGluZXMgb2YgdGhpcyBtb2RpZmllciFcbiAgc2V0U3R5bGVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLnN0eWxlcyk7XG5cbiAgLy8gYW55IHByb3BlcnR5IHByZXNlbnQgaW4gYGRhdGEuYXR0cmlidXRlc2Agd2lsbCBiZSBhcHBsaWVkIHRvIHRoZSBwb3BwZXIsXG4gIC8vIHRoZXkgd2lsbCBiZSBzZXQgYXMgSFRNTCBhdHRyaWJ1dGVzIG9mIHRoZSBlbGVtZW50XG4gIHNldEF0dHJpYnV0ZXMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEuYXR0cmlidXRlcyk7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGRlZmluZWQgYW5kIGFycm93U3R5bGVzIGhhcyBzb21lIHByb3BlcnRpZXNcbiAgaWYgKGRhdGEuYXJyb3dFbGVtZW50ICYmIE9iamVjdC5rZXlzKGRhdGEuYXJyb3dTdHlsZXMpLmxlbmd0aCkge1xuICAgIHNldFN0eWxlcyhkYXRhLmFycm93RWxlbWVudCwgZGF0YS5hcnJvd1N0eWxlcyk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBTZXQgdGhlIHgtcGxhY2VtZW50IGF0dHJpYnV0ZSBiZWZvcmUgZXZlcnl0aGluZyBlbHNlIGJlY2F1c2UgaXQgY291bGQgYmUgdXNlZFxuICogdG8gYWRkIG1hcmdpbnMgdG8gdGhlIHBvcHBlciBtYXJnaW5zIG5lZWRzIHRvIGJlIGNhbGN1bGF0ZWQgdG8gZ2V0IHRoZVxuICogY29ycmVjdCBwb3BwZXIgb2Zmc2V0cy5cbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIubW9kaWZpZXJzXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSByZWZlcmVuY2UgLSBUaGUgcmVmZXJlbmNlIGVsZW1lbnQgdXNlZCB0byBwb3NpdGlvbiB0aGUgcG9wcGVyXG4gKiBAcGFyYW0ge0hUTUxFbGVtZW50fSBwb3BwZXIgLSBUaGUgSFRNTCBlbGVtZW50IHVzZWQgYXMgcG9wcGVyLlxuICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBQb3BwZXIuanMgb3B0aW9uc1xuICovXG5mdW5jdGlvbiBhcHBseVN0eWxlT25Mb2FkKHJlZmVyZW5jZSwgcG9wcGVyLCBvcHRpb25zLCBtb2RpZmllck9wdGlvbnMsIHN0YXRlKSB7XG4gIC8vIGNvbXB1dGUgcmVmZXJlbmNlIGVsZW1lbnQgb2Zmc2V0c1xuICB2YXIgcmVmZXJlbmNlT2Zmc2V0cyA9IGdldFJlZmVyZW5jZU9mZnNldHMoc3RhdGUsIHBvcHBlciwgcmVmZXJlbmNlKTtcblxuICAvLyBjb21wdXRlIGF1dG8gcGxhY2VtZW50LCBzdG9yZSBwbGFjZW1lbnQgaW5zaWRlIHRoZSBkYXRhIG9iamVjdCxcbiAgLy8gbW9kaWZpZXJzIHdpbGwgYmUgYWJsZSB0byBlZGl0IGBwbGFjZW1lbnRgIGlmIG5lZWRlZFxuICAvLyBhbmQgcmVmZXIgdG8gb3JpZ2luYWxQbGFjZW1lbnQgdG8ga25vdyB0aGUgb3JpZ2luYWwgdmFsdWVcbiAgdmFyIHBsYWNlbWVudCA9IGNvbXB1dGVBdXRvUGxhY2VtZW50KG9wdGlvbnMucGxhY2VtZW50LCByZWZlcmVuY2VPZmZzZXRzLCBwb3BwZXIsIHJlZmVyZW5jZSwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5ib3VuZGFyaWVzRWxlbWVudCwgb3B0aW9ucy5tb2RpZmllcnMuZmxpcC5wYWRkaW5nKTtcblxuICBwb3BwZXIuc2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcsIHBsYWNlbWVudCk7XG5cbiAgLy8gQXBwbHkgYHBvc2l0aW9uYCB0byBwb3BwZXIgYmVmb3JlIGFueXRoaW5nIGVsc2UgYmVjYXVzZVxuICAvLyB3aXRob3V0IHRoZSBwb3NpdGlvbiBhcHBsaWVkIHdlIGNhbid0IGd1YXJhbnRlZSBjb3JyZWN0IGNvbXB1dGF0aW9uc1xuICBzZXRTdHlsZXMocG9wcGVyLCB7IHBvc2l0aW9uOiAnYWJzb2x1dGUnIH0pO1xuXG4gIHJldHVybiBvcHRpb25zO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IGB1cGRhdGVgIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBjb21wdXRlU3R5bGUoZGF0YSwgb3B0aW9ucykge1xuICB2YXIgeCA9IG9wdGlvbnMueCxcbiAgICAgIHkgPSBvcHRpb25zLnk7XG4gIHZhciBwb3BwZXIgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuXG4gIC8vIFJlbW92ZSB0aGlzIGxlZ2FjeSBzdXBwb3J0IGluIFBvcHBlci5qcyB2MlxuXG4gIHZhciBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gPSBmaW5kJDEoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGZ1bmN0aW9uIChtb2RpZmllcikge1xuICAgIHJldHVybiBtb2RpZmllci5uYW1lID09PSAnYXBwbHlTdHlsZSc7XG4gIH0pLmdwdUFjY2VsZXJhdGlvbjtcbiAgaWYgKGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiAhPT0gdW5kZWZpbmVkKSB7XG4gICAgY29uc29sZS53YXJuKCdXQVJOSU5HOiBgZ3B1QWNjZWxlcmF0aW9uYCBvcHRpb24gbW92ZWQgdG8gYGNvbXB1dGVTdHlsZWAgbW9kaWZpZXIgYW5kIHdpbGwgbm90IGJlIHN1cHBvcnRlZCBpbiBmdXR1cmUgdmVyc2lvbnMgb2YgUG9wcGVyLmpzIScpO1xuICB9XG4gIHZhciBncHVBY2NlbGVyYXRpb24gPSBsZWdhY3lHcHVBY2NlbGVyYXRpb25PcHRpb24gIT09IHVuZGVmaW5lZCA/IGxlZ2FjeUdwdUFjY2VsZXJhdGlvbk9wdGlvbiA6IG9wdGlvbnMuZ3B1QWNjZWxlcmF0aW9uO1xuXG4gIHZhciBvZmZzZXRQYXJlbnQgPSBnZXRPZmZzZXRQYXJlbnQoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgb2Zmc2V0UGFyZW50UmVjdCA9IGdldEJvdW5kaW5nQ2xpZW50UmVjdChvZmZzZXRQYXJlbnQpO1xuXG4gIC8vIFN0eWxlc1xuICB2YXIgc3R5bGVzID0ge1xuICAgIHBvc2l0aW9uOiBwb3BwZXIucG9zaXRpb25cbiAgfTtcblxuICAvLyBmbG9vciBzaWRlcyB0byBhdm9pZCBibHVycnkgdGV4dFxuICB2YXIgb2Zmc2V0cyA9IHtcbiAgICBsZWZ0OiBNYXRoLmZsb29yKHBvcHBlci5sZWZ0KSxcbiAgICB0b3A6IE1hdGguZmxvb3IocG9wcGVyLnRvcCksXG4gICAgYm90dG9tOiBNYXRoLmZsb29yKHBvcHBlci5ib3R0b20pLFxuICAgIHJpZ2h0OiBNYXRoLmZsb29yKHBvcHBlci5yaWdodClcbiAgfTtcblxuICB2YXIgc2lkZUEgPSB4ID09PSAnYm90dG9tJyA/ICd0b3AnIDogJ2JvdHRvbSc7XG4gIHZhciBzaWRlQiA9IHkgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAncmlnaHQnO1xuXG4gIC8vIGlmIGdwdUFjY2VsZXJhdGlvbiBpcyBzZXQgdG8gYHRydWVgIGFuZCB0cmFuc2Zvcm0gaXMgc3VwcG9ydGVkLFxuICAvLyAgd2UgdXNlIGB0cmFuc2xhdGUzZGAgdG8gYXBwbHkgdGhlIHBvc2l0aW9uIHRvIHRoZSBwb3BwZXIgd2VcbiAgLy8gYXV0b21hdGljYWxseSB1c2UgdGhlIHN1cHBvcnRlZCBwcmVmaXhlZCB2ZXJzaW9uIGlmIG5lZWRlZFxuICB2YXIgcHJlZml4ZWRQcm9wZXJ0eSA9IGdldFN1cHBvcnRlZFByb3BlcnR5TmFtZSgndHJhbnNmb3JtJyk7XG5cbiAgLy8gbm93LCBsZXQncyBtYWtlIGEgc3RlcCBiYWNrIGFuZCBsb29rIGF0IHRoaXMgY29kZSBjbG9zZWx5ICh3dGY/KVxuICAvLyBJZiB0aGUgY29udGVudCBvZiB0aGUgcG9wcGVyIGdyb3dzIG9uY2UgaXQncyBiZWVuIHBvc2l0aW9uZWQsIGl0XG4gIC8vIG1heSBoYXBwZW4gdGhhdCB0aGUgcG9wcGVyIGdldHMgbWlzcGxhY2VkIGJlY2F1c2Ugb2YgdGhlIG5ldyBjb250ZW50XG4gIC8vIG92ZXJmbG93aW5nIGl0cyByZWZlcmVuY2UgZWxlbWVudFxuICAvLyBUbyBhdm9pZCB0aGlzIHByb2JsZW0sIHdlIHByb3ZpZGUgdHdvIG9wdGlvbnMgKHggYW5kIHkpLCB3aGljaCBhbGxvd1xuICAvLyB0aGUgY29uc3VtZXIgdG8gZGVmaW5lIHRoZSBvZmZzZXQgb3JpZ2luLlxuICAvLyBJZiB3ZSBwb3NpdGlvbiBhIHBvcHBlciBvbiB0b3Agb2YgYSByZWZlcmVuY2UgZWxlbWVudCwgd2UgY2FuIHNldFxuICAvLyBgeGAgdG8gYHRvcGAgdG8gbWFrZSB0aGUgcG9wcGVyIGdyb3cgdG93YXJkcyBpdHMgdG9wIGluc3RlYWQgb2ZcbiAgLy8gaXRzIGJvdHRvbS5cbiAgdmFyIGxlZnQgPSB2b2lkIDAsXG4gICAgICB0b3AgPSB2b2lkIDA7XG4gIGlmIChzaWRlQSA9PT0gJ2JvdHRvbScpIHtcbiAgICB0b3AgPSAtb2Zmc2V0UGFyZW50UmVjdC5oZWlnaHQgKyBvZmZzZXRzLmJvdHRvbTtcbiAgfSBlbHNlIHtcbiAgICB0b3AgPSBvZmZzZXRzLnRvcDtcbiAgfVxuICBpZiAoc2lkZUIgPT09ICdyaWdodCcpIHtcbiAgICBsZWZ0ID0gLW9mZnNldFBhcmVudFJlY3Qud2lkdGggKyBvZmZzZXRzLnJpZ2h0O1xuICB9IGVsc2Uge1xuICAgIGxlZnQgPSBvZmZzZXRzLmxlZnQ7XG4gIH1cbiAgaWYgKGdwdUFjY2VsZXJhdGlvbiAmJiBwcmVmaXhlZFByb3BlcnR5KSB7XG4gICAgc3R5bGVzW3ByZWZpeGVkUHJvcGVydHldID0gJ3RyYW5zbGF0ZTNkKCcgKyBsZWZ0ICsgJ3B4LCAnICsgdG9wICsgJ3B4LCAwKSc7XG4gICAgc3R5bGVzW3NpZGVBXSA9IDA7XG4gICAgc3R5bGVzW3NpZGVCXSA9IDA7XG4gICAgc3R5bGVzLndpbGxDaGFuZ2UgPSAndHJhbnNmb3JtJztcbiAgfSBlbHNlIHtcbiAgICAvLyBvdGh3ZXJpc2UsIHdlIHVzZSB0aGUgc3RhbmRhcmQgYHRvcGAsIGBsZWZ0YCwgYGJvdHRvbWAgYW5kIGByaWdodGAgcHJvcGVydGllc1xuICAgIHZhciBpbnZlcnRUb3AgPSBzaWRlQSA9PT0gJ2JvdHRvbScgPyAtMSA6IDE7XG4gICAgdmFyIGludmVydExlZnQgPSBzaWRlQiA9PT0gJ3JpZ2h0JyA/IC0xIDogMTtcbiAgICBzdHlsZXNbc2lkZUFdID0gdG9wICogaW52ZXJ0VG9wO1xuICAgIHN0eWxlc1tzaWRlQl0gPSBsZWZ0ICogaW52ZXJ0TGVmdDtcbiAgICBzdHlsZXMud2lsbENoYW5nZSA9IHNpZGVBICsgJywgJyArIHNpZGVCO1xuICB9XG5cbiAgLy8gQXR0cmlidXRlc1xuICB2YXIgYXR0cmlidXRlcyA9IHtcbiAgICAneC1wbGFjZW1lbnQnOiBkYXRhLnBsYWNlbWVudFxuICB9O1xuXG4gIC8vIFVwZGF0ZSBgZGF0YWAgYXR0cmlidXRlcywgc3R5bGVzIGFuZCBhcnJvd1N0eWxlc1xuICBkYXRhLmF0dHJpYnV0ZXMgPSBfZXh0ZW5kcyh7fSwgYXR0cmlidXRlcywgZGF0YS5hdHRyaWJ1dGVzKTtcbiAgZGF0YS5zdHlsZXMgPSBfZXh0ZW5kcyh7fSwgc3R5bGVzLCBkYXRhLnN0eWxlcyk7XG4gIGRhdGEuYXJyb3dTdHlsZXMgPSBfZXh0ZW5kcyh7fSwgZGF0YS5vZmZzZXRzLmFycm93LCBkYXRhLmFycm93U3R5bGVzKTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdXNlZCB0byBrbm93IGlmIHRoZSBnaXZlbiBtb2RpZmllciBkZXBlbmRzIGZyb20gYW5vdGhlciBvbmUuPGJyIC8+XG4gKiBJdCBjaGVja3MgaWYgdGhlIG5lZWRlZCBtb2RpZmllciBpcyBsaXN0ZWQgYW5kIGVuYWJsZWQuXG4gKiBAbWV0aG9kXG4gKiBAbWVtYmVyb2YgUG9wcGVyLlV0aWxzXG4gKiBAcGFyYW0ge0FycmF5fSBtb2RpZmllcnMgLSBsaXN0IG9mIG1vZGlmaWVyc1xuICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RpbmdOYW1lIC0gbmFtZSBvZiByZXF1ZXN0aW5nIG1vZGlmaWVyXG4gKiBAcGFyYW0ge1N0cmluZ30gcmVxdWVzdGVkTmFtZSAtIG5hbWUgb2YgcmVxdWVzdGVkIG1vZGlmaWVyXG4gKiBAcmV0dXJucyB7Qm9vbGVhbn1cbiAqL1xuZnVuY3Rpb24gaXNNb2RpZmllclJlcXVpcmVkKG1vZGlmaWVycywgcmVxdWVzdGluZ05hbWUsIHJlcXVlc3RlZE5hbWUpIHtcbiAgdmFyIHJlcXVlc3RpbmcgPSBmaW5kJDEobW9kaWZpZXJzLCBmdW5jdGlvbiAoX3JlZikge1xuICAgIHZhciBuYW1lID0gX3JlZi5uYW1lO1xuICAgIHJldHVybiBuYW1lID09PSByZXF1ZXN0aW5nTmFtZTtcbiAgfSk7XG5cbiAgdmFyIGlzUmVxdWlyZWQgPSAhIXJlcXVlc3RpbmcgJiYgbW9kaWZpZXJzLnNvbWUoZnVuY3Rpb24gKG1vZGlmaWVyKSB7XG4gICAgcmV0dXJuIG1vZGlmaWVyLm5hbWUgPT09IHJlcXVlc3RlZE5hbWUgJiYgbW9kaWZpZXIuZW5hYmxlZCAmJiBtb2RpZmllci5vcmRlciA8IHJlcXVlc3Rpbmcub3JkZXI7XG4gIH0pO1xuXG4gIGlmICghaXNSZXF1aXJlZCkge1xuICAgIHZhciBfcmVxdWVzdGluZyA9ICdgJyArIHJlcXVlc3RpbmdOYW1lICsgJ2AnO1xuICAgIHZhciByZXF1ZXN0ZWQgPSAnYCcgKyByZXF1ZXN0ZWROYW1lICsgJ2AnO1xuICAgIGNvbnNvbGUud2FybihyZXF1ZXN0ZWQgKyAnIG1vZGlmaWVyIGlzIHJlcXVpcmVkIGJ5ICcgKyBfcmVxdWVzdGluZyArICcgbW9kaWZpZXIgaW4gb3JkZXIgdG8gd29yaywgYmUgc3VyZSB0byBpbmNsdWRlIGl0IGJlZm9yZSAnICsgX3JlcXVlc3RpbmcgKyAnIScpO1xuICB9XG4gIHJldHVybiBpc1JlcXVpcmVkO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gYXJyb3coZGF0YSwgb3B0aW9ucykge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyRhcnJvdztcblxuICAvLyBhcnJvdyBkZXBlbmRzIG9uIGtlZXBUb2dldGhlciBpbiBvcmRlciB0byB3b3JrXG4gIGlmICghaXNNb2RpZmllclJlcXVpcmVkKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCAnYXJyb3cnLCAna2VlcFRvZ2V0aGVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciBhcnJvd0VsZW1lbnQgPSBvcHRpb25zLmVsZW1lbnQ7XG5cbiAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIGEgc3RyaW5nLCBzdXBwb3NlIGl0J3MgYSBDU1Mgc2VsZWN0b3JcbiAgaWYgKHR5cGVvZiBhcnJvd0VsZW1lbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgYXJyb3dFbGVtZW50ID0gZGF0YS5pbnN0YW5jZS5wb3BwZXIucXVlcnlTZWxlY3RvcihhcnJvd0VsZW1lbnQpO1xuXG4gICAgLy8gaWYgYXJyb3dFbGVtZW50IGlzIG5vdCBmb3VuZCwgZG9uJ3QgcnVuIHRoZSBtb2RpZmllclxuICAgIGlmICghYXJyb3dFbGVtZW50KSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgLy8gaWYgdGhlIGFycm93RWxlbWVudCBpc24ndCBhIHF1ZXJ5IHNlbGVjdG9yIHdlIG11c3QgY2hlY2sgdGhhdCB0aGVcbiAgICAvLyBwcm92aWRlZCBET00gbm9kZSBpcyBjaGlsZCBvZiBpdHMgcG9wcGVyIG5vZGVcbiAgICBpZiAoIWRhdGEuaW5zdGFuY2UucG9wcGVyLmNvbnRhaW5zKGFycm93RWxlbWVudCkpIHtcbiAgICAgIGNvbnNvbGUud2FybignV0FSTklORzogYGFycm93LmVsZW1lbnRgIG11c3QgYmUgY2hpbGQgb2YgaXRzIHBvcHBlciBlbGVtZW50IScpO1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuICB9XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBfZGF0YSRvZmZzZXRzID0gZGF0YS5vZmZzZXRzLFxuICAgICAgcG9wcGVyID0gX2RhdGEkb2Zmc2V0cy5wb3BwZXIsXG4gICAgICByZWZlcmVuY2UgPSBfZGF0YSRvZmZzZXRzLnJlZmVyZW5jZTtcblxuICB2YXIgaXNWZXJ0aWNhbCA9IFsnbGVmdCcsICdyaWdodCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTE7XG5cbiAgdmFyIGxlbiA9IGlzVmVydGljYWwgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gIHZhciBzaWRlQ2FwaXRhbGl6ZWQgPSBpc1ZlcnRpY2FsID8gJ1RvcCcgOiAnTGVmdCc7XG4gIHZhciBzaWRlID0gc2lkZUNhcGl0YWxpemVkLnRvTG93ZXJDYXNlKCk7XG4gIHZhciBhbHRTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdib3R0b20nIDogJ3JpZ2h0JztcbiAgdmFyIGFycm93RWxlbWVudFNpemUgPSBnZXRPdXRlclNpemVzKGFycm93RWxlbWVudClbbGVuXTtcblxuICAvL1xuICAvLyBleHRlbmRzIGtlZXBUb2dldGhlciBiZWhhdmlvciBtYWtpbmcgc3VyZSB0aGUgcG9wcGVyIGFuZCBpdHNcbiAgLy8gcmVmZXJlbmNlIGhhdmUgZW5vdWdoIHBpeGVscyBpbiBjb25qdWN0aW9uXG4gIC8vXG5cbiAgLy8gdG9wL2xlZnQgc2lkZVxuICBpZiAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplIDwgcG9wcGVyW3NpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSAtPSBwb3BwZXJbc2lkZV0gLSAocmVmZXJlbmNlW29wU2lkZV0gLSBhcnJvd0VsZW1lbnRTaXplKTtcbiAgfVxuICAvLyBib3R0b20vcmlnaHQgc2lkZVxuICBpZiAocmVmZXJlbmNlW3NpZGVdICsgYXJyb3dFbGVtZW50U2l6ZSA+IHBvcHBlcltvcFNpZGVdKSB7XG4gICAgZGF0YS5vZmZzZXRzLnBvcHBlcltzaWRlXSArPSByZWZlcmVuY2Vbc2lkZV0gKyBhcnJvd0VsZW1lbnRTaXplIC0gcG9wcGVyW29wU2lkZV07XG4gIH1cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IGdldENsaWVudFJlY3QoZGF0YS5vZmZzZXRzLnBvcHBlcik7XG5cbiAgLy8gY29tcHV0ZSBjZW50ZXIgb2YgdGhlIHBvcHBlclxuICB2YXIgY2VudGVyID0gcmVmZXJlbmNlW3NpZGVdICsgcmVmZXJlbmNlW2xlbl0gLyAyIC0gYXJyb3dFbGVtZW50U2l6ZSAvIDI7XG5cbiAgLy8gQ29tcHV0ZSB0aGUgc2lkZVZhbHVlIHVzaW5nIHRoZSB1cGRhdGVkIHBvcHBlciBvZmZzZXRzXG4gIC8vIHRha2UgcG9wcGVyIG1hcmdpbiBpbiBhY2NvdW50IGJlY2F1c2Ugd2UgZG9uJ3QgaGF2ZSB0aGlzIGluZm8gYXZhaWxhYmxlXG4gIHZhciBjc3MgPSBnZXRTdHlsZUNvbXB1dGVkUHJvcGVydHkoZGF0YS5pbnN0YW5jZS5wb3BwZXIpO1xuICB2YXIgcG9wcGVyTWFyZ2luU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydtYXJnaW4nICsgc2lkZUNhcGl0YWxpemVkXSwgMTApO1xuICB2YXIgcG9wcGVyQm9yZGVyU2lkZSA9IHBhcnNlRmxvYXQoY3NzWydib3JkZXInICsgc2lkZUNhcGl0YWxpemVkICsgJ1dpZHRoJ10sIDEwKTtcbiAgdmFyIHNpZGVWYWx1ZSA9IGNlbnRlciAtIGRhdGEub2Zmc2V0cy5wb3BwZXJbc2lkZV0gLSBwb3BwZXJNYXJnaW5TaWRlIC0gcG9wcGVyQm9yZGVyU2lkZTtcblxuICAvLyBwcmV2ZW50IGFycm93RWxlbWVudCBmcm9tIGJlaW5nIHBsYWNlZCBub3QgY29udGlndW91c2x5IHRvIGl0cyBwb3BwZXJcbiAgc2lkZVZhbHVlID0gTWF0aC5tYXgoTWF0aC5taW4ocG9wcGVyW2xlbl0gLSBhcnJvd0VsZW1lbnRTaXplLCBzaWRlVmFsdWUpLCAwKTtcblxuICBkYXRhLmFycm93RWxlbWVudCA9IGFycm93RWxlbWVudDtcbiAgZGF0YS5vZmZzZXRzLmFycm93ID0gKF9kYXRhJG9mZnNldHMkYXJyb3cgPSB7fSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgc2lkZSwgTWF0aC5yb3VuZChzaWRlVmFsdWUpKSwgZGVmaW5lUHJvcGVydHkoX2RhdGEkb2Zmc2V0cyRhcnJvdywgYWx0U2lkZSwgJycpLCBfZGF0YSRvZmZzZXRzJGFycm93KTtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBHZXQgdGhlIG9wcG9zaXRlIHBsYWNlbWVudCB2YXJpYXRpb24gb2YgdGhlIGdpdmVuIG9uZVxuICogQG1ldGhvZFxuICogQG1lbWJlcm9mIFBvcHBlci5VdGlsc1xuICogQGFyZ3VtZW50IHtTdHJpbmd9IHBsYWNlbWVudCB2YXJpYXRpb25cbiAqIEByZXR1cm5zIHtTdHJpbmd9IGZsaXBwZWQgcGxhY2VtZW50IHZhcmlhdGlvblxuICovXG5mdW5jdGlvbiBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pIHtcbiAgaWYgKHZhcmlhdGlvbiA9PT0gJ2VuZCcpIHtcbiAgICByZXR1cm4gJ3N0YXJ0JztcbiAgfSBlbHNlIGlmICh2YXJpYXRpb24gPT09ICdzdGFydCcpIHtcbiAgICByZXR1cm4gJ2VuZCc7XG4gIH1cbiAgcmV0dXJuIHZhcmlhdGlvbjtcbn1cblxuLyoqXG4gKiBMaXN0IG9mIGFjY2VwdGVkIHBsYWNlbWVudHMgdG8gdXNlIGFzIHZhbHVlcyBvZiB0aGUgYHBsYWNlbWVudGAgb3B0aW9uLjxiciAvPlxuICogVmFsaWQgcGxhY2VtZW50cyBhcmU6XG4gKiAtIGBhdXRvYFxuICogLSBgdG9wYFxuICogLSBgcmlnaHRgXG4gKiAtIGBib3R0b21gXG4gKiAtIGBsZWZ0YFxuICpcbiAqIEVhY2ggcGxhY2VtZW50IGNhbiBoYXZlIGEgdmFyaWF0aW9uIGZyb20gdGhpcyBsaXN0OlxuICogLSBgLXN0YXJ0YFxuICogLSBgLWVuZGBcbiAqXG4gKiBWYXJpYXRpb25zIGFyZSBpbnRlcnByZXRlZCBlYXNpbHkgaWYgeW91IHRoaW5rIG9mIHRoZW0gYXMgdGhlIGxlZnQgdG8gcmlnaHRcbiAqIHdyaXR0ZW4gbGFuZ3VhZ2VzLiBIb3Jpem9udGFsbHkgKGB0b3BgIGFuZCBgYm90dG9tYCksIGBzdGFydGAgaXMgbGVmdCBhbmQgYGVuZGBcbiAqIGlzIHJpZ2h0LjxiciAvPlxuICogVmVydGljYWxseSAoYGxlZnRgIGFuZCBgcmlnaHRgKSwgYHN0YXJ0YCBpcyB0b3AgYW5kIGBlbmRgIGlzIGJvdHRvbS5cbiAqXG4gKiBTb21lIHZhbGlkIGV4YW1wbGVzIGFyZTpcbiAqIC0gYHRvcC1lbmRgIChvbiB0b3Agb2YgcmVmZXJlbmNlLCByaWdodCBhbGlnbmVkKVxuICogLSBgcmlnaHQtc3RhcnRgIChvbiByaWdodCBvZiByZWZlcmVuY2UsIHRvcCBhbGlnbmVkKVxuICogLSBgYm90dG9tYCAob24gYm90dG9tLCBjZW50ZXJlZClcbiAqIC0gYGF1dG8tcmlnaHRgIChvbiB0aGUgc2lkZSB3aXRoIG1vcmUgc3BhY2UgYXZhaWxhYmxlLCBhbGlnbm1lbnQgZGVwZW5kcyBieSBwbGFjZW1lbnQpXG4gKlxuICogQHN0YXRpY1xuICogQHR5cGUge0FycmF5fVxuICogQGVudW0ge1N0cmluZ31cbiAqIEByZWFkb25seVxuICogQG1ldGhvZCBwbGFjZW1lbnRzXG4gKiBAbWVtYmVyb2YgUG9wcGVyXG4gKi9cbnZhciBwbGFjZW1lbnRzID0gWydhdXRvLXN0YXJ0JywgJ2F1dG8nLCAnYXV0by1lbmQnLCAndG9wLXN0YXJ0JywgJ3RvcCcsICd0b3AtZW5kJywgJ3JpZ2h0LXN0YXJ0JywgJ3JpZ2h0JywgJ3JpZ2h0LWVuZCcsICdib3R0b20tZW5kJywgJ2JvdHRvbScsICdib3R0b20tc3RhcnQnLCAnbGVmdC1lbmQnLCAnbGVmdCcsICdsZWZ0LXN0YXJ0J107XG5cbi8vIEdldCByaWQgb2YgYGF1dG9gIGBhdXRvLXN0YXJ0YCBhbmQgYGF1dG8tZW5kYFxudmFyIHZhbGlkUGxhY2VtZW50cyA9IHBsYWNlbWVudHMuc2xpY2UoMyk7XG5cbi8qKlxuICogR2l2ZW4gYW4gaW5pdGlhbCBwbGFjZW1lbnQsIHJldHVybnMgYWxsIHRoZSBzdWJzZXF1ZW50IHBsYWNlbWVudHNcbiAqIGNsb2Nrd2lzZSAob3IgY291bnRlci1jbG9ja3dpc2UpLlxuICpcbiAqIEBtZXRob2RcbiAqIEBtZW1iZXJvZiBQb3BwZXIuVXRpbHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBwbGFjZW1lbnQgLSBBIHZhbGlkIHBsYWNlbWVudCAoaXQgYWNjZXB0cyB2YXJpYXRpb25zKVxuICogQGFyZ3VtZW50IHtCb29sZWFufSBjb3VudGVyIC0gU2V0IHRvIHRydWUgdG8gd2FsayB0aGUgcGxhY2VtZW50cyBjb3VudGVyY2xvY2t3aXNlXG4gKiBAcmV0dXJucyB7QXJyYXl9IHBsYWNlbWVudHMgaW5jbHVkaW5nIHRoZWlyIHZhcmlhdGlvbnNcbiAqL1xuZnVuY3Rpb24gY2xvY2t3aXNlKHBsYWNlbWVudCkge1xuICB2YXIgY291bnRlciA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogZmFsc2U7XG5cbiAgdmFyIGluZGV4ID0gdmFsaWRQbGFjZW1lbnRzLmluZGV4T2YocGxhY2VtZW50KTtcbiAgdmFyIGFyciA9IHZhbGlkUGxhY2VtZW50cy5zbGljZShpbmRleCArIDEpLmNvbmNhdCh2YWxpZFBsYWNlbWVudHMuc2xpY2UoMCwgaW5kZXgpKTtcbiAgcmV0dXJuIGNvdW50ZXIgPyBhcnIucmV2ZXJzZSgpIDogYXJyO1xufVxuXG52YXIgQkVIQVZJT1JTID0ge1xuICBGTElQOiAnZmxpcCcsXG4gIENMT0NLV0lTRTogJ2Nsb2Nrd2lzZScsXG4gIENPVU5URVJDTE9DS1dJU0U6ICdjb3VudGVyY2xvY2t3aXNlJ1xufTtcblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGZsaXAoZGF0YSwgb3B0aW9ucykge1xuICAvLyBpZiBgaW5uZXJgIG1vZGlmaWVyIGlzIGVuYWJsZWQsIHdlIGNhbid0IHVzZSB0aGUgYGZsaXBgIG1vZGlmaWVyXG4gIGlmIChpc01vZGlmaWVyRW5hYmxlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2lubmVyJykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIGlmIChkYXRhLmZsaXBwZWQgJiYgZGF0YS5wbGFjZW1lbnQgPT09IGRhdGEub3JpZ2luYWxQbGFjZW1lbnQpIHtcbiAgICAvLyBzZWVtcyBsaWtlIGZsaXAgaXMgdHJ5aW5nIHRvIGxvb3AsIHByb2JhYmx5IHRoZXJlJ3Mgbm90IGVub3VnaCBzcGFjZSBvbiBhbnkgb2YgdGhlIGZsaXBwYWJsZSBzaWRlc1xuICAgIHJldHVybiBkYXRhO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBvcHRpb25zLmJvdW5kYXJpZXNFbGVtZW50KTtcblxuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcbiAgdmFyIHBsYWNlbWVudE9wcG9zaXRlID0gZ2V0T3Bwb3NpdGVQbGFjZW1lbnQocGxhY2VtZW50KTtcbiAgdmFyIHZhcmlhdGlvbiA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMV0gfHwgJyc7XG5cbiAgdmFyIGZsaXBPcmRlciA9IFtdO1xuXG4gIHN3aXRjaCAob3B0aW9ucy5iZWhhdmlvcikge1xuICAgIGNhc2UgQkVIQVZJT1JTLkZMSVA6XG4gICAgICBmbGlwT3JkZXIgPSBbcGxhY2VtZW50LCBwbGFjZW1lbnRPcHBvc2l0ZV07XG4gICAgICBicmVhaztcbiAgICBjYXNlIEJFSEFWSU9SUy5DTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgQkVIQVZJT1JTLkNPVU5URVJDTE9DS1dJU0U6XG4gICAgICBmbGlwT3JkZXIgPSBjbG9ja3dpc2UocGxhY2VtZW50LCB0cnVlKTtcbiAgICAgIGJyZWFrO1xuICAgIGRlZmF1bHQ6XG4gICAgICBmbGlwT3JkZXIgPSBvcHRpb25zLmJlaGF2aW9yO1xuICB9XG5cbiAgZmxpcE9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHN0ZXAsIGluZGV4KSB7XG4gICAgaWYgKHBsYWNlbWVudCAhPT0gc3RlcCB8fCBmbGlwT3JkZXIubGVuZ3RoID09PSBpbmRleCArIDEpIHtcbiAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cblxuICAgIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gICAgcGxhY2VtZW50T3Bwb3NpdGUgPSBnZXRPcHBvc2l0ZVBsYWNlbWVudChwbGFjZW1lbnQpO1xuXG4gICAgdmFyIHBvcHBlck9mZnNldHMgPSBkYXRhLm9mZnNldHMucG9wcGVyO1xuICAgIHZhciByZWZPZmZzZXRzID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcblxuICAgIC8vIHVzaW5nIGZsb29yIGJlY2F1c2UgdGhlIHJlZmVyZW5jZSBvZmZzZXRzIG1heSBjb250YWluIGRlY2ltYWxzIHdlIGFyZSBub3QgZ29pbmcgdG8gY29uc2lkZXIgaGVyZVxuICAgIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gICAgdmFyIG92ZXJsYXBzUmVmID0gcGxhY2VtZW50ID09PSAnbGVmdCcgJiYgZmxvb3IocG9wcGVyT2Zmc2V0cy5yaWdodCkgPiBmbG9vcihyZWZPZmZzZXRzLmxlZnQpIHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmxlZnQpIDwgZmxvb3IocmVmT2Zmc2V0cy5yaWdodCkgfHwgcGxhY2VtZW50ID09PSAndG9wJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLmJvdHRvbSkgPiBmbG9vcihyZWZPZmZzZXRzLnRvcCkgfHwgcGxhY2VtZW50ID09PSAnYm90dG9tJyAmJiBmbG9vcihwb3BwZXJPZmZzZXRzLnRvcCkgPCBmbG9vcihyZWZPZmZzZXRzLmJvdHRvbSk7XG5cbiAgICB2YXIgb3ZlcmZsb3dzTGVmdCA9IGZsb29yKHBvcHBlck9mZnNldHMubGVmdCkgPCBmbG9vcihib3VuZGFyaWVzLmxlZnQpO1xuICAgIHZhciBvdmVyZmxvd3NSaWdodCA9IGZsb29yKHBvcHBlck9mZnNldHMucmlnaHQpID4gZmxvb3IoYm91bmRhcmllcy5yaWdodCk7XG4gICAgdmFyIG92ZXJmbG93c1RvcCA9IGZsb29yKHBvcHBlck9mZnNldHMudG9wKSA8IGZsb29yKGJvdW5kYXJpZXMudG9wKTtcbiAgICB2YXIgb3ZlcmZsb3dzQm90dG9tID0gZmxvb3IocG9wcGVyT2Zmc2V0cy5ib3R0b20pID4gZmxvb3IoYm91bmRhcmllcy5ib3R0b20pO1xuXG4gICAgdmFyIG92ZXJmbG93c0JvdW5kYXJpZXMgPSBwbGFjZW1lbnQgPT09ICdsZWZ0JyAmJiBvdmVyZmxvd3NMZWZ0IHx8IHBsYWNlbWVudCA9PT0gJ3JpZ2h0JyAmJiBvdmVyZmxvd3NSaWdodCB8fCBwbGFjZW1lbnQgPT09ICd0b3AnICYmIG92ZXJmbG93c1RvcCB8fCBwbGFjZW1lbnQgPT09ICdib3R0b20nICYmIG92ZXJmbG93c0JvdHRvbTtcblxuICAgIC8vIGZsaXAgdGhlIHZhcmlhdGlvbiBpZiByZXF1aXJlZFxuICAgIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgZmxpcHBlZFZhcmlhdGlvbiA9ICEhb3B0aW9ucy5mbGlwVmFyaWF0aW9ucyAmJiAoaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdzdGFydCcgJiYgb3ZlcmZsb3dzTGVmdCB8fCBpc1ZlcnRpY2FsICYmIHZhcmlhdGlvbiA9PT0gJ2VuZCcgJiYgb3ZlcmZsb3dzUmlnaHQgfHwgIWlzVmVydGljYWwgJiYgdmFyaWF0aW9uID09PSAnc3RhcnQnICYmIG92ZXJmbG93c1RvcCB8fCAhaXNWZXJ0aWNhbCAmJiB2YXJpYXRpb24gPT09ICdlbmQnICYmIG92ZXJmbG93c0JvdHRvbSk7XG5cbiAgICBpZiAob3ZlcmxhcHNSZWYgfHwgb3ZlcmZsb3dzQm91bmRhcmllcyB8fCBmbGlwcGVkVmFyaWF0aW9uKSB7XG4gICAgICAvLyB0aGlzIGJvb2xlYW4gdG8gZGV0ZWN0IGFueSBmbGlwIGxvb3BcbiAgICAgIGRhdGEuZmxpcHBlZCA9IHRydWU7XG5cbiAgICAgIGlmIChvdmVybGFwc1JlZiB8fCBvdmVyZmxvd3NCb3VuZGFyaWVzKSB7XG4gICAgICAgIHBsYWNlbWVudCA9IGZsaXBPcmRlcltpbmRleCArIDFdO1xuICAgICAgfVxuXG4gICAgICBpZiAoZmxpcHBlZFZhcmlhdGlvbikge1xuICAgICAgICB2YXJpYXRpb24gPSBnZXRPcHBvc2l0ZVZhcmlhdGlvbih2YXJpYXRpb24pO1xuICAgICAgfVxuXG4gICAgICBkYXRhLnBsYWNlbWVudCA9IHBsYWNlbWVudCArICh2YXJpYXRpb24gPyAnLScgKyB2YXJpYXRpb24gOiAnJyk7XG5cbiAgICAgIC8vIHRoaXMgb2JqZWN0IGNvbnRhaW5zIGBwb3NpdGlvbmAsIHdlIHdhbnQgdG8gcHJlc2VydmUgaXQgYWxvbmcgd2l0aFxuICAgICAgLy8gYW55IGFkZGl0aW9uYWwgcHJvcGVydHkgd2UgbWF5IGFkZCBpbiB0aGUgZnV0dXJlXG4gICAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIGRhdGEub2Zmc2V0cy5wb3BwZXIsIGdldFBvcHBlck9mZnNldHMoZGF0YS5pbnN0YW5jZS5wb3BwZXIsIGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UsIGRhdGEucGxhY2VtZW50KSk7XG5cbiAgICAgIGRhdGEgPSBydW5Nb2RpZmllcnMoZGF0YS5pbnN0YW5jZS5tb2RpZmllcnMsIGRhdGEsICdmbGlwJyk7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgdXBkYXRlIG1ldGhvZFxuICogQGFyZ3VtZW50IHtPYmplY3R9IG9wdGlvbnMgLSBNb2RpZmllcnMgY29uZmlndXJhdGlvbiBhbmQgb3B0aW9uc1xuICogQHJldHVybnMge09iamVjdH0gVGhlIGRhdGEgb2JqZWN0LCBwcm9wZXJseSBtb2RpZmllZFxuICovXG5mdW5jdGlvbiBrZWVwVG9nZXRoZXIoZGF0YSkge1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBmbG9vciA9IE1hdGguZmxvb3I7XG4gIHZhciBpc1ZlcnRpY2FsID0gWyd0b3AnLCAnYm90dG9tJ10uaW5kZXhPZihwbGFjZW1lbnQpICE9PSAtMTtcbiAgdmFyIHNpZGUgPSBpc1ZlcnRpY2FsID8gJ3JpZ2h0JyA6ICdib3R0b20nO1xuICB2YXIgb3BTaWRlID0gaXNWZXJ0aWNhbCA/ICdsZWZ0JyA6ICd0b3AnO1xuICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gIGlmIChwb3BwZXJbc2lkZV0gPCBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbb3BTaWRlXSkgLSBwb3BwZXJbbWVhc3VyZW1lbnRdO1xuICB9XG4gIGlmIChwb3BwZXJbb3BTaWRlXSA+IGZsb29yKHJlZmVyZW5jZVtzaWRlXSkpIHtcbiAgICBkYXRhLm9mZnNldHMucG9wcGVyW29wU2lkZV0gPSBmbG9vcihyZWZlcmVuY2Vbc2lkZV0pO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQ29udmVydHMgYSBzdHJpbmcgY29udGFpbmluZyB2YWx1ZSArIHVuaXQgaW50byBhIHB4IHZhbHVlIG51bWJlclxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2Yge21vZGlmaWVyc35vZmZzZXR9XG4gKiBAcHJpdmF0ZVxuICogQGFyZ3VtZW50IHtTdHJpbmd9IHN0ciAtIFZhbHVlICsgdW5pdCBzdHJpbmdcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBtZWFzdXJlbWVudCAtIGBoZWlnaHRgIG9yIGB3aWR0aGBcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBwb3BwZXJPZmZzZXRzXG4gKiBAYXJndW1lbnQge09iamVjdH0gcmVmZXJlbmNlT2Zmc2V0c1xuICogQHJldHVybnMge051bWJlcnxTdHJpbmd9XG4gKiBWYWx1ZSBpbiBwaXhlbHMsIG9yIG9yaWdpbmFsIHN0cmluZyBpZiBubyB2YWx1ZXMgd2VyZSBleHRyYWN0ZWRcbiAqL1xuZnVuY3Rpb24gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKSB7XG4gIC8vIHNlcGFyYXRlIHZhbHVlIGZyb20gdW5pdFxuICB2YXIgc3BsaXQgPSBzdHIubWF0Y2goLygoPzpcXC18XFwrKT9cXGQqXFwuP1xcZCopKC4qKS8pO1xuICB2YXIgdmFsdWUgPSArc3BsaXRbMV07XG4gIHZhciB1bml0ID0gc3BsaXRbMl07XG5cbiAgLy8gSWYgaXQncyBub3QgYSBudW1iZXIgaXQncyBhbiBvcGVyYXRvciwgSSBndWVzc1xuICBpZiAoIXZhbHVlKSB7XG4gICAgcmV0dXJuIHN0cjtcbiAgfVxuXG4gIGlmICh1bml0LmluZGV4T2YoJyUnKSA9PT0gMCkge1xuICAgIHZhciBlbGVtZW50ID0gdm9pZCAwO1xuICAgIHN3aXRjaCAodW5pdCkge1xuICAgICAgY2FzZSAnJXAnOlxuICAgICAgICBlbGVtZW50ID0gcG9wcGVyT2Zmc2V0cztcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICclJzpcbiAgICAgIGNhc2UgJyVyJzpcbiAgICAgIGRlZmF1bHQ6XG4gICAgICAgIGVsZW1lbnQgPSByZWZlcmVuY2VPZmZzZXRzO1xuICAgIH1cblxuICAgIHZhciByZWN0ID0gZ2V0Q2xpZW50UmVjdChlbGVtZW50KTtcbiAgICByZXR1cm4gcmVjdFttZWFzdXJlbWVudF0gLyAxMDAgKiB2YWx1ZTtcbiAgfSBlbHNlIGlmICh1bml0ID09PSAndmgnIHx8IHVuaXQgPT09ICd2dycpIHtcbiAgICAvLyBpZiBpcyBhIHZoIG9yIHZ3LCB3ZSBjYWxjdWxhdGUgdGhlIHNpemUgYmFzZWQgb24gdGhlIHZpZXdwb3J0XG4gICAgdmFyIHNpemUgPSB2b2lkIDA7XG4gICAgaWYgKHVuaXQgPT09ICd2aCcpIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50SGVpZ2h0LCB3aW5kb3cuaW5uZXJIZWlnaHQgfHwgMCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHNpemUgPSBNYXRoLm1heChkb2N1bWVudC5kb2N1bWVudEVsZW1lbnQuY2xpZW50V2lkdGgsIHdpbmRvdy5pbm5lcldpZHRoIHx8IDApO1xuICAgIH1cbiAgICByZXR1cm4gc2l6ZSAvIDEwMCAqIHZhbHVlO1xuICB9IGVsc2Uge1xuICAgIC8vIGlmIGlzIGFuIGV4cGxpY2l0IHBpeGVsIHVuaXQsIHdlIGdldCByaWQgb2YgdGhlIHVuaXQgYW5kIGtlZXAgdGhlIHZhbHVlXG4gICAgLy8gaWYgaXMgYW4gaW1wbGljaXQgdW5pdCwgaXQncyBweCwgYW5kIHdlIHJldHVybiBqdXN0IHRoZSB2YWx1ZVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxufVxuXG4vKipcbiAqIFBhcnNlIGFuIGBvZmZzZXRgIHN0cmluZyB0byBleHRyYXBvbGF0ZSBgeGAgYW5kIGB5YCBudW1lcmljIG9mZnNldHMuXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiB7bW9kaWZpZXJzfm9mZnNldH1cbiAqIEBwcml2YXRlXG4gKiBAYXJndW1lbnQge1N0cmluZ30gb2Zmc2V0XG4gKiBAYXJndW1lbnQge09iamVjdH0gcG9wcGVyT2Zmc2V0c1xuICogQGFyZ3VtZW50IHtPYmplY3R9IHJlZmVyZW5jZU9mZnNldHNcbiAqIEBhcmd1bWVudCB7U3RyaW5nfSBiYXNlUGxhY2VtZW50XG4gKiBAcmV0dXJucyB7QXJyYXl9IGEgdHdvIGNlbGxzIGFycmF5IHdpdGggeCBhbmQgeSBvZmZzZXRzIGluIG51bWJlcnNcbiAqL1xuZnVuY3Rpb24gcGFyc2VPZmZzZXQob2Zmc2V0LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzLCBiYXNlUGxhY2VtZW50KSB7XG4gIHZhciBvZmZzZXRzID0gWzAsIDBdO1xuXG4gIC8vIFVzZSBoZWlnaHQgaWYgcGxhY2VtZW50IGlzIGxlZnQgb3IgcmlnaHQgYW5kIGluZGV4IGlzIDAgb3RoZXJ3aXNlIHVzZSB3aWR0aFxuICAvLyBpbiB0aGlzIHdheSB0aGUgZmlyc3Qgb2Zmc2V0IHdpbGwgdXNlIGFuIGF4aXMgYW5kIHRoZSBzZWNvbmQgb25lXG4gIC8vIHdpbGwgdXNlIHRoZSBvdGhlciBvbmVcbiAgdmFyIHVzZUhlaWdodCA9IFsncmlnaHQnLCAnbGVmdCddLmluZGV4T2YoYmFzZVBsYWNlbWVudCkgIT09IC0xO1xuXG4gIC8vIFNwbGl0IHRoZSBvZmZzZXQgc3RyaW5nIHRvIG9idGFpbiBhIGxpc3Qgb2YgdmFsdWVzIGFuZCBvcGVyYW5kc1xuICAvLyBUaGUgcmVnZXggYWRkcmVzc2VzIHZhbHVlcyB3aXRoIHRoZSBwbHVzIG9yIG1pbnVzIHNpZ24gaW4gZnJvbnQgKCsxMCwgLTIwLCBldGMpXG4gIHZhciBmcmFnbWVudHMgPSBvZmZzZXQuc3BsaXQoLyhcXCt8XFwtKS8pLm1hcChmdW5jdGlvbiAoZnJhZykge1xuICAgIHJldHVybiBmcmFnLnRyaW0oKTtcbiAgfSk7XG5cbiAgLy8gRGV0ZWN0IGlmIHRoZSBvZmZzZXQgc3RyaW5nIGNvbnRhaW5zIGEgcGFpciBvZiB2YWx1ZXMgb3IgYSBzaW5nbGUgb25lXG4gIC8vIHRoZXkgY291bGQgYmUgc2VwYXJhdGVkIGJ5IGNvbW1hIG9yIHNwYWNlXG4gIHZhciBkaXZpZGVyID0gZnJhZ21lbnRzLmluZGV4T2YoZmluZCQxKGZyYWdtZW50cywgZnVuY3Rpb24gKGZyYWcpIHtcbiAgICByZXR1cm4gZnJhZy5zZWFyY2goLyx8XFxzLykgIT09IC0xO1xuICB9KSk7XG5cbiAgaWYgKGZyYWdtZW50c1tkaXZpZGVyXSAmJiBmcmFnbWVudHNbZGl2aWRlcl0uaW5kZXhPZignLCcpID09PSAtMSkge1xuICAgIGNvbnNvbGUud2FybignT2Zmc2V0cyBzZXBhcmF0ZWQgYnkgd2hpdGUgc3BhY2UocykgYXJlIGRlcHJlY2F0ZWQsIHVzZSBhIGNvbW1hICgsKSBpbnN0ZWFkLicpO1xuICB9XG5cbiAgLy8gSWYgZGl2aWRlciBpcyBmb3VuZCwgd2UgZGl2aWRlIHRoZSBsaXN0IG9mIHZhbHVlcyBhbmQgb3BlcmFuZHMgdG8gZGl2aWRlXG4gIC8vIHRoZW0gYnkgb2ZzZXQgWCBhbmQgWS5cbiAgdmFyIHNwbGl0UmVnZXggPSAvXFxzKixcXHMqfFxccysvO1xuICB2YXIgb3BzID0gZGl2aWRlciAhPT0gLTEgPyBbZnJhZ21lbnRzLnNsaWNlKDAsIGRpdmlkZXIpLmNvbmNhdChbZnJhZ21lbnRzW2RpdmlkZXJdLnNwbGl0KHNwbGl0UmVnZXgpWzBdXSksIFtmcmFnbWVudHNbZGl2aWRlcl0uc3BsaXQoc3BsaXRSZWdleClbMV1dLmNvbmNhdChmcmFnbWVudHMuc2xpY2UoZGl2aWRlciArIDEpKV0gOiBbZnJhZ21lbnRzXTtcblxuICAvLyBDb252ZXJ0IHRoZSB2YWx1ZXMgd2l0aCB1bml0cyB0byBhYnNvbHV0ZSBwaXhlbHMgdG8gYWxsb3cgb3VyIGNvbXB1dGF0aW9uc1xuICBvcHMgPSBvcHMubWFwKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICAvLyBNb3N0IG9mIHRoZSB1bml0cyByZWx5IG9uIHRoZSBvcmllbnRhdGlvbiBvZiB0aGUgcG9wcGVyXG4gICAgdmFyIG1lYXN1cmVtZW50ID0gKGluZGV4ID09PSAxID8gIXVzZUhlaWdodCA6IHVzZUhlaWdodCkgPyAnaGVpZ2h0JyA6ICd3aWR0aCc7XG4gICAgdmFyIG1lcmdlV2l0aFByZXZpb3VzID0gZmFsc2U7XG4gICAgcmV0dXJuIG9wXG4gICAgLy8gVGhpcyBhZ2dyZWdhdGVzIGFueSBgK2Agb3IgYC1gIHNpZ24gdGhhdCBhcmVuJ3QgY29uc2lkZXJlZCBvcGVyYXRvcnNcbiAgICAvLyBlLmcuOiAxMCArICs1ID0+IFsxMCwgKywgKzVdXG4gICAgLnJlZHVjZShmdW5jdGlvbiAoYSwgYikge1xuICAgICAgaWYgKGFbYS5sZW5ndGggLSAxXSA9PT0gJycgJiYgWycrJywgJy0nXS5pbmRleE9mKGIpICE9PSAtMSkge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gPSBiO1xuICAgICAgICBtZXJnZVdpdGhQcmV2aW91cyA9IHRydWU7XG4gICAgICAgIHJldHVybiBhO1xuICAgICAgfSBlbHNlIGlmIChtZXJnZVdpdGhQcmV2aW91cykge1xuICAgICAgICBhW2EubGVuZ3RoIC0gMV0gKz0gYjtcbiAgICAgICAgbWVyZ2VXaXRoUHJldmlvdXMgPSBmYWxzZTtcbiAgICAgICAgcmV0dXJuIGE7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gYS5jb25jYXQoYik7XG4gICAgICB9XG4gICAgfSwgW10pXG4gICAgLy8gSGVyZSB3ZSBjb252ZXJ0IHRoZSBzdHJpbmcgdmFsdWVzIGludG8gbnVtYmVyIHZhbHVlcyAoaW4gcHgpXG4gICAgLm1hcChmdW5jdGlvbiAoc3RyKSB7XG4gICAgICByZXR1cm4gdG9WYWx1ZShzdHIsIG1lYXN1cmVtZW50LCBwb3BwZXJPZmZzZXRzLCByZWZlcmVuY2VPZmZzZXRzKTtcbiAgICB9KTtcbiAgfSk7XG5cbiAgLy8gTG9vcCB0cm91Z2ggdGhlIG9mZnNldHMgYXJyYXlzIGFuZCBleGVjdXRlIHRoZSBvcGVyYXRpb25zXG4gIG9wcy5mb3JFYWNoKGZ1bmN0aW9uIChvcCwgaW5kZXgpIHtcbiAgICBvcC5mb3JFYWNoKGZ1bmN0aW9uIChmcmFnLCBpbmRleDIpIHtcbiAgICAgIGlmIChpc051bWVyaWMoZnJhZykpIHtcbiAgICAgICAgb2Zmc2V0c1tpbmRleF0gKz0gZnJhZyAqIChvcFtpbmRleDIgLSAxXSA9PT0gJy0nID8gLTEgOiAxKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfSk7XG4gIHJldHVybiBvZmZzZXRzO1xufVxuXG4vKipcbiAqIEBmdW5jdGlvblxuICogQG1lbWJlcm9mIE1vZGlmaWVyc1xuICogQGFyZ3VtZW50IHtPYmplY3R9IGRhdGEgLSBUaGUgZGF0YSBvYmplY3QgZ2VuZXJhdGVkIGJ5IHVwZGF0ZSBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEBhcmd1bWVudCB7TnVtYmVyfFN0cmluZ30gb3B0aW9ucy5vZmZzZXQ9MFxuICogVGhlIG9mZnNldCB2YWx1ZSBhcyBkZXNjcmliZWQgaW4gdGhlIG1vZGlmaWVyIGRlc2NyaXB0aW9uXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIG9mZnNldChkYXRhLCBfcmVmKSB7XG4gIHZhciBvZmZzZXQgPSBfcmVmLm9mZnNldDtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50LFxuICAgICAgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGJhc2VQbGFjZW1lbnQgPSBwbGFjZW1lbnQuc3BsaXQoJy0nKVswXTtcblxuICB2YXIgb2Zmc2V0cyA9IHZvaWQgMDtcbiAgaWYgKGlzTnVtZXJpYygrb2Zmc2V0KSkge1xuICAgIG9mZnNldHMgPSBbK29mZnNldCwgMF07XG4gIH0gZWxzZSB7XG4gICAgb2Zmc2V0cyA9IHBhcnNlT2Zmc2V0KG9mZnNldCwgcG9wcGVyLCByZWZlcmVuY2UsIGJhc2VQbGFjZW1lbnQpO1xuICB9XG5cbiAgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdsZWZ0Jykge1xuICAgIHBvcHBlci50b3AgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIubGVmdCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdyaWdodCcpIHtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1sxXTtcbiAgfSBlbHNlIGlmIChiYXNlUGxhY2VtZW50ID09PSAndG9wJykge1xuICAgIHBvcHBlci5sZWZ0ICs9IG9mZnNldHNbMF07XG4gICAgcG9wcGVyLnRvcCAtPSBvZmZzZXRzWzFdO1xuICB9IGVsc2UgaWYgKGJhc2VQbGFjZW1lbnQgPT09ICdib3R0b20nKSB7XG4gICAgcG9wcGVyLmxlZnQgKz0gb2Zmc2V0c1swXTtcbiAgICBwb3BwZXIudG9wICs9IG9mZnNldHNbMV07XG4gIH1cblxuICBkYXRhLnBvcHBlciA9IHBvcHBlcjtcbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIHByZXZlbnRPdmVyZmxvdyhkYXRhLCBvcHRpb25zKSB7XG4gIHZhciBib3VuZGFyaWVzRWxlbWVudCA9IG9wdGlvbnMuYm91bmRhcmllc0VsZW1lbnQgfHwgZ2V0T2Zmc2V0UGFyZW50KGRhdGEuaW5zdGFuY2UucG9wcGVyKTtcblxuICAvLyBJZiBvZmZzZXRQYXJlbnQgaXMgdGhlIHJlZmVyZW5jZSBlbGVtZW50LCB3ZSByZWFsbHkgd2FudCB0b1xuICAvLyBnbyBvbmUgc3RlcCB1cCBhbmQgdXNlIHRoZSBuZXh0IG9mZnNldFBhcmVudCBhcyByZWZlcmVuY2UgdG9cbiAgLy8gYXZvaWQgdG8gbWFrZSB0aGlzIG1vZGlmaWVyIGNvbXBsZXRlbHkgdXNlbGVzcyBhbmQgbG9vayBsaWtlIGJyb2tlblxuICBpZiAoZGF0YS5pbnN0YW5jZS5yZWZlcmVuY2UgPT09IGJvdW5kYXJpZXNFbGVtZW50KSB7XG4gICAgYm91bmRhcmllc0VsZW1lbnQgPSBnZXRPZmZzZXRQYXJlbnQoYm91bmRhcmllc0VsZW1lbnQpO1xuICB9XG5cbiAgdmFyIGJvdW5kYXJpZXMgPSBnZXRCb3VuZGFyaWVzKGRhdGEuaW5zdGFuY2UucG9wcGVyLCBkYXRhLmluc3RhbmNlLnJlZmVyZW5jZSwgb3B0aW9ucy5wYWRkaW5nLCBib3VuZGFyaWVzRWxlbWVudCk7XG4gIG9wdGlvbnMuYm91bmRhcmllcyA9IGJvdW5kYXJpZXM7XG5cbiAgdmFyIG9yZGVyID0gb3B0aW9ucy5wcmlvcml0eTtcbiAgdmFyIHBvcHBlciA9IGRhdGEub2Zmc2V0cy5wb3BwZXI7XG5cbiAgdmFyIGNoZWNrID0ge1xuICAgIHByaW1hcnk6IGZ1bmN0aW9uIHByaW1hcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgdmFsdWUgPSBwb3BwZXJbcGxhY2VtZW50XTtcbiAgICAgIGlmIChwb3BwZXJbcGxhY2VtZW50XSA8IGJvdW5kYXJpZXNbcGxhY2VtZW50XSAmJiAhb3B0aW9ucy5lc2NhcGVXaXRoUmVmZXJlbmNlKSB7XG4gICAgICAgIHZhbHVlID0gTWF0aC5tYXgocG9wcGVyW3BsYWNlbWVudF0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIHBsYWNlbWVudCwgdmFsdWUpO1xuICAgIH0sXG4gICAgc2Vjb25kYXJ5OiBmdW5jdGlvbiBzZWNvbmRhcnkocGxhY2VtZW50KSB7XG4gICAgICB2YXIgbWFpblNpZGUgPSBwbGFjZW1lbnQgPT09ICdyaWdodCcgPyAnbGVmdCcgOiAndG9wJztcbiAgICAgIHZhciB2YWx1ZSA9IHBvcHBlclttYWluU2lkZV07XG4gICAgICBpZiAocG9wcGVyW3BsYWNlbWVudF0gPiBib3VuZGFyaWVzW3BsYWNlbWVudF0gJiYgIW9wdGlvbnMuZXNjYXBlV2l0aFJlZmVyZW5jZSkge1xuICAgICAgICB2YWx1ZSA9IE1hdGgubWluKHBvcHBlclttYWluU2lkZV0sIGJvdW5kYXJpZXNbcGxhY2VtZW50XSAtIChwbGFjZW1lbnQgPT09ICdyaWdodCcgPyBwb3BwZXIud2lkdGggOiBwb3BwZXIuaGVpZ2h0KSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gZGVmaW5lUHJvcGVydHkoe30sIG1haW5TaWRlLCB2YWx1ZSk7XG4gICAgfVxuICB9O1xuXG4gIG9yZGVyLmZvckVhY2goZnVuY3Rpb24gKHBsYWNlbWVudCkge1xuICAgIHZhciBzaWRlID0gWydsZWZ0JywgJ3RvcCddLmluZGV4T2YocGxhY2VtZW50KSAhPT0gLTEgPyAncHJpbWFyeScgOiAnc2Vjb25kYXJ5JztcbiAgICBwb3BwZXIgPSBfZXh0ZW5kcyh7fSwgcG9wcGVyLCBjaGVja1tzaWRlXShwbGFjZW1lbnQpKTtcbiAgfSk7XG5cbiAgZGF0YS5vZmZzZXRzLnBvcHBlciA9IHBvcHBlcjtcblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtPYmplY3R9IFRoZSBkYXRhIG9iamVjdCwgcHJvcGVybHkgbW9kaWZpZWRcbiAqL1xuZnVuY3Rpb24gc2hpZnQoZGF0YSkge1xuICB2YXIgcGxhY2VtZW50ID0gZGF0YS5wbGFjZW1lbnQ7XG4gIHZhciBiYXNlUGxhY2VtZW50ID0gcGxhY2VtZW50LnNwbGl0KCctJylbMF07XG4gIHZhciBzaGlmdHZhcmlhdGlvbiA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzFdO1xuXG4gIC8vIGlmIHNoaWZ0IHNoaWZ0dmFyaWF0aW9uIGlzIHNwZWNpZmllZCwgcnVuIHRoZSBtb2RpZmllclxuICBpZiAoc2hpZnR2YXJpYXRpb24pIHtcbiAgICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2UsXG4gICAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyO1xuXG4gICAgdmFyIGlzVmVydGljYWwgPSBbJ2JvdHRvbScsICd0b3AnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcbiAgICB2YXIgc2lkZSA9IGlzVmVydGljYWwgPyAnbGVmdCcgOiAndG9wJztcbiAgICB2YXIgbWVhc3VyZW1lbnQgPSBpc1ZlcnRpY2FsID8gJ3dpZHRoJyA6ICdoZWlnaHQnO1xuXG4gICAgdmFyIHNoaWZ0T2Zmc2V0cyA9IHtcbiAgICAgIHN0YXJ0OiBkZWZpbmVQcm9wZXJ0eSh7fSwgc2lkZSwgcmVmZXJlbmNlW3NpZGVdKSxcbiAgICAgIGVuZDogZGVmaW5lUHJvcGVydHkoe30sIHNpZGUsIHJlZmVyZW5jZVtzaWRlXSArIHJlZmVyZW5jZVttZWFzdXJlbWVudF0gLSBwb3BwZXJbbWVhc3VyZW1lbnRdKVxuICAgIH07XG5cbiAgICBkYXRhLm9mZnNldHMucG9wcGVyID0gX2V4dGVuZHMoe30sIHBvcHBlciwgc2hpZnRPZmZzZXRzW3NoaWZ0dmFyaWF0aW9uXSk7XG4gIH1cblxuICByZXR1cm4gZGF0YTtcbn1cblxuLyoqXG4gKiBAZnVuY3Rpb25cbiAqIEBtZW1iZXJvZiBNb2RpZmllcnNcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSB1cGRhdGUgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGhpZGUoZGF0YSkge1xuICBpZiAoIWlzTW9kaWZpZXJSZXF1aXJlZChkYXRhLmluc3RhbmNlLm1vZGlmaWVycywgJ2hpZGUnLCAncHJldmVudE92ZXJmbG93JykpIHtcbiAgICByZXR1cm4gZGF0YTtcbiAgfVxuXG4gIHZhciByZWZSZWN0ID0gZGF0YS5vZmZzZXRzLnJlZmVyZW5jZTtcbiAgdmFyIGJvdW5kID0gZmluZCQxKGRhdGEuaW5zdGFuY2UubW9kaWZpZXJzLCBmdW5jdGlvbiAobW9kaWZpZXIpIHtcbiAgICByZXR1cm4gbW9kaWZpZXIubmFtZSA9PT0gJ3ByZXZlbnRPdmVyZmxvdyc7XG4gIH0pLmJvdW5kYXJpZXM7XG5cbiAgaWYgKHJlZlJlY3QuYm90dG9tIDwgYm91bmQudG9wIHx8IHJlZlJlY3QubGVmdCA+IGJvdW5kLnJpZ2h0IHx8IHJlZlJlY3QudG9wID4gYm91bmQuYm90dG9tIHx8IHJlZlJlY3QucmlnaHQgPCBib3VuZC5sZWZ0KSB7XG4gICAgLy8gQXZvaWQgdW5uZWNlc3NhcnkgRE9NIGFjY2VzcyBpZiB2aXNpYmlsaXR5IGhhc24ndCBjaGFuZ2VkXG4gICAgaWYgKGRhdGEuaGlkZSA9PT0gdHJ1ZSkge1xuICAgICAgcmV0dXJuIGRhdGE7XG4gICAgfVxuXG4gICAgZGF0YS5oaWRlID0gdHJ1ZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9ICcnO1xuICB9IGVsc2Uge1xuICAgIC8vIEF2b2lkIHVubmVjZXNzYXJ5IERPTSBhY2Nlc3MgaWYgdmlzaWJpbGl0eSBoYXNuJ3QgY2hhbmdlZFxuICAgIGlmIChkYXRhLmhpZGUgPT09IGZhbHNlKSB7XG4gICAgICByZXR1cm4gZGF0YTtcbiAgICB9XG5cbiAgICBkYXRhLmhpZGUgPSBmYWxzZTtcbiAgICBkYXRhLmF0dHJpYnV0ZXNbJ3gtb3V0LW9mLWJvdW5kYXJpZXMnXSA9IGZhbHNlO1xuICB9XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogQGZ1bmN0aW9uXG4gKiBAbWVtYmVyb2YgTW9kaWZpZXJzXG4gKiBAYXJndW1lbnQge09iamVjdH0gZGF0YSAtIFRoZSBkYXRhIG9iamVjdCBnZW5lcmF0ZWQgYnkgYHVwZGF0ZWAgbWV0aG9kXG4gKiBAYXJndW1lbnQge09iamVjdH0gb3B0aW9ucyAtIE1vZGlmaWVycyBjb25maWd1cmF0aW9uIGFuZCBvcHRpb25zXG4gKiBAcmV0dXJucyB7T2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cbmZ1bmN0aW9uIGlubmVyKGRhdGEpIHtcbiAgdmFyIHBsYWNlbWVudCA9IGRhdGEucGxhY2VtZW50O1xuICB2YXIgYmFzZVBsYWNlbWVudCA9IHBsYWNlbWVudC5zcGxpdCgnLScpWzBdO1xuICB2YXIgX2RhdGEkb2Zmc2V0cyA9IGRhdGEub2Zmc2V0cyxcbiAgICAgIHBvcHBlciA9IF9kYXRhJG9mZnNldHMucG9wcGVyLFxuICAgICAgcmVmZXJlbmNlID0gX2RhdGEkb2Zmc2V0cy5yZWZlcmVuY2U7XG5cbiAgdmFyIGlzSG9yaXogPSBbJ2xlZnQnLCAncmlnaHQnXS5pbmRleE9mKGJhc2VQbGFjZW1lbnQpICE9PSAtMTtcblxuICB2YXIgc3VidHJhY3RMZW5ndGggPSBbJ3RvcCcsICdsZWZ0J10uaW5kZXhPZihiYXNlUGxhY2VtZW50KSA9PT0gLTE7XG5cbiAgcG9wcGVyW2lzSG9yaXogPyAnbGVmdCcgOiAndG9wJ10gPSByZWZlcmVuY2VbYmFzZVBsYWNlbWVudF0gLSAoc3VidHJhY3RMZW5ndGggPyBwb3BwZXJbaXNIb3JpeiA/ICd3aWR0aCcgOiAnaGVpZ2h0J10gOiAwKTtcblxuICBkYXRhLnBsYWNlbWVudCA9IGdldE9wcG9zaXRlUGxhY2VtZW50KHBsYWNlbWVudCk7XG4gIGRhdGEub2Zmc2V0cy5wb3BwZXIgPSBnZXRDbGllbnRSZWN0KHBvcHBlcik7XG5cbiAgcmV0dXJuIGRhdGE7XG59XG5cbi8qKlxuICogTW9kaWZpZXIgZnVuY3Rpb24sIGVhY2ggbW9kaWZpZXIgY2FuIGhhdmUgYSBmdW5jdGlvbiBvZiB0aGlzIHR5cGUgYXNzaWduZWRcbiAqIHRvIGl0cyBgZm5gIHByb3BlcnR5LjxiciAvPlxuICogVGhlc2UgZnVuY3Rpb25zIHdpbGwgYmUgY2FsbGVkIG9uIGVhY2ggdXBkYXRlLCB0aGlzIG1lYW5zIHRoYXQgeW91IG11c3RcbiAqIG1ha2Ugc3VyZSB0aGV5IGFyZSBwZXJmb3JtYW50IGVub3VnaCB0byBhdm9pZCBwZXJmb3JtYW5jZSBib3R0bGVuZWNrcy5cbiAqXG4gKiBAZnVuY3Rpb24gTW9kaWZpZXJGblxuICogQGFyZ3VtZW50IHtkYXRhT2JqZWN0fSBkYXRhIC0gVGhlIGRhdGEgb2JqZWN0IGdlbmVyYXRlZCBieSBgdXBkYXRlYCBtZXRob2RcbiAqIEBhcmd1bWVudCB7T2JqZWN0fSBvcHRpb25zIC0gTW9kaWZpZXJzIGNvbmZpZ3VyYXRpb24gYW5kIG9wdGlvbnNcbiAqIEByZXR1cm5zIHtkYXRhT2JqZWN0fSBUaGUgZGF0YSBvYmplY3QsIHByb3Blcmx5IG1vZGlmaWVkXG4gKi9cblxuLyoqXG4gKiBNb2RpZmllcnMgYXJlIHBsdWdpbnMgdXNlZCB0byBhbHRlciB0aGUgYmVoYXZpb3Igb2YgeW91ciBwb3BwZXJzLjxiciAvPlxuICogUG9wcGVyLmpzIHVzZXMgYSBzZXQgb2YgOSBtb2RpZmllcnMgdG8gcHJvdmlkZSBhbGwgdGhlIGJhc2ljIGZ1bmN0aW9uYWxpdGllc1xuICogbmVlZGVkIGJ5IHRoZSBsaWJyYXJ5LlxuICpcbiAqIFVzdWFsbHkgeW91IGRvbid0IHdhbnQgdG8gb3ZlcnJpZGUgdGhlIGBvcmRlcmAsIGBmbmAgYW5kIGBvbkxvYWRgIHByb3BzLlxuICogQWxsIHRoZSBvdGhlciBwcm9wZXJ0aWVzIGFyZSBjb25maWd1cmF0aW9ucyB0aGF0IGNvdWxkIGJlIHR3ZWFrZWQuXG4gKiBAbmFtZXNwYWNlIG1vZGlmaWVyc1xuICovXG52YXIgbW9kaWZpZXJzID0ge1xuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBzaGlmdCB0aGUgcG9wcGVyIG9uIHRoZSBzdGFydCBvciBlbmQgb2YgaXRzIHJlZmVyZW5jZVxuICAgKiBlbGVtZW50LjxiciAvPlxuICAgKiBJdCB3aWxsIHJlYWQgdGhlIHZhcmlhdGlvbiBvZiB0aGUgYHBsYWNlbWVudGAgcHJvcGVydHkuPGJyIC8+XG4gICAqIEl0IGNhbiBiZSBvbmUgZWl0aGVyIGAtZW5kYCBvciBgLXN0YXJ0YC5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIHNoaWZ0OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTEwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogc2hpZnRcbiAgfSxcblxuICAvKipcbiAgICogVGhlIGBvZmZzZXRgIG1vZGlmaWVyIGNhbiBzaGlmdCB5b3VyIHBvcHBlciBvbiBib3RoIGl0cyBheGlzLlxuICAgKlxuICAgKiBJdCBhY2NlcHRzIHRoZSBmb2xsb3dpbmcgdW5pdHM6XG4gICAqIC0gYHB4YCBvciB1bml0bGVzcywgaW50ZXJwcmV0ZWQgYXMgcGl4ZWxzXG4gICAqIC0gYCVgIG9yIGAlcmAsIHBlcmNlbnRhZ2UgcmVsYXRpdmUgdG8gdGhlIGxlbmd0aCBvZiB0aGUgcmVmZXJlbmNlIGVsZW1lbnRcbiAgICogLSBgJXBgLCBwZXJjZW50YWdlIHJlbGF0aXZlIHRvIHRoZSBsZW5ndGggb2YgdGhlIHBvcHBlciBlbGVtZW50XG4gICAqIC0gYHZ3YCwgQ1NTIHZpZXdwb3J0IHdpZHRoIHVuaXRcbiAgICogLSBgdmhgLCBDU1Mgdmlld3BvcnQgaGVpZ2h0IHVuaXRcbiAgICpcbiAgICogRm9yIGxlbmd0aCBpcyBpbnRlbmRlZCB0aGUgbWFpbiBheGlzIHJlbGF0aXZlIHRvIHRoZSBwbGFjZW1lbnQgb2YgdGhlIHBvcHBlci48YnIgLz5cbiAgICogVGhpcyBtZWFucyB0aGF0IGlmIHRoZSBwbGFjZW1lbnQgaXMgYHRvcGAgb3IgYGJvdHRvbWAsIHRoZSBsZW5ndGggd2lsbCBiZSB0aGVcbiAgICogYHdpZHRoYC4gSW4gY2FzZSBvZiBgbGVmdGAgb3IgYHJpZ2h0YCwgaXQgd2lsbCBiZSB0aGUgaGVpZ2h0LlxuICAgKlxuICAgKiBZb3UgY2FuIHByb3ZpZGUgYSBzaW5nbGUgdmFsdWUgKGFzIGBOdW1iZXJgIG9yIGBTdHJpbmdgKSwgb3IgYSBwYWlyIG9mIHZhbHVlc1xuICAgKiBhcyBgU3RyaW5nYCBkaXZpZGVkIGJ5IGEgY29tbWEgb3Igb25lIChvciBtb3JlKSB3aGl0ZSBzcGFjZXMuPGJyIC8+XG4gICAqIFRoZSBsYXR0ZXIgaXMgYSBkZXByZWNhdGVkIG1ldGhvZCBiZWNhdXNlIGl0IGxlYWRzIHRvIGNvbmZ1c2lvbiBhbmQgd2lsbCBiZVxuICAgKiByZW1vdmVkIGluIHYyLjxiciAvPlxuICAgKiBBZGRpdGlvbmFsbHksIGl0IGFjY2VwdHMgYWRkaXRpb25zIGFuZCBzdWJ0cmFjdGlvbnMgYmV0d2VlbiBkaWZmZXJlbnQgdW5pdHMuXG4gICAqIE5vdGUgdGhhdCBtdWx0aXBsaWNhdGlvbnMgYW5kIGRpdmlzaW9ucyBhcmVuJ3Qgc3VwcG9ydGVkLlxuICAgKlxuICAgKiBWYWxpZCBleGFtcGxlcyBhcmU6XG4gICAqIGBgYFxuICAgKiAxMFxuICAgKiAnMTAlJ1xuICAgKiAnMTAsIDEwJ1xuICAgKiAnMTAlLCAxMCdcbiAgICogJzEwICsgMTAlJ1xuICAgKiAnMTAgLSA1dmggKyAzJSdcbiAgICogJy0xMHB4ICsgNXZoLCA1cHggLSA2JSdcbiAgICogYGBgXG4gICAqID4gKipOQioqOiBJZiB5b3UgZGVzaXJlIHRvIGFwcGx5IG9mZnNldHMgdG8geW91ciBwb3BwZXJzIGluIGEgd2F5IHRoYXQgbWF5IG1ha2UgdGhlbSBvdmVybGFwXG4gICAqID4gd2l0aCB0aGVpciByZWZlcmVuY2UgZWxlbWVudCwgdW5mb3J0dW5hdGVseSwgeW91IHdpbGwgaGF2ZSB0byBkaXNhYmxlIHRoZSBgZmxpcGAgbW9kaWZpZXIuXG4gICAqID4gTW9yZSBvbiB0aGlzIFtyZWFkaW5nIHRoaXMgaXNzdWVdKGh0dHBzOi8vZ2l0aHViLmNvbS9GZXpWcmFzdGEvcG9wcGVyLmpzL2lzc3Vlcy8zNzMpXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBvZmZzZXQ6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9MjAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiAyMDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBvZmZzZXQsXG4gICAgLyoqIEBwcm9wIHtOdW1iZXJ8U3RyaW5nfSBvZmZzZXQ9MFxuICAgICAqIFRoZSBvZmZzZXQgdmFsdWUgYXMgZGVzY3JpYmVkIGluIHRoZSBtb2RpZmllciBkZXNjcmlwdGlvblxuICAgICAqL1xuICAgIG9mZnNldDogMFxuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIHByZXZlbnQgdGhlIHBvcHBlciBmcm9tIGJlaW5nIHBvc2l0aW9uZWQgb3V0c2lkZSB0aGUgYm91bmRhcnkuXG4gICAqXG4gICAqIEFuIHNjZW5hcmlvIGV4aXN0cyB3aGVyZSB0aGUgcmVmZXJlbmNlIGl0c2VsZiBpcyBub3Qgd2l0aGluIHRoZSBib3VuZGFyaWVzLjxiciAvPlxuICAgKiBXZSBjYW4gc2F5IGl0IGhhcyBcImVzY2FwZWQgdGhlIGJvdW5kYXJpZXNcIiDigJQgb3IganVzdCBcImVzY2FwZWRcIi48YnIgLz5cbiAgICogSW4gdGhpcyBjYXNlIHdlIG5lZWQgdG8gZGVjaWRlIHdoZXRoZXIgdGhlIHBvcHBlciBzaG91bGQgZWl0aGVyOlxuICAgKlxuICAgKiAtIGRldGFjaCBmcm9tIHRoZSByZWZlcmVuY2UgYW5kIHJlbWFpbiBcInRyYXBwZWRcIiBpbiB0aGUgYm91bmRhcmllcywgb3JcbiAgICogLSBpZiBpdCBzaG91bGQgaWdub3JlIHRoZSBib3VuZGFyeSBhbmQgXCJlc2NhcGUgd2l0aCBpdHMgcmVmZXJlbmNlXCJcbiAgICpcbiAgICogV2hlbiBgZXNjYXBlV2l0aFJlZmVyZW5jZWAgaXMgc2V0IHRvYHRydWVgIGFuZCByZWZlcmVuY2UgaXMgY29tcGxldGVseVxuICAgKiBvdXRzaWRlIGl0cyBib3VuZGFyaWVzLCB0aGUgcG9wcGVyIHdpbGwgb3ZlcmZsb3cgKG9yIGNvbXBsZXRlbHkgbGVhdmUpXG4gICAqIHRoZSBib3VuZGFyaWVzIGluIG9yZGVyIHRvIHJlbWFpbiBhdHRhY2hlZCB0byB0aGUgZWRnZSBvZiB0aGUgcmVmZXJlbmNlLlxuICAgKlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgcHJldmVudE92ZXJmbG93OiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTMwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogMzAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogcHJldmVudE92ZXJmbG93LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtBcnJheX0gW3ByaW9yaXR5PVsnbGVmdCcsJ3JpZ2h0JywndG9wJywnYm90dG9tJ11dXG4gICAgICogUG9wcGVyIHdpbGwgdHJ5IHRvIHByZXZlbnQgb3ZlcmZsb3cgZm9sbG93aW5nIHRoZXNlIHByaW9yaXRpZXMgYnkgZGVmYXVsdCxcbiAgICAgKiB0aGVuLCBpdCBjb3VsZCBvdmVyZmxvdyBvbiB0aGUgbGVmdCBhbmQgb24gdG9wIG9mIHRoZSBgYm91bmRhcmllc0VsZW1lbnRgXG4gICAgICovXG4gICAgcHJpb3JpdHk6IFsnbGVmdCcsICdyaWdodCcsICd0b3AnLCAnYm90dG9tJ10sXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogQW1vdW50IG9mIHBpeGVsIHVzZWQgdG8gZGVmaW5lIGEgbWluaW11bSBkaXN0YW5jZSBiZXR3ZWVuIHRoZSBib3VuZGFyaWVzXG4gICAgICogYW5kIHRoZSBwb3BwZXIgdGhpcyBtYWtlcyBzdXJlIHRoZSBwb3BwZXIgaGFzIGFsd2F5cyBhIGxpdHRsZSBwYWRkaW5nXG4gICAgICogYmV0d2VlbiB0aGUgZWRnZXMgb2YgaXRzIGNvbnRhaW5lclxuICAgICAqL1xuICAgIHBhZGRpbmc6IDUsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gYm91bmRhcmllc0VsZW1lbnQ9J3Njcm9sbFBhcmVudCdcbiAgICAgKiBCb3VuZGFyaWVzIHVzZWQgYnkgdGhlIG1vZGlmaWVyLCBjYW4gYmUgYHNjcm9sbFBhcmVudGAsIGB3aW5kb3dgLFxuICAgICAqIGB2aWV3cG9ydGAgb3IgYW55IERPTSBlbGVtZW50LlxuICAgICAqL1xuICAgIGJvdW5kYXJpZXNFbGVtZW50OiAnc2Nyb2xsUGFyZW50J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2Ugc3VyZSB0aGUgcmVmZXJlbmNlIGFuZCBpdHMgcG9wcGVyIHN0YXkgbmVhciBlYWNob3RoZXJzXG4gICAqIHdpdGhvdXQgbGVhdmluZyBhbnkgZ2FwIGJldHdlZW4gdGhlIHR3by4gRXhwZWNpYWxseSB1c2VmdWwgd2hlbiB0aGUgYXJyb3cgaXNcbiAgICogZW5hYmxlZCBhbmQgeW91IHdhbnQgdG8gYXNzdXJlIGl0IHRvIHBvaW50IHRvIGl0cyByZWZlcmVuY2UgZWxlbWVudC5cbiAgICogSXQgY2FyZXMgb25seSBhYm91dCB0aGUgZmlyc3QgYXhpcywgeW91IGNhbiBzdGlsbCBoYXZlIHBvcHBlcnMgd2l0aCBtYXJnaW5cbiAgICogYmV0d2VlbiB0aGUgcG9wcGVyIGFuZCBpdHMgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBrZWVwVG9nZXRoZXI6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NDAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA0MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBrZWVwVG9nZXRoZXJcbiAgfSxcblxuICAvKipcbiAgICogVGhpcyBtb2RpZmllciBpcyB1c2VkIHRvIG1vdmUgdGhlIGBhcnJvd0VsZW1lbnRgIG9mIHRoZSBwb3BwZXIgdG8gbWFrZVxuICAgKiBzdXJlIGl0IGlzIHBvc2l0aW9uZWQgYmV0d2VlbiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgYW5kIGl0cyBwb3BwZXIgZWxlbWVudC5cbiAgICogSXQgd2lsbCByZWFkIHRoZSBvdXRlciBzaXplIG9mIHRoZSBgYXJyb3dFbGVtZW50YCBub2RlIHRvIGRldGVjdCBob3cgbWFueVxuICAgKiBwaXhlbHMgb2YgY29uanVjdGlvbiBhcmUgbmVlZGVkLlxuICAgKlxuICAgKiBJdCBoYXMgbm8gZWZmZWN0IGlmIG5vIGBhcnJvd0VsZW1lbnRgIGlzIHByb3ZpZGVkLlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgYXJyb3c6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9NTAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA1MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBhcnJvdyxcbiAgICAvKiogQHByb3Age1N0cmluZ3xIVE1MRWxlbWVudH0gZWxlbWVudD0nW3gtYXJyb3ddJyAtIFNlbGVjdG9yIG9yIG5vZGUgdXNlZCBhcyBhcnJvdyAqL1xuICAgIGVsZW1lbnQ6ICdbeC1hcnJvd10nXG4gIH0sXG5cbiAgLyoqXG4gICAqIE1vZGlmaWVyIHVzZWQgdG8gZmxpcCB0aGUgcG9wcGVyJ3MgcGxhY2VtZW50IHdoZW4gaXQgc3RhcnRzIHRvIG92ZXJsYXAgaXRzXG4gICAqIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKlxuICAgKiBSZXF1aXJlcyB0aGUgYHByZXZlbnRPdmVyZmxvd2AgbW9kaWZpZXIgYmVmb3JlIGl0IGluIG9yZGVyIHRvIHdvcmsuXG4gICAqXG4gICAqICoqTk9URToqKiB0aGlzIG1vZGlmaWVyIHdpbGwgaW50ZXJydXB0IHRoZSBjdXJyZW50IHVwZGF0ZSBjeWNsZSBhbmQgd2lsbFxuICAgKiByZXN0YXJ0IGl0IGlmIGl0IGRldGVjdHMgdGhlIG5lZWQgdG8gZmxpcCB0aGUgcGxhY2VtZW50LlxuICAgKiBAbWVtYmVyb2YgbW9kaWZpZXJzXG4gICAqIEBpbm5lclxuICAgKi9cbiAgZmxpcDoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj02MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDYwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGZsaXAsXG4gICAgLyoqXG4gICAgICogQHByb3Age1N0cmluZ3xBcnJheX0gYmVoYXZpb3I9J2ZsaXAnXG4gICAgICogVGhlIGJlaGF2aW9yIHVzZWQgdG8gY2hhbmdlIHRoZSBwb3BwZXIncyBwbGFjZW1lbnQuIEl0IGNhbiBiZSBvbmUgb2ZcbiAgICAgKiBgZmxpcGAsIGBjbG9ja3dpc2VgLCBgY291bnRlcmNsb2Nrd2lzZWAgb3IgYW4gYXJyYXkgd2l0aCBhIGxpc3Qgb2YgdmFsaWRcbiAgICAgKiBwbGFjZW1lbnRzICh3aXRoIG9wdGlvbmFsIHZhcmlhdGlvbnMpLlxuICAgICAqL1xuICAgIGJlaGF2aW9yOiAnZmxpcCcsXG4gICAgLyoqXG4gICAgICogQHByb3Age251bWJlcn0gcGFkZGluZz01XG4gICAgICogVGhlIHBvcHBlciB3aWxsIGZsaXAgaWYgaXQgaGl0cyB0aGUgZWRnZXMgb2YgdGhlIGBib3VuZGFyaWVzRWxlbWVudGBcbiAgICAgKi9cbiAgICBwYWRkaW5nOiA1LFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtTdHJpbmd8SFRNTEVsZW1lbnR9IGJvdW5kYXJpZXNFbGVtZW50PSd2aWV3cG9ydCdcbiAgICAgKiBUaGUgZWxlbWVudCB3aGljaCB3aWxsIGRlZmluZSB0aGUgYm91bmRhcmllcyBvZiB0aGUgcG9wcGVyIHBvc2l0aW9uLFxuICAgICAqIHRoZSBwb3BwZXIgd2lsbCBuZXZlciBiZSBwbGFjZWQgb3V0c2lkZSBvZiB0aGUgZGVmaW5lZCBib3VuZGFyaWVzXG4gICAgICogKGV4Y2VwdCBpZiBrZWVwVG9nZXRoZXIgaXMgZW5hYmxlZClcbiAgICAgKi9cbiAgICBib3VuZGFyaWVzRWxlbWVudDogJ3ZpZXdwb3J0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBNb2RpZmllciB1c2VkIHRvIG1ha2UgdGhlIHBvcHBlciBmbG93IHRvd2FyZCB0aGUgaW5uZXIgb2YgdGhlIHJlZmVyZW5jZSBlbGVtZW50LlxuICAgKiBCeSBkZWZhdWx0LCB3aGVuIHRoaXMgbW9kaWZpZXIgaXMgZGlzYWJsZWQsIHRoZSBwb3BwZXIgd2lsbCBiZSBwbGFjZWQgb3V0c2lkZVxuICAgKiB0aGUgcmVmZXJlbmNlIGVsZW1lbnQuXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBpbm5lcjoge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj03MDAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDcwMCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9ZmFsc2UgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IGZhbHNlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogaW5uZXJcbiAgfSxcblxuICAvKipcbiAgICogTW9kaWZpZXIgdXNlZCB0byBoaWRlIHRoZSBwb3BwZXIgd2hlbiBpdHMgcmVmZXJlbmNlIGVsZW1lbnQgaXMgb3V0c2lkZSBvZiB0aGVcbiAgICogcG9wcGVyIGJvdW5kYXJpZXMuIEl0IHdpbGwgc2V0IGEgYHgtb3V0LW9mLWJvdW5kYXJpZXNgIGF0dHJpYnV0ZSB3aGljaCBjYW5cbiAgICogYmUgdXNlZCB0byBoaWRlIHdpdGggYSBDU1Mgc2VsZWN0b3IgdGhlIHBvcHBlciB3aGVuIGl0cyByZWZlcmVuY2UgaXNcbiAgICogb3V0IG9mIGJvdW5kYXJpZXMuXG4gICAqXG4gICAqIFJlcXVpcmVzIHRoZSBgcHJldmVudE92ZXJmbG93YCBtb2RpZmllciBiZWZvcmUgaXQgaW4gb3JkZXIgdG8gd29yay5cbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGhpZGU6IHtcbiAgICAvKiogQHByb3Age251bWJlcn0gb3JkZXI9ODAwIC0gSW5kZXggdXNlZCB0byBkZWZpbmUgdGhlIG9yZGVyIG9mIGV4ZWN1dGlvbiAqL1xuICAgIG9yZGVyOiA4MDAsXG4gICAgLyoqIEBwcm9wIHtCb29sZWFufSBlbmFibGVkPXRydWUgLSBXaGV0aGVyIHRoZSBtb2RpZmllciBpcyBlbmFibGVkIG9yIG5vdCAqL1xuICAgIGVuYWJsZWQ6IHRydWUsXG4gICAgLyoqIEBwcm9wIHtNb2RpZmllckZufSAqL1xuICAgIGZuOiBoaWRlXG4gIH0sXG5cbiAgLyoqXG4gICAqIENvbXB1dGVzIHRoZSBzdHlsZSB0aGF0IHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGVsZW1lbnQgdG8gZ2V0c1xuICAgKiBwcm9wZXJseSBwb3NpdGlvbmVkLlxuICAgKlxuICAgKiBOb3RlIHRoYXQgdGhpcyBtb2RpZmllciB3aWxsIG5vdCB0b3VjaCB0aGUgRE9NLCBpdCBqdXN0IHByZXBhcmVzIHRoZSBzdHlsZXNcbiAgICogc28gdGhhdCBgYXBwbHlTdHlsZWAgbW9kaWZpZXIgY2FuIGFwcGx5IGl0LiBUaGlzIHNlcGFyYXRpb24gaXMgdXNlZnVsXG4gICAqIGluIGNhc2UgeW91IG5lZWQgdG8gcmVwbGFjZSBgYXBwbHlTdHlsZWAgd2l0aCBhIGN1c3RvbSBpbXBsZW1lbnRhdGlvbi5cbiAgICpcbiAgICogVGhpcyBtb2RpZmllciBoYXMgYDg1MGAgYXMgYG9yZGVyYCB2YWx1ZSB0byBtYWludGFpbiBiYWNrd2FyZCBjb21wYXRpYmlsaXR5XG4gICAqIHdpdGggcHJldmlvdXMgdmVyc2lvbnMgb2YgUG9wcGVyLmpzLiBFeHBlY3QgdGhlIG1vZGlmaWVycyBvcmRlcmluZyBtZXRob2RcbiAgICogdG8gY2hhbmdlIGluIGZ1dHVyZSBtYWpvciB2ZXJzaW9ucyBvZiB0aGUgbGlicmFyeS5cbiAgICpcbiAgICogQG1lbWJlcm9mIG1vZGlmaWVyc1xuICAgKiBAaW5uZXJcbiAgICovXG4gIGNvbXB1dGVTdHlsZToge1xuICAgIC8qKiBAcHJvcCB7bnVtYmVyfSBvcmRlcj04NTAgLSBJbmRleCB1c2VkIHRvIGRlZmluZSB0aGUgb3JkZXIgb2YgZXhlY3V0aW9uICovXG4gICAgb3JkZXI6IDg1MCxcbiAgICAvKiogQHByb3Age0Jvb2xlYW59IGVuYWJsZWQ9dHJ1ZSAtIFdoZXRoZXIgdGhlIG1vZGlmaWVyIGlzIGVuYWJsZWQgb3Igbm90ICovXG4gICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAvKiogQHByb3Age01vZGlmaWVyRm59ICovXG4gICAgZm46IGNvbXB1dGVTdHlsZSxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7Qm9vbGVhbn0gZ3B1QWNjZWxlcmF0aW9uPXRydWVcbiAgICAgKiBJZiB0cnVlLCBpdCB1c2VzIHRoZSBDU1MgM2QgdHJhbnNmb3JtYXRpb24gdG8gcG9zaXRpb24gdGhlIHBvcHBlci5cbiAgICAgKiBPdGhlcndpc2UsIGl0IHdpbGwgdXNlIHRoZSBgdG9wYCBhbmQgYGxlZnRgIHByb3BlcnRpZXMuXG4gICAgICovXG4gICAgZ3B1QWNjZWxlcmF0aW9uOiB0cnVlLFxuICAgIC8qKlxuICAgICAqIEBwcm9wIHtzdHJpbmd9IFt4PSdib3R0b20nXVxuICAgICAqIFdoZXJlIHRvIGFuY2hvciB0aGUgWCBheGlzIChgYm90dG9tYCBvciBgdG9wYCkuIEFLQSBYIG9mZnNldCBvcmlnaW4uXG4gICAgICogQ2hhbmdlIHRoaXMgaWYgeW91ciBwb3BwZXIgc2hvdWxkIGdyb3cgaW4gYSBkaXJlY3Rpb24gZGlmZmVyZW50IGZyb20gYGJvdHRvbWBcbiAgICAgKi9cbiAgICB4OiAnYm90dG9tJyxcbiAgICAvKipcbiAgICAgKiBAcHJvcCB7c3RyaW5nfSBbeD0nbGVmdCddXG4gICAgICogV2hlcmUgdG8gYW5jaG9yIHRoZSBZIGF4aXMgKGBsZWZ0YCBvciBgcmlnaHRgKS4gQUtBIFkgb2Zmc2V0IG9yaWdpbi5cbiAgICAgKiBDaGFuZ2UgdGhpcyBpZiB5b3VyIHBvcHBlciBzaG91bGQgZ3JvdyBpbiBhIGRpcmVjdGlvbiBkaWZmZXJlbnQgZnJvbSBgcmlnaHRgXG4gICAgICovXG4gICAgeTogJ3JpZ2h0J1xuICB9LFxuXG4gIC8qKlxuICAgKiBBcHBsaWVzIHRoZSBjb21wdXRlZCBzdHlsZXMgdG8gdGhlIHBvcHBlciBlbGVtZW50LlxuICAgKlxuICAgKiBBbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIGFyZSBsaW1pdGVkIHRvIHRoaXMgbW9kaWZpZXIuIFRoaXMgaXMgdXNlZnVsIGluIGNhc2VcbiAgICogeW91IHdhbnQgdG8gaW50ZWdyYXRlIFBvcHBlci5qcyBpbnNpZGUgYSBmcmFtZXdvcmsgb3IgdmlldyBsaWJyYXJ5IGFuZCB5b3VcbiAgICogd2FudCB0byBkZWxlZ2F0ZSBhbGwgdGhlIERPTSBtYW5pcHVsYXRpb25zIHRvIGl0LlxuICAgKlxuICAgKiBOb3RlIHRoYXQgaWYgeW91IGRpc2FibGUgdGhpcyBtb2RpZmllciwgeW91IG11c3QgbWFrZSBzdXJlIHRoZSBwb3BwZXIgZWxlbWVudFxuICAgKiBoYXMgaXRzIHBvc2l0aW9uIHNldCB0byBgYWJzb2x1dGVgIGJlZm9yZSBQb3BwZXIuanMgY2FuIGRvIGl0cyB3b3JrIVxuICAgKlxuICAgKiBKdXN0IGRpc2FibGUgdGhpcyBtb2RpZmllciBhbmQgZGVmaW5lIHlvdSBvd24gdG8gYWNoaWV2ZSB0aGUgZGVzaXJlZCBlZmZlY3QuXG4gICAqXG4gICAqIEBtZW1iZXJvZiBtb2RpZmllcnNcbiAgICogQGlubmVyXG4gICAqL1xuICBhcHBseVN0eWxlOiB7XG4gICAgLyoqIEBwcm9wIHtudW1iZXJ9IG9yZGVyPTkwMCAtIEluZGV4IHVzZWQgdG8gZGVmaW5lIHRoZSBvcmRlciBvZiBleGVjdXRpb24gKi9cbiAgICBvcmRlcjogOTAwLFxuICAgIC8qKiBAcHJvcCB7Qm9vbGVhbn0gZW5hYmxlZD10cnVlIC0gV2hldGhlciB0aGUgbW9kaWZpZXIgaXMgZW5hYmxlZCBvciBub3QgKi9cbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIC8qKiBAcHJvcCB7TW9kaWZpZXJGbn0gKi9cbiAgICBmbjogYXBwbHlTdHlsZSxcbiAgICAvKiogQHByb3Age0Z1bmN0aW9ufSAqL1xuICAgIG9uTG9hZDogYXBwbHlTdHlsZU9uTG9hZCxcbiAgICAvKipcbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuMTAuMCwgdGhlIHByb3BlcnR5IG1vdmVkIHRvIGBjb21wdXRlU3R5bGVgIG1vZGlmaWVyXG4gICAgICogQHByb3Age0Jvb2xlYW59IGdwdUFjY2VsZXJhdGlvbj10cnVlXG4gICAgICogSWYgdHJ1ZSwgaXQgdXNlcyB0aGUgQ1NTIDNkIHRyYW5zZm9ybWF0aW9uIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXIuXG4gICAgICogT3RoZXJ3aXNlLCBpdCB3aWxsIHVzZSB0aGUgYHRvcGAgYW5kIGBsZWZ0YCBwcm9wZXJ0aWVzLlxuICAgICAqL1xuICAgIGdwdUFjY2VsZXJhdGlvbjogdW5kZWZpbmVkXG4gIH1cbn07XG5cbi8qKlxuICogVGhlIGBkYXRhT2JqZWN0YCBpcyBhbiBvYmplY3QgY29udGFpbmluZyBhbGwgdGhlIGluZm9ybWF0aW9ucyB1c2VkIGJ5IFBvcHBlci5qc1xuICogdGhpcyBvYmplY3QgZ2V0IHBhc3NlZCB0byBtb2RpZmllcnMgYW5kIHRvIHRoZSBgb25DcmVhdGVgIGFuZCBgb25VcGRhdGVgIGNhbGxiYWNrcy5cbiAqIEBuYW1lIGRhdGFPYmplY3RcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmluc3RhbmNlIFRoZSBQb3BwZXIuanMgaW5zdGFuY2VcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLnBsYWNlbWVudCBQbGFjZW1lbnQgYXBwbGllZCB0byBwb3BwZXJcbiAqIEBwcm9wZXJ0eSB7U3RyaW5nfSBkYXRhLm9yaWdpbmFsUGxhY2VtZW50IFBsYWNlbWVudCBvcmlnaW5hbGx5IGRlZmluZWQgb24gaW5pdFxuICogQHByb3BlcnR5IHtCb29sZWFufSBkYXRhLmZsaXBwZWQgVHJ1ZSBpZiBwb3BwZXIgaGFzIGJlZW4gZmxpcHBlZCBieSBmbGlwIG1vZGlmaWVyXG4gKiBAcHJvcGVydHkge0Jvb2xlYW59IGRhdGEuaGlkZSBUcnVlIGlmIHRoZSByZWZlcmVuY2UgZWxlbWVudCBpcyBvdXQgb2YgYm91bmRhcmllcywgdXNlZnVsIHRvIGtub3cgd2hlbiB0byBoaWRlIHRoZSBwb3BwZXIuXG4gKiBAcHJvcGVydHkge0hUTUxFbGVtZW50fSBkYXRhLmFycm93RWxlbWVudCBOb2RlIHVzZWQgYXMgYXJyb3cgYnkgYXJyb3cgbW9kaWZpZXJcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLnN0eWxlcyBBbnkgQ1NTIHByb3BlcnR5IGRlZmluZWQgaGVyZSB3aWxsIGJlIGFwcGxpZWQgdG8gdGhlIHBvcHBlciwgaXQgZXhwZWN0cyB0aGUgSmF2YVNjcmlwdCBub21lbmNsYXR1cmUgKGVnLiBgbWFyZ2luQm90dG9tYClcbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLmFycm93U3R5bGVzIEFueSBDU1MgcHJvcGVydHkgZGVmaW5lZCBoZXJlIHdpbGwgYmUgYXBwbGllZCB0byB0aGUgcG9wcGVyIGFycm93LCBpdCBleHBlY3RzIHRoZSBKYXZhU2NyaXB0IG5vbWVuY2xhdHVyZSAoZWcuIGBtYXJnaW5Cb3R0b21gKVxuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEuYm91bmRhcmllcyBPZmZzZXRzIG9mIHRoZSBwb3BwZXIgYm91bmRhcmllc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cyBUaGUgbWVhc3VyZW1lbnRzIG9mIHBvcHBlciwgcmVmZXJlbmNlIGFuZCBhcnJvdyBlbGVtZW50cy5cbiAqIEBwcm9wZXJ0eSB7T2JqZWN0fSBkYXRhLm9mZnNldHMucG9wcGVyIGB0b3BgLCBgbGVmdGAsIGB3aWR0aGAsIGBoZWlnaHRgIHZhbHVlc1xuICogQHByb3BlcnR5IHtPYmplY3R9IGRhdGEub2Zmc2V0cy5yZWZlcmVuY2UgYHRvcGAsIGBsZWZ0YCwgYHdpZHRoYCwgYGhlaWdodGAgdmFsdWVzXG4gKiBAcHJvcGVydHkge09iamVjdH0gZGF0YS5vZmZzZXRzLmFycm93XSBgdG9wYCBhbmQgYGxlZnRgIG9mZnNldHMsIG9ubHkgb25lIG9mIHRoZW0gd2lsbCBiZSBkaWZmZXJlbnQgZnJvbSAwXG4gKi9cblxuLyoqXG4gKiBEZWZhdWx0IG9wdGlvbnMgcHJvdmlkZWQgdG8gUG9wcGVyLmpzIGNvbnN0cnVjdG9yLjxiciAvPlxuICogVGhlc2UgY2FuIGJlIG92ZXJyaWRlbiB1c2luZyB0aGUgYG9wdGlvbnNgIGFyZ3VtZW50IG9mIFBvcHBlci5qcy48YnIgLz5cbiAqIFRvIG92ZXJyaWRlIGFuIG9wdGlvbiwgc2ltcGx5IHBhc3MgYXMgM3JkIGFyZ3VtZW50IGFuIG9iamVjdCB3aXRoIHRoZSBzYW1lXG4gKiBzdHJ1Y3R1cmUgb2YgdGhpcyBvYmplY3QsIGV4YW1wbGU6XG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmLCBwb3AsIHtcbiAqICAgbW9kaWZpZXJzOiB7XG4gKiAgICAgcHJldmVudE92ZXJmbG93OiB7IGVuYWJsZWQ6IGZhbHNlIH1cbiAqICAgfVxuICogfSlcbiAqIGBgYFxuICogQHR5cGUge09iamVjdH1cbiAqIEBzdGF0aWNcbiAqIEBtZW1iZXJvZiBQb3BwZXJcbiAqL1xudmFyIERlZmF1bHRzJDEgPSB7XG4gIC8qKlxuICAgKiBQb3BwZXIncyBwbGFjZW1lbnRcbiAgICogQHByb3Age1BvcHBlci5wbGFjZW1lbnRzfSBwbGFjZW1lbnQ9J2JvdHRvbSdcbiAgICovXG4gIHBsYWNlbWVudDogJ2JvdHRvbScsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgZXZlbnRzIChyZXNpemUsIHNjcm9sbCkgYXJlIGluaXRpYWxseSBlbmFibGVkXG4gICAqIEBwcm9wIHtCb29sZWFufSBldmVudHNFbmFibGVkPXRydWVcbiAgICovXG4gIGV2ZW50c0VuYWJsZWQ6IHRydWUsXG5cbiAgLyoqXG4gICAqIFNldCB0byB0cnVlIGlmIHlvdSB3YW50IHRvIGF1dG9tYXRpY2FsbHkgcmVtb3ZlIHRoZSBwb3BwZXIgd2hlblxuICAgKiB5b3UgY2FsbCB0aGUgYGRlc3Ryb3lgIG1ldGhvZC5cbiAgICogQHByb3Age0Jvb2xlYW59IHJlbW92ZU9uRGVzdHJveT1mYWxzZVxuICAgKi9cbiAgcmVtb3ZlT25EZXN0cm95OiBmYWxzZSxcblxuICAvKipcbiAgICogQ2FsbGJhY2sgY2FsbGVkIHdoZW4gdGhlIHBvcHBlciBpcyBjcmVhdGVkLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvbkNyZWF0ZX1cbiAgICovXG4gIG9uQ3JlYXRlOiBmdW5jdGlvbiBvbkNyZWF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBDYWxsYmFjayBjYWxsZWQgd2hlbiB0aGUgcG9wcGVyIGlzIHVwZGF0ZWQsIHRoaXMgY2FsbGJhY2sgaXMgbm90IGNhbGxlZFxuICAgKiBvbiB0aGUgaW5pdGlhbGl6YXRpb24vY3JlYXRpb24gb2YgdGhlIHBvcHBlciwgYnV0IG9ubHkgb24gc3Vic2VxdWVudFxuICAgKiB1cGRhdGVzLjxiciAvPlxuICAgKiBCeSBkZWZhdWx0LCBpcyBzZXQgdG8gbm8tb3AuPGJyIC8+XG4gICAqIEFjY2VzcyBQb3BwZXIuanMgaW5zdGFuY2Ugd2l0aCBgZGF0YS5pbnN0YW5jZWAuXG4gICAqIEBwcm9wIHtvblVwZGF0ZX1cbiAgICovXG4gIG9uVXBkYXRlOiBmdW5jdGlvbiBvblVwZGF0ZSgpIHt9LFxuXG4gIC8qKlxuICAgKiBMaXN0IG9mIG1vZGlmaWVycyB1c2VkIHRvIG1vZGlmeSB0aGUgb2Zmc2V0cyBiZWZvcmUgdGhleSBhcmUgYXBwbGllZCB0byB0aGUgcG9wcGVyLlxuICAgKiBUaGV5IHByb3ZpZGUgbW9zdCBvZiB0aGUgZnVuY3Rpb25hbGl0aWVzIG9mIFBvcHBlci5qc1xuICAgKiBAcHJvcCB7bW9kaWZpZXJzfVxuICAgKi9cbiAgbW9kaWZpZXJzOiBtb2RpZmllcnNcbn07XG5cbi8qKlxuICogQGNhbGxiYWNrIG9uQ3JlYXRlXG4gKiBAcGFyYW0ge2RhdGFPYmplY3R9IGRhdGFcbiAqL1xuXG4vKipcbiAqIEBjYWxsYmFjayBvblVwZGF0ZVxuICogQHBhcmFtIHtkYXRhT2JqZWN0fSBkYXRhXG4gKi9cblxuLy8gVXRpbHNcbi8vIE1ldGhvZHNcbnZhciBQb3BwZXIgPSBmdW5jdGlvbiAoKSB7XG4gIC8qKlxuICAgKiBDcmVhdGUgYSBuZXcgUG9wcGVyLmpzIGluc3RhbmNlXG4gICAqIEBjbGFzcyBQb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudHxyZWZlcmVuY2VPYmplY3R9IHJlZmVyZW5jZSAtIFRoZSByZWZlcmVuY2UgZWxlbWVudCB1c2VkIHRvIHBvc2l0aW9uIHRoZSBwb3BwZXJcbiAgICogQHBhcmFtIHtIVE1MRWxlbWVudH0gcG9wcGVyIC0gVGhlIEhUTUwgZWxlbWVudCB1c2VkIGFzIHBvcHBlci5cbiAgICogQHBhcmFtIHtPYmplY3R9IG9wdGlvbnMgLSBZb3VyIGN1c3RvbSBvcHRpb25zIHRvIG92ZXJyaWRlIHRoZSBvbmVzIGRlZmluZWQgaW4gW0RlZmF1bHRzXSgjZGVmYXVsdHMpXG4gICAqIEByZXR1cm4ge09iamVjdH0gaW5zdGFuY2UgLSBUaGUgZ2VuZXJhdGVkIFBvcHBlci5qcyBpbnN0YW5jZVxuICAgKi9cbiAgZnVuY3Rpb24gUG9wcGVyKHJlZmVyZW5jZSwgcG9wcGVyKSB7XG4gICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayh0aGlzLCBQb3BwZXIpO1xuXG4gICAgdGhpcy5zY2hlZHVsZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiByZXF1ZXN0QW5pbWF0aW9uRnJhbWUoX3RoaXMudXBkYXRlKTtcbiAgICB9O1xuXG4gICAgLy8gbWFrZSB1cGRhdGUoKSBkZWJvdW5jZWQsIHNvIHRoYXQgaXQgb25seSBydW5zIGF0IG1vc3Qgb25jZS1wZXItdGlja1xuICAgIHRoaXMudXBkYXRlID0gZGVib3VuY2UodGhpcy51cGRhdGUuYmluZCh0aGlzKSk7XG5cbiAgICAvLyB3aXRoIHt9IHdlIGNyZWF0ZSBhIG5ldyBvYmplY3Qgd2l0aCB0aGUgb3B0aW9ucyBpbnNpZGUgaXRcbiAgICB0aGlzLm9wdGlvbnMgPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLCBvcHRpb25zKTtcblxuICAgIC8vIGluaXQgc3RhdGVcbiAgICB0aGlzLnN0YXRlID0ge1xuICAgICAgaXNEZXN0cm95ZWQ6IGZhbHNlLFxuICAgICAgaXNDcmVhdGVkOiBmYWxzZSxcbiAgICAgIHNjcm9sbFBhcmVudHM6IFtdXG4gICAgfTtcblxuICAgIC8vIGdldCByZWZlcmVuY2UgYW5kIHBvcHBlciBlbGVtZW50cyAoYWxsb3cgalF1ZXJ5IHdyYXBwZXJzKVxuICAgIHRoaXMucmVmZXJlbmNlID0gcmVmZXJlbmNlICYmIHJlZmVyZW5jZS5qcXVlcnkgPyByZWZlcmVuY2VbMF0gOiByZWZlcmVuY2U7XG4gICAgdGhpcy5wb3BwZXIgPSBwb3BwZXIgJiYgcG9wcGVyLmpxdWVyeSA/IHBvcHBlclswXSA6IHBvcHBlcjtcblxuICAgIC8vIERlZXAgbWVyZ2UgbW9kaWZpZXJzIG9wdGlvbnNcbiAgICB0aGlzLm9wdGlvbnMubW9kaWZpZXJzID0ge307XG4gICAgT2JqZWN0LmtleXMoX2V4dGVuZHMoe30sIFBvcHBlci5EZWZhdWx0cy5tb2RpZmllcnMsIG9wdGlvbnMubW9kaWZpZXJzKSkuZm9yRWFjaChmdW5jdGlvbiAobmFtZSkge1xuICAgICAgX3RoaXMub3B0aW9ucy5tb2RpZmllcnNbbmFtZV0gPSBfZXh0ZW5kcyh7fSwgUG9wcGVyLkRlZmF1bHRzLm1vZGlmaWVyc1tuYW1lXSB8fCB7fSwgb3B0aW9ucy5tb2RpZmllcnMgPyBvcHRpb25zLm1vZGlmaWVyc1tuYW1lXSA6IHt9KTtcbiAgICB9KTtcblxuICAgIC8vIFJlZmFjdG9yaW5nIG1vZGlmaWVycycgbGlzdCAoT2JqZWN0ID0+IEFycmF5KVxuICAgIHRoaXMubW9kaWZpZXJzID0gT2JqZWN0LmtleXModGhpcy5vcHRpb25zLm1vZGlmaWVycykubWFwKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgICByZXR1cm4gX2V4dGVuZHMoe1xuICAgICAgICBuYW1lOiBuYW1lXG4gICAgICB9LCBfdGhpcy5vcHRpb25zLm1vZGlmaWVyc1tuYW1lXSk7XG4gICAgfSlcbiAgICAvLyBzb3J0IHRoZSBtb2RpZmllcnMgYnkgb3JkZXJcbiAgICAuc29ydChmdW5jdGlvbiAoYSwgYikge1xuICAgICAgcmV0dXJuIGEub3JkZXIgLSBiLm9yZGVyO1xuICAgIH0pO1xuXG4gICAgLy8gbW9kaWZpZXJzIGhhdmUgdGhlIGFiaWxpdHkgdG8gZXhlY3V0ZSBhcmJpdHJhcnkgY29kZSB3aGVuIFBvcHBlci5qcyBnZXQgaW5pdGVkXG4gICAgLy8gc3VjaCBjb2RlIGlzIGV4ZWN1dGVkIGluIHRoZSBzYW1lIG9yZGVyIG9mIGl0cyBtb2RpZmllclxuICAgIC8vIHRoZXkgY291bGQgYWRkIG5ldyBwcm9wZXJ0aWVzIHRvIHRoZWlyIG9wdGlvbnMgY29uZmlndXJhdGlvblxuICAgIC8vIEJFIEFXQVJFOiBkb24ndCBhZGQgb3B0aW9ucyB0byBgb3B0aW9ucy5tb2RpZmllcnMubmFtZWAgYnV0IHRvIGBtb2RpZmllck9wdGlvbnNgIVxuICAgIHRoaXMubW9kaWZpZXJzLmZvckVhY2goZnVuY3Rpb24gKG1vZGlmaWVyT3B0aW9ucykge1xuICAgICAgaWYgKG1vZGlmaWVyT3B0aW9ucy5lbmFibGVkICYmIGlzRnVuY3Rpb24obW9kaWZpZXJPcHRpb25zLm9uTG9hZCkpIHtcbiAgICAgICAgbW9kaWZpZXJPcHRpb25zLm9uTG9hZChfdGhpcy5yZWZlcmVuY2UsIF90aGlzLnBvcHBlciwgX3RoaXMub3B0aW9ucywgbW9kaWZpZXJPcHRpb25zLCBfdGhpcy5zdGF0ZSk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBmaXJlIHRoZSBmaXJzdCB1cGRhdGUgdG8gcG9zaXRpb24gdGhlIHBvcHBlciBpbiB0aGUgcmlnaHQgcGxhY2VcbiAgICB0aGlzLnVwZGF0ZSgpO1xuXG4gICAgdmFyIGV2ZW50c0VuYWJsZWQgPSB0aGlzLm9wdGlvbnMuZXZlbnRzRW5hYmxlZDtcbiAgICBpZiAoZXZlbnRzRW5hYmxlZCkge1xuICAgICAgLy8gc2V0dXAgZXZlbnQgbGlzdGVuZXJzLCB0aGV5IHdpbGwgdGFrZSBjYXJlIG9mIHVwZGF0ZSB0aGUgcG9zaXRpb24gaW4gc3BlY2lmaWMgc2l0dWF0aW9uc1xuICAgICAgdGhpcy5lbmFibGVFdmVudExpc3RlbmVycygpO1xuICAgIH1cblxuICAgIHRoaXMuc3RhdGUuZXZlbnRzRW5hYmxlZCA9IGV2ZW50c0VuYWJsZWQ7XG4gIH1cblxuICAvLyBXZSBjYW4ndCB1c2UgY2xhc3MgcHJvcGVydGllcyBiZWNhdXNlIHRoZXkgZG9uJ3QgZ2V0IGxpc3RlZCBpbiB0aGVcbiAgLy8gY2xhc3MgcHJvdG90eXBlIGFuZCBicmVhayBzdHVmZiBsaWtlIFNpbm9uIHN0dWJzXG5cblxuICBjcmVhdGVDbGFzcyhQb3BwZXIsIFt7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlJCQxKCkge1xuICAgICAgcmV0dXJuIHVwZGF0ZS5jYWxsKHRoaXMpO1xuICAgIH1cbiAgfSwge1xuICAgIGtleTogJ2Rlc3Ryb3knLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBkZXN0cm95JCQxKCkge1xuICAgICAgcmV0dXJuIGRlc3Ryb3kuY2FsbCh0aGlzKTtcbiAgICB9XG4gIH0sIHtcbiAgICBrZXk6ICdlbmFibGVFdmVudExpc3RlbmVycycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGVuYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGVuYWJsZUV2ZW50TGlzdGVuZXJzLmNhbGwodGhpcyk7XG4gICAgfVxuICB9LCB7XG4gICAga2V5OiAnZGlzYWJsZUV2ZW50TGlzdGVuZXJzJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGlzYWJsZUV2ZW50TGlzdGVuZXJzJCQxKCkge1xuICAgICAgcmV0dXJuIGRpc2FibGVFdmVudExpc3RlbmVycy5jYWxsKHRoaXMpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFNjaGVkdWxlIGFuIHVwZGF0ZSwgaXQgd2lsbCBydW4gb24gdGhlIG5leHQgVUkgdXBkYXRlIGF2YWlsYWJsZVxuICAgICAqIEBtZXRob2Qgc2NoZWR1bGVVcGRhdGVcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgICAvKipcbiAgICAgKiBDb2xsZWN0aW9uIG9mIHV0aWxpdGllcyB1c2VmdWwgd2hlbiB3cml0aW5nIGN1c3RvbSBtb2RpZmllcnMuXG4gICAgICogU3RhcnRpbmcgZnJvbSB2ZXJzaW9uIDEuNywgdGhpcyBtZXRob2QgaXMgYXZhaWxhYmxlIG9ubHkgaWYgeW91XG4gICAgICogaW5jbHVkZSBgcG9wcGVyLXV0aWxzLmpzYCBiZWZvcmUgYHBvcHBlci5qc2AuXG4gICAgICpcbiAgICAgKiAqKkRFUFJFQ0FUSU9OKio6IFRoaXMgd2F5IHRvIGFjY2VzcyBQb3BwZXJVdGlscyBpcyBkZXByZWNhdGVkXG4gICAgICogYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2MiEgVXNlIHRoZSBQb3BwZXJVdGlscyBtb2R1bGUgZGlyZWN0bHkgaW5zdGVhZC5cbiAgICAgKiBEdWUgdG8gdGhlIGhpZ2ggaW5zdGFiaWxpdHkgb2YgdGhlIG1ldGhvZHMgY29udGFpbmVkIGluIFV0aWxzLCB3ZSBjYW4ndFxuICAgICAqIGd1YXJhbnRlZSB0aGVtIHRvIGZvbGxvdyBzZW12ZXIuIFVzZSB0aGVtIGF0IHlvdXIgb3duIHJpc2shXG4gICAgICogQHN0YXRpY1xuICAgICAqIEBwcml2YXRlXG4gICAgICogQHR5cGUge09iamVjdH1cbiAgICAgKiBAZGVwcmVjYXRlZCBzaW5jZSB2ZXJzaW9uIDEuOFxuICAgICAqIEBtZW1iZXIgVXRpbHNcbiAgICAgKiBAbWVtYmVyb2YgUG9wcGVyXG4gICAgICovXG5cbiAgfV0pO1xuICByZXR1cm4gUG9wcGVyO1xufSgpO1xuXG4vKipcbiAqIFRoZSBgcmVmZXJlbmNlT2JqZWN0YCBpcyBhbiBvYmplY3QgdGhhdCBwcm92aWRlcyBhbiBpbnRlcmZhY2UgY29tcGF0aWJsZSB3aXRoIFBvcHBlci5qc1xuICogYW5kIGxldHMgeW91IHVzZSBpdCBhcyByZXBsYWNlbWVudCBvZiBhIHJlYWwgRE9NIG5vZGUuPGJyIC8+XG4gKiBZb3UgY2FuIHVzZSB0aGlzIG1ldGhvZCB0byBwb3NpdGlvbiBhIHBvcHBlciByZWxhdGl2ZWx5IHRvIGEgc2V0IG9mIGNvb3JkaW5hdGVzXG4gKiBpbiBjYXNlIHlvdSBkb24ndCBoYXZlIGEgRE9NIG5vZGUgdG8gdXNlIGFzIHJlZmVyZW5jZS5cbiAqXG4gKiBgYGBcbiAqIG5ldyBQb3BwZXIocmVmZXJlbmNlT2JqZWN0LCBwb3BwZXJOb2RlKTtcbiAqIGBgYFxuICpcbiAqIE5COiBUaGlzIGZlYXR1cmUgaXNuJ3Qgc3VwcG9ydGVkIGluIEludGVybmV0IEV4cGxvcmVyIDEwXG4gKiBAbmFtZSByZWZlcmVuY2VPYmplY3RcbiAqIEBwcm9wZXJ0eSB7RnVuY3Rpb259IGRhdGEuZ2V0Qm91bmRpbmdDbGllbnRSZWN0XG4gKiBBIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyBhIHNldCBvZiBjb29yZGluYXRlcyBjb21wYXRpYmxlIHdpdGggdGhlIG5hdGl2ZSBgZ2V0Qm91bmRpbmdDbGllbnRSZWN0YCBtZXRob2QuXG4gKiBAcHJvcGVydHkge251bWJlcn0gZGF0YS5jbGllbnRXaWR0aFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSB3aWR0aCBvZiB0aGUgdmlydHVhbCByZWZlcmVuY2UgZWxlbWVudC5cbiAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBkYXRhLmNsaWVudEhlaWdodFxuICogQW4gRVM2IGdldHRlciB0aGF0IHdpbGwgcmV0dXJuIHRoZSBoZWlnaHQgb2YgdGhlIHZpcnR1YWwgcmVmZXJlbmNlIGVsZW1lbnQuXG4gKi9cblxuUG9wcGVyLlV0aWxzID0gKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogZ2xvYmFsKS5Qb3BwZXJVdGlscztcblBvcHBlci5wbGFjZW1lbnRzID0gcGxhY2VtZW50cztcblBvcHBlci5EZWZhdWx0cyA9IERlZmF1bHRzJDE7XG5cbi8qKlxuKiBSZXR1cm5zIHRoZSBkaXN0YW5jZSB0YWtpbmcgaW50byBhY2NvdW50IHRoZSBkZWZhdWx0IGRpc3RhbmNlIGR1ZSB0b1xuKiB0aGUgdHJhbnNmb3JtOiB0cmFuc2xhdGUgc2V0dGluZyBpbiBDU1NcbiogQHBhcmFtIHtOdW1iZXJ9IGRpc3RhbmNlXG4qIEByZXR1cm4ge1N0cmluZ31cbiovXG5mdW5jdGlvbiBnZXRPZmZzZXREaXN0YW5jZUluUHgoZGlzdGFuY2UpIHtcbiAgcmV0dXJuIC0oZGlzdGFuY2UgLSBEZWZhdWx0cy5kaXN0YW5jZSkgKyAncHgnO1xufVxuXG52YXIgY2xhc3NDYWxsQ2hlY2skMSA9IGZ1bmN0aW9uIChpbnN0YW5jZSwgQ29uc3RydWN0b3IpIHtcbiAgaWYgKCEoaW5zdGFuY2UgaW5zdGFuY2VvZiBDb25zdHJ1Y3RvcikpIHtcbiAgICB0aHJvdyBuZXcgVHlwZUVycm9yKFwiQ2Fubm90IGNhbGwgYSBjbGFzcyBhcyBhIGZ1bmN0aW9uXCIpO1xuICB9XG59O1xuXG52YXIgY3JlYXRlQ2xhc3MkMSA9IGZ1bmN0aW9uICgpIHtcbiAgZnVuY3Rpb24gZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIHByb3BzKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRlc2NyaXB0b3IgPSBwcm9wc1tpXTtcbiAgICAgIGRlc2NyaXB0b3IuZW51bWVyYWJsZSA9IGRlc2NyaXB0b3IuZW51bWVyYWJsZSB8fCBmYWxzZTtcbiAgICAgIGRlc2NyaXB0b3IuY29uZmlndXJhYmxlID0gdHJ1ZTtcbiAgICAgIGlmIChcInZhbHVlXCIgaW4gZGVzY3JpcHRvcikgZGVzY3JpcHRvci53cml0YWJsZSA9IHRydWU7XG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBkZXNjcmlwdG9yLmtleSwgZGVzY3JpcHRvcik7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIChDb25zdHJ1Y3RvciwgcHJvdG9Qcm9wcywgc3RhdGljUHJvcHMpIHtcbiAgICBpZiAocHJvdG9Qcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvci5wcm90b3R5cGUsIHByb3RvUHJvcHMpO1xuICAgIGlmIChzdGF0aWNQcm9wcykgZGVmaW5lUHJvcGVydGllcyhDb25zdHJ1Y3Rvciwgc3RhdGljUHJvcHMpO1xuICAgIHJldHVybiBDb25zdHJ1Y3RvcjtcbiAgfTtcbn0oKTtcblxuXG5cblxuXG5cblxudmFyIF9leHRlbmRzJDEgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxuLyoqXG4qIENyZWF0ZXMgYSBuZXcgcG9wcGVyIGluc3RhbmNlXG4qIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG4qIEByZXR1cm4ge09iamVjdH0gLSB0aGUgcG9wcGVyIGluc3RhbmNlXG4qL1xuZnVuY3Rpb24gY3JlYXRlUG9wcGVySW5zdGFuY2UoZGF0YSkge1xuICB2YXIgZWwgPSBkYXRhLmVsLFxuICAgICAgcG9wcGVyID0gZGF0YS5wb3BwZXIsXG4gICAgICBfZGF0YSRzZXR0aW5ncyA9IGRhdGEuc2V0dGluZ3MsXG4gICAgICBwb3NpdGlvbiA9IF9kYXRhJHNldHRpbmdzLnBvc2l0aW9uLFxuICAgICAgcG9wcGVyT3B0aW9ucyA9IF9kYXRhJHNldHRpbmdzLnBvcHBlck9wdGlvbnMsXG4gICAgICBvZmZzZXQgPSBfZGF0YSRzZXR0aW5ncy5vZmZzZXQsXG4gICAgICBkaXN0YW5jZSA9IF9kYXRhJHNldHRpbmdzLmRpc3RhbmNlLFxuICAgICAgZmxpcER1cmF0aW9uID0gX2RhdGEkc2V0dGluZ3MuZmxpcER1cmF0aW9uO1xuXG4gIHZhciBfZ2V0SW5uZXJFbGVtZW50cyA9IGdldElubmVyRWxlbWVudHMocG9wcGVyKSxcbiAgICAgIHRvb2x0aXAgPSBfZ2V0SW5uZXJFbGVtZW50cy50b29sdGlwO1xuXG4gIHZhciBjb25maWcgPSBfZXh0ZW5kcyQxKHtcbiAgICBwbGFjZW1lbnQ6IHBvc2l0aW9uXG4gIH0sIHBvcHBlck9wdGlvbnMgfHwge30sIHtcbiAgICBtb2RpZmllcnM6IF9leHRlbmRzJDEoe30sIHBvcHBlck9wdGlvbnMgPyBwb3BwZXJPcHRpb25zLm1vZGlmaWVycyA6IHt9LCB7XG4gICAgICBmbGlwOiBfZXh0ZW5kcyQxKHtcbiAgICAgICAgcGFkZGluZzogZGlzdGFuY2UgKyA1IC8qIDVweCBmcm9tIHZpZXdwb3J0IGJvdW5kYXJ5ICovXG4gICAgICB9LCBwb3BwZXJPcHRpb25zICYmIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzID8gcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMuZmxpcCA6IHt9KSxcbiAgICAgIG9mZnNldDogX2V4dGVuZHMkMSh7XG4gICAgICAgIG9mZnNldDogb2Zmc2V0XG4gICAgICB9LCBwb3BwZXJPcHRpb25zICYmIHBvcHBlck9wdGlvbnMubW9kaWZpZXJzID8gcG9wcGVyT3B0aW9ucy5tb2RpZmllcnMub2Zmc2V0IDoge30pXG4gICAgfSksXG4gICAgb25VcGRhdGU6IGZ1bmN0aW9uIG9uVXBkYXRlKCkge1xuICAgICAgdmFyIHN0eWxlcyA9IHRvb2x0aXAuc3R5bGU7XG4gICAgICBzdHlsZXMudG9wID0gJyc7XG4gICAgICBzdHlsZXMuYm90dG9tID0gJyc7XG4gICAgICBzdHlsZXMubGVmdCA9ICcnO1xuICAgICAgc3R5bGVzLnJpZ2h0ID0gJyc7XG4gICAgICBzdHlsZXNbZ2V0Q29yZVBsYWNlbWVudChwb3BwZXIuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpKV0gPSBnZXRPZmZzZXREaXN0YW5jZUluUHgoZGlzdGFuY2UpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gVXBkYXRlIHRoZSBwb3BwZXIncyBwb3NpdGlvbiB3aGVuZXZlciBpdHMgY29udGVudCBjaGFuZ2VzXG4gIC8vIE5vdCBzdXBwb3J0ZWQgaW4gSUUxMCB1bmxlc3MgcG9seWZpbGxlZFxuICBpZiAod2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICB2YXIgc3R5bGVzID0gcG9wcGVyLnN0eWxlO1xuXG4gICAgdmFyIG9ic2VydmVyID0gbmV3IE11dGF0aW9uT2JzZXJ2ZXIoZnVuY3Rpb24gKCkge1xuICAgICAgc3R5bGVzW3ByZWZpeCgndHJhbnNpdGlvbkR1cmF0aW9uJyldID0gJzBtcyc7XG4gICAgICBkYXRhLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgICAgZGVmZXIoZnVuY3Rpb24gKCkge1xuICAgICAgICBzdHlsZXNbcHJlZml4KCd0cmFuc2l0aW9uRHVyYXRpb24nKV0gPSBmbGlwRHVyYXRpb24gKyAnbXMnO1xuICAgICAgfSk7XG4gICAgfSk7XG5cbiAgICBvYnNlcnZlci5vYnNlcnZlKHBvcHBlciwge1xuICAgICAgY2hpbGRMaXN0OiB0cnVlLFxuICAgICAgc3VidHJlZTogdHJ1ZSxcbiAgICAgIGNoYXJhY3RlckRhdGE6IHRydWVcbiAgICB9KTtcblxuICAgIGRhdGEuX211dGF0aW9uT2JzZXJ2ZXJzLnB1c2gob2JzZXJ2ZXIpO1xuICB9XG5cbiAgcmV0dXJuIG5ldyBQb3BwZXIoZWwsIHBvcHBlciwgY29uZmlnKTtcbn1cblxuLyoqXG4qIEFwcGVuZHMgdGhlIHBvcHBlciBhbmQgY3JlYXRlcyBhIHBvcHBlciBpbnN0YW5jZSBpZiBvbmUgZG9lcyBub3QgZXhpc3RcbiogQWxzbyB1cGRhdGVzIGl0cyBwb3NpdGlvbiBpZiBuZWVkIGJlIGFuZCBlbmFibGVzIGV2ZW50IGxpc3RlbmVyc1xuKiBAcGFyYW0ge09iamVjdH0gZGF0YSAtICB0aGUgZWxlbWVudC9wb3BwZXIgcmVmZXJlbmNlIGRhdGFcbiovXG5mdW5jdGlvbiBtb3VudFBvcHBlcihkYXRhKSB7XG4gIHZhciBlbCA9IGRhdGEuZWwsXG4gICAgICBwb3BwZXIgPSBkYXRhLnBvcHBlcixcbiAgICAgIF9kYXRhJHNldHRpbmdzID0gZGF0YS5zZXR0aW5ncyxcbiAgICAgIGFwcGVuZFRvID0gX2RhdGEkc2V0dGluZ3MuYXBwZW5kVG8sXG4gICAgICBmb2xsb3dDdXJzb3IgPSBfZGF0YSRzZXR0aW5ncy5mb2xsb3dDdXJzb3I7XG5cbiAgLy8gQWxyZWFkeSBvbiB0aGUgRE9NXG5cbiAgaWYgKGFwcGVuZFRvLmNvbnRhaW5zKHBvcHBlcikpIHJldHVybjtcblxuICBhcHBlbmRUby5hcHBlbmRDaGlsZChwb3BwZXIpO1xuXG4gIGlmICghZGF0YS5wb3BwZXJJbnN0YW5jZSkge1xuICAgIGRhdGEucG9wcGVySW5zdGFuY2UgPSBjcmVhdGVQb3BwZXJJbnN0YW5jZShkYXRhKTtcbiAgfSBlbHNlIHtcbiAgICBkYXRhLnBvcHBlckluc3RhbmNlLnVwZGF0ZSgpO1xuICAgIGlmICghZm9sbG93Q3Vyc29yIHx8IEJyb3dzZXIudG91Y2gpIHtcbiAgICAgIGRhdGEucG9wcGVySW5zdGFuY2UuZW5hYmxlRXZlbnRMaXN0ZW5lcnMoKTtcbiAgICB9XG4gIH1cblxuICAvLyBTaW5jZSB0b3VjaCBpcyBkZXRlcm1pbmVkIGR5bmFtaWNhbGx5LCBmb2xsb3dDdXJzb3IgaXMgc2V0IG9uIG1vdW50XG4gIGlmIChmb2xsb3dDdXJzb3IgJiYgIUJyb3dzZXIudG91Y2gpIHtcbiAgICBlbC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBmb2xsb3dDdXJzb3JIYW5kbGVyKTtcbiAgICBkYXRhLnBvcHBlckluc3RhbmNlLmRpc2FibGVFdmVudExpc3RlbmVycygpO1xuICB9XG59XG5cbi8qKlxuKiBVcGRhdGVzIGEgcG9wcGVyJ3MgcG9zaXRpb24gb24gZWFjaCBhbmltYXRpb24gZnJhbWUgdG8gbWFrZSBpdCBzdGljayB0byBhIG1vdmluZyBlbGVtZW50XG4qIEBwYXJhbSB7T2JqZWN0fSByZWZEYXRhXG4qL1xuZnVuY3Rpb24gbWFrZVN0aWNreShyZWZEYXRhKSB7XG4gIHZhciBwb3BwZXIgPSByZWZEYXRhLnBvcHBlcixcbiAgICAgIHBvcHBlckluc3RhbmNlID0gcmVmRGF0YS5wb3BwZXJJbnN0YW5jZSxcbiAgICAgIHN0aWNreUR1cmF0aW9uID0gcmVmRGF0YS5zZXR0aW5ncy5zdGlja3lEdXJhdGlvbjtcblxuXG4gIHZhciBhcHBseVRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uIGFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uKCkge1xuICAgIHJldHVybiBwb3BwZXIuc3R5bGVbcHJlZml4KCd0cmFuc2l0aW9uRHVyYXRpb24nKV0gPSBzdGlja3lEdXJhdGlvbiArICdtcyc7XG4gIH07XG5cbiAgdmFyIHJlbW92ZVRyYW5zaXRpb25EdXJhdGlvbiA9IGZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25EdXJhdGlvbigpIHtcbiAgICByZXR1cm4gcG9wcGVyLnN0eWxlW3ByZWZpeCgndHJhbnNpdGlvbkR1cmF0aW9uJyldID0gJyc7XG4gIH07XG5cbiAgdmFyIHVwZGF0ZVBvc2l0aW9uID0gZnVuY3Rpb24gdXBkYXRlUG9zaXRpb24oKSB7XG4gICAgcG9wcGVySW5zdGFuY2UgJiYgcG9wcGVySW5zdGFuY2Uuc2NoZWR1bGVVcGRhdGUoKTtcblxuICAgIGFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uKCk7XG5cbiAgICBpc1Zpc2libGUocG9wcGVyKSA/IHdpbmRvdy5yZXF1ZXN0QW5pbWF0aW9uRnJhbWUodXBkYXRlUG9zaXRpb24pIDogcmVtb3ZlVHJhbnNpdGlvbkR1cmF0aW9uKCk7XG4gIH07XG5cbiAgLy8gV2FpdCB1bnRpbCBQb3BwZXIncyBwb3NpdGlvbiBoYXMgYmVlbiB1cGRhdGVkIGluaXRpYWxseVxuICBkZWZlcih1cGRhdGVQb3NpdGlvbik7XG59XG5cbi8qKlxuKiBSZXR1cm5zIGFuIG9iamVjdCBvZiBzZXR0aW5ncyB0byBvdmVycmlkZSBnbG9iYWwgc2V0dGluZ3NcbiogQHBhcmFtIHtFbGVtZW50fSBlbCAtIHRoZSB0b29sdGlwcGVkIGVsZW1lbnRcbiogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlU2V0dGluZ3NcbiogQHJldHVybiB7T2JqZWN0fSAtIGluZGl2aWR1YWwgc2V0dGluZ3NcbiovXG5mdW5jdGlvbiBnZXRJbmRpdmlkdWFsU2V0dGluZ3MoZWwsIGluc3RhbmNlU2V0dGluZ3MpIHtcbiAgdmFyIHNldHRpbmdzID0gRGVmYXVsdHNLZXlzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcbiAgICB2YXIgdmFsID0gZWwuZ2V0QXR0cmlidXRlKCdkYXRhLScgKyBrZXkudG9Mb3dlckNhc2UoKSkgfHwgaW5zdGFuY2VTZXR0aW5nc1trZXldO1xuXG4gICAgLy8gQ29udmVydCBzdHJpbmdzIHRvIGJvb2xlYW5zXG4gICAgaWYgKHZhbCA9PT0gJ2ZhbHNlJykgdmFsID0gZmFsc2U7XG4gICAgaWYgKHZhbCA9PT0gJ3RydWUnKSB2YWwgPSB0cnVlO1xuXG4gICAgLy8gQ29udmVydCBudW1iZXIgc3RyaW5ncyB0byB0cnVlIG51bWJlcnNcbiAgICBpZiAoaXNGaW5pdGUodmFsKSAmJiAhaXNOYU4ocGFyc2VGbG9hdCh2YWwpKSkge1xuICAgICAgdmFsID0gcGFyc2VGbG9hdCh2YWwpO1xuICAgIH1cblxuICAgIC8vIENvbnZlcnQgYXJyYXkgc3RyaW5ncyB0byBhY3R1YWwgYXJyYXlzXG4gICAgaWYgKHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIHZhbC50cmltKCkuY2hhckF0KDApID09PSAnWycpIHtcbiAgICAgIHZhbCA9IEpTT04ucGFyc2UodmFsKTtcbiAgICB9XG5cbiAgICBhY2Nba2V5XSA9IHZhbDtcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIHt9KTtcblxuICByZXR1cm4gX2V4dGVuZHMkMSh7fSwgaW5zdGFuY2VTZXR0aW5ncywgc2V0dGluZ3MpO1xufVxuXG4vKipcbiogQ3JlYXRlcyBhIHBvcHBlciBlbGVtZW50IHRoZW4gcmV0dXJucyBpdFxuKiBAcGFyYW0ge051bWJlcn0gaWQgLSB0aGUgcG9wcGVyIGlkXG4qIEBwYXJhbSB7U3RyaW5nfSB0aXRsZSAtIHRoZSB0b29sdGlwJ3MgYHRpdGxlYCBhdHRyaWJ1dGVcbiogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIC0gaW5kaXZpZHVhbCBzZXR0aW5nc1xuKiBAcmV0dXJuIHtFbGVtZW50fSAtIHRoZSBwb3BwZXIgZWxlbWVudFxuKi9cbmZ1bmN0aW9uIGNyZWF0ZVBvcHBlckVsZW1lbnQoaWQsIHRpdGxlLCBzZXR0aW5ncykge1xuICB2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbixcbiAgICAgIGRpc3RhbmNlID0gc2V0dGluZ3MuZGlzdGFuY2UsXG4gICAgICBhcnJvdyA9IHNldHRpbmdzLmFycm93LFxuICAgICAgYW5pbWF0ZUZpbGwgPSBzZXR0aW5ncy5hbmltYXRlRmlsbCxcbiAgICAgIGluZXJ0aWEgPSBzZXR0aW5ncy5pbmVydGlhLFxuICAgICAgYW5pbWF0aW9uID0gc2V0dGluZ3MuYW5pbWF0aW9uLFxuICAgICAgYXJyb3dTaXplID0gc2V0dGluZ3MuYXJyb3dTaXplLFxuICAgICAgc2l6ZSA9IHNldHRpbmdzLnNpemUsXG4gICAgICB0aGVtZSA9IHNldHRpbmdzLnRoZW1lLFxuICAgICAgaHRtbCA9IHNldHRpbmdzLmh0bWwsXG4gICAgICB6SW5kZXggPSBzZXR0aW5ncy56SW5kZXgsXG4gICAgICBpbnRlcmFjdGl2ZSA9IHNldHRpbmdzLmludGVyYWN0aXZlO1xuXG5cbiAgdmFyIHBvcHBlciA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBwb3BwZXIuc2V0QXR0cmlidXRlKCdjbGFzcycsICd0aXBweS1wb3BwZXInKTtcbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgncm9sZScsICd0b29sdGlwJyk7XG4gIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcbiAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnaWQnLCAndGlwcHktdG9vbHRpcC0nICsgaWQpO1xuICBwb3BwZXIuc3R5bGUuekluZGV4ID0gekluZGV4O1xuXG4gIHZhciB0b29sdGlwID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdjbGFzcycsICd0aXBweS10b29sdGlwIHRpcHB5LXRvb2x0aXAtLScgKyBzaXplICsgJyBsZWF2ZScpO1xuICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1hbmltYXRpb24nLCBhbmltYXRpb24pO1xuXG4gIHRoZW1lLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAodCkge1xuICAgIHRvb2x0aXAuY2xhc3NMaXN0LmFkZCh0ICsgJy10aGVtZScpO1xuICB9KTtcblxuICBpZiAoYXJyb3cpIHtcbiAgICAvLyBBZGQgYW4gYXJyb3dcbiAgICB2YXIgX2Fycm93ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgX2Fycm93LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAnYXJyb3ctJyArIGFycm93U2l6ZSk7XG4gICAgX2Fycm93LnNldEF0dHJpYnV0ZSgneC1hcnJvdycsICcnKTtcbiAgICB0b29sdGlwLmFwcGVuZENoaWxkKF9hcnJvdyk7XG4gIH1cblxuICBpZiAoYW5pbWF0ZUZpbGwpIHtcbiAgICAvLyBDcmVhdGUgYW5pbWF0ZUZpbGwgY2lyY2xlIGVsZW1lbnQgZm9yIGFuaW1hdGlvblxuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWFuaW1hdGVmaWxsJywgJycpO1xuICAgIHZhciBjaXJjbGUgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjaXJjbGUuc2V0QXR0cmlidXRlKCdjbGFzcycsICdsZWF2ZScpO1xuICAgIGNpcmNsZS5zZXRBdHRyaWJ1dGUoJ3gtY2lyY2xlJywgJycpO1xuICAgIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY2lyY2xlKTtcbiAgfVxuXG4gIGlmIChpbmVydGlhKSB7XG4gICAgLy8gQ2hhbmdlIHRyYW5zaXRpb24gdGltaW5nIGZ1bmN0aW9uIGN1YmljIGJlemllclxuICAgIHRvb2x0aXAuc2V0QXR0cmlidXRlKCdkYXRhLWluZXJ0aWEnLCAnJyk7XG4gIH1cblxuICBpZiAoaW50ZXJhY3RpdmUpIHtcbiAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS1pbnRlcmFjdGl2ZScsICcnKTtcbiAgfVxuXG4gIC8vIFRvb2x0aXAgY29udGVudCAodGV4dCBvciBIVE1MKVxuICB2YXIgY29udGVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBjb250ZW50LnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAndGlwcHktdG9vbHRpcC1jb250ZW50Jyk7XG5cbiAgaWYgKGh0bWwpIHtcbiAgICB2YXIgdGVtcGxhdGVJZCA9IHZvaWQgMDtcblxuICAgIGlmIChodG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgY29udGVudC5hcHBlbmRDaGlsZChodG1sKTtcbiAgICAgIHRlbXBsYXRlSWQgPSAnIycgKyBodG1sLmlkIHx8ICd0aXBweS1odG1sLXRlbXBsYXRlJztcbiAgICB9IGVsc2Uge1xuICAgICAgY29udGVudC5pbm5lckhUTUwgPSBkb2N1bWVudC5nZXRFbGVtZW50QnlJZChodG1sLnJlcGxhY2UoJyMnLCAnJykpLmlubmVySFRNTDtcbiAgICAgIHRlbXBsYXRlSWQgPSBodG1sO1xuICAgIH1cblxuICAgIHBvcHBlci5jbGFzc0xpc3QuYWRkKCdodG1sLXRlbXBsYXRlJyk7XG4gICAgaW50ZXJhY3RpdmUgJiYgcG9wcGVyLnNldEF0dHJpYnV0ZSgndGFiaW5kZXgnLCAnLTEnKTtcbiAgICB0b29sdGlwLnNldEF0dHJpYnV0ZSgnZGF0YS10ZW1wbGF0ZS1pZCcsIHRlbXBsYXRlSWQpO1xuICB9IGVsc2Uge1xuICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gdGl0bGU7XG4gIH1cblxuICAvLyBJbml0IGRpc3RhbmNlLiBGdXJ0aGVyIHVwZGF0ZXMgYXJlIG1hZGUgaW4gdGhlIHBvcHBlciBpbnN0YW5jZSdzIGBvblVwZGF0ZSgpYCBtZXRob2RcbiAgdG9vbHRpcC5zdHlsZVtnZXRDb3JlUGxhY2VtZW50KHBvc2l0aW9uKV0gPSBnZXRPZmZzZXREaXN0YW5jZUluUHgoZGlzdGFuY2UpO1xuXG4gIHRvb2x0aXAuYXBwZW5kQ2hpbGQoY29udGVudCk7XG4gIHBvcHBlci5hcHBlbmRDaGlsZCh0b29sdGlwKTtcblxuICByZXR1cm4gcG9wcGVyO1xufVxuXG4vKipcbiogQ3JlYXRlcyBhIHRyaWdnZXJcbiogQHBhcmFtIHtPYmplY3R9IGV2ZW50IC0gdGhlIGN1c3RvbSBldmVudCBzcGVjaWZpZWQgaW4gdGhlIGB0cmlnZ2VyYCBzZXR0aW5nXG4qIEBwYXJhbSB7RWxlbWVudH0gZWwgLSB0b29sdGlwcGVkIGVsZW1lbnRcbiogQHBhcmFtIHtPYmplY3R9IGhhbmRsZXJzIC0gdGhlIGhhbmRsZXJzIGZvciBlYWNoIGxpc3RlbmVyXG4qIEBwYXJhbSB7Qm9vbGVhbn0gdG91Y2hIb2xkXG4qIEByZXR1cm4ge0FycmF5fSAtIGFycmF5IG9mIGxpc3RlbmVyIG9iamVjdHNcbiovXG5mdW5jdGlvbiBjcmVhdGVUcmlnZ2VyKGV2ZW50LCBlbCwgaGFuZGxlcnMsIHRvdWNoSG9sZCkge1xuICB2YXIgbGlzdGVuZXJzID0gW107XG5cbiAgaWYgKGV2ZW50ID09PSAnbWFudWFsJykgcmV0dXJuIGxpc3RlbmVycztcblxuICAvLyBFbnRlclxuICBlbC5hZGRFdmVudExpc3RlbmVyKGV2ZW50LCBoYW5kbGVycy5oYW5kbGVUcmlnZ2VyKTtcbiAgbGlzdGVuZXJzLnB1c2goe1xuICAgIGV2ZW50OiBldmVudCxcbiAgICBoYW5kbGVyOiBoYW5kbGVycy5oYW5kbGVUcmlnZ2VyXG4gIH0pO1xuXG4gIC8vIExlYXZlXG4gIGlmIChldmVudCA9PT0gJ21vdXNlZW50ZXInKSB7XG4gICAgaWYgKEJyb3dzZXIuU1VQUE9SVFNfVE9VQ0ggJiYgdG91Y2hIb2xkKSB7XG4gICAgICBlbC5hZGRFdmVudExpc3RlbmVyKCd0b3VjaHN0YXJ0JywgaGFuZGxlcnMuaGFuZGxlVHJpZ2dlcik7XG4gICAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICAgIGV2ZW50OiAndG91Y2hzdGFydCcsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzLmhhbmRsZVRyaWdnZXJcbiAgICAgIH0pO1xuICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcigndG91Y2hlbmQnLCBoYW5kbGVycy5oYW5kbGVNb3VzZWxlYXZlKTtcbiAgICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgICAgZXZlbnQ6ICd0b3VjaGVuZCcsXG4gICAgICAgIGhhbmRsZXI6IGhhbmRsZXJzLmhhbmRsZU1vdXNlbGVhdmVcbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlbGVhdmUnLCBoYW5kbGVycy5oYW5kbGVNb3VzZWxlYXZlKTtcbiAgICBsaXN0ZW5lcnMucHVzaCh7XG4gICAgICBldmVudDogJ21vdXNlbGVhdmUnLFxuICAgICAgaGFuZGxlcjogaGFuZGxlcnMuaGFuZGxlTW91c2VsZWF2ZVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKGV2ZW50ID09PSAnZm9jdXMnKSB7XG4gICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignYmx1cicsIGhhbmRsZXJzLmhhbmRsZUJsdXIpO1xuICAgIGxpc3RlbmVycy5wdXNoKHtcbiAgICAgIGV2ZW50OiAnYmx1cicsXG4gICAgICBoYW5kbGVyOiBoYW5kbGVycy5oYW5kbGVCbHVyXG4gICAgfSk7XG4gIH1cblxuICByZXR1cm4gbGlzdGVuZXJzO1xufVxuXG4vKipcbiogRGV0ZXJtaW5lcyBpZiB0aGUgbW91c2UncyBjdXJzb3IgaXMgb3V0c2lkZSB0aGUgaW50ZXJhY3RpdmUgYm9yZGVyXG4qIEBwYXJhbSB7TW91c2VFdmVudH0gZXZlbnRcbiogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXJcbiogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4qIEByZXR1cm4ge0Jvb2xlYW59XG4qL1xuZnVuY3Rpb24gY3Vyc29ySXNPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIoZXZlbnQsIHBvcHBlciwgc2V0dGluZ3MpIHtcbiAgaWYgKCFwb3BwZXIuZ2V0QXR0cmlidXRlKCd4LXBsYWNlbWVudCcpKSByZXR1cm4gdHJ1ZTtcblxuICB2YXIgeCA9IGV2ZW50LmNsaWVudFgsXG4gICAgICB5ID0gZXZlbnQuY2xpZW50WTtcbiAgdmFyIGludGVyYWN0aXZlQm9yZGVyID0gc2V0dGluZ3MuaW50ZXJhY3RpdmVCb3JkZXIsXG4gICAgICBkaXN0YW5jZSA9IHNldHRpbmdzLmRpc3RhbmNlO1xuXG5cbiAgdmFyIHJlY3QgPSBwb3BwZXIuZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gIHZhciBjb3JlUG9zaXRpb24gPSBnZXRDb3JlUGxhY2VtZW50KHBvcHBlci5nZXRBdHRyaWJ1dGUoJ3gtcGxhY2VtZW50JykpO1xuICB2YXIgYm9yZGVyV2l0aERpc3RhbmNlID0gaW50ZXJhY3RpdmVCb3JkZXIgKyBkaXN0YW5jZTtcblxuICB2YXIgZXhjZWVkcyA9IHtcbiAgICB0b3A6IHJlY3QudG9wIC0geSA+IGludGVyYWN0aXZlQm9yZGVyLFxuICAgIGJvdHRvbTogeSAtIHJlY3QuYm90dG9tID4gaW50ZXJhY3RpdmVCb3JkZXIsXG4gICAgbGVmdDogcmVjdC5sZWZ0IC0geCA+IGludGVyYWN0aXZlQm9yZGVyLFxuICAgIHJpZ2h0OiB4IC0gcmVjdC5yaWdodCA+IGludGVyYWN0aXZlQm9yZGVyXG4gIH07XG5cbiAgc3dpdGNoIChjb3JlUG9zaXRpb24pIHtcbiAgICBjYXNlICd0b3AnOlxuICAgICAgZXhjZWVkcy50b3AgPSByZWN0LnRvcCAtIHkgPiBib3JkZXJXaXRoRGlzdGFuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdib3R0b20nOlxuICAgICAgZXhjZWVkcy5ib3R0b20gPSB5IC0gcmVjdC5ib3R0b20gPiBib3JkZXJXaXRoRGlzdGFuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdsZWZ0JzpcbiAgICAgIGV4Y2VlZHMubGVmdCA9IHJlY3QubGVmdCAtIHggPiBib3JkZXJXaXRoRGlzdGFuY2U7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdyaWdodCc6XG4gICAgICBleGNlZWRzLnJpZ2h0ID0geCAtIHJlY3QucmlnaHQgPiBib3JkZXJXaXRoRGlzdGFuY2U7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHJldHVybiBleGNlZWRzLnRvcCB8fCBleGNlZWRzLmJvdHRvbSB8fCBleGNlZWRzLmxlZnQgfHwgZXhjZWVkcy5yaWdodDtcbn1cblxuLyoqXG4qIFJldHVybnMgcmVsZXZhbnQgbGlzdGVuZXIgY2FsbGJhY2tzIGZvciBlYWNoIHJlZlxuKiBAcGFyYW0ge0VsZW1lbnR9IGVsXG4qIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyXG4qIEBwYXJhbSB7T2JqZWN0fSBzZXR0aW5nc1xuKiBAcmV0dXJuIHtPYmplY3R9IC0gcmVsZXZhbnQgbGlzdGVuZXIgaGFuZGxlcnNcbiovXG5mdW5jdGlvbiBnZXRFdmVudExpc3RlbmVySGFuZGxlcnMoZWwsIHBvcHBlciwgc2V0dGluZ3MpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICB2YXIgcG9zaXRpb24gPSBzZXR0aW5ncy5wb3NpdGlvbixcbiAgICAgIGRlbGF5ID0gc2V0dGluZ3MuZGVsYXksXG4gICAgICBkdXJhdGlvbiA9IHNldHRpbmdzLmR1cmF0aW9uLFxuICAgICAgaW50ZXJhY3RpdmUgPSBzZXR0aW5ncy5pbnRlcmFjdGl2ZSxcbiAgICAgIGludGVyYWN0aXZlQm9yZGVyID0gc2V0dGluZ3MuaW50ZXJhY3RpdmVCb3JkZXIsXG4gICAgICBkaXN0YW5jZSA9IHNldHRpbmdzLmRpc3RhbmNlLFxuICAgICAgaGlkZU9uQ2xpY2sgPSBzZXR0aW5ncy5oaWRlT25DbGljayxcbiAgICAgIHRyaWdnZXIgPSBzZXR0aW5ncy50cmlnZ2VyLFxuICAgICAgdG91Y2hIb2xkID0gc2V0dGluZ3MudG91Y2hIb2xkLFxuICAgICAgdG91Y2hXYWl0ID0gc2V0dGluZ3MudG91Y2hXYWl0O1xuXG5cbiAgdmFyIHNob3dEZWxheSA9IHZvaWQgMCxcbiAgICAgIGhpZGVEZWxheSA9IHZvaWQgMDtcblxuICB2YXIgY2xlYXJUaW1lb3V0cyA9IGZ1bmN0aW9uIGNsZWFyVGltZW91dHMoKSB7XG4gICAgY2xlYXJUaW1lb3V0KHNob3dEZWxheSk7XG4gICAgY2xlYXJUaW1lb3V0KGhpZGVEZWxheSk7XG4gIH07XG5cbiAgdmFyIF9zaG93ID0gZnVuY3Rpb24gX3Nob3coKSB7XG4gICAgY2xlYXJUaW1lb3V0cygpO1xuXG4gICAgLy8gTm90IGhpZGRlbi4gRm9yIGNsaWNraW5nIHdoZW4gaXQgYWxzbyBoYXMgYSBgZm9jdXNgIGV2ZW50IGxpc3RlbmVyXG4gICAgaWYgKGlzVmlzaWJsZShwb3BwZXIpKSByZXR1cm47XG5cbiAgICB2YXIgX2RlbGF5ID0gQXJyYXkuaXNBcnJheShkZWxheSkgPyBkZWxheVswXSA6IGRlbGF5O1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBzaG93RGVsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLnNob3cocG9wcGVyKTtcbiAgICAgIH0sIF9kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLnNob3cocG9wcGVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIHNob3cgPSBmdW5jdGlvbiBzaG93KGV2ZW50KSB7XG4gICAgcmV0dXJuIF90aGlzLmNhbGxiYWNrcy53YWl0ID8gX3RoaXMuY2FsbGJhY2tzLndhaXQuY2FsbChwb3BwZXIsIF9zaG93LCBldmVudCkgOiBfc2hvdygpO1xuICB9O1xuXG4gIHZhciBoaWRlID0gZnVuY3Rpb24gaGlkZSgpIHtcbiAgICBjbGVhclRpbWVvdXRzKCk7XG5cbiAgICB2YXIgX2RlbGF5ID0gQXJyYXkuaXNBcnJheShkZWxheSkgPyBkZWxheVsxXSA6IGRlbGF5O1xuXG4gICAgaWYgKGRlbGF5KSB7XG4gICAgICBoaWRlRGVsYXkgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIF90aGlzLmhpZGUocG9wcGVyKTtcbiAgICAgIH0sIF9kZWxheSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIF90aGlzLmhpZGUocG9wcGVyKTtcbiAgICB9XG4gIH07XG5cbiAgdmFyIGhhbmRsZVRyaWdnZXIgPSBmdW5jdGlvbiBoYW5kbGVUcmlnZ2VyKGV2ZW50KSB7XG4gICAgdmFyIG1vdXNlZW50ZXJUb3VjaCA9IGV2ZW50LnR5cGUgPT09ICdtb3VzZWVudGVyJyAmJiBCcm93c2VyLlNVUFBPUlRTX1RPVUNIICYmIEJyb3dzZXIudG91Y2g7XG5cbiAgICBpZiAobW91c2VlbnRlclRvdWNoICYmIHRvdWNoSG9sZCkgcmV0dXJuO1xuXG4gICAgLy8gVG9nZ2xlIHNob3cvaGlkZSB3aGVuIGNsaWNraW5nIGNsaWNrLXRyaWdnZXJlZCB0b29sdGlwc1xuICAgIHZhciBpc0NsaWNrID0gZXZlbnQudHlwZSA9PT0gJ2NsaWNrJztcbiAgICB2YXIgaXNOb3RQZXJzaXN0ZW50ID0gaGlkZU9uQ2xpY2sgIT09ICdwZXJzaXN0ZW50JztcblxuICAgIGlzQ2xpY2sgJiYgaXNWaXNpYmxlKHBvcHBlcikgJiYgaXNOb3RQZXJzaXN0ZW50ID8gaGlkZSgpIDogc2hvdyhldmVudCk7XG5cbiAgICBpZiAobW91c2VlbnRlclRvdWNoICYmIEJyb3dzZXIuaU9TKCkgJiYgZWwuY2xpY2spIHtcbiAgICAgIGVsLmNsaWNrKCk7XG4gICAgfVxuICB9O1xuXG4gIHZhciBoYW5kbGVNb3VzZWxlYXZlID0gZnVuY3Rpb24gaGFuZGxlTW91c2VsZWF2ZShldmVudCkge1xuXG4gICAgLy8gRG9uJ3QgZmlyZSAnbW91c2VsZWF2ZScsIHVzZSB0aGUgJ3RvdWNoZW5kJ1xuICAgIGlmIChldmVudC50eXBlID09PSAnbW91c2VsZWF2ZScgJiYgQnJvd3Nlci5TVVBQT1JUU19UT1VDSCAmJiBCcm93c2VyLnRvdWNoICYmIHRvdWNoSG9sZCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpbnRlcmFjdGl2ZSkge1xuICAgICAgLy8gVGVtcG9yYXJpbHkgaGFuZGxlIG1vdXNlbW92ZSB0byBjaGVjayBpZiB0aGUgbW91c2UgbGVmdCBzb21ld2hlcmVcbiAgICAgIC8vIG90aGVyIHRoYW4gaXRzIHBvcHBlclxuICAgICAgdmFyIGhhbmRsZU1vdXNlbW92ZSA9IGZ1bmN0aW9uIGhhbmRsZU1vdXNlbW92ZShldmVudCkge1xuXG4gICAgICAgIHZhciB0cmlnZ2VySGlkZSA9IGZ1bmN0aW9uIHRyaWdnZXJIaWRlKCkge1xuICAgICAgICAgIGRvY3VtZW50LmJvZHkucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VsZWF2ZScsIGhpZGUpO1xuICAgICAgICAgIGRvY3VtZW50LnJlbW92ZUV2ZW50TGlzdGVuZXIoJ21vdXNlbW92ZScsIGhhbmRsZU1vdXNlbW92ZSk7XG4gICAgICAgICAgaGlkZSgpO1xuICAgICAgICB9O1xuXG4gICAgICAgIHZhciBjbG9zZXN0VG9vbHRpcHBlZEVsID0gY2xvc2VzdChldmVudC50YXJnZXQsIFNlbGVjdG9ycy5UT09MVElQUEVEX0VMKTtcblxuICAgICAgICB2YXIgaXNPdmVyUG9wcGVyID0gY2xvc2VzdChldmVudC50YXJnZXQsIFNlbGVjdG9ycy5QT1BQRVIpID09PSBwb3BwZXI7XG4gICAgICAgIHZhciBpc092ZXJFbCA9IGNsb3Nlc3RUb29sdGlwcGVkRWwgPT09IGVsO1xuICAgICAgICB2YXIgaXNDbGlja1RyaWdnZXJlZCA9IHRyaWdnZXIuaW5kZXhPZignY2xpY2snKSAhPT0gLTE7XG4gICAgICAgIHZhciBpc092ZXJPdGhlclRvb2x0aXBwZWRFbCA9IGNsb3Nlc3RUb29sdGlwcGVkRWwgJiYgY2xvc2VzdFRvb2x0aXBwZWRFbCAhPT0gZWw7XG5cbiAgICAgICAgaWYgKGlzT3Zlck90aGVyVG9vbHRpcHBlZEVsKSB7XG4gICAgICAgICAgcmV0dXJuIHRyaWdnZXJIaWRlKCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNPdmVyUG9wcGVyIHx8IGlzT3ZlckVsIHx8IGlzQ2xpY2tUcmlnZ2VyZWQpIHJldHVybjtcblxuICAgICAgICBpZiAoY3Vyc29ySXNPdXRzaWRlSW50ZXJhY3RpdmVCb3JkZXIoZXZlbnQsIHBvcHBlciwgc2V0dGluZ3MpKSB7XG4gICAgICAgICAgdHJpZ2dlckhpZGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcblxuICAgICAgZG9jdW1lbnQuYm9keS5hZGRFdmVudExpc3RlbmVyKCdtb3VzZWxlYXZlJywgaGlkZSk7XG4gICAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKCdtb3VzZW1vdmUnLCBoYW5kbGVNb3VzZW1vdmUpO1xuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgLy8gSWYgaXQncyBub3QgaW50ZXJhY3RpdmUsIGp1c3QgaGlkZSBpdFxuICAgIGhpZGUoKTtcbiAgfTtcblxuICB2YXIgaGFuZGxlQmx1ciA9IGZ1bmN0aW9uIGhhbmRsZUJsdXIoZXZlbnQpIHtcbiAgICAvLyBJZ25vcmUgYmx1ciBvbiB0b3VjaCBkZXZpY2VzLCBpZiB0aGVyZSBpcyBubyBgcmVsYXRlZFRhcmdldGAsIGhpZGVcbiAgICAvLyBJZiB0aGUgcmVsYXRlZCB0YXJnZXQgaXMgYSBwb3BwZXIsIGlnbm9yZVxuICAgIGlmICghZXZlbnQucmVsYXRlZFRhcmdldCB8fCBCcm93c2VyLnRvdWNoKSByZXR1cm47XG4gICAgaWYgKGNsb3Nlc3QoZXZlbnQucmVsYXRlZFRhcmdldCwgU2VsZWN0b3JzLlBPUFBFUikpIHJldHVybjtcblxuICAgIGhpZGUoKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIGhhbmRsZVRyaWdnZXI6IGhhbmRsZVRyaWdnZXIsXG4gICAgaGFuZGxlTW91c2VsZWF2ZTogaGFuZGxlTW91c2VsZWF2ZSxcbiAgICBoYW5kbGVCbHVyOiBoYW5kbGVCbHVyXG4gIH07XG59XG5cbi8qKlxuKiBFdmFsdWF0ZXMvbW9kaWZpZXMgdGhlIHNldHRpbmdzIG9iamVjdCBmb3IgYXBwcm9wcmlhdGUgYmVoYXZpb3JcbiogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzXG4qIEByZXR1cm4ge09iamVjdH0gbW9kaWZpZWQvZXZhbHVhdGVkIHNldHRpbmdzXG4qL1xuZnVuY3Rpb24gZXZhbHVhdGVTZXR0aW5ncyhzZXR0aW5ncykge1xuICAvLyBhbmltYXRlRmlsbCBpcyBkaXNhYmxlZCBpZiBhbiBhcnJvdyBpcyB0cnVlXG4gIGlmIChzZXR0aW5ncy5hcnJvdykge1xuICAgIHNldHRpbmdzLmFuaW1hdGVGaWxsID0gZmFsc2U7XG4gIH1cblxuICAvLyByZWFzc2lnbiBhcHBlbmRUbyBpbnRvIHRoZSByZXN1bHQgb2YgZXZhbHVhdGluZyBhcHBlbmRUb1xuICAvLyBpZiBpdCdzIHNldCBhcyBhIGZ1bmN0aW9uIGluc3RlYWQgb2YgRWxlbWVudFxuICBpZiAoc2V0dGluZ3MuYXBwZW5kVG8gJiYgdHlwZW9mIHNldHRpbmdzLmFwcGVuZFRvID09PSAnZnVuY3Rpb24nKSB7XG4gICAgc2V0dGluZ3MuYXBwZW5kVG8gPSBzZXR0aW5ncy5hcHBlbmRUbygpO1xuICB9XG5cbiAgcmV0dXJuIHNldHRpbmdzO1xufVxuXG52YXIgaWRDb3VudGVyID0gMTtcblxuLyoqXG4qIENyZWF0ZXMgdG9vbHRpcHMgZm9yIGFsbCBlbCBlbGVtZW50cyB0aGF0IG1hdGNoIHRoZSBpbnN0YW5jZSdzIHNlbGVjdG9yXG4qIEBwYXJhbSB7RWxlbWVudFtdfSBlbHNcbiogQHJldHVybiB7T2JqZWN0W119IEFycmF5IG9mIHJlZiBkYXRhIG9iamVjdHNcbiovXG5mdW5jdGlvbiBjcmVhdGVUb29sdGlwcyhlbHMpIHtcbiAgdmFyIF90aGlzID0gdGhpcztcblxuICByZXR1cm4gZWxzLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBlbCkge1xuICAgIHZhciBpZCA9IGlkQ291bnRlcjtcblxuICAgIHZhciBzZXR0aW5ncyA9IF9leHRlbmRzJDEoe30sIGV2YWx1YXRlU2V0dGluZ3MoX3RoaXMuc2V0dGluZ3MucGVyZm9ybWFuY2UgPyBfdGhpcy5zZXR0aW5ncyA6IGdldEluZGl2aWR1YWxTZXR0aW5ncyhlbCwgX3RoaXMuc2V0dGluZ3MpKSk7XG5cbiAgICBpZiAodHlwZW9mIHNldHRpbmdzLmh0bWwgPT09ICdmdW5jdGlvbicpIHNldHRpbmdzLmh0bWwgPSBzZXR0aW5ncy5odG1sKGVsKTtcblxuICAgIHZhciBodG1sID0gc2V0dGluZ3MuaHRtbCxcbiAgICAgICAgdHJpZ2dlciA9IHNldHRpbmdzLnRyaWdnZXIsXG4gICAgICAgIHRvdWNoSG9sZCA9IHNldHRpbmdzLnRvdWNoSG9sZCxcbiAgICAgICAgZHluYW1pY1RpdGxlID0gc2V0dGluZ3MuZHluYW1pY1RpdGxlO1xuXG5cbiAgICB2YXIgdGl0bGUgPSBlbC5nZXRBdHRyaWJ1dGUoJ3RpdGxlJyk7XG4gICAgaWYgKCF0aXRsZSAmJiAhaHRtbCkgcmV0dXJuIGFjYztcblxuICAgIGVsLnNldEF0dHJpYnV0ZSgnZGF0YS10b29sdGlwcGVkJywgJycpO1xuICAgIGVsLnNldEF0dHJpYnV0ZSgnYXJpYS1kZXNjcmliZWRieScsICd0aXBweS10b29sdGlwLScgKyBpZCk7XG4gICAgcmVtb3ZlVGl0bGUoZWwpO1xuXG4gICAgdmFyIHBvcHBlciA9IGNyZWF0ZVBvcHBlckVsZW1lbnQoaWQsIHRpdGxlLCBzZXR0aW5ncyk7XG4gICAgdmFyIGhhbmRsZXJzID0gZ2V0RXZlbnRMaXN0ZW5lckhhbmRsZXJzLmNhbGwoX3RoaXMsIGVsLCBwb3BwZXIsIHNldHRpbmdzKTtcblxuICAgIHZhciBsaXN0ZW5lcnMgPSBbXTtcblxuICAgIHRyaWdnZXIudHJpbSgpLnNwbGl0KCcgJykuZm9yRWFjaChmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgIHJldHVybiBsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMuY29uY2F0KGNyZWF0ZVRyaWdnZXIoZXZlbnQsIGVsLCBoYW5kbGVycywgdG91Y2hIb2xkKSk7XG4gICAgfSk7XG5cbiAgICAvLyBBZGQgYSBtdXRhdGlvbiBvYnNlcnZlciB0byBvYnNlcnZlIHRoZSByZWZlcmVuY2UgZWxlbWVudCBmb3IgYHRpdGxlYFxuICAgIC8vIGF0dHJpYnV0ZSBjaGFuZ2VzLCB0aGVuIGF1dG9tYXRpY2FsbHkgdXBkYXRlIHRvb2x0aXAgY29udGVudFxuICAgIHZhciBvYnNlcnZlciA9IHZvaWQgMDtcblxuICAgIGlmIChkeW5hbWljVGl0bGUgJiYgd2luZG93Lk11dGF0aW9uT2JzZXJ2ZXIpIHtcbiAgICAgIHZhciBfZ2V0SW5uZXJFbGVtZW50cyA9IGdldElubmVyRWxlbWVudHMocG9wcGVyKSxcbiAgICAgICAgICBjb250ZW50ID0gX2dldElubmVyRWxlbWVudHMuY29udGVudDtcblxuICAgICAgb2JzZXJ2ZXIgPSBuZXcgTXV0YXRpb25PYnNlcnZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aXRsZSA9IGVsLmdldEF0dHJpYnV0ZSgndGl0bGUnKTtcbiAgICAgICAgaWYgKHRpdGxlKSB7XG4gICAgICAgICAgY29udGVudC5pbm5lckhUTUwgPSB0aXRsZTtcbiAgICAgICAgICByZW1vdmVUaXRsZShlbCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBvYnNlcnZlci5vYnNlcnZlKGVsLCB7IGF0dHJpYnV0ZXM6IHRydWUgfSk7XG4gICAgfVxuXG4gICAgYWNjLnB1c2goe1xuICAgICAgaWQ6IGlkLFxuICAgICAgZWw6IGVsLFxuICAgICAgcG9wcGVyOiBwb3BwZXIsXG4gICAgICBzZXR0aW5nczogc2V0dGluZ3MsXG4gICAgICBsaXN0ZW5lcnM6IGxpc3RlbmVycyxcbiAgICAgIHRpcHB5SW5zdGFuY2U6IF90aGlzLFxuICAgICAgX211dGF0aW9uT2JzZXJ2ZXJzOiBbb2JzZXJ2ZXJdXG4gICAgfSk7XG5cbiAgICBpZENvdW50ZXIrKztcblxuICAgIHJldHVybiBhY2M7XG4gIH0sIFtdKTtcbn1cblxuLyogVXRpbGl0eSBmdW5jdGlvbnMgKi9cbi8qIENvcmUgbGlicmFyeSBmdW5jdGlvbnMgKi9cbi8qKlxuKiBAcGFyYW0ge1N0cmluZ3xFbGVtZW50fEVsZW1lbnRbXX0gc2VsZWN0b3JcbiogQHBhcmFtIHtPYmplY3R9IHNldHRpbmdzIChvcHRpb25hbCkgLSB0aGUgb2JqZWN0IG9mIHNldHRpbmdzIHRvIGJlIGFwcGxpZWQgdG8gdGhlIGluc3RhbmNlXG4qL1xuXG52YXIgVGlwcHkgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIFRpcHB5KHNlbGVjdG9yKSB7XG4gICAgdmFyIHNldHRpbmdzID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiB7fTtcbiAgICBjbGFzc0NhbGxDaGVjayQxKHRoaXMsIFRpcHB5KTtcblxuICAgIC8vIFVzZSBkZWZhdWx0IGJyb3dzZXIgdG9vbHRpcCBvbiB1bnN1cHBvcnRlZCBicm93c2Vyc1xuICAgIGlmICghQnJvd3Nlci5TVVBQT1JURUQpIHJldHVybjtcblxuICAgIGluaXQoKTtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBkZXN0cm95ZWQ6IGZhbHNlXG4gICAgfTtcblxuICAgIHRoaXMuc2VsZWN0b3IgPSBzZWxlY3RvcjtcblxuICAgIHRoaXMuc2V0dGluZ3MgPSBfZXh0ZW5kcyQxKHt9LCBEZWZhdWx0cywgc2V0dGluZ3MpO1xuXG4gICAgaWYgKHNldHRpbmdzLnNob3cgfHwgc2V0dGluZ3Muc2hvd24gfHwgc2V0dGluZ3MuaGlkZSB8fCBzZXR0aW5ncy5oaWRkZW4pIHtcbiAgICAgIGNvbnNvbGUud2FybignQ2FsbGJhY2tzIHdpdGhvdXQgdGhlIGBvbmAgcHJlZml4IGFyZSBkZXByZWNhdGVkICh3aXRoIHRoZSBleGNlcHRpb24gb2YgYHdhaXRgKS4nICsgJyBVc2Ugb25TaG93LCBvblNob3duLCBvbkhpZGUsIGFuZCBvbkhpZGRlbiBpbnN0ZWFkLicpO1xuICAgIH1cblxuICAgIHRoaXMuY2FsbGJhY2tzID0ge1xuICAgICAgd2FpdDogc2V0dGluZ3Mud2FpdCxcbiAgICAgIHNob3c6IHNldHRpbmdzLm9uU2hvdyB8fCBzZXR0aW5ncy5zaG93IHx8IG5vb3AsXG4gICAgICBzaG93bjogc2V0dGluZ3Mub25TaG93biB8fCBzZXR0aW5ncy5zaG93biB8fCBub29wLFxuICAgICAgaGlkZTogc2V0dGluZ3Mub25IaWRlIHx8IHNldHRpbmdzLmhpZGUgfHwgbm9vcCxcbiAgICAgIGhpZGRlbjogc2V0dGluZ3Mub25IaWRkZW4gfHwgc2V0dGluZ3MuaGlkZGVuIHx8IG5vb3BcbiAgICB9O1xuXG4gICAgdGhpcy5zdG9yZSA9IGNyZWF0ZVRvb2x0aXBzLmNhbGwodGhpcywgZ2V0QXJyYXlPZkVsZW1lbnRzKHNlbGVjdG9yKSk7XG4gICAgU3RvcmUucHVzaC5hcHBseShTdG9yZSwgdGhpcy5zdG9yZSk7XG4gIH1cblxuICAvKipcbiAgKiBSZXR1cm5zIHRoZSByZWZlcmVuY2UgZWxlbWVudCdzIHBvcHBlciBlbGVtZW50XG4gICogQHBhcmFtIHtFbGVtZW50fSBlbFxuICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICovXG5cblxuICBjcmVhdGVDbGFzcyQxKFRpcHB5LCBbe1xuICAgIGtleTogJ2dldFBvcHBlckVsZW1lbnQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRQb3BwZXJFbGVtZW50KGVsKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmluZCh0aGlzLnN0b3JlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhLmVsID09PSBlbDtcbiAgICAgICAgfSkucG9wcGVyO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBjb25zb2xlLmVycm9yKCdbZ2V0UG9wcGVyRWxlbWVudF06IEVsZW1lbnQgcGFzc2VkIGFzIHRoZSBhcmd1bWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgaW5zdGFuY2UnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgYSBwb3BwZXIncyByZWZlcmVuY2UgZWxlbWVudFxuICAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXJcbiAgICAqIEByZXR1cm4ge0VsZW1lbnR9XG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZ2V0UmVmZXJlbmNlRWxlbWVudCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGdldFJlZmVyZW5jZUVsZW1lbnQocG9wcGVyKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gZmluZCh0aGlzLnN0b3JlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgIHJldHVybiBkYXRhLnBvcHBlciA9PT0gcG9wcGVyO1xuICAgICAgICB9KS5lbDtcbiAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgY29uc29sZS5lcnJvcignW2dldFJlZmVyZW5jZUVsZW1lbnRdOiBQb3BwZXIgcGFzc2VkIGFzIHRoZSBhcmd1bWVudCBkb2VzIG5vdCBleGlzdCBpbiB0aGUgaW5zdGFuY2UnKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvKipcbiAgICAqIFJldHVybnMgdGhlIHJlZmVyZW5jZSBkYXRhIG9iamVjdCBmcm9tIGVpdGhlciB0aGUgcmVmZXJlbmNlIGVsZW1lbnQgb3IgcG9wcGVyIGVsZW1lbnRcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0geCAocmVmZXJlbmNlIGVsZW1lbnQgb3IgcG9wcGVyKVxuICAgICogQHJldHVybiB7T2JqZWN0fVxuICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2dldFJlZmVyZW5jZURhdGEnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXRSZWZlcmVuY2VEYXRhKHgpIHtcbiAgICAgIHJldHVybiBmaW5kKHRoaXMuc3RvcmUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLmVsID09PSB4IHx8IGRhdGEucG9wcGVyID09PSB4O1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBTaG93cyBhIHBvcHBlclxuICAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXN0b21EdXJhdGlvbiAob3B0aW9uYWwpXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2hvdycsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIHNob3cocG9wcGVyLCBjdXN0b21EdXJhdGlvbikge1xuICAgICAgdmFyIF90aGlzID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgIHZhciBkYXRhID0gZmluZCh0aGlzLnN0b3JlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5wb3BwZXIgPT09IHBvcHBlcjtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2dldElubmVyRWxlbWVudHMgPSBnZXRJbm5lckVsZW1lbnRzKHBvcHBlciksXG4gICAgICAgICAgdG9vbHRpcCA9IF9nZXRJbm5lckVsZW1lbnRzLnRvb2x0aXAsXG4gICAgICAgICAgY2lyY2xlID0gX2dldElubmVyRWxlbWVudHMuY2lyY2xlLFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0SW5uZXJFbGVtZW50cy5jb250ZW50O1xuXG4gICAgICAvLyBEZXN0cm95IHBvcHBlciBpZiBpdHMgcmVmZXJlbmNlIGlzIG5vIGxvbmdlciBvbiB0aGUgRE9NIChleGNsdWRpbmcgcmVmT2JqcylcblxuXG4gICAgICBpZiAoIXRoaXMuc2VsZWN0b3IucmVmT2JqICYmICFkb2N1bWVudC5ib2R5LmNvbnRhaW5zKGRhdGEuZWwpKSB7XG4gICAgICAgIHRoaXMuZGVzdHJveShwb3BwZXIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIHRoaXMuY2FsbGJhY2tzLnNob3cuY2FsbChwb3BwZXIpO1xuXG4gICAgICB2YXIgZWwgPSBkYXRhLmVsLFxuICAgICAgICAgIF9kYXRhJHNldHRpbmdzID0gZGF0YS5zZXR0aW5ncyxcbiAgICAgICAgICBhcHBlbmRUbyA9IF9kYXRhJHNldHRpbmdzLmFwcGVuZFRvLFxuICAgICAgICAgIHN0aWNreSA9IF9kYXRhJHNldHRpbmdzLnN0aWNreSxcbiAgICAgICAgICBpbnRlcmFjdGl2ZSA9IF9kYXRhJHNldHRpbmdzLmludGVyYWN0aXZlLFxuICAgICAgICAgIGZvbGxvd0N1cnNvciA9IF9kYXRhJHNldHRpbmdzLmZvbGxvd0N1cnNvcixcbiAgICAgICAgICBmbGlwRHVyYXRpb24gPSBfZGF0YSRzZXR0aW5ncy5mbGlwRHVyYXRpb24sXG4gICAgICAgICAgZHVyYXRpb24gPSBfZGF0YSRzZXR0aW5ncy5kdXJhdGlvbjtcblxuXG4gICAgICB2YXIgX2R1cmF0aW9uID0gY3VzdG9tRHVyYXRpb24gIT09IHVuZGVmaW5lZCA/IGN1c3RvbUR1cmF0aW9uIDogQXJyYXkuaXNBcnJheShkdXJhdGlvbikgPyBkdXJhdGlvblswXSA6IGR1cmF0aW9uO1xuXG4gICAgICAvLyBQcmV2ZW50IGEgdHJhbnNpdGlvbiB3aGVuIHBvcHBlciBjaGFuZ2VzIHBvc2l0aW9uXG4gICAgICBhcHBseVRyYW5zaXRpb25EdXJhdGlvbihbcG9wcGVyLCB0b29sdGlwLCBjaXJjbGVdLCAwKTtcblxuICAgICAgbW91bnRQb3BwZXIoZGF0YSk7XG5cbiAgICAgIHBvcHBlci5zdHlsZS52aXNpYmlsaXR5ID0gJ3Zpc2libGUnO1xuICAgICAgcG9wcGVyLnNldEF0dHJpYnV0ZSgnYXJpYS1oaWRkZW4nLCAnZmFsc2UnKTtcblxuICAgICAgLy8gV2FpdCBmb3IgcG9wcGVyJ3MgcG9zaXRpb24gdG8gdXBkYXRlXG4gICAgICBkZWZlcihmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghaXNWaXNpYmxlKHBvcHBlcikpIHJldHVybjtcblxuICAgICAgICAvLyBTb21ldGltZXMgdGhlIGFycm93IHdpbGwgbm90IGJlIGluIHRoZSBjb3JyZWN0IHBvc2l0aW9uLCBmb3JjZSBhbm90aGVyIHVwZGF0ZVxuICAgICAgICBpZiAoIWZvbGxvd0N1cnNvciB8fCBCcm93c2VyLnRvdWNoKSB7XG4gICAgICAgICAgZGF0YS5wb3BwZXJJbnN0YW5jZS51cGRhdGUoKTtcbiAgICAgICAgICBhcHBseVRyYW5zaXRpb25EdXJhdGlvbihbcG9wcGVyXSwgZmxpcER1cmF0aW9uKTtcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFJlLWFwcGx5IHRyYW5zaXRpb24gZHVyYXRpb25zXG4gICAgICAgIGFwcGx5VHJhbnNpdGlvbkR1cmF0aW9uKFt0b29sdGlwLCBjaXJjbGVdLCBfZHVyYXRpb24pO1xuXG4gICAgICAgIC8vIE1ha2UgY29udGVudCBmYWRlIG91dCBhIGJpdCBmYXN0ZXIgdGhhbiB0aGUgdG9vbHRpcCBpZiBgYW5pbWF0ZUZpbGxgXG4gICAgICAgIGlmIChjaXJjbGUpIGNvbnRlbnQuc3R5bGUub3BhY2l0eSA9IDE7XG5cbiAgICAgICAgLy8gSW50ZXJhY3RpdmUgdG9vbHRpcHMgcmVjZWl2ZSBhIGNsYXNzIG9mICdhY3RpdmUnXG4gICAgICAgIGludGVyYWN0aXZlICYmIGVsLmNsYXNzTGlzdC5hZGQoJ2FjdGl2ZScpO1xuXG4gICAgICAgIC8vIFVwZGF0ZSBwb3BwZXIncyBwb3NpdGlvbiBvbiBldmVyeSBhbmltYXRpb24gZnJhbWVcbiAgICAgICAgc3RpY2t5ICYmIG1ha2VTdGlja3koZGF0YSk7XG5cbiAgICAgICAgLy8gUmVwYWludC9yZWZsb3cgaXMgcmVxdWlyZWQgZm9yIENTUyB0cmFuc2l0aW9uIHdoZW4gYXBwZW5kaW5nXG4gICAgICAgIHRyaWdnZXJSZWZsb3codG9vbHRpcCwgY2lyY2xlKTtcblxuICAgICAgICBtb2RpZnlDbGFzc0xpc3QoW3Rvb2x0aXAsIGNpcmNsZV0sIGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgICAgbGlzdC5jb250YWlucygndGlwcHktbm90cmFuc2l0aW9uJykgJiYgbGlzdC5yZW1vdmUoJ3RpcHB5LW5vdHJhbnNpdGlvbicpO1xuICAgICAgICAgIGxpc3QucmVtb3ZlKCdsZWF2ZScpO1xuICAgICAgICAgIGxpc3QuYWRkKCdlbnRlcicpO1xuICAgICAgICB9KTtcblxuICAgICAgICAvLyBXYWl0IGZvciB0cmFuc2l0aW9ucyB0byBjb21wbGV0ZVxuICAgICAgICBvblRyYW5zaXRpb25FbmQoZGF0YSwgX2R1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgaWYgKCFpc1Zpc2libGUocG9wcGVyKSB8fCBkYXRhLl9vblNob3duRmlyZWQpIHJldHVybjtcblxuICAgICAgICAgIC8vIEZvY3VzIGludGVyYWN0aXZlIHRvb2x0aXBzIG9ubHlcbiAgICAgICAgICBpbnRlcmFjdGl2ZSAmJiBwb3BwZXIuZm9jdXMoKTtcbiAgICAgICAgICAvLyBSZW1vdmUgdHJhbnNpdGlvbnMgZnJvbSB0b29sdGlwXG4gICAgICAgICAgdG9vbHRpcC5jbGFzc0xpc3QuYWRkKCd0aXBweS1ub3RyYW5zaXRpb24nKTtcbiAgICAgICAgICAvLyBQcmV2ZW50cyBzaG93bigpIGZyb20gZmlyaW5nIG1vcmUgdGhhbiBvbmNlIGZyb20gZWFybHkgdHJhbnNpdGlvbiBjYW5jZWxsYXRpb25zXG4gICAgICAgICAgZGF0YS5fb25TaG93bkZpcmVkID0gdHJ1ZTtcblxuICAgICAgICAgIF90aGlzLmNhbGxiYWNrcy5zaG93bi5jYWxsKHBvcHBlcik7XG4gICAgICAgIH0pO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBIaWRlcyBhIHBvcHBlclxuICAgICogQHBhcmFtIHtFbGVtZW50fSBwb3BwZXJcbiAgICAqIEBwYXJhbSB7TnVtYmVyfSBjdXN0b21EdXJhdGlvbiAob3B0aW9uYWwpXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnaGlkZScsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGhpZGUocG9wcGVyLCBjdXN0b21EdXJhdGlvbikge1xuICAgICAgdmFyIF90aGlzMiA9IHRoaXM7XG5cbiAgICAgIGlmICh0aGlzLnN0YXRlLmRlc3Ryb3llZCkgcmV0dXJuO1xuXG4gICAgICB0aGlzLmNhbGxiYWNrcy5oaWRlLmNhbGwocG9wcGVyKTtcblxuICAgICAgdmFyIGRhdGEgPSBmaW5kKHRoaXMuc3RvcmUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnBvcHBlciA9PT0gcG9wcGVyO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBfZ2V0SW5uZXJFbGVtZW50czIgPSBnZXRJbm5lckVsZW1lbnRzKHBvcHBlciksXG4gICAgICAgICAgdG9vbHRpcCA9IF9nZXRJbm5lckVsZW1lbnRzMi50b29sdGlwLFxuICAgICAgICAgIGNpcmNsZSA9IF9nZXRJbm5lckVsZW1lbnRzMi5jaXJjbGUsXG4gICAgICAgICAgY29udGVudCA9IF9nZXRJbm5lckVsZW1lbnRzMi5jb250ZW50O1xuXG4gICAgICB2YXIgZWwgPSBkYXRhLmVsLFxuICAgICAgICAgIF9kYXRhJHNldHRpbmdzMiA9IGRhdGEuc2V0dGluZ3MsXG4gICAgICAgICAgYXBwZW5kVG8gPSBfZGF0YSRzZXR0aW5nczIuYXBwZW5kVG8sXG4gICAgICAgICAgc3RpY2t5ID0gX2RhdGEkc2V0dGluZ3MyLnN0aWNreSxcbiAgICAgICAgICBpbnRlcmFjdGl2ZSA9IF9kYXRhJHNldHRpbmdzMi5pbnRlcmFjdGl2ZSxcbiAgICAgICAgICBmb2xsb3dDdXJzb3IgPSBfZGF0YSRzZXR0aW5nczIuZm9sbG93Q3Vyc29yLFxuICAgICAgICAgIGh0bWwgPSBfZGF0YSRzZXR0aW5nczIuaHRtbCxcbiAgICAgICAgICB0cmlnZ2VyID0gX2RhdGEkc2V0dGluZ3MyLnRyaWdnZXIsXG4gICAgICAgICAgZHVyYXRpb24gPSBfZGF0YSRzZXR0aW5nczIuZHVyYXRpb247XG5cblxuICAgICAgdmFyIF9kdXJhdGlvbiA9IGN1c3RvbUR1cmF0aW9uICE9PSB1bmRlZmluZWQgPyBjdXN0b21EdXJhdGlvbiA6IEFycmF5LmlzQXJyYXkoZHVyYXRpb24pID8gZHVyYXRpb25bMV0gOiBkdXJhdGlvbjtcblxuICAgICAgZGF0YS5fb25TaG93bkZpcmVkID0gZmFsc2U7XG4gICAgICBpbnRlcmFjdGl2ZSAmJiBlbC5jbGFzc0xpc3QucmVtb3ZlKCdhY3RpdmUnKTtcblxuICAgICAgcG9wcGVyLnN0eWxlLnZpc2liaWxpdHkgPSAnaGlkZGVuJztcbiAgICAgIHBvcHBlci5zZXRBdHRyaWJ1dGUoJ2FyaWEtaGlkZGVuJywgJ3RydWUnKTtcblxuICAgICAgYXBwbHlUcmFuc2l0aW9uRHVyYXRpb24oW3Rvb2x0aXAsIGNpcmNsZSwgY2lyY2xlID8gY29udGVudCA6IG51bGxdLCBfZHVyYXRpb24pO1xuXG4gICAgICBpZiAoY2lyY2xlKSBjb250ZW50LnN0eWxlLm9wYWNpdHkgPSAwO1xuXG4gICAgICBtb2RpZnlDbGFzc0xpc3QoW3Rvb2x0aXAsIGNpcmNsZV0sIGZ1bmN0aW9uIChsaXN0KSB7XG4gICAgICAgIGxpc3QuY29udGFpbnMoJ3RpcHB5LXRvb2x0aXAnKSAmJiBsaXN0LnJlbW92ZSgndGlwcHktbm90cmFuc2l0aW9uJyk7XG4gICAgICAgIGxpc3QucmVtb3ZlKCdlbnRlcicpO1xuICAgICAgICBsaXN0LmFkZCgnbGVhdmUnKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZS1mb2N1cyBjbGljay10cmlnZ2VyZWQgaHRtbCBlbGVtZW50c1xuICAgICAgLy8gYW5kIHRoZSB0b29sdGlwcGVkIGVsZW1lbnQgSVMgaW4gdGhlIHZpZXdwb3J0IChvdGhlcndpc2UgaXQgY2F1c2VzIHVuc2lnaHRseSBzY3JvbGxpbmdcbiAgICAgIC8vIGlmIHRoZSB0b29sdGlwIGlzIGNsb3NlZCBhbmQgdGhlIGVsZW1lbnQgaXNuJ3QgaW4gdGhlIHZpZXdwb3J0IGFueW1vcmUpXG4gICAgICBpZiAoaHRtbCAmJiB0cmlnZ2VyLmluZGV4T2YoJ2NsaWNrJykgIT09IC0xICYmIGVsZW1lbnRJc0luVmlld3BvcnQoZWwpKSB7XG4gICAgICAgIGVsLmZvY3VzKCk7XG4gICAgICB9XG5cbiAgICAgIC8vIFdhaXQgZm9yIHRyYW5zaXRpb25zIHRvIGNvbXBsZXRlXG4gICAgICBvblRyYW5zaXRpb25FbmQoZGF0YSwgX2R1cmF0aW9uLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8vIGBpc1Zpc2libGVgIGlzIG5vdCBjb21wbGV0ZWx5IHJlbGlhYmxlIHRvIGRldGVybWluZSBpZiB3ZSBzaG91bGRuJ3RcbiAgICAgICAgLy8gcnVuIHRoZSBoaWRkZW4gY2FsbGJhY2ssIHdlIG5lZWQgdG8gY2hlY2sgdGhlIGNvbXB1dGVkIG9wYWNpdHkgc3R5bGUuXG4gICAgICAgIC8vIFRoaXMgcHJldmVudHMgZ2xpdGNoeSBiZWhhdmlvciBvZiB0aGUgdHJhbnNpdGlvbiB3aGVuIHF1aWNrbHkgc2hvd2luZ1xuICAgICAgICAvLyBhbmQgaGlkaW5nIGEgdG9vbHRpcC5cbiAgICAgICAgaWYgKGlzVmlzaWJsZShwb3BwZXIpIHx8ICFhcHBlbmRUby5jb250YWlucyhwb3BwZXIpIHx8IGdldENvbXB1dGVkU3R5bGUodG9vbHRpcCkub3BhY2l0eSA9PT0gJzEnKSByZXR1cm47XG5cbiAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2Vtb3ZlJywgZm9sbG93Q3Vyc29ySGFuZGxlcik7XG4gICAgICAgIGRhdGEucG9wcGVySW5zdGFuY2UuZGlzYWJsZUV2ZW50TGlzdGVuZXJzKCk7XG4gICAgICAgIGFwcGVuZFRvLnJlbW92ZUNoaWxkKHBvcHBlcik7XG5cbiAgICAgICAgX3RoaXMyLmNhbGxiYWNrcy5oaWRkZW4uY2FsbChwb3BwZXIpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgKiBVcGRhdGVzIGEgcG9wcGVyIHdpdGggbmV3IGNvbnRlbnRcbiAgICAqIEBwYXJhbSB7RWxlbWVudH0gcG9wcGVyXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAndXBkYXRlJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gdXBkYXRlKHBvcHBlcikge1xuICAgICAgaWYgKHRoaXMuc3RhdGUuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgIHZhciBkYXRhID0gZmluZCh0aGlzLnN0b3JlLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICByZXR1cm4gZGF0YS5wb3BwZXIgPT09IHBvcHBlcjtcbiAgICAgIH0pO1xuXG4gICAgICB2YXIgX2dldElubmVyRWxlbWVudHMzID0gZ2V0SW5uZXJFbGVtZW50cyhwb3BwZXIpLFxuICAgICAgICAgIGNvbnRlbnQgPSBfZ2V0SW5uZXJFbGVtZW50czMuY29udGVudDtcblxuICAgICAgdmFyIGVsID0gZGF0YS5lbCxcbiAgICAgICAgICBodG1sID0gZGF0YS5zZXR0aW5ncy5odG1sO1xuXG5cbiAgICAgIGlmIChodG1sIGluc3RhbmNlb2YgRWxlbWVudCkge1xuICAgICAgICBjb25zb2xlLndhcm4oJ0Fib3J0ZWQ6IHVwZGF0ZSgpIHNob3VsZCBub3QgYmUgdXNlZCBpZiBgaHRtbGAgaXMgYSBET00gZWxlbWVudCcpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIGNvbnRlbnQuaW5uZXJIVE1MID0gaHRtbCA/IGRvY3VtZW50LmdldEVsZW1lbnRCeUlkKGh0bWwucmVwbGFjZSgnIycsICcnKSkuaW5uZXJIVE1MIDogZWwuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpO1xuXG4gICAgICBpZiAoIWh0bWwpIHJlbW92ZVRpdGxlKGVsKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAqIERlc3Ryb3lzIGEgcG9wcGVyXG4gICAgKiBAcGFyYW0ge0VsZW1lbnR9IHBvcHBlclxuICAgICogQHBhcmFtIHtCb29sZWFufSBfaXNMYXN0IC0gcHJpdmF0ZSBwYXJhbSB1c2VkIGJ5IGRlc3Ryb3lBbGwgdG8gb3B0aW1pemVcbiAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdkZXN0cm95JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZGVzdHJveShwb3BwZXIsIF9pc0xhc3QpIHtcbiAgICAgIHZhciBfdGhpczMgPSB0aGlzO1xuXG4gICAgICBpZiAodGhpcy5zdGF0ZS5kZXN0cm95ZWQpIHJldHVybjtcblxuICAgICAgdmFyIGRhdGEgPSBmaW5kKHRoaXMuc3RvcmUsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgIHJldHVybiBkYXRhLnBvcHBlciA9PT0gcG9wcGVyO1xuICAgICAgfSk7XG5cbiAgICAgIHZhciBlbCA9IGRhdGEuZWwsXG4gICAgICAgICAgcG9wcGVySW5zdGFuY2UgPSBkYXRhLnBvcHBlckluc3RhbmNlLFxuICAgICAgICAgIGxpc3RlbmVycyA9IGRhdGEubGlzdGVuZXJzLFxuICAgICAgICAgIF9tdXRhdGlvbk9ic2VydmVycyA9IGRhdGEuX211dGF0aW9uT2JzZXJ2ZXJzO1xuXG4gICAgICAvLyBFbnN1cmUgdGhlIHBvcHBlciBpcyBoaWRkZW5cblxuICAgICAgaWYgKGlzVmlzaWJsZShwb3BwZXIpKSB7XG4gICAgICAgIHRoaXMuaGlkZShwb3BwZXIsIDApO1xuICAgICAgfVxuXG4gICAgICAvLyBSZW1vdmUgVGlwcHktb25seSBldmVudCBsaXN0ZW5lcnMgZnJvbSB0b29sdGlwcGVkIGVsZW1lbnRcbiAgICAgIGxpc3RlbmVycy5mb3JFYWNoKGZ1bmN0aW9uIChsaXN0ZW5lcikge1xuICAgICAgICByZXR1cm4gZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihsaXN0ZW5lci5ldmVudCwgbGlzdGVuZXIuaGFuZGxlcik7XG4gICAgICB9KTtcblxuICAgICAgLy8gUmVzdG9yZSBvcmlnaW5hbCB0aXRsZVxuICAgICAgZWwuc2V0QXR0cmlidXRlKCd0aXRsZScsIGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1vcmlnaW5hbC10aXRsZScpKTtcblxuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdkYXRhLW9yaWdpbmFsLXRpdGxlJyk7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2RhdGEtdG9vbHRpcHBlZCcpO1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKCdhcmlhLWRlc2NyaWJlZGJ5Jyk7XG5cbiAgICAgIHBvcHBlckluc3RhbmNlICYmIHBvcHBlckluc3RhbmNlLmRlc3Ryb3koKTtcblxuICAgICAgX211dGF0aW9uT2JzZXJ2ZXJzLmZvckVhY2goZnVuY3Rpb24gKG9ic2VydmVyKSB7XG4gICAgICAgIG9ic2VydmVyICYmIG9ic2VydmVyLmRpc2Nvbm5lY3QoKTtcbiAgICAgIH0pO1xuXG4gICAgICAvLyBSZW1vdmUgZnJvbSBzdG9yZVxuICAgICAgU3RvcmUuc3BsaWNlKGZpbmRJbmRleChTdG9yZSwgZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgcmV0dXJuIGRhdGEucG9wcGVyID09PSBwb3BwZXI7XG4gICAgICB9KSwgMSk7XG5cbiAgICAgIC8vIEVuc3VyZSBmaWx0ZXIgaXMgY2FsbGVkIG9ubHkgb25jZVxuICAgICAgaWYgKF9pc0xhc3QgPT09IHVuZGVmaW5lZCB8fCBfaXNMYXN0KSB7XG4gICAgICAgIHRoaXMuc3RvcmUgPSBTdG9yZS5maWx0ZXIoZnVuY3Rpb24gKGRhdGEpIHtcbiAgICAgICAgICByZXR1cm4gZGF0YS50aXBweUluc3RhbmNlID09PSBfdGhpczM7XG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICogRGVzdHJveXMgYWxsIHRvb2x0aXBzIGNyZWF0ZWQgYnkgdGhlIGluc3RhbmNlXG4gICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnZGVzdHJveUFsbCcsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIGRlc3Ryb3lBbGwoKSB7XG4gICAgICB2YXIgX3RoaXM0ID0gdGhpcztcblxuICAgICAgaWYgKHRoaXMuc3RhdGUuZGVzdHJveWVkKSByZXR1cm47XG5cbiAgICAgIHZhciBzdG9yZUxlbmd0aCA9IHRoaXMuc3RvcmUubGVuZ3RoO1xuXG4gICAgICB0aGlzLnN0b3JlLmZvckVhY2goZnVuY3Rpb24gKF9yZWYsIGluZGV4KSB7XG4gICAgICAgIHZhciBwb3BwZXIgPSBfcmVmLnBvcHBlcjtcblxuICAgICAgICBfdGhpczQuZGVzdHJveShwb3BwZXIsIGluZGV4ID09PSBzdG9yZUxlbmd0aCAtIDEpO1xuICAgICAgfSk7XG5cbiAgICAgIHRoaXMuc3RvcmUgPSBudWxsO1xuICAgICAgdGhpcy5zdGF0ZS5kZXN0cm95ZWQgPSB0cnVlO1xuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gVGlwcHk7XG59KCk7XG5cbmZ1bmN0aW9uIHRpcHB5JDIoc2VsZWN0b3IsIHNldHRpbmdzKSB7XG4gIC8vIENyZWF0ZSBhIHZpcnR1YWwgb2JqZWN0IGZvciBjdXN0b20gcG9zaXRpb25pbmdcbiAgaWYgKGlzT2JqZWN0TGl0ZXJhbChzZWxlY3RvcikpIHtcbiAgICBzZWxlY3RvciA9IHtcbiAgICAgIHJlZk9iajogdHJ1ZSxcbiAgICAgIGF0dHJpYnV0ZXM6IHNlbGVjdG9yLmF0dHJpYnV0ZXMgfHwge30sXG4gICAgICBnZXRCb3VuZGluZ0NsaWVudFJlY3Q6IHNlbGVjdG9yLmdldEJvdW5kaW5nQ2xpZW50UmVjdCxcbiAgICAgIGNsaWVudFdpZHRoOiBzZWxlY3Rvci5jbGllbnRXaWR0aCxcbiAgICAgIGNsaWVudEhlaWdodDogc2VsZWN0b3IuY2xpZW50SGVpZ2h0LFxuICAgICAgc2V0QXR0cmlidXRlOiBmdW5jdGlvbiBzZXRBdHRyaWJ1dGUoa2V5LCB2YWwpIHtcbiAgICAgICAgc2VsZWN0b3IuYXR0cmlidXRlc1trZXldID0gdmFsO1xuICAgICAgfSxcbiAgICAgIGdldEF0dHJpYnV0ZTogZnVuY3Rpb24gZ2V0QXR0cmlidXRlKGtleSkge1xuICAgICAgICByZXR1cm4gc2VsZWN0b3IuYXR0cmlidXRlc1trZXldO1xuICAgICAgfSxcbiAgICAgIHJlbW92ZUF0dHJpYnV0ZTogZnVuY3Rpb24gcmVtb3ZlQXR0cmlidXRlKGtleSkge1xuICAgICAgICBkZWxldGUgc2VsZWN0b3IuYXR0cmlidXRlc1trZXldO1xuICAgICAgfSxcbiAgICAgIGFkZEV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIGFkZEV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgICAgIHJlbW92ZUV2ZW50TGlzdGVuZXI6IGZ1bmN0aW9uIHJlbW92ZUV2ZW50TGlzdGVuZXIoKSB7fSxcbiAgICAgIGNsYXNzTGlzdDoge1xuICAgICAgICBjbGFzc05hbWVzOiB7fSxcbiAgICAgICAgYWRkOiBmdW5jdGlvbiBhZGQoa2V5KSB7XG4gICAgICAgICAgc2VsZWN0b3IuY2xhc3NMaXN0LmNsYXNzTmFtZXNba2V5XSA9IHRydWU7XG4gICAgICAgIH0sXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKGtleSkge1xuICAgICAgICAgIHNlbGVjdG9yLmNsYXNzTGlzdC5jbGFzc05hbWVzW2tleV0gPSBmYWxzZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfSxcbiAgICAgICAgY29udGFpbnM6IGZ1bmN0aW9uIGNvbnRhaW5zKGtleSkge1xuICAgICAgICAgIHJldHVybiAhIXNlbGVjdG9yLmNsYXNzTGlzdC5jbGFzc05hbWVzW2tleV07XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9O1xuICB9XG5cbiAgcmV0dXJuIG5ldyBUaXBweShzZWxlY3Rvciwgc2V0dGluZ3MpO1xufVxuXG50aXBweSQyLkJyb3dzZXIgPSBCcm93c2VyO1xudGlwcHkkMi5EZWZhdWx0cyA9IERlZmF1bHRzO1xudGlwcHkkMi5kaXNhYmxlRHluYW1pY0lucHV0RGV0ZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gQnJvd3Nlci5keW5hbWljSW5wdXREZXRlY3Rpb24gPSBmYWxzZTtcbn07XG50aXBweSQyLmVuYWJsZUR5bmFtaWNJbnB1dERldGVjdGlvbiA9IGZ1bmN0aW9uICgpIHtcbiAgcmV0dXJuIEJyb3dzZXIuZHluYW1pY0lucHV0RGV0ZWN0aW9uID0gdHJ1ZTtcbn07XG5cbnJldHVybiB0aXBweSQyO1xuXG59KSkpO1xuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3RpcHB5LmpzL2Rpc3QvdGlwcHkuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxuZnVuY3Rpb24gaW5qZWN0U3R5bGUgKHNzckNvbnRleHQpIHtcbiAgaWYgKGRpc3Bvc2VkKSByZXR1cm5cbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYWZhYWJkNzBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOnRydWV9IS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vSWNvbi52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj97XFxcImNhY2hlRGlyZWN0b3J5XFxcIjp0cnVlLFxcXCJwcmVzZXRzXFxcIjpbW1xcXCJlbnZcXFwiLHtcXFwibW9kdWxlc1xcXCI6ZmFsc2UsXFxcInRhcmdldHNcXFwiOntcXFwiYnJvd3NlcnNcXFwiOltcXFwiPiAyJVxcXCJdLFxcXCJ1Z2xpZnlcXFwiOnRydWV9fV1dLFxcXCJwbHVnaW5zXFxcIjpbXFxcInRyYW5zZm9ybS1vYmplY3QtcmVzdC1zcHJlYWRcXFwiLFtcXFwidHJhbnNmb3JtLXJ1bnRpbWVcXFwiLHtcXFwicG9seWZpbGxcXFwiOmZhbHNlLFxcXCJoZWxwZXJzXFxcIjpmYWxzZX1dXX0hLi4vLi4vdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9JY29uLnZ1ZVwiKVxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhLi4vLi4vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi1hZmFhYmQ3MFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL0ljb24udnVlXCIpXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBudWxsXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtYWZhYWJkNzBcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1hZmFhYmQ3MFwiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImFyY2hpdmVcIjp7XCJ3aWR0aFwiOjE3OTIsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTEwODggODMycTAtMjYtMTktNDV0LTQ1LTE5aC0yNTZxLTI2IDAtNDUgMTl0LTE5IDQ1IDE5IDQ1IDQ1IDE5aDI1NnEyNiAwIDQ1LTE5dDE5LTQ1ek0xNjY0IDY0MHY5NjBxMCAyNi0xOSA0NXQtNDUgMTloLTE0MDhxLTI2IDAtNDUtMTl0LTE5LTQ1di05NjBxMC0yNiAxOS00NXQ0NS0xOWgxNDA4cTI2IDAgNDUgMTl0MTkgNDV6TTE3MjggMTkydjI1NnEwIDI2LTE5IDQ1dC00NSAxOWgtMTUzNnEtMjYgMC00NS0xOXQtMTktNDV2LTI1NnEwLTI2IDE5LTQ1dDQ1LTE5aDE1MzZxMjYgMCA0NSAxOXQxOSA0NXpcIn1dfX0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvYXJjaGl2ZS5qcyIsImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wiZmlsZS1vXCI6e1wid2lkdGhcIjoxNTM2LFwiaGVpZ2h0XCI6MTc5MixcInBhdGhzXCI6W3tcImRcIjpcIk0xNDY4IDM4MHEyOCAyOCA0OCA3NnQyMCA4OHYxMTUycTAgNDAtMjggNjh0LTY4IDI4aC0xMzQ0cS00MCAwLTY4LTI4dC0yOC02OHYtMTYwMHEwLTQwIDI4LTY4dDY4LTI4aDg5NnE0MCAwIDg4IDIwdDc2IDQ4ek0xMDI0IDEzNnYzNzZoMzc2cS0xMC0yOS0yMi00MWwtMzEzLTMxM3EtMTItMTItNDEtMjJ6TTE0MDggMTY2NHYtMTAyNGgtNDE2cS00MCAwLTY4LTI4dC0yOC02OHYtNDE2aC03Njh2MTUzNmgxMjgwelwifV19fSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtYXdlc29tZS9pY29ucy9maWxlLW8uanMiLCJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcImZpbGVcIjp7XCJ3aWR0aFwiOjE1MzYsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTEwMjQgNTEydi00NzJxMjIgMTQgMzYgMjhsNDA4IDQwOHExNCAxNCAyOCAzNmgtNDcyek04OTYgNTQ0cTAgNDAgMjggNjh0NjggMjhoNTQ0djEwNTZxMCA0MC0yOCA2OHQtNjggMjhoLTEzNDRxLTQwIDAtNjgtMjh0LTI4LTY4di0xNjAwcTAtNDAgMjgtNjh0NjgtMjhoODAwdjU0NHpcIn1dfX0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvZmlsZS5qcyIsImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wiZmlsZXMtb1wiOntcIndpZHRoXCI6MTc5MixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMTY5NiAzODRxNDAgMCA2OCAyOHQyOCA2OHYxMjE2cTAgNDAtMjggNjh0LTY4IDI4aC05NjBxLTQwIDAtNjgtMjh0LTI4LTY4di0yODhoLTU0NHEtNDAgMC02OC0yOHQtMjgtNjh2LTY3MnEwLTQwIDIwLTg4dDQ4LTc2bDQwOC00MDhxMjgtMjggNzYtNDh0ODgtMjBoNDE2cTQwIDAgNjggMjh0MjggNjh2MzI4cTY4LTQwIDEyOC00MGg0MTZ6TTExNTIgNTk3bC0yOTkgMjk5aDI5OXYtMjk5ek01MTIgMjEzbC0yOTkgMjk5aDI5OXYtMjk5ek03MDggODYwbDMxNi0zMTZ2LTQxNmgtMzg0djQxNnEwIDQwLTI4IDY4dC02OCAyOGgtNDE2djY0MGg1MTJ2LTI1NnEwLTQwIDIwLTg4dDQ4LTc2ek0xNjY0IDE2NjR2LTExNTJoLTM4NHY0MTZxMCA0MC0yOCA2OHQtNjggMjhoLTQxNnY2NDBoODk2elwifV19fSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtYXdlc29tZS9pY29ucy9maWxlcy1vLmpzIiwiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJmb2xkZXJcIjp7XCJ3aWR0aFwiOjE2NjQsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTE2NjQgNjA4djcwNHEwIDkyLTY2IDE1OHQtMTU4IDY2aC0xMjE2cS05MiAwLTE1OC02NnQtNjYtMTU4di05NjBxMC05MiA2Ni0xNTh0MTU4LTY2aDMyMHE5MiAwIDE1OCA2NnQ2NiAxNTh2MzJoNjcycTkyIDAgMTU4IDY2dDY2IDE1OHpcIn1dfX0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvZm9sZGVyLmpzIiwiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJnbG9iZVwiOntcIndpZHRoXCI6MTUzNixcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNNzY4IDEyOHEyMDkgMCAzODUuNSAxMDN0Mjc5LjUgMjc5LjUgMTAzIDM4NS41LTEwMyAzODUuNS0yNzkuNSAyNzkuNS0zODUuNSAxMDMtMzg1LjUtMTAzLTI3OS41LTI3OS41LTEwMy0zODUuNSAxMDMtMzg1LjUgMjc5LjUtMjc5LjUgMzg1LjUtMTAzek0xMDQyIDY0OXEtMiAxLTkuNSA5LjV0LTEzLjUgOS41cTIgMCA0LjUtNXQ1LTExIDMuNS03cTYtNyAyMi0xNSAxNC02IDUyLTEyIDM0LTggNTEgMTEtMi0yIDkuNS0xM3QxNC41LTEycTMtMiAxNS00LjV0MTUtNy41bDItMjJxLTEyIDEtMTcuNS03dC02LjUtMjFxMCAyLTYgOCAwLTctNC41LTh0LTExLjUgMS05IDFxLTEwLTMtMTUtNy41dC04LTE2LjUtNC0xNXEtMi01LTkuNS0xMXQtOS41LTEwcS0xLTItMi41LTUuNXQtMy02LjUtNC01LjUtNS41LTIuNS03IDUtNy41IDEwLTQuNSA1cS0zLTItNi0xLjV0LTQuNSAxLTQuNSAzLTUgMy41cS0zIDItOC41IDN0LTguNSAycTE1LTUtMS0xMS0xMC00LTE2LTMgOS00IDcuNS0xMnQtOC41LTE0aDVxLTEtNC04LjUtOC41dC0xNy41LTguNS0xMy02cS04LTUtMzQtOS41dC0zMy0wLjVxLTUgNi00LjUgMTAuNXQ0IDE0IDMuNSAxMi41cTEgNi01LjUgMTN0LTYuNSAxMnEwIDcgMTQgMTUuNXQxMCAyMS41cS0zIDgtMTYgMTZ0LTE2IDEycS01IDgtMS41IDE4LjV0MTAuNSAxNi41cTIgMiAxLjUgNHQtMy41IDQuNS01LjUgNC02LjUgMy41bC0zIDJxLTExIDUtMjAuNS02dC0xMy41LTI2cS03LTI1LTE2LTMwLTIzLTgtMjkgMS01LTEzLTQxLTI2LTI1LTktNTgtNCA2LTEgMC0xNS03LTE1LTE5LTEyIDMtNiA0LTE3LjV0MS0xMy41cTMtMTMgMTItMjMgMS0xIDctOC41dDkuNS0xMy41IDAuNS02cTM1IDQgNTAtMTEgNS01IDExLjUtMTd0MTAuNS0xN3E5LTYgMTQtNS41dDE0LjUgNS41IDE0LjUgNXExNCAxIDE1LjUtMTF0LTcuNS0yMHExMiAxIDMtMTctNC03LTgtOS0xMi00LTI3IDUtOCA0IDIgOC0xLTEtOS41IDEwLjV0LTE2LjUgMTcuNS0xNi01cS0xLTEtNS41LTEzLjV0LTkuNS0xMy41cS04IDAtMTYgMTUgMy04LTExLTE1dC0yNC04cTE5LTEyLTgtMjctNy00LTIwLjUtNXQtMTkuNSA0cS01IDctNS41IDExLjV0NSA4IDEwLjUgNS41IDExLjUgNCA4LjUgM3ExNCAxMCA4IDE0LTIgMS04LjUgMy41dC0xMS41IDQuNS02IDRxLTMgNCAwIDE0dC0yIDE0cS01LTUtOS0xNy41dC03LTE2LjVxNyA5LTI1IDZsLTEwLTFxLTQgMC0xNiAydC0yMC41IDEtMTMuNS04cS00LTggMC0yMCAxLTQgNC0yLTQtMy0xMS05LjV0LTEwLTguNXEtNDYgMTUtOTQgNDEgNiAxIDEyLTEgNS0yIDEzLTYuNXQxMC01LjVxMzQtMTQgNDItN2w1LTVxMTQgMTYgMjAgMjUtNy00LTMwLTEtMjAgNi0yMiAxMiA3IDEyIDUgMTgtNC0zLTExLjUtMTB0LTE0LjUtMTEtMTUtNXEtMTYgMC0yMiAxLTE0NiA4MC0yMzUgMjIyIDcgNyAxMiA4IDQgMSA1IDl0Mi41IDExIDExLjUtM3E5IDggMyAxOSAxLTEgNDQgMjcgMTkgMTcgMjEgMjEgMyAxMS0xMCAxOC0xLTItOS05dC05LTRxLTMgNSAwLjUgMTguNXQxMC41IDEyLjVxLTcgMC05LjUgMTZ0LTIuNSAzNS41LTEgMjMuNWwyIDFxLTMgMTIgNS41IDM0LjV0MjEuNSAxOS41cS0xMyAzIDIwIDQzIDYgOCA4IDkgMyAyIDEyIDcuNXQxNSAxMCAxMCAxMC41cTQgNSAxMCAyMi41dDE0IDIzLjVxLTIgNiA5LjUgMjB0MTAuNSAyM3EtMSAwLTIuNSAxdC0yLjUgMXEzIDcgMTUuNSAxNHQxNS41IDEzcTEgMyAyIDEwdDMgMTEgOCAycTItMjAtMjQtNjItMTUtMjUtMTctMjktMy01LTUuNS0xNS41dC00LjUtMTQuNXEyIDAgNiAxLjV0OC41IDMuNSA3LjUgNCAyIDNxLTMgNyAyIDE3LjV0MTIgMTguNSAxNyAxOSAxMiAxM3E2IDYgMTQgMTkuNXQwIDEzLjVxOSAwIDIwIDEwLjV0MTcgMTkuNXE1IDggOCAyNnQ1IDI0cTIgNyA4LjUgMTMuNXQxMi41IDkuNWwxNiA4dDEzIDdxNSAyIDE4LjUgMTAuNXQyMS41IDExLjVxMTAgNCAxNiA0dDE0LjUtMi41IDEzLjUtMy41cTE1LTIgMjkgMTV0MjEgMjFxMzYgMTkgNTUgMTEtMiAxIDAuNSA3LjV0OCAxNS41IDkgMTQuNSA1LjUgOC41cTUgNiAxOCAxNXQxOCAxNXE2LTQgNy05LTMgOCA3IDIwdDE4IDEwcTE0LTMgMTQtMzItMzEgMTUtNDktMTggMC0xLTIuNS01LjV0LTQtOC41LTIuNS04LjUgMC03LjUgNS0zcTkgMCAxMC0zLjV0LTItMTIuNS00LTEzcS0xLTgtMTEtMjB0LTEyLTE1cS01IDktMTYgOHQtMTYtOXEwIDEtMS41IDUuNXQtMS41IDYuNXEtMTMgMC0xNS0xIDEtMyAyLjUtMTcuNXQzLjUtMjIuNXExLTQgNS41LTEydDcuNS0xNC41IDQtMTIuNS00LjUtOS41LTE3LjUtMi41cS0xOSAxLTI2IDIwLTEgMy0zIDEwLjV0LTUgMTEuNS05IDdxLTcgMy0yNCAydC0yNC01cS0xMy04LTIyLjUtMjl0LTkuNS0zN3EwLTEwIDIuNS0yNi41dDMtMjUtNS41LTI0LjVxMy0yIDktOS41dDEwLTEwLjVxMi0xIDQuNS0xLjV0NC41IDAgNC0xLjUgMy02cS0xLTEtNC0zLTMtMy00LTMgNyAzIDI4LjUtMS41dDI3LjUgMS41cTE1IDExIDIyLTIgMC0xLTIuNS05LjV0LTAuNS0xMy41cTUgMjcgMjkgOSAzIDMgMTUuNSA1dDE3LjUgNXEzIDIgNyA1LjV0NS41IDQuNSA1LTAuNSA4LjUtNi41cTEwIDE0IDEyIDI0IDExIDQwIDE5IDQ0IDcgMyAxMSAydDQuNS05LjUgMC0xNC0xLjUtMTIuNWwtMS04di0xOGwtMS04cS0xNS0zLTE4LjUtMTJ0MS41LTE4LjUgMTUtMTguNXExLTEgOC0zLjV0MTUuNS02LjUgMTIuNS04cTIxLTE5IDE1LTM1IDcgMCAxMS05LTEgMC01LTN0LTcuNS01LTQuNS0ycTktNSAyLTE2IDUtMyA3LjUtMTF0Ny41LTEwcTkgMTIgMjEgMiA4LTggMS0xNiA1LTcgMjAuNS0xMC41dDE4LjUtOS41cTcgMiA4LTJ0MS0xMiAzLTEycTQtNSAxNS05dDEzLTVsMTctMTFxMy00IDAtNCAxOCAyIDMxLTExIDEwLTExLTYtMjAgMy02LTMtOS41dC0xNS01LjVxMy0xIDExLjUtMC41dDEwLjUtMS41cTE1LTEwLTctMTYtMTctNS00MyAxMnpNODc5IDE1MjZxMjA2LTM2IDM1MS0xODktMy0zLTEyLjUtNC41dC0xMi41LTMuNXEtMTgtNy0yNC04IDEtNy0yLjUtMTN0LTgtOS0xMi41LTgtMTEtN3EtMi0yLTctNnQtNy01LjUtNy41LTQuNS04LjUtMi0xMCAxbC0zIDFxLTMgMS01LjUgMi41dC01LjUgMy00IDMgMCAyLjVxLTIxLTE3LTM2LTIyLTUtMS0xMS01LjV0LTEwLjUtNy0xMC0xLjUtMTEuNSA3cS01IDUtNiAxNXQtMiAxM3EtNy01IDAtMTcuNXQyLTE4LjVxLTMtNi0xMC41LTQuNXQtMTIgNC41LTExLjUgOC41LTkgNi41LTguNSA1LjUtOC41IDcuNXEtMyA0LTYgMTJ0LTUgMTFxLTItNC0xMS41LTYuNXQtOS41LTUuNXEyIDEwIDQgMzV0NSAzOHE3IDMxLTEyIDQ4LTI3IDI1LTI5IDQwLTQgMjIgMTIgMjYgMCA3LTggMjAuNXQtNyAyMS41cTAgNiAyIDE2elwifV19fSlcblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtYXdlc29tZS9pY29ucy9nbG9iZS5qcyIsImltcG9ydCBJY29uIGZyb20gJy4uL2NvbXBvbmVudHMvSWNvbi52dWUnXG5cbkljb24ucmVnaXN0ZXIoe1wia2V5Ym9hcmQtb1wiOntcIndpZHRoXCI6MTkyMCxcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMzg0IDExNjh2OTZxMCAxNi0xNiAxNmgtOTZxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoOTZxMTYgMCAxNiAxNnpNNTEyIDkxMnY5NnEwIDE2LTE2IDE2aC0yMjRxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoMjI0cTE2IDAgMTYgMTZ6TTM4NCA2NTZ2OTZxMCAxNi0xNiAxNmgtOTZxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoOTZxMTYgMCAxNiAxNnpNMTQwOCAxMTY4djk2cTAgMTYtMTYgMTZoLTg2NHEtMTYgMC0xNi0xNnYtOTZxMC0xNiAxNi0xNmg4NjRxMTYgMCAxNiAxNnpNNzY4IDkxMnY5NnEwIDE2LTE2IDE2aC05NnEtMTYgMC0xNi0xNnYtOTZxMC0xNiAxNi0xNmg5NnExNiAwIDE2IDE2ek02NDAgNjU2djk2cTAgMTYtMTYgMTZoLTk2cS0xNiAwLTE2LTE2di05NnEwLTE2IDE2LTE2aDk2cTE2IDAgMTYgMTZ6TTEwMjQgOTEydjk2cTAgMTYtMTYgMTZoLTk2cS0xNiAwLTE2LTE2di05NnEwLTE2IDE2LTE2aDk2cTE2IDAgMTYgMTZ6TTg5NiA2NTZ2OTZxMCAxNi0xNiAxNmgtOTZxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoOTZxMTYgMCAxNiAxNnpNMTI4MCA5MTJ2OTZxMCAxNi0xNiAxNmgtOTZxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoOTZxMTYgMCAxNiAxNnpNMTY2NCAxMTY4djk2cTAgMTYtMTYgMTZoLTk2cS0xNiAwLTE2LTE2di05NnEwLTE2IDE2LTE2aDk2cTE2IDAgMTYgMTZ6TTExNTIgNjU2djk2cTAgMTYtMTYgMTZoLTk2cS0xNiAwLTE2LTE2di05NnEwLTE2IDE2LTE2aDk2cTE2IDAgMTYgMTZ6TTE0MDggNjU2djk2cTAgMTYtMTYgMTZoLTk2cS0xNiAwLTE2LTE2di05NnEwLTE2IDE2LTE2aDk2cTE2IDAgMTYgMTZ6TTE2NjQgNjU2djM1MnEwIDE2LTE2IDE2aC0yMjRxLTE2IDAtMTYtMTZ2LTk2cTAtMTYgMTYtMTZoMTEydi0yNDBxMC0xNiAxNi0xNmg5NnExNiAwIDE2IDE2ek0xNzkyIDE0MDh2LTg5NmgtMTY2NHY4OTZoMTY2NHpNMTkyMCA1MTJ2ODk2cTAgNTMtMzcuNSA5MC41dC05MC41IDM3LjVoLTE2NjRxLTUzIDAtOTAuNS0zNy41dC0zNy41LTkwLjV2LTg5NnEwLTUzIDM3LjUtOTAuNXQ5MC41LTM3LjVoMTY2NHE1MyAwIDkwLjUgMzcuNXQzNy41IDkwLjV6XCJ9XX19KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2ljb25zL2tleWJvYXJkLW8uanMiLCJpbXBvcnQgSWNvbiBmcm9tICcuLi9jb21wb25lbnRzL0ljb24udnVlJ1xuXG5JY29uLnJlZ2lzdGVyKHtcInFyY29kZVwiOntcIndpZHRoXCI6MTQwOCxcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNMzg0IDExNTJ2MTI4aC0xMjh2LTEyOGgxMjh6TTM4NCAzODR2MTI4aC0xMjh2LTEyOGgxMjh6TTExNTIgMzg0djEyOGgtMTI4di0xMjhoMTI4ek0xMjggMTQwN2gzODR2LTM4M2gtMzg0djM4M3pNMTI4IDY0MGgzODR2LTM4NGgtMzg0djM4NHpNODk2IDY0MGgzODR2LTM4NGgtMzg0djM4NHpNNjQwIDg5NnY2NDBoLTY0MHYtNjQwaDY0MHpNMTE1MiAxNDA4djEyOGgtMTI4di0xMjhoMTI4ek0xNDA4IDE0MDh2MTI4aC0xMjh2LTEyOGgxMjh6TTE0MDggODk2djM4NGgtMzg0di0xMjhoLTEyOHYzODRoLTEyOHYtNjQwaDM4NHYxMjhoMTI4di0xMjhoMTI4ek02NDAgMTI4djY0MGgtNjQwdi02NDBoNjQwek0xNDA4IDEyOHY2NDBoLTY0MHYtNjQwaDY0MHpcIn1dfX0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvcXJjb2RlLmpzIiwiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJzZWFyY2hcIjp7XCJ3aWR0aFwiOjE2NjQsXCJoZWlnaHRcIjoxNzkyLFwicGF0aHNcIjpbe1wiZFwiOlwiTTExNTIgODMycTAtMTg1LTEzMS41LTMxNi41dC0zMTYuNS0xMzEuNS0zMTYuNSAxMzEuNS0xMzEuNSAzMTYuNSAxMzEuNSAzMTYuNSAzMTYuNSAxMzEuNSAzMTYuNS0xMzEuNSAxMzEuNS0zMTYuNXpNMTY2NCAxNjY0cTAgNTItMzggOTB0LTkwIDM4cS01NCAwLTkwLTM4bC0zNDMtMzQycS0xNzkgMTI0LTM5OSAxMjQtMTQzIDAtMjczLjUtNTUuNXQtMjI1LTE1MC0xNTAtMjI1LTU1LjUtMjczLjUgNTUuNS0yNzMuNSAxNTAtMjI1IDIyNS0xNTAgMjczLjUtNTUuNSAyNzMuNSA1NS41IDIyNSAxNTAgMTUwIDIyNSA1NS41IDI3My41cTAgMjIwLTEyNCAzOTlsMzQzIDM0M3EzNyAzNyAzNyA5MHpcIn1dfX0pXG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvaWNvbnMvc2VhcmNoLmpzIiwiaW1wb3J0IEljb24gZnJvbSAnLi4vY29tcG9uZW50cy9JY29uLnZ1ZSdcblxuSWNvbi5yZWdpc3Rlcih7XCJ0cmFzaFwiOntcIndpZHRoXCI6MTQwOCxcImhlaWdodFwiOjE3OTIsXCJwYXRoc1wiOlt7XCJkXCI6XCJNNTEyIDEzNzZ2LTcwNHEwLTE0LTktMjN0LTIzLTloLTY0cS0xNCAwLTIzIDl0LTkgMjN2NzA0cTAgMTQgOSAyM3QyMyA5aDY0cTE0IDAgMjMtOXQ5LTIzek03NjggMTM3NnYtNzA0cTAtMTQtOS0yM3QtMjMtOWgtNjRxLTE0IDAtMjMgOXQtOSAyM3Y3MDRxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMy05dDktMjN6TTEwMjQgMTM3NnYtNzA0cTAtMTQtOS0yM3QtMjMtOWgtNjRxLTE0IDAtMjMgOXQtOSAyM3Y3MDRxMCAxNCA5IDIzdDIzIDloNjRxMTQgMCAyMy05dDktMjN6TTQ4MCAzODRoNDQ4bC00OC0xMTdxLTctOS0xNy0xMWgtMzE3cS0xMCAyLTE3IDExek0xNDA4IDQxNnY2NHEwIDE0LTkgMjN0LTIzIDloLTk2djk0OHEwIDgzLTQ3IDE0My41dC0xMTMgNjAuNWgtODMycS02NiAwLTExMy01OC41dC00Ny0xNDEuNXYtOTUyaC05NnEtMTQgMC0yMy05dC05LTIzdi02NHEwLTE0IDktMjN0MjMtOWgzMDlsNzAtMTY3cTE1LTM3IDU0LTYzdDc5LTI2aDMyMHE0MCAwIDc5IDI2dDU0IDYzbDcwIDE2N2gzMDlxMTQgMCAyMyA5dDkgMjN6XCJ9XX19KVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2ljb25zL3RyYXNoLmpzIiwidmFyIENsaXBib2FyZCA9IHJlcXVpcmUoJ2NsaXBib2FyZCcpXG5cbnZhciBWdWVDbGlwYm9hcmQgPSB7XG4gIGluc3RhbGw6IGZ1bmN0aW9uIChWdWUpIHtcbiAgICBWdWUucHJvdG90eXBlLiRjb3B5VGV4dCA9IGZ1bmN0aW9uICh0ZXh0KSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgZmFrZV9lbCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2J1dHRvbicpO1xuICAgICAgICB2YXIgY2xpcGJvYXJkID0gbmV3IENsaXBib2FyZChmYWtlX2VsLCB7XG4gICAgICAgICAgdGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gdGV4dCB9LFxuICAgICAgICAgIGFjdGlvbjogZnVuY3Rpb24gKCkgeyByZXR1cm4gJ2NvcHknIH1cbiAgICAgICAgfSk7XG4gICAgICAgIGNsaXBib2FyZC5vbignc3VjY2VzcycsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY2xpcGJvYXJkLmRlc3Ryb3koKTtcbiAgICAgICAgICByZXNvbHZlKGUpO1xuICAgICAgICB9KTtcbiAgICAgICAgY2xpcGJvYXJkLm9uKCdlcnJvcicsIGZ1bmN0aW9uIChlKSB7XG4gICAgICAgICAgY2xpcGJvYXJkLmRlc3Ryb3koKTtcbiAgICAgICAgICByZWplY3QoZSk7XG4gICAgICAgIH0pO1xuICAgICAgICBmYWtlX2VsLmNsaWNrKCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgVnVlLmRpcmVjdGl2ZSgnY2xpcGJvYXJkJywge1xuICAgICAgYmluZDogZnVuY3Rpb24gKGVsLCBiaW5kaW5nLCB2bm9kZSkge1xuICAgICAgICBpZihiaW5kaW5nLmFyZyA9PT0gJ3N1Y2Nlc3MnKSB7XG4gICAgICAgICAgZWwuX3ZfY2xpcGJvYXJkX3N1Y2Nlc3MgPSBiaW5kaW5nLnZhbHVlXG4gICAgICAgIH0gZWxzZSBpZihiaW5kaW5nLmFyZyA9PT0gJ2Vycm9yJykge1xuICAgICAgICAgIGVsLl92X2NsaXBib2FyZF9lcnJvciA9IGJpbmRpbmcudmFsdWVcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgY2xpcGJvYXJkID0gbmV3IENsaXBib2FyZChlbCwge1xuICAgICAgICAgICAgdGV4dDogZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZGluZy52YWx1ZSB9LFxuICAgICAgICAgICAgYWN0aW9uOiBmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5kaW5nLmFyZyA9PT0gJ2N1dCcgPyAnY3V0JyA6ICdjb3B5JyB9XG4gICAgICAgICAgfSlcbiAgICAgICAgICBjbGlwYm9hcmQub24oJ3N1Y2Nlc3MnLCBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgICAgdmFyIGNhbGxiYWNrID0gZWwuX3ZfY2xpcGJvYXJkX3N1Y2Nlc3NcbiAgICAgICAgICAgIGNhbGxiYWNrICYmIGNhbGxiYWNrKGUpXG4gICAgICAgICAgfSlcbiAgICAgICAgICBjbGlwYm9hcmQub24oJ2Vycm9yJywgZnVuY3Rpb24gKGUpIHtcbiAgICAgICAgICAgIHZhciBjYWxsYmFjayA9IGVsLl92X2NsaXBib2FyZF9lcnJvclxuICAgICAgICAgICAgY2FsbGJhY2sgJiYgY2FsbGJhY2soZSlcbiAgICAgICAgICB9KVxuICAgICAgICAgIGVsLl92X2NsaXBib2FyZCA9IGNsaXBib2FyZFxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdXBkYXRlOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgaWYoYmluZGluZy5hcmcgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgIGVsLl92X2NsaXBib2FyZF9zdWNjZXNzID0gYmluZGluZy52YWx1ZVxuICAgICAgICB9IGVsc2UgaWYoYmluZGluZy5hcmcgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBlbC5fdl9jbGlwYm9hcmRfZXJyb3IgPSBiaW5kaW5nLnZhbHVlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuX3ZfY2xpcGJvYXJkLnRleHQgPSBmdW5jdGlvbiAoKSB7IHJldHVybiBiaW5kaW5nLnZhbHVlIH1cbiAgICAgICAgICBlbC5fdl9jbGlwYm9hcmQuYWN0aW9uID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gYmluZGluZy5hcmcgPT09ICdjdXQnID8gJ2N1dCcgOiAnY29weScgfVxuICAgICAgICB9XG4gICAgICB9LFxuICAgICAgdW5iaW5kOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcpIHtcbiAgICAgICAgaWYoYmluZGluZy5hcmcgPT09ICdzdWNjZXNzJykge1xuICAgICAgICAgIGRlbGV0ZSBlbC5fdl9jbGlwYm9hcmRfc3VjY2Vzc1xuICAgICAgICB9IGVsc2UgaWYoYmluZGluZy5hcmcgPT09ICdlcnJvcicpIHtcbiAgICAgICAgICBkZWxldGUgZWwuX3ZfY2xpcGJvYXJkX2Vycm9yXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZWwuX3ZfY2xpcGJvYXJkLmRlc3Ryb3koKVxuICAgICAgICAgIGRlbGV0ZSBlbC5fdl9jbGlwYm9hcmRcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0pXG4gIH1cbn1cblxuaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSBWdWVDbGlwYm9hcmRcbn0gZWxzZSBpZiAodHlwZW9mIGRlZmluZSA9PSBcImZ1bmN0aW9uXCIgJiYgZGVmaW5lLmFtZCkge1xuICBkZWZpbmUoW10sIGZ1bmN0aW9uKCkge1xuICAgIHJldHVybiBWdWVDbGlwYm9hcmRcbiAgfSlcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtY2xpcGJvYXJkMi92dWUtY2xpcGJvYXJkLmpzIiwiLyogZ2xvYmFscyBfX1ZVRV9TU1JfQ09OVEVYVF9fICovXG5cbi8vIElNUE9SVEFOVDogRG8gTk9UIHVzZSBFUzIwMTUgZmVhdHVyZXMgaW4gdGhpcyBmaWxlLlxuLy8gVGhpcyBtb2R1bGUgaXMgYSBydW50aW1lIHV0aWxpdHkgZm9yIGNsZWFuZXIgY29tcG9uZW50IG1vZHVsZSBvdXRwdXQgYW5kIHdpbGxcbi8vIGJlIGluY2x1ZGVkIGluIHRoZSBmaW5hbCB3ZWJwYWNrIHVzZXIgYnVuZGxlLlxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZUNvbXBvbmVudCAoXG4gIHJhd1NjcmlwdEV4cG9ydHMsXG4gIGNvbXBpbGVkVGVtcGxhdGUsXG4gIGZ1bmN0aW9uYWxUZW1wbGF0ZSxcbiAgaW5qZWN0U3R5bGVzLFxuICBzY29wZUlkLFxuICBtb2R1bGVJZGVudGlmaWVyIC8qIHNlcnZlciBvbmx5ICovXG4pIHtcbiAgdmFyIGVzTW9kdWxlXG4gIHZhciBzY3JpcHRFeHBvcnRzID0gcmF3U2NyaXB0RXhwb3J0cyA9IHJhd1NjcmlwdEV4cG9ydHMgfHwge31cblxuICAvLyBFUzYgbW9kdWxlcyBpbnRlcm9wXG4gIHZhciB0eXBlID0gdHlwZW9mIHJhd1NjcmlwdEV4cG9ydHMuZGVmYXVsdFxuICBpZiAodHlwZSA9PT0gJ29iamVjdCcgfHwgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGVzTW9kdWxlID0gcmF3U2NyaXB0RXhwb3J0c1xuICAgIHNjcmlwdEV4cG9ydHMgPSByYXdTY3JpcHRFeHBvcnRzLmRlZmF1bHRcbiAgfVxuXG4gIC8vIFZ1ZS5leHRlbmQgY29uc3RydWN0b3IgZXhwb3J0IGludGVyb3BcbiAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygc2NyaXB0RXhwb3J0cyA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gc2NyaXB0RXhwb3J0cy5vcHRpb25zXG4gICAgOiBzY3JpcHRFeHBvcnRzXG5cbiAgLy8gcmVuZGVyIGZ1bmN0aW9uc1xuICBpZiAoY29tcGlsZWRUZW1wbGF0ZSkge1xuICAgIG9wdGlvbnMucmVuZGVyID0gY29tcGlsZWRUZW1wbGF0ZS5yZW5kZXJcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGNvbXBpbGVkVGVtcGxhdGUuc3RhdGljUmVuZGVyRm5zXG4gICAgb3B0aW9ucy5fY29tcGlsZWQgPSB0cnVlXG4gIH1cblxuICAvLyBmdW5jdGlvbmFsIHRlbXBsYXRlXG4gIGlmIChmdW5jdGlvbmFsVGVtcGxhdGUpIHtcbiAgICBvcHRpb25zLmZ1bmN0aW9uYWwgPSB0cnVlXG4gIH1cblxuICAvLyBzY29wZWRJZFxuICBpZiAoc2NvcGVJZCkge1xuICAgIG9wdGlvbnMuX3Njb3BlSWQgPSBzY29wZUlkXG4gIH1cblxuICB2YXIgaG9va1xuICBpZiAobW9kdWxlSWRlbnRpZmllcikgeyAvLyBzZXJ2ZXIgYnVpbGRcbiAgICBob29rID0gZnVuY3Rpb24gKGNvbnRleHQpIHtcbiAgICAgIC8vIDIuMyBpbmplY3Rpb25cbiAgICAgIGNvbnRleHQgPVxuICAgICAgICBjb250ZXh0IHx8IC8vIGNhY2hlZCBjYWxsXG4gICAgICAgICh0aGlzLiR2bm9kZSAmJiB0aGlzLiR2bm9kZS5zc3JDb250ZXh0KSB8fCAvLyBzdGF0ZWZ1bFxuICAgICAgICAodGhpcy5wYXJlbnQgJiYgdGhpcy5wYXJlbnQuJHZub2RlICYmIHRoaXMucGFyZW50LiR2bm9kZS5zc3JDb250ZXh0KSAvLyBmdW5jdGlvbmFsXG4gICAgICAvLyAyLjIgd2l0aCBydW5Jbk5ld0NvbnRleHQ6IHRydWVcbiAgICAgIGlmICghY29udGV4dCAmJiB0eXBlb2YgX19WVUVfU1NSX0NPTlRFWFRfXyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgY29udGV4dCA9IF9fVlVFX1NTUl9DT05URVhUX19cbiAgICAgIH1cbiAgICAgIC8vIGluamVjdCBjb21wb25lbnQgc3R5bGVzXG4gICAgICBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgICAgIGluamVjdFN0eWxlcy5jYWxsKHRoaXMsIGNvbnRleHQpXG4gICAgICB9XG4gICAgICAvLyByZWdpc3RlciBjb21wb25lbnQgbW9kdWxlIGlkZW50aWZpZXIgZm9yIGFzeW5jIGNodW5rIGluZmVycmVuY2VcbiAgICAgIGlmIChjb250ZXh0ICYmIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzKSB7XG4gICAgICAgIGNvbnRleHQuX3JlZ2lzdGVyZWRDb21wb25lbnRzLmFkZChtb2R1bGVJZGVudGlmaWVyKVxuICAgICAgfVxuICAgIH1cbiAgICAvLyB1c2VkIGJ5IHNzciBpbiBjYXNlIGNvbXBvbmVudCBpcyBjYWNoZWQgYW5kIGJlZm9yZUNyZWF0ZVxuICAgIC8vIG5ldmVyIGdldHMgY2FsbGVkXG4gICAgb3B0aW9ucy5fc3NyUmVnaXN0ZXIgPSBob29rXG4gIH0gZWxzZSBpZiAoaW5qZWN0U3R5bGVzKSB7XG4gICAgaG9vayA9IGluamVjdFN0eWxlc1xuICB9XG5cbiAgaWYgKGhvb2spIHtcbiAgICB2YXIgZnVuY3Rpb25hbCA9IG9wdGlvbnMuZnVuY3Rpb25hbFxuICAgIHZhciBleGlzdGluZyA9IGZ1bmN0aW9uYWxcbiAgICAgID8gb3B0aW9ucy5yZW5kZXJcbiAgICAgIDogb3B0aW9ucy5iZWZvcmVDcmVhdGVcblxuICAgIGlmICghZnVuY3Rpb25hbCkge1xuICAgICAgLy8gaW5qZWN0IGNvbXBvbmVudCByZWdpc3RyYXRpb24gYXMgYmVmb3JlQ3JlYXRlIGhvb2tcbiAgICAgIG9wdGlvbnMuYmVmb3JlQ3JlYXRlID0gZXhpc3RpbmdcbiAgICAgICAgPyBbXS5jb25jYXQoZXhpc3RpbmcsIGhvb2spXG4gICAgICAgIDogW2hvb2tdXG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGZvciB0ZW1wbGF0ZS1vbmx5IGhvdC1yZWxvYWQgYmVjYXVzZSBpbiB0aGF0IGNhc2UgdGhlIHJlbmRlciBmbiBkb2Vzbid0XG4gICAgICAvLyBnbyB0aHJvdWdoIHRoZSBub3JtYWxpemVyXG4gICAgICBvcHRpb25zLl9pbmplY3RTdHlsZXMgPSBob29rXG4gICAgICAvLyByZWdpc3RlciBmb3IgZnVuY3Rpb2FsIGNvbXBvbmVudCBpbiB2dWUgZmlsZVxuICAgICAgb3B0aW9ucy5yZW5kZXIgPSBmdW5jdGlvbiByZW5kZXJXaXRoU3R5bGVJbmplY3Rpb24gKGgsIGNvbnRleHQpIHtcbiAgICAgICAgaG9vay5jYWxsKGNvbnRleHQpXG4gICAgICAgIHJldHVybiBleGlzdGluZyhoLCBjb250ZXh0KVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiB7XG4gICAgZXNNb2R1bGU6IGVzTW9kdWxlLFxuICAgIGV4cG9ydHM6IHNjcmlwdEV4cG9ydHMsXG4gICAgb3B0aW9uczogb3B0aW9uc1xuICB9XG59XG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplci5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXIuanNcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIFtcbiAgICAgIF92bS5kaXJzLmxlbmd0aFxuICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLXJpZ2h0XCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sIGhhcy1pY29ucy1sZWZ0XCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcInNlbGVjdFwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwic2VsZWN0XCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBuYW1lOiBcIm1vZGVsXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiBfdm0uc2VsZWN0ZWREaXIsXG4gICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInNlbGVjdGVkRGlyXCJcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgY2hhbmdlOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsIGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gby5zZWxlY3RlZFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAubWFwKGZ1bmN0aW9uKG8pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgdmFsID0gXCJfdmFsdWVcIiBpbiBvID8gby5fdmFsdWUgOiBvLnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNlbGVjdGVkRGlyID0gJGV2ZW50LnRhcmdldC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICA/ICQkc2VsZWN0ZWRWYWxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgOiAkJHNlbGVjdGVkVmFsWzBdXG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcIm9wdGlvblwiLCB7IGF0dHJzOiB7IHZhbHVlOiBcIlwiLCBkaXNhYmxlZDogXCJcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS50cmFucyhcInNlbGVjdF9kaXJcIikpKVxuICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl9sKF92bS5kaXJzLCBmdW5jdGlvbihkLCBpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFwib3B0aW9uXCIsIHsga2V5OiBpIH0sIFtfdm0uX3YoX3ZtLl9zKGQpKV0pXG4gICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwiZGl2XCIsXG4gICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJpY29uIGlzLXNtYWxsIGlzLWxlZnRcIiB9LFxuICAgICAgICAgICAgICAgIFtfYyhcImljb25cIiwgeyBhdHRyczogeyBuYW1lOiBcImZvbGRlclwiIH0gfSldLFxuICAgICAgICAgICAgICAgIDFcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX3ZtLnNlbGVjdGVkRGlyXG4gICAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnJlbW92ZVNlbGVjdGVkRGlyKClcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJpY29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgIFtfYyhcImljb25cIiwgeyBhdHRyczogeyBuYW1lOiBcInRyYXNoXCIgfSB9KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAxXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgIF0pXG4gICAgICAgIDogX3ZtLl9lKCksXG4gICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgX3ZtLnNlbGVjdGVkRGlyID8gW19jKFwic2hhcmVkLWNvbnRlbnRcIildIDogX3ZtLl9lKClcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbm1vZHVsZS5leHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi0wNjIzMzVkMlwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtMDYyMzM1ZDJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3ZlbmRvci52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtMDYyMzM1ZDJcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3ZlbmRvci52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCBbXG4gICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXZlbCBpcy1tb2JpbGUgaXMtbWFyZ2lubGVzc1wiIH0sIFtcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV2ZWwtbGVmdFwiIH0sIFtcbiAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXZlbC1pdGVtXCIgfSwgW1xuICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLWxlZnRcIiB9LCBbXG4gICAgICAgICAgICBfdm0uc2VsZWN0ZWRGaWxlXG4gICAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJjb250cm9sXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgX2MoXCJoNFwiLCB7IHN0YXRpY0NsYXNzOiBcInRpdGxlIGlzLTRcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdignXCInICsgX3ZtLl9zKF92bS5pdGVtc0NvdW50KSArICdcIiBJdGVtL3MnKVxuICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIF0pLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV2ZWwtcmlnaHRcIiB9LCBbXG4gICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV2ZWwtaXRlbVwiIH0sIFtcbiAgICAgICAgICBfdm0uZmlsZXMubGVuZ3RoXG4gICAgICAgICAgICA/IF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiZmllbGQgaXMtZ3JvdXBlZCBpcy1ncm91cGVkLXJpZ2h0XCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwiY29udHJvbCBoYXMtaWNvbnMtbGVmdFwiIH0sIFtcbiAgICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwic2VsZWN0XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICBcInNlbGVjdFwiLFxuICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRpcmVjdGl2ZXM6IFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwibW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByYXdOYW1lOiBcInYtbW9kZWxcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YWx1ZTogX3ZtLnNlbGVjdGVkRmlsZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOiBcInNlbGVjdGVkRmlsZVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIF0sXG4gICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBjaGFuZ2U6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciAkJHNlbGVjdGVkVmFsID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmNhbGwoJGV2ZW50LnRhcmdldC5vcHRpb25zLCBmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBvLnNlbGVjdGVkXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbihvKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhciB2YWwgPSBcIl92YWx1ZVwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uc2VsZWN0ZWRGaWxlID0gJGV2ZW50LnRhcmdldC5tdWx0aXBsZVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAkJHNlbGVjdGVkVmFsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6ICQkc2VsZWN0ZWRWYWxbMF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJvcHRpb25cIiwgeyBhdHRyczogeyB2YWx1ZTogXCJcIiwgZGlzYWJsZWQ6IFwiXCIgfSB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnRyYW5zKFwic2VsZWN0X2ZpbGVcIikpKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9sKF92bS5maWxlcywgZnVuY3Rpb24oZiwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXCJvcHRpb25cIiwgeyBrZXk6IGkgfSwgW192bS5fdihfdm0uX3MoZikpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAyXG4gICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImljb24gaXMtc21hbGwgaXMtbGVmdFwiIH0sXG4gICAgICAgICAgICAgICAgICAgIFtfYyhcImljb25cIiwgeyBhdHRyczogeyBuYW1lOiBcImZpbGVcIiB9IH0pXSxcbiAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgIF0pLFxuICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgX3ZtLnNlbGVjdGVkRmlsZVxuICAgICAgICAgICAgICAgICAgPyBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImNvbnRyb2xcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnJlbW92ZVNlbGVjdGVkRmlsZSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImljb25cIiB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfYyhcImljb25cIiwgeyBhdHRyczogeyBuYW1lOiBcInRyYXNoXCIgfSB9KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgICBdKVxuICAgICAgXSlcbiAgICBdKSxcbiAgICBfdm0uX3YoXCIgXCIpLFxuICAgIF92bS5zZWxlY3RlZEZpbGVcbiAgICAgID8gX2MoXCJzZWN0aW9uXCIsIHsgc3RhdGljQ2xhc3M6IFwibS10LTUwXCIgfSwgW1xuICAgICAgICAgIF9jKFxuICAgICAgICAgICAgXCJ0YWJsZVwiLFxuICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJ0YWJsZSBpcy1mdWxsd2lkdGggaXMtaG92ZXJhYmxlIGlzLWJvcmRlcmVkXCIgfSxcbiAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgX2MoXCJ0aGVhZFwiLCBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcInRyXCIsXG4gICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImlzLXVuc2VsZWN0YWJsZVwiIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgIFwidGhcIixcbiAgICAgICAgICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcImlzLWxpbmtcIiwgYXR0cnM6IHsgd2lkdGg6IFwiMSVcIiB9IH0sXG4gICAgICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MoX3ZtLnRyYW5zKFwia2V5XCIpKSldXG4gICAgICAgICAgICAgICAgICAgICksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fbChfdm0ubG9jYWxlcywgZnVuY3Rpb24obCwgaSkge1xuICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBfYyhcInRoXCIsIHsga2V5OiBpLCBzdGF0aWNDbGFzczogXCJpcy1saW5rXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJ0YWdzIGhhcy1hZGRvbnNcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHsgc3RhdGljQ2xhc3M6IFwidGFnIGlzLWxpZ2h0IGlzLW1lZGl1bVwiIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgW192bS5fdihfdm0uX3MobCkpXVxuICAgICAgICAgICAgICAgICAgICAgICAgICApLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0YWcgaXMtd2FybmluZyBpcy1tZWRpdW1cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ucmVtb3ZlTG9jYWxlKGwpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtfYyhcImljb25cIiwgeyBhdHRyczogeyBuYW1lOiBcInRyYXNoXCIgfSB9KV0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIH0pLFxuICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcInRoXCIsIHsgc3RhdGljQ2xhc3M6IFwiaXMtbGlua1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS50cmFucyhcIm9wc1wiKSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgMlxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgIFwidGJvZHlcIixcbiAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICBfdm0uX2woX3ZtLnNlbGVjdGVkRmlsZURhdGFDbG9uZSwgZnVuY3Rpb24oXG4gICAgICAgICAgICAgICAgICAgIG1haW5WLFxuICAgICAgICAgICAgICAgICAgICBtYWluSyxcbiAgICAgICAgICAgICAgICAgICAgbWFpbklcbiAgICAgICAgICAgICAgICAgICkge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgICAgICAgXCJ0clwiLFxuICAgICAgICAgICAgICAgICAgICAgIHsga2V5OiBtYWluSSB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICBcInRkXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXJlY3RpdmVzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hbWU6IFwidGlwcHlcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmF3TmFtZTogXCJ2LXRpcHB5XCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zaXRpb246IFwicmlnaHRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcnJvdzogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcmFjdGl2ZTogdHJ1ZSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0cmlnZ2VyOiBcIm1vdXNlZW50ZXJcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleHByZXNzaW9uOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwieyBwb3NpdGlvbiA6ICdyaWdodCcsIGFycm93OiB0cnVlLCBpbnRlcmFjdGl2ZTogdHJ1ZSwgdHJpZ2dlcjogJ21vdXNlZW50ZXInfVwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGFzczogX3ZtLm5lc3RDaGVjayhtYWluSyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5vd3JhcDogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRlZGl0YWJsZTogXCJcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRpcjogXCJhdXRvXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aXRsZTogX3ZtLmdldEtleShtYWluSyksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtaHRtbFwiOiBcIiN0aXBweVRlbXBsYXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtbWFpbi1rZXlcIjogbWFpbktcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBtb3VzZWVudGVyOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmtleVRvQ29weSA9IF92bS5nZXRLZXkobWFpbkspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2hvd246IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ucmVmb2N1cygpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ZG93bjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAhKFwiYnV0dG9uXCIgaW4gJGV2ZW50KSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fayhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5rZXlDb2RlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJlbnRlclwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMTMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQua2V5XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gbnVsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICRldmVudC5wcmV2ZW50RGVmYXVsdCgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0ubmV3RW50cnkoKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmdldFBvcygkZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zYXZlTmV3S2V5KCRldmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG1haW5LKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uX2wobWFpblYsIGZ1bmN0aW9uKG5lc3RWLCBuZXN0SywgbmVzdEkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwidGRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBrZXk6IG5lc3RJLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGVudGVkaXRhYmxlOiBcIlwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBkaXI6IFwiYXV0b1wiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcImRhdGEtbWFpbi1rZXlcIjogbWFpbkssXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiZGF0YS1jb2RlXCI6IG5lc3RLXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW5wdXQ6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5uZXdFbnRyeSgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvY3VzOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uZ2V0UG9zKCRldmVudClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgYmx1cjogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnNhdmVOZXdWYWx1ZSgkZXZlbnQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKG5lc3RWKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgIFwiXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcInRkXCIsIHsgYXR0cnM6IHsgd2lkdGg6IFwiMSVcIiB9IH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtZGFuZ2VyXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLnJlbW92ZUl0ZW0obWFpbkspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBcInNwYW5cIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgeyBzdGF0aWNDbGFzczogXCJpY29uXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgW19jKFwiaWNvblwiLCB7IGF0dHJzOiB7IG5hbWU6IFwidHJhc2hcIiB9IH0pXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgMVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgfSksXG4gICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgX3ZtLmRvbnRIYXZlRGF0YSgpXG4gICAgICAgICAgICAgICAgICAgID8gX2MoXCJ0clwiLCBbXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXCJ0ZFwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgICB7IGF0dHJzOiB7IGNvbHNwYW46IF92bS5sb2NhbGVzLmxlbmd0aCArIDIgfSB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXCJcXG4gICAgICAgICAgICAgICAgICAgICAgICBcIiArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udHJhbnMoXCJub19kYXRhXCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgIDogX3ZtLl9lKClcbiAgICAgICAgICAgICAgICBdLFxuICAgICAgICAgICAgICAgIDJcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgXVxuICAgICAgICAgICksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImxldmVsXCIgfSwgW1xuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXZlbC1yaWdodFwiIH0sIFtcbiAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXZlbC1pdGVtXCIgfSwgW1xuICAgICAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICAgICAgXCJidXR0b25cIixcbiAgICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiYnV0dG9uIGlzLWxpbmtcIixcbiAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAkZXZlbnQucHJldmVudERlZmF1bHQoKVxuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmFkZE5ld0l0ZW0oKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS50cmFucyhcImFkZF9uZXdcIikpICtcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICBcIlxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgXSksXG4gICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJsZXZlbC1sZWZ0XCIgfSwgW1xuICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcImxldmVsLWl0ZW1cIiB9LCBbXG4gICAgICAgICAgICAgICAgX2MoXG4gICAgICAgICAgICAgICAgICBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJidXR0b24gaXMtc3VjY2Vzc1wiLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBkaXNhYmxlZDogIV92bS5kYXRhQ2hhbmdlZCB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5zdWJtaXROZXdEYXRhKClcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcbiAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgICAgIFwiICtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fcyhfdm0udHJhbnMoXCJzYXZlXCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibGV2ZWwtaXRlbVwiIH0sIFtcbiAgICAgICAgICAgICAgICBfYyhcbiAgICAgICAgICAgICAgICAgIFwiYnV0dG9uXCIsXG4gICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgIHN0YXRpY0NsYXNzOiBcImJ1dHRvblwiLFxuICAgICAgICAgICAgICAgICAgICBhdHRyczogeyBkaXNhYmxlZDogIV92bS5kYXRhQ2hhbmdlZCB9LFxuICAgICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICAgIGNsaWNrOiBmdW5jdGlvbigkZXZlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5yZXNldERhdGEoKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFxuICAgICAgICAgICAgICAgICAgICAgIFwiXFxuICAgICAgICAgICAgICAgICAgICAgICAgXCIgK1xuICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl9zKF92bS50cmFucyhcInJlc2V0XCIpKSArXG4gICAgICAgICAgICAgICAgICAgICAgICBcIlxcbiAgICAgICAgICAgICAgICAgICAgXCJcbiAgICAgICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgIClcbiAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgIF0pXG4gICAgICAgICAgXSksXG4gICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICBfYyhcImRpdlwiLCB7IGF0dHJzOiB7IGlkOiBcInRpcHB5VGVtcGxhdGVcIiB9IH0sIFtcbiAgICAgICAgICAgIF9jKFwic3BhblwiLCB7IHN0YXRpY0NsYXNzOiBcImMyY1wiIH0sIFtfdm0uX3YoX3ZtLl9zKF92bS5rZXlUb0NvcHkpKV0pXG4gICAgICAgICAgXSlcbiAgICAgICAgXSlcbiAgICAgIDogX3ZtLl9lKClcbiAgXSlcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtMzE0MzMzYzRcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTMxNDMzM2M0XCIsXCJoYXNTY29wZWRcIjp0cnVlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXguanM/e1wiaWRcIjpcImRhdGEtdi0zMTQzMzNjNFwiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcImRpdlwiLFxuICAgIFtcbiAgICAgIF92bS5zZWxmX3Nob3dcbiAgICAgICAgPyBfYyhcInRyYW5zaXRpb25cIiwgeyBhdHRyczogeyBuYW1lOiBcInNsaWRlLWZhZGVcIiB9IH0sIFtcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcImRpdlwiLFxuICAgICAgICAgICAgICB7IHN0YXRpY0NsYXNzOiBcIml0ZW1cIiwgY2xhc3M6IF92bS5jbGFzc09iaihfdm0uc2VsZl90eXBlKSB9LFxuICAgICAgICAgICAgICBbXG4gICAgICAgICAgICAgICAgX2MoXCJidXR0b25cIiwge1xuICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICBvbjoge1xuICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgX3ZtLnNlbGZfc2hvdyA9IGZhbHNlXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgIF9jKFwiZGl2XCIsIHsgc3RhdGljQ2xhc3M6IFwibWVkaWFcIiB9LCBbXG4gICAgICAgICAgICAgICAgICBfdm0uc2VsZl9pY29uXG4gICAgICAgICAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZWRpYS1sZWZ0XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJmaWd1cmVcIiwgeyBzdGF0aWNDbGFzczogXCJpY29uIGlzLWxhcmdlXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImlcIiwgeyBzdGF0aWNDbGFzczogXCJtYXRlcmlhbC1pY29uc1wiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5nZXRJY29uKF92bS5zZWxmX3R5cGUpKSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1lZGlhLWNvbnRlbnRcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgIF9jKFwiaDRcIiwgeyBzdGF0aWNDbGFzczogXCJ0aXRsZVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICBfYyhcInN0cm9uZ1wiLCBbX3ZtLl92KF92bS5fcyhfdm0uc2VsZl90aXRsZSkpXSlcbiAgICAgICAgICAgICAgICAgICAgXSksXG4gICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgIF9jKFwicFwiLCB7IHN0YXRpY0NsYXNzOiBcInN1YnRpdGxlXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihfdm0uX3MoX3ZtLnNlbGZfYm9keSkpXG4gICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICBdKVxuICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgIF1cbiAgICAgICAgICAgIClcbiAgICAgICAgICBdKVxuICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICFfdm0uc2VsZl90aXRsZVxuICAgICAgICA/IFtcbiAgICAgICAgICAgIF92bS5jaGVja0Zvckdyb3VwKClcbiAgICAgICAgICAgICAgPyBfYyhcbiAgICAgICAgICAgICAgICAgIFwic3BhblwiLFxuICAgICAgICAgICAgICAgICAge1xuICAgICAgICAgICAgICAgICAgICBzdGF0aWNDbGFzczogXCJ0YWcgaXMtZGFyayBpcy1tZWRpdW1cIixcbiAgICAgICAgICAgICAgICAgICAgYXR0cnM6IHsgaWQ6IFwiY2xvc2VfYWxsXCIgfSxcbiAgICAgICAgICAgICAgICAgICAgb246IHtcbiAgICAgICAgICAgICAgICAgICAgICBjbGljazogZnVuY3Rpb24oJGV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdm0uY2xvc2VBbGwoKVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfSxcbiAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiXFxuICAgICAgICAgICAgQ2xvc2UgQWxsXFxuICAgICAgICAgICAgXCIpLFxuICAgICAgICAgICAgICAgICAgICBfYyhcImJ1dHRvblwiLCB7IHN0YXRpY0NsYXNzOiBcImRlbGV0ZVwiIH0pXG4gICAgICAgICAgICAgICAgICBdXG4gICAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgIF9jKFxuICAgICAgICAgICAgICBcInRyYW5zaXRpb24tZ3JvdXBcIixcbiAgICAgICAgICAgICAgeyBhdHRyczogeyBuYW1lOiBcInNsaWRlLWZhZGVcIiwgdGFnOiBcInVsXCIgfSB9LFxuICAgICAgICAgICAgICBfdm0uX2woX3ZtLm5vdGlmX2dyb3VwLCBmdW5jdGlvbihvbmUsIGluZGV4KSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF92bS5Jc1Zpc2libGUoaW5kZXgpXG4gICAgICAgICAgICAgICAgICA/IF9jKFxuICAgICAgICAgICAgICAgICAgICAgIFwibGlcIixcbiAgICAgICAgICAgICAgICAgICAgICB7XG4gICAgICAgICAgICAgICAgICAgICAgICBrZXk6IGluZGV4LFxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiaXRlbVwiLFxuICAgICAgICAgICAgICAgICAgICAgICAgY2xhc3M6IF92bS5jbGFzc09iaihvbmUudHlwZSlcbiAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgIFtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiYnV0dG9uXCIsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgc3RhdGljQ2xhc3M6IFwiZGVsZXRlXCIsXG4gICAgICAgICAgICAgICAgICAgICAgICAgIG9uOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2xpY2s6IGZ1bmN0aW9uKCRldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLmNsb3NlTm90aWYoaW5kZXgpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9KSxcbiAgICAgICAgICAgICAgICAgICAgICAgIF92bS5fdihcIiBcIiksXG4gICAgICAgICAgICAgICAgICAgICAgICBfYyhcImRpdlwiLCB7IHN0YXRpY0NsYXNzOiBcIm1lZGlhXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICBvbmUuaWNvblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZWRpYS1sZWZ0XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYyhcImZpZ3VyZVwiLCB7IHN0YXRpY0NsYXNzOiBcImljb24gaXMtbGFyZ2VcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJpXCIsIHsgc3RhdGljQ2xhc3M6IFwibWF0ZXJpYWwtaWNvbnNcIiB9LCBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoX3ZtLl9zKF92bS5nZXRJY29uKG9uZS50eXBlKSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBfdm0uX2UoKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KFwiIFwiKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgX2MoXCJkaXZcIiwgeyBzdGF0aWNDbGFzczogXCJtZWRpYS1jb250ZW50XCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwiaDRcIiwgeyBzdGF0aWNDbGFzczogXCJ0aXRsZVwiIH0sIFtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwic3Ryb25nXCIsIFtfdm0uX3YoX3ZtLl9zKG9uZS50aXRsZSkpXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdKSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9jKFwicFwiLCB7IHN0YXRpY0NsYXNzOiBcInN1YnRpdGxlXCIgfSwgW1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgX3ZtLl92KF92bS5fcyhvbmUuYm9keSkpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIF0pXG4gICAgICAgICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgICAgICAgICApXG4gICAgICAgICAgICAgICAgICA6IF92bS5fZSgpXG4gICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICApXG4gICAgICAgICAgXVxuICAgICAgICA6IF92bS5fZSgpXG4gICAgXSxcbiAgICAyXG4gIClcbn1cbnZhciBzdGF0aWNSZW5kZXJGbnMgPSBbXVxucmVuZGVyLl93aXRoU3RyaXBwZWQgPSB0cnVlXG5tb2R1bGUuZXhwb3J0cyA9IHsgcmVuZGVyOiByZW5kZXIsIHN0YXRpY1JlbmRlckZuczogc3RhdGljUmVuZGVyRm5zIH1cbmlmIChtb2R1bGUuaG90KSB7XG4gIG1vZHVsZS5ob3QuYWNjZXB0KClcbiAgaWYgKG1vZHVsZS5ob3QuZGF0YSkge1xuICAgIHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIikgICAgICAucmVyZW5kZXIoXCJkYXRhLXYtNjRkODE3YzNcIiwgbW9kdWxlLmV4cG9ydHMpXG4gIH1cbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlcj97XCJpZFwiOlwiZGF0YS12LTY0ZDgxN2MzXCIsXCJoYXNTY29wZWRcIjp0cnVlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXguanM/e1wiaWRcIjpcImRhdGEtdi02NGQ4MTdjM1wiLFwiaGFzU2NvcGVkXCI6dHJ1ZSxcImJ1YmxlXCI6e1widHJhbnNmb3Jtc1wiOnt9fX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcbiAgICBcInN2Z1wiLFxuICAgIHtcbiAgICAgIGNsYXNzOiBfdm0ua2xhc3MsXG4gICAgICBzdHlsZTogX3ZtLnN0eWxlLFxuICAgICAgYXR0cnM6IHtcbiAgICAgICAgdmVyc2lvbjogXCIxLjFcIixcbiAgICAgICAgcm9sZTogX3ZtLmxhYmVsID8gXCJpbWdcIiA6IFwicHJlc2VudGF0aW9uXCIsXG4gICAgICAgIFwiYXJpYS1sYWJlbFwiOiBfdm0ubGFiZWwsXG4gICAgICAgIHg6IF92bS54LFxuICAgICAgICB5OiBfdm0ueSxcbiAgICAgICAgd2lkdGg6IF92bS53aWR0aCxcbiAgICAgICAgaGVpZ2h0OiBfdm0uaGVpZ2h0LFxuICAgICAgICB2aWV3Qm94OiBfdm0uYm94XG4gICAgICB9XG4gICAgfSxcbiAgICBbXG4gICAgICBfdm0uX3QoXCJkZWZhdWx0XCIsIFtcbiAgICAgICAgX3ZtLmljb24gJiYgX3ZtLmljb24ucGF0aHNcbiAgICAgICAgICA/IF92bS5fbChfdm0uaWNvbi5wYXRocywgZnVuY3Rpb24ocGF0aCwgaSkge1xuICAgICAgICAgICAgICByZXR1cm4gX2MoXG4gICAgICAgICAgICAgICAgXCJwYXRoXCIsXG4gICAgICAgICAgICAgICAgX3ZtLl9iKHsga2V5OiBcInBhdGgtXCIgKyBpIH0sIFwicGF0aFwiLCBwYXRoLCBmYWxzZSlcbiAgICAgICAgICAgICAgKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgICA6IF92bS5fZSgpLFxuICAgICAgICBfdm0uX3YoXCIgXCIpLFxuICAgICAgICBfdm0uaWNvbiAmJiBfdm0uaWNvbi5wb2x5Z29uc1xuICAgICAgICAgID8gX3ZtLl9sKF92bS5pY29uLnBvbHlnb25zLCBmdW5jdGlvbihwb2x5Z29uLCBpKSB7XG4gICAgICAgICAgICAgIHJldHVybiBfYyhcbiAgICAgICAgICAgICAgICBcInBvbHlnb25cIixcbiAgICAgICAgICAgICAgICBfdm0uX2IoeyBrZXk6IFwicG9seWdvbi1cIiArIGkgfSwgXCJwb2x5Z29uXCIsIHBvbHlnb24sIGZhbHNlKVxuICAgICAgICAgICAgICApXG4gICAgICAgICAgICB9KVxuICAgICAgICAgIDogX3ZtLl9lKCksXG4gICAgICAgIF92bS5fdihcIlxcYlxcbiAgICBcIiksXG4gICAgICAgIF92bS5pY29uICYmIF92bS5pY29uLnJhd1xuICAgICAgICAgID8gW19jKFwiZ1wiLCB7IGRvbVByb3BzOiB7IGlubmVySFRNTDogX3ZtLl9zKF92bS5yYXcpIH0gfSldXG4gICAgICAgICAgOiBfdm0uX2UoKVxuICAgICAgXSlcbiAgICBdLFxuICAgIDJcbiAgKVxufVxudmFyIHN0YXRpY1JlbmRlckZucyA9IFtdXG5yZW5kZXIuX3dpdGhTdHJpcHBlZCA9IHRydWVcbm1vZHVsZS5leHBvcnRzID0geyByZW5kZXI6IHJlbmRlciwgc3RhdGljUmVuZGVyRm5zOiBzdGF0aWNSZW5kZXJGbnMgfVxuaWYgKG1vZHVsZS5ob3QpIHtcbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAobW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgcmVxdWlyZShcInZ1ZS1ob3QtcmVsb2FkLWFwaVwiKSAgICAgIC5yZXJlbmRlcihcImRhdGEtdi1hZmFhYmQ3MFwiLCBtb2R1bGUuZXhwb3J0cylcbiAgfVxufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyP3tcImlkXCI6XCJkYXRhLXYtYWZhYWJkNzBcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtYWZhYWJkNzBcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwidmFyIHJlbmRlciA9IGZ1bmN0aW9uKCkge1xuICB2YXIgX3ZtID0gdGhpc1xuICB2YXIgX2ggPSBfdm0uJGNyZWF0ZUVsZW1lbnRcbiAgdmFyIF9jID0gX3ZtLl9zZWxmLl9jIHx8IF9oXG4gIHJldHVybiBfYyhcImRpdlwiLCBbX2MoXCJzaGFyZWQtY29udGVudFwiKV0sIDEpXG59XG52YXIgc3RhdGljUmVuZGVyRm5zID0gW11cbnJlbmRlci5fd2l0aFN0cmlwcGVkID0gdHJ1ZVxubW9kdWxlLmV4cG9ydHMgPSB7IHJlbmRlcjogcmVuZGVyLCBzdGF0aWNSZW5kZXJGbnM6IHN0YXRpY1JlbmRlckZucyB9XG5pZiAobW9kdWxlLmhvdCkge1xuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmIChtb2R1bGUuaG90LmRhdGEpIHtcbiAgICByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpICAgICAgLnJlcmVuZGVyKFwiZGF0YS12LWY0MzY5M2ZjXCIsIG1vZHVsZS5leHBvcnRzKVxuICB9XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXI/e1wiaWRcIjpcImRhdGEtdi1mNDM2OTNmY1wiLFwiaGFzU2NvcGVkXCI6ZmFsc2UsXCJidWJsZVwiOntcInRyYW5zZm9ybXNcIjp7fX19IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvZGVmYXVsdC52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3RlbXBsYXRlLWNvbXBpbGVyL2luZGV4LmpzP3tcImlkXCI6XCJkYXRhLXYtZjQzNjkzZmNcIixcImhhc1Njb3BlZFwiOmZhbHNlLFwiYnVibGVcIjp7XCJ0cmFuc2Zvcm1zXCI6e319fSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL2RlZmF1bHQudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIihmdW5jdGlvbiAoZ2xvYmFsLCBmYWN0b3J5KSB7XG5cdHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlICE9PSAndW5kZWZpbmVkJyA/IG1vZHVsZS5leHBvcnRzID0gZmFjdG9yeSgpIDpcblx0dHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kID8gZGVmaW5lKGZhY3RvcnkpIDpcblx0KGdsb2JhbFsndnVlLWxzJ10gPSBmYWN0b3J5KCkpO1xufSh0aGlzLCAoZnVuY3Rpb24gKCkgeyAndXNlIHN0cmljdCc7XG5cbnZhciBscyQxID0ge307XG5cbnZhciBtZW1vcnlTdG9yYWdlID0ge1xuICAvKipcbiAgICogR2V0IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBnZXRJdGVtOiBmdW5jdGlvbiBnZXRJdGVtKG5hbWUpIHtcbiAgICByZXR1cm4gbmFtZSBpbiBscyQxID8gbHMkMVtuYW1lXSA6IG51bGw7XG4gIH0sXG5cblxuICAvKipcbiAgICogU2V0IGl0ZW1cbiAgICpcbiAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHNldEl0ZW06IGZ1bmN0aW9uIHNldEl0ZW0obmFtZSwgdmFsdWUpIHtcbiAgICBscyQxW25hbWVdID0gdmFsdWU7XG5cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBSZW1vdmUgaXRlbVxuICAgKlxuICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgKiBAcmV0dXJucyB7Ym9vbGVhbn1cbiAgICovXG4gIHJlbW92ZUl0ZW06IGZ1bmN0aW9uIHJlbW92ZUl0ZW0obmFtZSkge1xuICAgIHZhciBmb3VuZCA9IG5hbWUgaW4gbHMkMTtcblxuICAgIGlmIChmb3VuZCkge1xuICAgICAgcmV0dXJuIGRlbGV0ZSBscyQxW25hbWVdO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfSxcblxuXG4gIC8qKlxuICAgKiBDbGVhciBzdG9yYWdlXG4gICAqXG4gICAqIEByZXR1cm5zIHtib29sZWFufVxuICAgKi9cbiAgY2xlYXI6IGZ1bmN0aW9uIGNsZWFyKCkge1xuICAgIGxzJDEgPSB7fTtcblxuICAgIHJldHVybiB0cnVlO1xuICB9LFxuXG5cbiAgLyoqXG4gICAqIEdldCBpdGVtIGJ5IGtleVxuICAgKlxuICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICogQHJldHVybnMgeyp9XG4gICAqL1xuICBrZXk6IGZ1bmN0aW9uIGtleShpbmRleCkge1xuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMobHMkMSk7XG5cbiAgICByZXR1cm4gdHlwZW9mIGtleXNbaW5kZXhdICE9PSAndW5kZWZpbmVkJyA/IGtleXNbaW5kZXhdIDogbnVsbDtcbiAgfVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KG1lbW9yeVN0b3JhZ2UsICdsZW5ndGgnLCB7XG4gIC8qKlxuICAgKiBEZWZpbmUgbGVuZ3RoIHByb3BlcnR5XG4gICAqXG4gICAqIEByZXR1cm4ge251bWJlcn1cbiAgICovXG4gIGdldDogZnVuY3Rpb24gZ2V0KCkge1xuICAgIHJldHVybiBPYmplY3Qua2V5cyhscyQxKS5sZW5ndGg7XG4gIH1cbn0pO1xuXG52YXIgYXN5bmNHZW5lcmF0b3IgPSBmdW5jdGlvbiAoKSB7XG4gIGZ1bmN0aW9uIEF3YWl0VmFsdWUodmFsdWUpIHtcbiAgICB0aGlzLnZhbHVlID0gdmFsdWU7XG4gIH1cblxuICBmdW5jdGlvbiBBc3luY0dlbmVyYXRvcihnZW4pIHtcbiAgICB2YXIgZnJvbnQsIGJhY2s7XG5cbiAgICBmdW5jdGlvbiBzZW5kKGtleSwgYXJnKSB7XG4gICAgICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICB2YXIgcmVxdWVzdCA9IHtcbiAgICAgICAgICBrZXk6IGtleSxcbiAgICAgICAgICBhcmc6IGFyZyxcbiAgICAgICAgICByZXNvbHZlOiByZXNvbHZlLFxuICAgICAgICAgIHJlamVjdDogcmVqZWN0LFxuICAgICAgICAgIG5leHQ6IG51bGxcbiAgICAgICAgfTtcblxuICAgICAgICBpZiAoYmFjaykge1xuICAgICAgICAgIGJhY2sgPSBiYWNrLm5leHQgPSByZXF1ZXN0O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGZyb250ID0gYmFjayA9IHJlcXVlc3Q7XG4gICAgICAgICAgcmVzdW1lKGtleSwgYXJnKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gcmVzdW1lKGtleSwgYXJnKSB7XG4gICAgICB0cnkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gZ2VuW2tleV0oYXJnKTtcbiAgICAgICAgdmFyIHZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIEF3YWl0VmFsdWUpIHtcbiAgICAgICAgICBQcm9taXNlLnJlc29sdmUodmFsdWUudmFsdWUpLnRoZW4oZnVuY3Rpb24gKGFyZykge1xuICAgICAgICAgICAgcmVzdW1lKFwibmV4dFwiLCBhcmcpO1xuICAgICAgICAgIH0sIGZ1bmN0aW9uIChhcmcpIHtcbiAgICAgICAgICAgIHJlc3VtZShcInRocm93XCIsIGFyZyk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2V0dGxlKHJlc3VsdC5kb25lID8gXCJyZXR1cm5cIiA6IFwibm9ybWFsXCIsIHJlc3VsdC52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICBzZXR0bGUoXCJ0aHJvd1wiLCBlcnIpO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHNldHRsZSh0eXBlLCB2YWx1ZSkge1xuICAgICAgc3dpdGNoICh0eXBlKSB7XG4gICAgICAgIGNhc2UgXCJyZXR1cm5cIjpcbiAgICAgICAgICBmcm9udC5yZXNvbHZlKHtcbiAgICAgICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgICAgIGRvbmU6IHRydWVcbiAgICAgICAgICB9KTtcbiAgICAgICAgICBicmVhaztcblxuICAgICAgICBjYXNlIFwidGhyb3dcIjpcbiAgICAgICAgICBmcm9udC5yZWplY3QodmFsdWUpO1xuICAgICAgICAgIGJyZWFrO1xuXG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZnJvbnQucmVzb2x2ZSh7XG4gICAgICAgICAgICB2YWx1ZTogdmFsdWUsXG4gICAgICAgICAgICBkb25lOiBmYWxzZVxuICAgICAgICAgIH0pO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuXG4gICAgICBmcm9udCA9IGZyb250Lm5leHQ7XG5cbiAgICAgIGlmIChmcm9udCkge1xuICAgICAgICByZXN1bWUoZnJvbnQua2V5LCBmcm9udC5hcmcpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgYmFjayA9IG51bGw7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5faW52b2tlID0gc2VuZDtcblxuICAgIGlmICh0eXBlb2YgZ2VuLnJldHVybiAhPT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICB0aGlzLnJldHVybiA9IHVuZGVmaW5lZDtcbiAgICB9XG4gIH1cblxuICBpZiAodHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIFN5bWJvbC5hc3luY0l0ZXJhdG9yKSB7XG4gICAgQXN5bmNHZW5lcmF0b3IucHJvdG90eXBlW1N5bWJvbC5hc3luY0l0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIHJldHVybiB0aGlzO1xuICAgIH07XG4gIH1cblxuICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUubmV4dCA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwibmV4dFwiLCBhcmcpO1xuICB9O1xuXG4gIEFzeW5jR2VuZXJhdG9yLnByb3RvdHlwZS50aHJvdyA9IGZ1bmN0aW9uIChhcmcpIHtcbiAgICByZXR1cm4gdGhpcy5faW52b2tlKFwidGhyb3dcIiwgYXJnKTtcbiAgfTtcblxuICBBc3luY0dlbmVyYXRvci5wcm90b3R5cGUucmV0dXJuID0gZnVuY3Rpb24gKGFyZykge1xuICAgIHJldHVybiB0aGlzLl9pbnZva2UoXCJyZXR1cm5cIiwgYXJnKTtcbiAgfTtcblxuICByZXR1cm4ge1xuICAgIHdyYXA6IGZ1bmN0aW9uIChmbikge1xuICAgICAgcmV0dXJuIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBBc3luY0dlbmVyYXRvcihmbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpKTtcbiAgICAgIH07XG4gICAgfSxcbiAgICBhd2FpdDogZnVuY3Rpb24gKHZhbHVlKSB7XG4gICAgICByZXR1cm4gbmV3IEF3YWl0VmFsdWUodmFsdWUpO1xuICAgIH1cbiAgfTtcbn0oKTtcblxuXG5cblxuXG52YXIgY2xhc3NDYWxsQ2hlY2sgPSBmdW5jdGlvbiAoaW5zdGFuY2UsIENvbnN0cnVjdG9yKSB7XG4gIGlmICghKGluc3RhbmNlIGluc3RhbmNlb2YgQ29uc3RydWN0b3IpKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCBjYWxsIGEgY2xhc3MgYXMgYSBmdW5jdGlvblwiKTtcbiAgfVxufTtcblxudmFyIGNyZWF0ZUNsYXNzID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBkZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgcHJvcHMpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByb3BzLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgZGVzY3JpcHRvciA9IHByb3BzW2ldO1xuICAgICAgZGVzY3JpcHRvci5lbnVtZXJhYmxlID0gZGVzY3JpcHRvci5lbnVtZXJhYmxlIHx8IGZhbHNlO1xuICAgICAgZGVzY3JpcHRvci5jb25maWd1cmFibGUgPSB0cnVlO1xuICAgICAgaWYgKFwidmFsdWVcIiBpbiBkZXNjcmlwdG9yKSBkZXNjcmlwdG9yLndyaXRhYmxlID0gdHJ1ZTtcbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGRlc2NyaXB0b3Iua2V5LCBkZXNjcmlwdG9yKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZnVuY3Rpb24gKENvbnN0cnVjdG9yLCBwcm90b1Byb3BzLCBzdGF0aWNQcm9wcykge1xuICAgIGlmIChwcm90b1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLnByb3RvdHlwZSwgcHJvdG9Qcm9wcyk7XG4gICAgaWYgKHN0YXRpY1Byb3BzKSBkZWZpbmVQcm9wZXJ0aWVzKENvbnN0cnVjdG9yLCBzdGF0aWNQcm9wcyk7XG4gICAgcmV0dXJuIENvbnN0cnVjdG9yO1xuICB9O1xufSgpO1xuXG5cblxuXG5cblxuXG52YXIgX2V4dGVuZHMgPSBPYmplY3QuYXNzaWduIHx8IGZ1bmN0aW9uICh0YXJnZXQpIHtcbiAgZm9yICh2YXIgaSA9IDE7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc291cmNlID0gYXJndW1lbnRzW2ldO1xuXG4gICAgZm9yICh2YXIga2V5IGluIHNvdXJjZSkge1xuICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzb3VyY2UsIGtleSkpIHtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gdGFyZ2V0O1xufTtcblxudmFyIGxpc3RlbmVycyA9IHt9O1xuXG4vKipcbiAqIEV2ZW50IGNsYXNzXG4gKi9cblxudmFyIF9jbGFzcyQxID0gZnVuY3Rpb24gKCkge1xuICBmdW5jdGlvbiBfY2xhc3MoKSB7XG4gICAgY2xhc3NDYWxsQ2hlY2sodGhpcywgX2NsYXNzKTtcbiAgfVxuXG4gIGNyZWF0ZUNsYXNzKF9jbGFzcywgbnVsbCwgW3tcbiAgICBrZXk6ICdvbicsXG5cbiAgICAvKipcbiAgICAgKiBBZGQgc3RvcmFnZSBjaGFuZ2UgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7c3RyaW5nfSBuYW1lXG4gICAgICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcbiAgICAgKi9cbiAgICB2YWx1ZTogZnVuY3Rpb24gb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXJzW25hbWVdID09PSAndW5kZWZpbmVkJykge1xuICAgICAgICBsaXN0ZW5lcnNbbmFtZV0gPSBbXTtcbiAgICAgIH1cblxuICAgICAgbGlzdGVuZXJzW25hbWVdLnB1c2goY2FsbGJhY2spO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIFJlbW92ZSBzdG9yYWdlIGNoYW5nZSBldmVudFxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdvZmYnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBvZmYobmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIGlmIChsaXN0ZW5lcnNbbmFtZV0ubGVuZ3RoKSB7XG4gICAgICAgIGxpc3RlbmVyc1tuYW1lXS5zcGxpY2UobGlzdGVuZXJzW25hbWVdLmluZGV4T2YoY2FsbGJhY2spLCAxKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGxpc3RlbmVyc1tuYW1lXSA9IFtdO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEVtaXQgZXZlbnRcbiAgICAgKlxuICAgICAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdlbWl0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gZW1pdChldmVudCkge1xuICAgICAgdmFyIGUgPSBldmVudCB8fCB3aW5kb3cuZXZlbnQ7XG5cbiAgICAgIHZhciBnZXRWYWx1ZSA9IGZ1bmN0aW9uIGdldFZhbHVlKGRhdGEpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKS52YWx1ZTtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgIH07XG5cbiAgICAgIHZhciBmaXJlID0gZnVuY3Rpb24gZmlyZShsaXN0ZW5lcikge1xuICAgICAgICB2YXIgbmV3VmFsdWUgPSBnZXRWYWx1ZShlLm5ld1ZhbHVlKTtcbiAgICAgICAgdmFyIG9sZFZhbHVlID0gZ2V0VmFsdWUoZS5vbGRWYWx1ZSk7XG5cbiAgICAgICAgbGlzdGVuZXIobmV3VmFsdWUsIG9sZFZhbHVlLCBlLnVybCB8fCBlLnVyaSk7XG4gICAgICB9O1xuXG4gICAgICBpZiAodHlwZW9mIGUgPT09ICd1bmRlZmluZWQnIHx8IHR5cGVvZiBlLmtleSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgYWxsID0gbGlzdGVuZXJzW2Uua2V5XTtcblxuICAgICAgaWYgKHR5cGVvZiBhbGwgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGFsbC5mb3JFYWNoKGZpcmUpO1xuICAgICAgfVxuICAgIH1cbiAgfV0pO1xuICByZXR1cm4gX2NsYXNzO1xufSgpO1xuXG4vKipcbiAqIFN0b3JhZ2UgQnJpZGdlXG4gKi9cblxudmFyIF9jbGFzcyA9IGZ1bmN0aW9uICgpIHtcbiAgLyoqXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBzdG9yYWdlXG4gICAqL1xuICBmdW5jdGlvbiBfY2xhc3Moc3RvcmFnZSkge1xuICAgIGNsYXNzQ2FsbENoZWNrKHRoaXMsIF9jbGFzcyk7XG5cbiAgICB0aGlzLnN0b3JhZ2UgPSBzdG9yYWdlO1xuICAgIHRoaXMub3B0aW9ucyA9IHtcbiAgICAgIG5hbWVzcGFjZTogJycsXG4gICAgICBldmVudHM6IFsnc3RvcmFnZSddXG4gICAgfTtcblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0aGlzLCAnbGVuZ3RoJywge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmUgbGVuZ3RoIHByb3BlcnR5XG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7bnVtYmVyfVxuICAgICAgICovXG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCQkMSgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5sZW5ndGg7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgIGZvciAodmFyIGkgaW4gdGhpcy5vcHRpb25zLmV2ZW50cykge1xuICAgICAgICBpZiAod2luZG93LmFkZEV2ZW50TGlzdGVuZXIpIHtcbiAgICAgICAgICB3aW5kb3cuYWRkRXZlbnRMaXN0ZW5lcih0aGlzLm9wdGlvbnMuZXZlbnRzW2ldLCBfY2xhc3MkMS5lbWl0LCBmYWxzZSk7XG4gICAgICAgIH0gZWxzZSBpZiAod2luZG93LmF0dGFjaEV2ZW50KSB7XG4gICAgICAgICAgd2luZG93LmF0dGFjaEV2ZW50KCdvbicgKyB0aGlzLm9wdGlvbnMuZXZlbnRzW2ldLCBfY2xhc3MkMS5lbWl0KTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB3aW5kb3dbJ29uJyArIHRoaXMub3B0aW9ucy5ldmVudHNbaV1dID0gX2NsYXNzJDEuZW1pdDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8qKlxuICAgKiBTZXQgT3B0aW9uc1xuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKi9cblxuXG4gIGNyZWF0ZUNsYXNzKF9jbGFzcywgW3tcbiAgICBrZXk6ICdzZXRPcHRpb25zJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0T3B0aW9ucygpIHtcbiAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcblxuICAgICAgdGhpcy5vcHRpb25zID0gX2V4dGVuZHModGhpcy5vcHRpb25zLCBvcHRpb25zKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBTZXQgaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcGFyYW0geyp9IHZhbHVlXG4gICAgICogQHBhcmFtIHtudW1iZXJ9IGV4cGlyZSAtIHNlY29uZHNcbiAgICAgKi9cblxuICB9LCB7XG4gICAga2V5OiAnc2V0JyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gc2V0JCQxKG5hbWUsIHZhbHVlKSB7XG4gICAgICB2YXIgZXhwaXJlID0gYXJndW1lbnRzLmxlbmd0aCA+IDIgJiYgYXJndW1lbnRzWzJdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMl0gOiBudWxsO1xuXG4gICAgICB2YXIgc3RyaW5naWZ5VmFsdWUgPSBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgIHZhbHVlOiB2YWx1ZSxcbiAgICAgICAgZXhwaXJlOiBleHBpcmUgIT09IG51bGwgPyBuZXcgRGF0ZSgpLmdldFRpbWUoKSArIGV4cGlyZSA6IG51bGxcbiAgICAgIH0pO1xuXG4gICAgICB0aGlzLnN0b3JhZ2Uuc2V0SXRlbSh0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgbmFtZSwgc3RyaW5naWZ5VmFsdWUpO1xuICAgIH1cblxuICAgIC8qKlxuICAgICAqIEdldCBpdGVtXG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7Kn0gZGVmIC0gZGVmYXVsdCB2YWx1ZVxuICAgICAqIEByZXR1cm5zIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdnZXQnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBnZXQkJDEobmFtZSkge1xuICAgICAgdmFyIGRlZiA9IGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIGFyZ3VtZW50c1sxXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzFdIDogbnVsbDtcblxuICAgICAgdmFyIGl0ZW0gPSB0aGlzLnN0b3JhZ2UuZ2V0SXRlbSh0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgbmFtZSk7XG5cbiAgICAgIGlmIChpdGVtICE9PSBudWxsKSB7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgdmFyIGRhdGEgPSBKU09OLnBhcnNlKGl0ZW0pO1xuXG4gICAgICAgICAgaWYgKGRhdGEuZXhwaXJlID09PSBudWxsKSB7XG4gICAgICAgICAgICByZXR1cm4gZGF0YS52YWx1ZTtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBpZiAoZGF0YS5leHBpcmUgPj0gbmV3IERhdGUoKS5nZXRUaW1lKCkpIHtcbiAgICAgICAgICAgIHJldHVybiBkYXRhLnZhbHVlO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIHRoaXMucmVtb3ZlKG5hbWUpO1xuICAgICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgICByZXR1cm4gZGVmO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHJldHVybiBkZWY7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogR2V0IGl0ZW0gYnkga2V5XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge251bWJlcn0gaW5kZXhcbiAgICAgKiBAcmV0dXJuIHsqfVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdrZXknLFxuICAgIHZhbHVlOiBmdW5jdGlvbiBrZXkoaW5kZXgpIHtcbiAgICAgIHJldHVybiB0aGlzLnN0b3JhZ2Uua2V5KGluZGV4KTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBSZW1vdmUgaXRlbVxuICAgICAqXG4gICAgICogQHBhcmFtIHtzdHJpbmd9IG5hbWVcbiAgICAgKiBAcmV0dXJuIHtib29sZWFufVxuICAgICAqL1xuXG4gIH0sIHtcbiAgICBrZXk6ICdyZW1vdmUnLFxuICAgIHZhbHVlOiBmdW5jdGlvbiByZW1vdmUobmFtZSkge1xuICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZS5yZW1vdmVJdGVtKHRoaXMub3B0aW9ucy5uYW1lc3BhY2UgKyBuYW1lKTtcbiAgICB9XG5cbiAgICAvKipcbiAgICAgKiBDbGVhciBzdG9yYWdlXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ2NsZWFyJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gY2xlYXIoKSB7XG4gICAgICBpZiAodGhpcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuXG4gICAgICB2YXIgcmVtb3ZlZEtleXMgPSBbXTtcblxuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGlzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBrZXkgPSB0aGlzLnN0b3JhZ2Uua2V5KGkpO1xuICAgICAgICB2YXIgcmVnZXhwID0gbmV3IFJlZ0V4cCgnXicgKyB0aGlzLm9wdGlvbnMubmFtZXNwYWNlICsgJy4rJywgJ2knKTtcblxuICAgICAgICBpZiAocmVnZXhwLnRlc3Qoa2V5KSA9PT0gZmFsc2UpIHtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuXG4gICAgICAgIHJlbW92ZWRLZXlzLnB1c2goa2V5KTtcbiAgICAgIH1cblxuICAgICAgZm9yICh2YXIgX2tleSBpbiByZW1vdmVkS2V5cykge1xuICAgICAgICB0aGlzLnN0b3JhZ2UucmVtb3ZlSXRlbShyZW1vdmVkS2V5c1tfa2V5XSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogQWRkIHN0b3JhZ2UgY2hhbmdlIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29uJyxcbiAgICB2YWx1ZTogZnVuY3Rpb24gb24obmFtZSwgY2FsbGJhY2spIHtcbiAgICAgIF9jbGFzcyQxLm9uKHRoaXMub3B0aW9ucy5uYW1lc3BhY2UgKyBuYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuXG4gICAgLyoqXG4gICAgICogUmVtb3ZlIHN0b3JhZ2UgY2hhbmdlIGV2ZW50XG4gICAgICpcbiAgICAgKiBAcGFyYW0ge3N0cmluZ30gbmFtZVxuICAgICAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG4gICAgICovXG5cbiAgfSwge1xuICAgIGtleTogJ29mZicsXG4gICAgdmFsdWU6IGZ1bmN0aW9uIG9mZihuYW1lLCBjYWxsYmFjaykge1xuICAgICAgX2NsYXNzJDEub2ZmKHRoaXMub3B0aW9ucy5uYW1lc3BhY2UgKyBuYW1lLCBjYWxsYmFjayk7XG4gICAgfVxuICB9XSk7XG4gIHJldHVybiBfY2xhc3M7XG59KCk7XG5cbnZhciBzdG9yZSA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICdsb2NhbFN0b3JhZ2UnIGluIHdpbmRvdyA/IHdpbmRvdy5sb2NhbFN0b3JhZ2UgOiBtZW1vcnlTdG9yYWdlO1xudmFyIGxzID0gbmV3IF9jbGFzcyhzdG9yZSk7XG5cbnZhciBWdWVMb2NhbFN0b3JhZ2UgPSB7XG4gIC8qKlxuICAgKiBJbnN0YWxsIHBsdWdpblxuICAgKlxuICAgKiBAcGFyYW0ge09iamVjdH0gVnVlXG4gICAqIEBwYXJhbSB7T2JqZWN0fSBvcHRpb25zXG4gICAqIEByZXR1cm5zIHtTdG9yYWdlfVxuICAgKi9cbiAgaW5zdGFsbDogZnVuY3Rpb24gaW5zdGFsbChWdWUsIG9wdGlvbnMpIHtcbiAgICBscy5zZXRPcHRpb25zKF9leHRlbmRzKGxzLm9wdGlvbnMsIHtcbiAgICAgIG5hbWVzcGFjZTogJydcbiAgICB9LCBvcHRpb25zIHx8IHt9KSk7XG5cbiAgICBWdWUubHMgPSBsczsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJGxzJywge1xuICAgICAgLyoqXG4gICAgICAgKiBEZWZpbmUgJGxzIHByb3BlcnR5XG4gICAgICAgKlxuICAgICAgICogQHJldHVybiB7U3RvcmFnZX1cbiAgICAgICAqL1xuICAgICAgZ2V0OiBmdW5jdGlvbiBnZXQkJDEoKSB7XG4gICAgICAgIHJldHVybiBscztcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufTtcblxuaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XG4gIHdpbmRvdy5WdWVMb2NhbFN0b3JhZ2UgPSBWdWVMb2NhbFN0b3JhZ2U7XG59XG5cbnJldHVybiBWdWVMb2NhbFN0b3JhZ2U7XG5cbn0pKSk7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLWxzL2Rpc3QvdnVlLWxzLmpzIiwidmFyIGRpc3Bvc2VkID0gZmFsc2VcbmZ1bmN0aW9uIGluamVjdFN0eWxlIChzc3JDb250ZXh0KSB7XG4gIGlmIChkaXNwb3NlZCkgcmV0dXJuXG4gIHJlcXVpcmUoXCIhIXZ1ZS1zdHlsZS1sb2FkZXIhY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXg/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY0ZDgxN2MzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL05vdGlmaWNhdGlvbi52dWVcIilcbiAgcmVxdWlyZShcIiEhdnVlLXN0eWxlLWxvYWRlciFjc3MtbG9hZGVyP3NvdXJjZU1hcCEuLi8uLi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNjRkODE3YzNcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi4vLi4vdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zdHlsZXMmaW5kZXg9MSZidXN0Q2FjaGUhLi9Ob3RpZmljYXRpb24udnVlXCIpXG59XG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG52YXIgX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/e1xcXCJjYWNoZURpcmVjdG9yeVxcXCI6dHJ1ZSxcXFwicHJlc2V0c1xcXCI6W1tcXFwiZW52XFxcIix7XFxcIm1vZHVsZXNcXFwiOmZhbHNlLFxcXCJ0YXJnZXRzXFxcIjp7XFxcImJyb3dzZXJzXFxcIjpbXFxcIj4gMiVcXFwiXSxcXFwidWdsaWZ5XFxcIjp0cnVlfX1dXSxcXFwicGx1Z2luc1xcXCI6W1xcXCJ0cmFuc2Zvcm0tb2JqZWN0LXJlc3Qtc3ByZWFkXFxcIixbXFxcInRyYW5zZm9ybS1ydW50aW1lXFxcIix7XFxcInBvbHlmaWxsXFxcIjpmYWxzZSxcXFwiaGVscGVyc1xcXCI6ZmFsc2V9XV19IS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vTm90aWZpY2F0aW9uLnZ1ZVwiKVxuLyogdGVtcGxhdGUgKi9cbnZhciBfX3Z1ZV90ZW1wbGF0ZV9fID0gcmVxdWlyZShcIiEhLi4vLi4vdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi02NGQ4MTdjM1xcXCIsXFxcImhhc1Njb3BlZFxcXCI6dHJ1ZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXRlbXBsYXRlJmluZGV4PTAmYnVzdENhY2hlIS4vTm90aWZpY2F0aW9uLnZ1ZVwiKVxuLyogdGVtcGxhdGUgZnVuY3Rpb25hbCAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyA9IGZhbHNlXG4vKiBzdHlsZXMgKi9cbnZhciBfX3Z1ZV9zdHlsZXNfXyA9IGluamVjdFN0eWxlXG4vKiBzY29wZUlkICovXG52YXIgX192dWVfc2NvcGVJZF9fID0gXCJkYXRhLXYtNjRkODE3YzNcIlxuLyogbW9kdWxlSWRlbnRpZmllciAoc2VydmVyIG9ubHkpICovXG52YXIgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfXyA9IG51bGxcbnZhciBDb21wb25lbnQgPSBub3JtYWxpemVDb21wb25lbnQoXG4gIF9fdnVlX3NjcmlwdF9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9fLFxuICBfX3Z1ZV90ZW1wbGF0ZV9mdW5jdGlvbmFsX18sXG4gIF9fdnVlX3N0eWxlc19fLFxuICBfX3Z1ZV9zY29wZUlkX18sXG4gIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX19cbilcbkNvbXBvbmVudC5vcHRpb25zLl9fZmlsZSA9IFwibm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtNjRkODE3YzNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi02NGQ4MTdjM1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTMxNDMzM2M0XFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOnRydWV9IS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL2NvbnRlbnQudnVlXCIpO1xuaWYodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSBjb250ZW50ID0gW1ttb2R1bGUuaWQsIGNvbnRlbnQsICcnXV07XG5pZihjb250ZW50LmxvY2FscykgbW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2Fscztcbi8vIGFkZCB0aGUgc3R5bGVzIHRvIHRoZSBET01cbnZhciB1cGRhdGUgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCJlZjdkYjc0NlwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zMTQzMzNjNFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9jb250ZW50LnZ1ZVwiLCBmdW5jdGlvbigpIHtcbiAgICAgdmFyIG5ld0NvbnRlbnQgPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi0zMTQzMzNjNFxcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9jb250ZW50LnZ1ZVwiKTtcbiAgICAgaWYodHlwZW9mIG5ld0NvbnRlbnQgPT09ICdzdHJpbmcnKSBuZXdDb250ZW50ID0gW1ttb2R1bGUuaWQsIG5ld0NvbnRlbnQsICcnXV07XG4gICAgIHVwZGF0ZShuZXdDb250ZW50KTtcbiAgIH0pO1xuIH1cbiAvLyBXaGVuIHRoZSBtb2R1bGUgaXMgZGlzcG9zZWQsIHJlbW92ZSB0aGUgPHN0eWxlPiB0YWdzXG4gbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkgeyB1cGRhdGUoKTsgfSk7XG59XG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlciEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlcj97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zMTQzMzNjNFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZVxuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9pbmRleC5qcyEuL25vZGVfbW9kdWxlcy9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XCJ2dWVcIjp0cnVlLFwiaWRcIjpcImRhdGEtdi0zMTQzMzNjNFwiLFwic2NvcGVkXCI6dHJ1ZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY0ZDgxN2MzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL05vdGlmaWNhdGlvbi52dWVcIik7XG5pZih0eXBlb2YgY29udGVudCA9PT0gJ3N0cmluZycpIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbmlmKGNvbnRlbnQubG9jYWxzKSBtb2R1bGUuZXhwb3J0cyA9IGNvbnRlbnQubG9jYWxzO1xuLy8gYWRkIHRoZSBzdHlsZXMgdG8gdGhlIERPTVxudmFyIHVwZGF0ZSA9IHJlcXVpcmUoXCIhLi4vLi4vdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXCIpKFwiNTBhM2Q3NDRcIiwgY29udGVudCwgZmFsc2UpO1xuLy8gSG90IE1vZHVsZSBSZXBsYWNlbWVudFxuaWYobW9kdWxlLmhvdCkge1xuIC8vIFdoZW4gdGhlIHN0eWxlcyBjaGFuZ2UsIHVwZGF0ZSB0aGUgPHN0eWxlPiB0YWdzXG4gaWYoIWNvbnRlbnQubG9jYWxzKSB7XG4gICBtb2R1bGUuaG90LmFjY2VwdChcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY0ZDgxN2MzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL05vdGlmaWNhdGlvbi52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY0ZDgxN2MzXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL05vdGlmaWNhdGlvbi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNjRkODE3YzNcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9ub2RlX21vZHVsZXMvdnVlLW5vdGlmL3NyYy9Ob3RpZmljYXRpb24udnVlXG4vLyBtb2R1bGUgaWQgPSAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2luZGV4LmpzIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LTY0ZDgxN2MzXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1ub3RpZi9zcmMvTm90aWZpY2F0aW9uLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvLyBzdHlsZS1sb2FkZXI6IEFkZHMgc29tZSBjc3MgdG8gdGhlIERPTSBieSBhZGRpbmcgYSA8c3R5bGU+IHRhZ1xuXG4vLyBsb2FkIHRoZSBzdHlsZXNcbnZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LTY0ZDgxN2MzXFxcIixcXFwic2NvcGVkXFxcIjp0cnVlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOnRydWV9IS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTEmYnVzdENhY2hlIS4vTm90aWZpY2F0aW9uLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI4MDU5NDNkMFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtNjRkODE3YzNcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi4vLi4vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MSZidXN0Q2FjaGUhLi9Ob3RpZmljYXRpb24udnVlXCIsIGZ1bmN0aW9uKCkge1xuICAgICB2YXIgbmV3Q29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi02NGQ4MTdjM1xcXCIsXFxcInNjb3BlZFxcXCI6dHJ1ZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xJmJ1c3RDYWNoZSEuL05vdGlmaWNhdGlvbi52dWVcIik7XG4gICAgIGlmKHR5cGVvZiBuZXdDb250ZW50ID09PSAnc3RyaW5nJykgbmV3Q29udGVudCA9IFtbbW9kdWxlLmlkLCBuZXdDb250ZW50LCAnJ11dO1xuICAgICB1cGRhdGUobmV3Q29udGVudCk7XG4gICB9KTtcbiB9XG4gLy8gV2hlbiB0aGUgbW9kdWxlIGlzIGRpc3Bvc2VkLCByZW1vdmUgdGhlIDxzdHlsZT4gdGFnc1xuIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbigpIHsgdXBkYXRlKCk7IH0pO1xufVxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlcj9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXI/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNjRkODE3YzNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xJmJ1c3RDYWNoZSEuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtNjRkODE3YzNcIixcInNjb3BlZFwiOnRydWUsXCJoYXNJbmxpbmVDb25maWdcIjp0cnVlfSEuL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0xJmJ1c3RDYWNoZSEuL25vZGVfbW9kdWxlcy92dWUtbm90aWYvc3JjL05vdGlmaWNhdGlvbi52dWVcbi8vIG1vZHVsZSBjaHVua3MgPSAwIiwiLy8gc3R5bGUtbG9hZGVyOiBBZGRzIHNvbWUgY3NzIHRvIHRoZSBET00gYnkgYWRkaW5nIGEgPHN0eWxlPiB0YWdcblxuLy8gbG9hZCB0aGUgc3R5bGVzXG52YXIgY29udGVudCA9IHJlcXVpcmUoXCIhIS4uLy4uL2Nzcy1sb2FkZXIvaW5kZXguanM/c291cmNlTWFwIS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyL2luZGV4LmpzP3tcXFwidnVlXFxcIjp0cnVlLFxcXCJpZFxcXCI6XFxcImRhdGEtdi1hZmFhYmQ3MFxcXCIsXFxcInNjb3BlZFxcXCI6ZmFsc2UsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi4vLi4vdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9JY29uLnZ1ZVwiKTtcbmlmKHR5cGVvZiBjb250ZW50ID09PSAnc3RyaW5nJykgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuaWYoY29udGVudC5sb2NhbHMpIG1vZHVsZS5leHBvcnRzID0gY29udGVudC5sb2NhbHM7XG4vLyBhZGQgdGhlIHN0eWxlcyB0byB0aGUgRE9NXG52YXIgdXBkYXRlID0gcmVxdWlyZShcIiEuLi8uLi92dWUtc3R5bGUtbG9hZGVyL2xpYi9hZGRTdHlsZXNDbGllbnQuanNcIikoXCI3YjQ2OGRhNFwiLCBjb250ZW50LCBmYWxzZSk7XG4vLyBIb3QgTW9kdWxlIFJlcGxhY2VtZW50XG5pZihtb2R1bGUuaG90KSB7XG4gLy8gV2hlbiB0aGUgc3R5bGVzIGNoYW5nZSwgdXBkYXRlIHRoZSA8c3R5bGU+IHRhZ3NcbiBpZighY29udGVudC5sb2NhbHMpIHtcbiAgIG1vZHVsZS5ob3QuYWNjZXB0KFwiISEuLi8uLi9jc3MtbG9hZGVyL2luZGV4LmpzP3NvdXJjZU1hcCEuLi8uLi92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleC5qcz97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtYWZhYWJkNzBcXFwiLFxcXCJzY29wZWRcXFwiOmZhbHNlLFxcXCJoYXNJbmxpbmVDb25maWdcXFwiOnRydWV9IS4uLy4uL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vSWNvbi52dWVcIiwgZnVuY3Rpb24oKSB7XG4gICAgIHZhciBuZXdDb250ZW50ID0gcmVxdWlyZShcIiEhLi4vLi4vY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi4vLi4vdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1xcXCJ2dWVcXFwiOnRydWUsXFxcImlkXFxcIjpcXFwiZGF0YS12LWFmYWFiZDcwXFxcIixcXFwic2NvcGVkXFxcIjpmYWxzZSxcXFwiaGFzSW5saW5lQ29uZmlnXFxcIjp0cnVlfSEuLi8uLi92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvci5qcz90eXBlPXN0eWxlcyZpbmRleD0wJmJ1c3RDYWNoZSEuL0ljb24udnVlXCIpO1xuICAgICBpZih0eXBlb2YgbmV3Q29udGVudCA9PT0gJ3N0cmluZycpIG5ld0NvbnRlbnQgPSBbW21vZHVsZS5pZCwgbmV3Q29udGVudCwgJyddXTtcbiAgICAgdXBkYXRlKG5ld0NvbnRlbnQpO1xuICAgfSk7XG4gfVxuIC8vIFdoZW4gdGhlIG1vZHVsZSBpcyBkaXNwb3NlZCwgcmVtb3ZlIHRoZSA8c3R5bGU+IHRhZ3NcbiBtb2R1bGUuaG90LmRpc3Bvc2UoZnVuY3Rpb24oKSB7IHVwZGF0ZSgpOyB9KTtcbn1cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyIS4vbm9kZV9tb2R1bGVzL2Nzcy1sb2FkZXI/c291cmNlTWFwIS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3N0eWxlLWNvbXBpbGVyP3tcInZ1ZVwiOnRydWUsXCJpZFwiOlwiZGF0YS12LWFmYWFiZDcwXCIsXCJzY29wZWRcIjpmYWxzZSxcImhhc0lubGluZUNvbmZpZ1wiOnRydWV9IS4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yLmpzP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vbm9kZV9tb2R1bGVzL3Z1ZS1hd2Vzb21lL2NvbXBvbmVudHMvSWNvbi52dWVcbi8vIG1vZHVsZSBpZCA9IC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvaW5kZXguanMhLi9ub2RlX21vZHVsZXMvY3NzLWxvYWRlci9pbmRleC5qcz9zb3VyY2VNYXAhLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc3R5bGUtY29tcGlsZXIvaW5kZXguanM/e1widnVlXCI6dHJ1ZSxcImlkXCI6XCJkYXRhLXYtYWZhYWJkNzBcIixcInNjb3BlZFwiOmZhbHNlLFwiaGFzSW5saW5lQ29uZmlnXCI6dHJ1ZX0hLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3IuanM/dHlwZT1zdHlsZXMmaW5kZXg9MCZidXN0Q2FjaGUhLi9ub2RlX21vZHVsZXMvdnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uLnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4gIE1vZGlmaWVkIGJ5IEV2YW4gWW91IEB5eXg5OTA4MDNcbiovXG5cbnZhciBoYXNEb2N1bWVudCA9IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCdcblxuaWYgKHR5cGVvZiBERUJVRyAhPT0gJ3VuZGVmaW5lZCcgJiYgREVCVUcpIHtcbiAgaWYgKCFoYXNEb2N1bWVudCkge1xuICAgIHRocm93IG5ldyBFcnJvcihcbiAgICAndnVlLXN0eWxlLWxvYWRlciBjYW5ub3QgYmUgdXNlZCBpbiBhIG5vbi1icm93c2VyIGVudmlyb25tZW50LiAnICtcbiAgICBcIlVzZSB7IHRhcmdldDogJ25vZGUnIH0gaW4geW91ciBXZWJwYWNrIGNvbmZpZyB0byBpbmRpY2F0ZSBhIHNlcnZlci1yZW5kZXJpbmcgZW52aXJvbm1lbnQuXCJcbiAgKSB9XG59XG5cbnZhciBsaXN0VG9TdHlsZXMgPSByZXF1aXJlKCcuL2xpc3RUb1N0eWxlcycpXG5cbi8qXG50eXBlIFN0eWxlT2JqZWN0ID0ge1xuICBpZDogbnVtYmVyO1xuICBwYXJ0czogQXJyYXk8U3R5bGVPYmplY3RQYXJ0PlxufVxuXG50eXBlIFN0eWxlT2JqZWN0UGFydCA9IHtcbiAgY3NzOiBzdHJpbmc7XG4gIG1lZGlhOiBzdHJpbmc7XG4gIHNvdXJjZU1hcDogP3N0cmluZ1xufVxuKi9cblxudmFyIHN0eWxlc0luRG9tID0gey8qXG4gIFtpZDogbnVtYmVyXToge1xuICAgIGlkOiBudW1iZXIsXG4gICAgcmVmczogbnVtYmVyLFxuICAgIHBhcnRzOiBBcnJheTwob2JqPzogU3R5bGVPYmplY3RQYXJ0KSA9PiB2b2lkPlxuICB9XG4qL31cblxudmFyIGhlYWQgPSBoYXNEb2N1bWVudCAmJiAoZG9jdW1lbnQuaGVhZCB8fCBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdKVxudmFyIHNpbmdsZXRvbkVsZW1lbnQgPSBudWxsXG52YXIgc2luZ2xldG9uQ291bnRlciA9IDBcbnZhciBpc1Byb2R1Y3Rpb24gPSBmYWxzZVxudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7fVxuXG4vLyBGb3JjZSBzaW5nbGUtdGFnIHNvbHV0aW9uIG9uIElFNi05LCB3aGljaCBoYXMgYSBoYXJkIGxpbWl0IG9uIHRoZSAjIG9mIDxzdHlsZT5cbi8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbnZhciBpc09sZElFID0gdHlwZW9mIG5hdmlnYXRvciAhPT0gJ3VuZGVmaW5lZCcgJiYgL21zaWUgWzYtOV1cXGIvLnRlc3QobmF2aWdhdG9yLnVzZXJBZ2VudC50b0xvd2VyQ2FzZSgpKVxuXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChwYXJlbnRJZCwgbGlzdCwgX2lzUHJvZHVjdGlvbikge1xuICBpc1Byb2R1Y3Rpb24gPSBfaXNQcm9kdWN0aW9uXG5cbiAgdmFyIHN0eWxlcyA9IGxpc3RUb1N0eWxlcyhwYXJlbnRJZCwgbGlzdClcbiAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuXG4gIHJldHVybiBmdW5jdGlvbiB1cGRhdGUgKG5ld0xpc3QpIHtcbiAgICB2YXIgbWF5UmVtb3ZlID0gW11cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0eWxlcy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGl0ZW0gPSBzdHlsZXNbaV1cbiAgICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgICBkb21TdHlsZS5yZWZzLS1cbiAgICAgIG1heVJlbW92ZS5wdXNoKGRvbVN0eWxlKVxuICAgIH1cbiAgICBpZiAobmV3TGlzdCkge1xuICAgICAgc3R5bGVzID0gbGlzdFRvU3R5bGVzKHBhcmVudElkLCBuZXdMaXN0KVxuICAgICAgYWRkU3R5bGVzVG9Eb20oc3R5bGVzKVxuICAgIH0gZWxzZSB7XG4gICAgICBzdHlsZXMgPSBbXVxuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1heVJlbW92ZS5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGRvbVN0eWxlID0gbWF5UmVtb3ZlW2ldXG4gICAgICBpZiAoZG9tU3R5bGUucmVmcyA9PT0gMCkge1xuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGRvbVN0eWxlLnBhcnRzLmxlbmd0aDsgaisrKSB7XG4gICAgICAgICAgZG9tU3R5bGUucGFydHNbal0oKVxuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBzdHlsZXNJbkRvbVtkb21TdHlsZS5pZF1cbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYWRkU3R5bGVzVG9Eb20gKHN0eWxlcyAvKiBBcnJheTxTdHlsZU9iamVjdD4gKi8pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBzdHlsZXMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgaXRlbSA9IHN0eWxlc1tpXVxuICAgIHZhciBkb21TdHlsZSA9IHN0eWxlc0luRG9tW2l0ZW0uaWRdXG4gICAgaWYgKGRvbVN0eWxlKSB7XG4gICAgICBkb21TdHlsZS5yZWZzKytcbiAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgZG9tU3R5bGUucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgZG9tU3R5bGUucGFydHNbal0oaXRlbS5wYXJ0c1tqXSlcbiAgICAgIH1cbiAgICAgIGZvciAoOyBqIDwgaXRlbS5wYXJ0cy5sZW5ndGg7IGorKykge1xuICAgICAgICBkb21TdHlsZS5wYXJ0cy5wdXNoKGFkZFN0eWxlKGl0ZW0ucGFydHNbal0pKVxuICAgICAgfVxuICAgICAgaWYgKGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA+IGl0ZW0ucGFydHMubGVuZ3RoKSB7XG4gICAgICAgIGRvbVN0eWxlLnBhcnRzLmxlbmd0aCA9IGl0ZW0ucGFydHMubGVuZ3RoXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBwYXJ0cyA9IFtdXG4gICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGl0ZW0ucGFydHMubGVuZ3RoOyBqKyspIHtcbiAgICAgICAgcGFydHMucHVzaChhZGRTdHlsZShpdGVtLnBhcnRzW2pdKSlcbiAgICAgIH1cbiAgICAgIHN0eWxlc0luRG9tW2l0ZW0uaWRdID0geyBpZDogaXRlbS5pZCwgcmVmczogMSwgcGFydHM6IHBhcnRzIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlU3R5bGVFbGVtZW50ICgpIHtcbiAgdmFyIHN0eWxlRWxlbWVudCA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ3N0eWxlJylcbiAgc3R5bGVFbGVtZW50LnR5cGUgPSAndGV4dC9jc3MnXG4gIGhlYWQuYXBwZW5kQ2hpbGQoc3R5bGVFbGVtZW50KVxuICByZXR1cm4gc3R5bGVFbGVtZW50XG59XG5cbmZ1bmN0aW9uIGFkZFN0eWxlIChvYmogLyogU3R5bGVPYmplY3RQYXJ0ICovKSB7XG4gIHZhciB1cGRhdGUsIHJlbW92ZVxuICB2YXIgc3R5bGVFbGVtZW50ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcignc3R5bGVbZGF0YS12dWUtc3NyLWlkfj1cIicgKyBvYmouaWQgKyAnXCJdJylcblxuICBpZiAoc3R5bGVFbGVtZW50KSB7XG4gICAgaWYgKGlzUHJvZHVjdGlvbikge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYW5kIGluIHByb2R1Y3Rpb24gbW9kZS5cbiAgICAgIC8vIHNpbXBseSBkbyBub3RoaW5nLlxuICAgICAgcmV0dXJuIG5vb3BcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gaGFzIFNTUiBzdHlsZXMgYnV0IGluIGRldiBtb2RlLlxuICAgICAgLy8gZm9yIHNvbWUgcmVhc29uIENocm9tZSBjYW4ndCBoYW5kbGUgc291cmNlIG1hcCBpbiBzZXJ2ZXItcmVuZGVyZWRcbiAgICAgIC8vIHN0eWxlIHRhZ3MgLSBzb3VyY2UgbWFwcyBpbiA8c3R5bGU+IG9ubHkgd29ya3MgaWYgdGhlIHN0eWxlIHRhZyBpc1xuICAgICAgLy8gY3JlYXRlZCBhbmQgaW5zZXJ0ZWQgZHluYW1pY2FsbHkuIFNvIHdlIHJlbW92ZSB0aGUgc2VydmVyIHJlbmRlcmVkXG4gICAgICAvLyBzdHlsZXMgYW5kIGluamVjdCBuZXcgb25lcy5cbiAgICAgIHN0eWxlRWxlbWVudC5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlRWxlbWVudClcbiAgICB9XG4gIH1cblxuICBpZiAoaXNPbGRJRSkge1xuICAgIC8vIHVzZSBzaW5nbGV0b24gbW9kZSBmb3IgSUU5LlxuICAgIHZhciBzdHlsZUluZGV4ID0gc2luZ2xldG9uQ291bnRlcisrXG4gICAgc3R5bGVFbGVtZW50ID0gc2luZ2xldG9uRWxlbWVudCB8fCAoc2luZ2xldG9uRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpKVxuICAgIHVwZGF0ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIGZhbHNlKVxuICAgIHJlbW92ZSA9IGFwcGx5VG9TaW5nbGV0b25UYWcuYmluZChudWxsLCBzdHlsZUVsZW1lbnQsIHN0eWxlSW5kZXgsIHRydWUpXG4gIH0gZWxzZSB7XG4gICAgLy8gdXNlIG11bHRpLXN0eWxlLXRhZyBtb2RlIGluIGFsbCBvdGhlciBjYXNlc1xuICAgIHN0eWxlRWxlbWVudCA9IGNyZWF0ZVN0eWxlRWxlbWVudCgpXG4gICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlRWxlbWVudClcbiAgICByZW1vdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICBzdHlsZUVsZW1lbnQucGFyZW50Tm9kZS5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQpXG4gICAgfVxuICB9XG5cbiAgdXBkYXRlKG9iailcblxuICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUgKG5ld09iaiAvKiBTdHlsZU9iamVjdFBhcnQgKi8pIHtcbiAgICBpZiAobmV3T2JqKSB7XG4gICAgICBpZiAobmV3T2JqLmNzcyA9PT0gb2JqLmNzcyAmJlxuICAgICAgICAgIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmXG4gICAgICAgICAgbmV3T2JqLnNvdXJjZU1hcCA9PT0gb2JqLnNvdXJjZU1hcCkge1xuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIHVwZGF0ZShvYmogPSBuZXdPYmopXG4gICAgfSBlbHNlIHtcbiAgICAgIHJlbW92ZSgpXG4gICAgfVxuICB9XG59XG5cbnZhciByZXBsYWNlVGV4dCA9IChmdW5jdGlvbiAoKSB7XG4gIHZhciB0ZXh0U3RvcmUgPSBbXVxuXG4gIHJldHVybiBmdW5jdGlvbiAoaW5kZXgsIHJlcGxhY2VtZW50KSB7XG4gICAgdGV4dFN0b3JlW2luZGV4XSA9IHJlcGxhY2VtZW50XG4gICAgcmV0dXJuIHRleHRTdG9yZS5maWx0ZXIoQm9vbGVhbikuam9pbignXFxuJylcbiAgfVxufSkoKVxuXG5mdW5jdGlvbiBhcHBseVRvU2luZ2xldG9uVGFnIChzdHlsZUVsZW1lbnQsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICB2YXIgY3NzID0gcmVtb3ZlID8gJycgOiBvYmouY3NzXG5cbiAgaWYgKHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0KSB7XG4gICAgc3R5bGVFbGVtZW50LnN0eWxlU2hlZXQuY3NzVGV4dCA9IHJlcGxhY2VUZXh0KGluZGV4LCBjc3MpXG4gIH0gZWxzZSB7XG4gICAgdmFyIGNzc05vZGUgPSBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpXG4gICAgdmFyIGNoaWxkTm9kZXMgPSBzdHlsZUVsZW1lbnQuY2hpbGROb2Rlc1xuICAgIGlmIChjaGlsZE5vZGVzW2luZGV4XSkgc3R5bGVFbGVtZW50LnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKVxuICAgIGlmIChjaGlsZE5vZGVzLmxlbmd0aCkge1xuICAgICAgc3R5bGVFbGVtZW50Lmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSlcbiAgICB9IGVsc2Uge1xuICAgICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGNzc05vZGUpXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5VG9UYWcgKHN0eWxlRWxlbWVudCwgb2JqKSB7XG4gIHZhciBjc3MgPSBvYmouY3NzXG4gIHZhciBtZWRpYSA9IG9iai5tZWRpYVxuICB2YXIgc291cmNlTWFwID0gb2JqLnNvdXJjZU1hcFxuXG4gIGlmIChtZWRpYSkge1xuICAgIHN0eWxlRWxlbWVudC5zZXRBdHRyaWJ1dGUoJ21lZGlhJywgbWVkaWEpXG4gIH1cblxuICBpZiAoc291cmNlTWFwKSB7XG4gICAgLy8gaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kZXZ0b29scy9kb2NzL2phdmFzY3JpcHQtZGVidWdnaW5nXG4gICAgLy8gdGhpcyBtYWtlcyBzb3VyY2UgbWFwcyBpbnNpZGUgc3R5bGUgdGFncyB3b3JrIHByb3Blcmx5IGluIENocm9tZVxuICAgIGNzcyArPSAnXFxuLyojIHNvdXJjZVVSTD0nICsgc291cmNlTWFwLnNvdXJjZXNbMF0gKyAnICovJ1xuICAgIC8vIGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzI2NjAzODc1XG4gICAgY3NzICs9ICdcXG4vKiMgc291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247YmFzZTY0LCcgKyBidG9hKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudChKU09OLnN0cmluZ2lmeShzb3VyY2VNYXApKSkpICsgJyAqLydcbiAgfVxuXG4gIGlmIChzdHlsZUVsZW1lbnQuc3R5bGVTaGVldCkge1xuICAgIHN0eWxlRWxlbWVudC5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3NcbiAgfSBlbHNlIHtcbiAgICB3aGlsZSAoc3R5bGVFbGVtZW50LmZpcnN0Q2hpbGQpIHtcbiAgICAgIHN0eWxlRWxlbWVudC5yZW1vdmVDaGlsZChzdHlsZUVsZW1lbnQuZmlyc3RDaGlsZClcbiAgICB9XG4gICAgc3R5bGVFbGVtZW50LmFwcGVuZENoaWxkKGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcykpXG4gIH1cbn1cblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZS1zdHlsZS1sb2FkZXIvbGliL2FkZFN0eWxlc0NsaWVudC5qc1xuLy8gbW9kdWxlIGlkID0gLi9ub2RlX21vZHVsZXMvdnVlLXN0eWxlLWxvYWRlci9saWIvYWRkU3R5bGVzQ2xpZW50LmpzXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qKlxuICogVHJhbnNsYXRlcyB0aGUgbGlzdCBmb3JtYXQgcHJvZHVjZWQgYnkgY3NzLWxvYWRlciBpbnRvIHNvbWV0aGluZ1xuICogZWFzaWVyIHRvIG1hbmlwdWxhdGUuXG4gKi9cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbGlzdFRvU3R5bGVzIChwYXJlbnRJZCwgbGlzdCkge1xuICB2YXIgc3R5bGVzID0gW11cbiAgdmFyIG5ld1N0eWxlcyA9IHt9XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgbGlzdC5sZW5ndGg7IGkrKykge1xuICAgIHZhciBpdGVtID0gbGlzdFtpXVxuICAgIHZhciBpZCA9IGl0ZW1bMF1cbiAgICB2YXIgY3NzID0gaXRlbVsxXVxuICAgIHZhciBtZWRpYSA9IGl0ZW1bMl1cbiAgICB2YXIgc291cmNlTWFwID0gaXRlbVszXVxuICAgIHZhciBwYXJ0ID0ge1xuICAgICAgaWQ6IHBhcmVudElkICsgJzonICsgaSxcbiAgICAgIGNzczogY3NzLFxuICAgICAgbWVkaWE6IG1lZGlhLFxuICAgICAgc291cmNlTWFwOiBzb3VyY2VNYXBcbiAgICB9XG4gICAgaWYgKCFuZXdTdHlsZXNbaWRdKSB7XG4gICAgICBzdHlsZXMucHVzaChuZXdTdHlsZXNbaWRdID0geyBpZDogaWQsIHBhcnRzOiBbcGFydF0gfSlcbiAgICB9IGVsc2Uge1xuICAgICAgbmV3U3R5bGVzW2lkXS5wYXJ0cy5wdXNoKHBhcnQpXG4gICAgfVxuICB9XG4gIHJldHVybiBzdHlsZXNcbn1cblxuXG5cbi8vIFdFQlBBQ0sgRk9PVEVSIC8vXG4vLyAuL25vZGVfbW9kdWxlcy92dWUtc3R5bGUtbG9hZGVyL2xpYi9saXN0VG9TdHlsZXMuanMiLCJjb25zdCBUaXBweSA9IHJlcXVpcmUoJ3RpcHB5LmpzJyk7XG5jb25zdCBjc3MgPSByZXF1aXJlKCd0aXBweS5qcy9kaXN0L3RpcHB5LmNzcycpO1xuXG5pZiAoIUFycmF5LnByb3RvdHlwZS5zb21lKSB7XG4gICAgQXJyYXkucHJvdG90eXBlLnNvbWUgPSBmdW5jdGlvbiAoZnVuLyosIHRoaXNBcmcqLykge1xuICAgICAgICAndXNlIHN0cmljdCc7XG5cbiAgICAgICAgaWYgKHRoaXMgPT0gbnVsbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignQXJyYXkucHJvdG90eXBlLnNvbWUgY2FsbGVkIG9uIG51bGwgb3IgdW5kZWZpbmVkJyk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAodHlwZW9mIGZ1biAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcigpO1xuICAgICAgICB9XG5cbiAgICAgICAgdmFyIHQgPSBPYmplY3QodGhpcyk7XG4gICAgICAgIHZhciBsZW4gPSB0Lmxlbmd0aCA+Pj4gMDtcblxuICAgICAgICB2YXIgdGhpc0FyZyA9IGFyZ3VtZW50cy5sZW5ndGggPj0gMiA/IGFyZ3VtZW50c1sxXSA6IHZvaWQgMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGkgaW4gdCAmJiBmdW4uY2FsbCh0aGlzQXJnLCB0W2ldLCBpLCB0KSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH07XG59XG52YXIgVnVlVGlwcHkgPSB7XG4gICAgaW5zdGFsbDogZnVuY3Rpb24gKFZ1ZSwgb3B0aW9ucykge1xuICAgICAgICBWdWUuJHRpcHB5SW5zdGFuY2VzID0gW107XG4gICAgICAgIFZ1ZS4kdGlwcHlDb21wb25lbnRzID0gW107XG4gICAgICAgIFZ1ZS5wcm90b3R5cGUuJHRpcHB5ID0ge1xuXG4gICAgICAgICAgICBnZXRJbnN0YW5jZTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFZ1ZS4kdGlwcHlJbnN0YW5jZXMuZmluZChmdW5jdGlvbiAoJGluc3RhbmNlKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAkaW5zdGFuY2UuZWwgPT09IGVsO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldFRpcHB5UG9wcGVyOiBmdW5jdGlvbiAodGlwcHkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGlwcHkuZ2V0UG9wcGVyRWxlbWVudCh0aXBweS5zZWxlY3RvcilcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzaG93UG9wcGVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGlwcHkgPSB0aGlzLmdldFRpcHB5KGVsKTtcbiAgICAgICAgICAgICAgICB0aXBweS5zaG93KHRoaXMuZ2V0VGlwcHlQb3BwZXIodGlwcHkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBoaWRlUG9wcGVyOiBmdW5jdGlvbiAoZWwpIHtcbiAgICAgICAgICAgICAgICB2YXIgdGlwcHkgPSB0aGlzLmdldFRpcHB5KGVsKTtcbiAgICAgICAgICAgICAgICB0aXBweS5oaWRlKHRoaXMuZ2V0VGlwcHlQb3BwZXIodGlwcHkpKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBkZXN0cm95VGlwcHk6IGZ1bmN0aW9uIChlbCkge1xuICAgICAgICAgICAgICAgIHZhciBpID0gdGhpcy5nZXRJbnN0YW5jZShlbCk7XG4gICAgICAgICAgICAgICAgdmFyIHQgPSB0aGlzLmdldFRpcHB5KGVsKTtcbiAgICAgICAgICAgICAgICB0LmRlc3Ryb3kodGhpcy5nZXRUaXBweVBvcHBlcih0KSk7XG4gICAgICAgICAgICAgICAgdmFyIGluZGV4ID0gVnVlLiR0aXBweUluc3RhbmNlcy5pbmRleE9mKGkpO1xuICAgICAgICAgICAgICAgIGlmIChpbmRleCA+IC0xKVxuICAgICAgICAgICAgICAgICAgICBWdWUuJHRpcHB5SW5zdGFuY2VzLnNwbGljZShpbmRleCwgMSk7XG5cbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXRUaXBweTogZnVuY3Rpb24gKGVsKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuZ2V0SW5zdGFuY2UoZWwpLnRpcHB5O1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKGVsKSB7XG5cbiAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlID0gdGhpcy5nZXRJbnN0YW5jZShlbCk7XG5cbiAgICAgICAgICAgICAgICBpZiAodGhpcy5pbnN0YW5jZSkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmluc3RhbmNlLnRpcHB5LnVwZGF0ZSh0aGlzLmluc3RhbmNlLnRpcHB5LmdldFBvcHBlckVsZW1lbnQodGhpcy5pbnN0YW5jZS50aXBweS5zZWxlY3RvcikpXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZm9yY2VVcGRhdGVIdG1sOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgVnVlLiR0aXBweUluc3RhbmNlcy5mb3JFYWNoKGZ1bmN0aW9uIChpbnN0YW5jZSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGlmIChpbnN0YW5jZS50aXBweSAmJiBpbnN0YW5jZS50aXBweSAmJiBpbnN0YW5jZS50aXBweS5zdG9yZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaW5zdGFuY2UudGlwcHkuc3RvcmUuZm9yRWFjaChmdW5jdGlvbiAocykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHMgJiYgcyAmJiBzLnNldHRpbmdzICYmICFzLnNldHRpbmdzLmh0bWwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgVnVlLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHMudGlwcHlJbnN0YW5jZS51cGRhdGUocy5wb3BwZXIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cblxuICAgICAgICB9O1xuXG4gICAgICAgIFZ1ZS5kaXJlY3RpdmUoJ3RpcHB5Jywge1xuICAgICAgICAgICAgaW5zZXJ0ZWQ6IGZ1bmN0aW9uIChlbCwgYmluZGluZywgdm5vZGUsIG9sZFZub2RlKSB7XG5cbiAgICAgICAgICAgICAgICBjb25zdCBoYW5kbGVycyA9ICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEub24pIHx8XG4gICAgICAgICAgICAgICAgICAgICh2bm9kZS5jb21wb25lbnRPcHRpb25zICYmIHZub2RlLmNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzKTtcblxuICAgICAgICAgICAgICAgIHZhciBvcHRzID0gYmluZGluZy52YWx1ZSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIE9iamVjdC5hc3NpZ24ob3B0cywge30sIG9wdGlvbnMpO1xuXG4gICAgICAgICAgICAgICAgb3B0cy5vblNob3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW1wic2hvd1wiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbXCJzaG93XCJdLmZucygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBvcHRzLm9uU2hvd24gPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW1wic2hvd25cIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW1wic2hvd25cIl0uZm5zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wdHMub25IaWRkZW4gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVyc1tcImhpZGRlblwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbXCJoaWRkZW5cIl0uZm5zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIG9wdHMub25IaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaGFuZGxlcnMgJiYgaGFuZGxlcnNbXCJoaWRlXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tcImhpZGVcIl0uZm5zKCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9O1xuXG4gICAgICAgICAgICAgICAgaWYgKGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1odG1sJykpIHtcblxuICAgICAgICAgICAgICAgICAgICB2bm9kZS5jb250ZXh0LiRjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uICgkdm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghVnVlLiR0aXBweUNvbXBvbmVudHMuc29tZShmdW5jdGlvbiAoeCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4geC5fdWlkID09PSAkdm0uX3VpZFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCR2bS4kb3B0aW9ucy51cGRhdGVkID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZtLiRvcHRpb25zLnVwZGF0ZWQgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAkdm0uJG9wdGlvbnMudXBkYXRlZC5wdXNoKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgJHZtLiR0aXBweS5mb3JjZVVwZGF0ZUh0bWwoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZ1ZS4kdGlwcHlDb21wb25lbnRzLnB1c2goJHZtKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSlcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKG9wdHMuaHRtbCkge1xuICAgICAgICAgICAgICAgICAgICBvcHRzLmh0bWwgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKG9wdHMuaHRtbClcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAvLyBpZiAob3B0cy5zaG93ICYmICFvcHRzLnRyaWdnZXIpIHtcbiAgICAgICAgICAgICAgICAvLyAgICAgb3B0cy50cmlnZ2VyID0gJ21hbnVhbCc7XG4gICAgICAgICAgICAgICAgLy8gfVxuXG4gICAgICAgICAgICAgICAgZWwudGlwcHkgPSBuZXcgVGlwcHkoZWwsIG9wdHMpO1xuXG4gICAgICAgICAgICAgICAgVnVlLiR0aXBweUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgZWw6IGVsLFxuICAgICAgICAgICAgICAgICAgICB0aXBweTogZWwudGlwcHlcbiAgICAgICAgICAgICAgICB9KTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRzLnNob3dPbkxvYWQpIHtcbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29udGV4dC4kdGlwcHkuc2hvd1BvcHBlcihlbCk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgdW5iaW5kOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgICAgICAgICAgICAgdm5vZGUuY29udGV4dC4kdGlwcHkuZGVzdHJveVRpcHB5KGVsKTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjb21wb25lbnRVcGRhdGVkOiBmdW5jdGlvbiAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG5cbiAgICAgICAgICAgICAgICB2YXIgb3B0cyA9IGJpbmRpbmcudmFsdWUgfHwge307XG4gICAgICAgICAgICAgICAgdmFyIG9sZFZhbHVlID0gYmluZGluZy5vbGRWYWx1ZSB8fCB7fTtcblxuICAgICAgICAgICAgICAgIGlmIChvcHRzLmh0bWwpIHJldHVybjtcblxuICAgICAgICAgICAgICAgIGlmIChlbC50aXBweSAmJiAoIEpTT04uc3RyaW5naWZ5KG9wdHMpICE9PSBKU09OLnN0cmluZ2lmeShvbGRWYWx1ZSkgKSkge1xuXG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGhhbmRsZXJzID0gKHZub2RlLmRhdGEgJiYgdm5vZGUuZGF0YS5vbikgfHwgKHZub2RlLmNvbXBvbmVudE9wdGlvbnMgJiYgdm5vZGUuY29tcG9uZW50T3B0aW9ucy5saXN0ZW5lcnMpO1xuXG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHQuJHRpcHB5LmRlc3Ryb3lUaXBweShlbCk7XG5cbiAgICAgICAgICAgICAgICAgICAgb3B0cy5vblNob3cgPSBmdW5jdGlvbiAoKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChoYW5kbGVycyAmJiBoYW5kbGVyc1tcInNob3dcIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tcInNob3dcIl0uZm5zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25TaG93biA9IGZ1bmN0aW9uICgpIHtcblxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW1wic2hvd25cIl0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBoYW5kbGVyc1tcInNob3duXCJdLmZucygpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgICAgICBvcHRzLm9uSGlkZGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW1wiaGlkZGVuXCJdKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaGFuZGxlcnNbXCJoaWRkZW5cIl0uZm5zKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIG9wdHMub25IaWRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGhhbmRsZXJzICYmIGhhbmRsZXJzW1wiaGlkZVwiXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhhbmRsZXJzW1wiaGlkZVwiXS5mbnMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfTtcblxuICAgICAgICAgICAgICAgICAgICBlbC50aXBweSA9IG5ldyBUaXBweShlbCwgb3B0cyk7XG5cbiAgICAgICAgICAgICAgICAgICAgVnVlLiR0aXBweUluc3RhbmNlcy5wdXNoKHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVsOiBlbCxcbiAgICAgICAgICAgICAgICAgICAgICAgIHRpcHB5OiBlbC50aXBweSxcblxuICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChlbC50aXBweSAmJiAoZWwuZ2V0QXR0cmlidXRlKCd0aXRsZScpIHx8IGVsLmdldEF0dHJpYnV0ZSgnZGF0YS1odG1sJykpKSB7XG5cbiAgICAgICAgICAgICAgICAgICAgdm5vZGUuY29udGV4dC4kbmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgZWwudGlwcHkuc3RvcmUuZm9yRWFjaChmdW5jdGlvbiAocykge1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHBvcHBlciA9IHMucG9wcGVyO1xuXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHRpcCA9IHMudGlwcHlJbnN0YW5jZTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpcC51cGRhdGUocG9wcGVyKTtcblxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuXG5cbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICBpZiAoZWwudGlwcHkgJiYgb3B0cy5zaG93KSB7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHQuJHRpcHB5LnNob3dQb3BwZXIoZWwpO1xuICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoZWwudGlwcHkgJiYgIW9wdHMuc2hvdyAmJiBvcHRzLnRyaWdnZXIgPT09ICdtYW51YWwnKSB7XG4gICAgICAgICAgICAgICAgICAgIHZub2RlLmNvbnRleHQuJHRpcHB5LmhpZGVQb3BwZXIoZWwpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgfVxuXG4gICAgICAgIH0pXG4gICAgfVxufTtcblxuaWYgKHR5cGVvZiBleHBvcnRzID09IFwib2JqZWN0XCIpIHtcbiAgICBtb2R1bGUuZXhwb3J0cyA9IFZ1ZVRpcHB5XG59IGVsc2UgaWYgKHR5cGVvZiBkZWZpbmUgPT0gXCJmdW5jdGlvblwiICYmIGRlZmluZS5hbWQpIHtcbiAgICBkZWZpbmUoW10sIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFZ1ZVRpcHB5XG4gICAgfSlcbn1cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlLXRpcHB5L3Z1ZS10aXBweS5qcyIsIi8qIVxuICogVnVlLmpzIHYyLjUuOVxuICogKGMpIDIwMTQtMjAxNyBFdmFuIFlvdVxuICogUmVsZWFzZWQgdW5kZXIgdGhlIE1JVCBMaWNlbnNlLlxuICovXG4ndXNlIHN0cmljdCc7XG5cbi8qICAqL1xuXG52YXIgZW1wdHlPYmplY3QgPSBPYmplY3QuZnJlZXplKHt9KTtcblxuLy8gdGhlc2UgaGVscGVycyBwcm9kdWNlcyBiZXR0ZXIgdm0gY29kZSBpbiBKUyBlbmdpbmVzIGR1ZSB0byB0aGVpclxuLy8gZXhwbGljaXRuZXNzIGFuZCBmdW5jdGlvbiBpbmxpbmluZ1xuZnVuY3Rpb24gaXNVbmRlZiAodikge1xuICByZXR1cm4gdiA9PT0gdW5kZWZpbmVkIHx8IHYgPT09IG51bGxcbn1cblxuZnVuY3Rpb24gaXNEZWYgKHYpIHtcbiAgcmV0dXJuIHYgIT09IHVuZGVmaW5lZCAmJiB2ICE9PSBudWxsXG59XG5cbmZ1bmN0aW9uIGlzVHJ1ZSAodikge1xuICByZXR1cm4gdiA9PT0gdHJ1ZVxufVxuXG5mdW5jdGlvbiBpc0ZhbHNlICh2KSB7XG4gIHJldHVybiB2ID09PSBmYWxzZVxufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbHVlIGlzIHByaW1pdGl2ZVxuICovXG5mdW5jdGlvbiBpc1ByaW1pdGl2ZSAodmFsdWUpIHtcbiAgcmV0dXJuIChcbiAgICB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnIHx8XG4gICAgdHlwZW9mIHZhbHVlID09PSAnbnVtYmVyJyB8fFxuICAgIHR5cGVvZiB2YWx1ZSA9PT0gJ2Jvb2xlYW4nXG4gIClcbn1cblxuLyoqXG4gKiBRdWljayBvYmplY3QgY2hlY2sgLSB0aGlzIGlzIHByaW1hcmlseSB1c2VkIHRvIHRlbGxcbiAqIE9iamVjdHMgZnJvbSBwcmltaXRpdmUgdmFsdWVzIHdoZW4gd2Uga25vdyB0aGUgdmFsdWVcbiAqIGlzIGEgSlNPTi1jb21wbGlhbnQgdHlwZS5cbiAqL1xuZnVuY3Rpb24gaXNPYmplY3QgKG9iaikge1xuICByZXR1cm4gb2JqICE9PSBudWxsICYmIHR5cGVvZiBvYmogPT09ICdvYmplY3QnXG59XG5cbi8qKlxuICogR2V0IHRoZSByYXcgdHlwZSBzdHJpbmcgb2YgYSB2YWx1ZSBlLmcuIFtvYmplY3QgT2JqZWN0XVxuICovXG52YXIgX3RvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcblxuZnVuY3Rpb24gdG9SYXdUeXBlICh2YWx1ZSkge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwodmFsdWUpLnNsaWNlKDgsIC0xKVxufVxuXG4vKipcbiAqIFN0cmljdCBvYmplY3QgdHlwZSBjaGVjay4gT25seSByZXR1cm5zIHRydWVcbiAqIGZvciBwbGFpbiBKYXZhU2NyaXB0IG9iamVjdHMuXG4gKi9cbmZ1bmN0aW9uIGlzUGxhaW5PYmplY3QgKG9iaikge1xuICByZXR1cm4gX3RvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgT2JqZWN0XSdcbn1cblxuZnVuY3Rpb24gaXNSZWdFeHAgKHYpIHtcbiAgcmV0dXJuIF90b1N0cmluZy5jYWxsKHYpID09PSAnW29iamVjdCBSZWdFeHBdJ1xufVxuXG4vKipcbiAqIENoZWNrIGlmIHZhbCBpcyBhIHZhbGlkIGFycmF5IGluZGV4LlxuICovXG5mdW5jdGlvbiBpc1ZhbGlkQXJyYXlJbmRleCAodmFsKSB7XG4gIHZhciBuID0gcGFyc2VGbG9hdChTdHJpbmcodmFsKSk7XG4gIHJldHVybiBuID49IDAgJiYgTWF0aC5mbG9vcihuKSA9PT0gbiAmJiBpc0Zpbml0ZSh2YWwpXG59XG5cbi8qKlxuICogQ29udmVydCBhIHZhbHVlIHRvIGEgc3RyaW5nIHRoYXQgaXMgYWN0dWFsbHkgcmVuZGVyZWQuXG4gKi9cbmZ1bmN0aW9uIHRvU3RyaW5nICh2YWwpIHtcbiAgcmV0dXJuIHZhbCA9PSBudWxsXG4gICAgPyAnJ1xuICAgIDogdHlwZW9mIHZhbCA9PT0gJ29iamVjdCdcbiAgICAgID8gSlNPTi5zdHJpbmdpZnkodmFsLCBudWxsLCAyKVxuICAgICAgOiBTdHJpbmcodmFsKVxufVxuXG4vKipcbiAqIENvbnZlcnQgYSBpbnB1dCB2YWx1ZSB0byBhIG51bWJlciBmb3IgcGVyc2lzdGVuY2UuXG4gKiBJZiB0aGUgY29udmVyc2lvbiBmYWlscywgcmV0dXJuIG9yaWdpbmFsIHN0cmluZy5cbiAqL1xuZnVuY3Rpb24gdG9OdW1iZXIgKHZhbCkge1xuICB2YXIgbiA9IHBhcnNlRmxvYXQodmFsKTtcbiAgcmV0dXJuIGlzTmFOKG4pID8gdmFsIDogblxufVxuXG4vKipcbiAqIE1ha2UgYSBtYXAgYW5kIHJldHVybiBhIGZ1bmN0aW9uIGZvciBjaGVja2luZyBpZiBhIGtleVxuICogaXMgaW4gdGhhdCBtYXAuXG4gKi9cbmZ1bmN0aW9uIG1ha2VNYXAgKFxuICBzdHIsXG4gIGV4cGVjdHNMb3dlckNhc2Vcbikge1xuICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdmFyIGxpc3QgPSBzdHIuc3BsaXQoJywnKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsaXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgbWFwW2xpc3RbaV1dID0gdHJ1ZTtcbiAgfVxuICByZXR1cm4gZXhwZWN0c0xvd2VyQ2FzZVxuICAgID8gZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbC50b0xvd2VyQ2FzZSgpXTsgfVxuICAgIDogZnVuY3Rpb24gKHZhbCkgeyByZXR1cm4gbWFwW3ZhbF07IH1cbn1cblxuLyoqXG4gKiBDaGVjayBpZiBhIHRhZyBpcyBhIGJ1aWx0LWluIHRhZy5cbiAqL1xudmFyIGlzQnVpbHRJblRhZyA9IG1ha2VNYXAoJ3Nsb3QsY29tcG9uZW50JywgdHJ1ZSk7XG5cbi8qKlxuICogQ2hlY2sgaWYgYSBhdHRyaWJ1dGUgaXMgYSByZXNlcnZlZCBhdHRyaWJ1dGUuXG4gKi9cbnZhciBpc1Jlc2VydmVkQXR0cmlidXRlID0gbWFrZU1hcCgna2V5LHJlZixzbG90LHNsb3Qtc2NvcGUsaXMnKTtcblxuLyoqXG4gKiBSZW1vdmUgYW4gaXRlbSBmcm9tIGFuIGFycmF5XG4gKi9cbmZ1bmN0aW9uIHJlbW92ZSAoYXJyLCBpdGVtKSB7XG4gIGlmIChhcnIubGVuZ3RoKSB7XG4gICAgdmFyIGluZGV4ID0gYXJyLmluZGV4T2YoaXRlbSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHtcbiAgICAgIHJldHVybiBhcnIuc3BsaWNlKGluZGV4LCAxKVxuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIENoZWNrIHdoZXRoZXIgdGhlIG9iamVjdCBoYXMgdGhlIHByb3BlcnR5LlxuICovXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuZnVuY3Rpb24gaGFzT3duIChvYmosIGtleSkge1xuICByZXR1cm4gaGFzT3duUHJvcGVydHkuY2FsbChvYmosIGtleSlcbn1cblxuLyoqXG4gKiBDcmVhdGUgYSBjYWNoZWQgdmVyc2lvbiBvZiBhIHB1cmUgZnVuY3Rpb24uXG4gKi9cbmZ1bmN0aW9uIGNhY2hlZCAoZm4pIHtcbiAgdmFyIGNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgcmV0dXJuIChmdW5jdGlvbiBjYWNoZWRGbiAoc3RyKSB7XG4gICAgdmFyIGhpdCA9IGNhY2hlW3N0cl07XG4gICAgcmV0dXJuIGhpdCB8fCAoY2FjaGVbc3RyXSA9IGZuKHN0cikpXG4gIH0pXG59XG5cbi8qKlxuICogQ2FtZWxpemUgYSBoeXBoZW4tZGVsaW1pdGVkIHN0cmluZy5cbiAqL1xudmFyIGNhbWVsaXplUkUgPSAvLShcXHcpL2c7XG52YXIgY2FtZWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoY2FtZWxpemVSRSwgZnVuY3Rpb24gKF8sIGMpIHsgcmV0dXJuIGMgPyBjLnRvVXBwZXJDYXNlKCkgOiAnJzsgfSlcbn0pO1xuXG4vKipcbiAqIENhcGl0YWxpemUgYSBzdHJpbmcuXG4gKi9cbnZhciBjYXBpdGFsaXplID0gY2FjaGVkKGZ1bmN0aW9uIChzdHIpIHtcbiAgcmV0dXJuIHN0ci5jaGFyQXQoMCkudG9VcHBlckNhc2UoKSArIHN0ci5zbGljZSgxKVxufSk7XG5cbi8qKlxuICogSHlwaGVuYXRlIGEgY2FtZWxDYXNlIHN0cmluZy5cbiAqL1xudmFyIGh5cGhlbmF0ZVJFID0gL1xcQihbQS1aXSkvZztcbnZhciBoeXBoZW5hdGUgPSBjYWNoZWQoZnVuY3Rpb24gKHN0cikge1xuICByZXR1cm4gc3RyLnJlcGxhY2UoaHlwaGVuYXRlUkUsICctJDEnKS50b0xvd2VyQ2FzZSgpXG59KTtcblxuLyoqXG4gKiBTaW1wbGUgYmluZCwgZmFzdGVyIHRoYW4gbmF0aXZlXG4gKi9cbmZ1bmN0aW9uIGJpbmQgKGZuLCBjdHgpIHtcbiAgZnVuY3Rpb24gYm91bmRGbiAoYSkge1xuICAgIHZhciBsID0gYXJndW1lbnRzLmxlbmd0aDtcbiAgICByZXR1cm4gbFxuICAgICAgPyBsID4gMVxuICAgICAgICA/IGZuLmFwcGx5KGN0eCwgYXJndW1lbnRzKVxuICAgICAgICA6IGZuLmNhbGwoY3R4LCBhKVxuICAgICAgOiBmbi5jYWxsKGN0eClcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgZm4gbGVuZ3RoXG4gIGJvdW5kRm4uX2xlbmd0aCA9IGZuLmxlbmd0aDtcbiAgcmV0dXJuIGJvdW5kRm5cbn1cblxuLyoqXG4gKiBDb252ZXJ0IGFuIEFycmF5LWxpa2Ugb2JqZWN0IHRvIGEgcmVhbCBBcnJheS5cbiAqL1xuZnVuY3Rpb24gdG9BcnJheSAobGlzdCwgc3RhcnQpIHtcbiAgc3RhcnQgPSBzdGFydCB8fCAwO1xuICB2YXIgaSA9IGxpc3QubGVuZ3RoIC0gc3RhcnQ7XG4gIHZhciByZXQgPSBuZXcgQXJyYXkoaSk7XG4gIHdoaWxlIChpLS0pIHtcbiAgICByZXRbaV0gPSBsaXN0W2kgKyBzdGFydF07XG4gIH1cbiAgcmV0dXJuIHJldFxufVxuXG4vKipcbiAqIE1peCBwcm9wZXJ0aWVzIGludG8gdGFyZ2V0IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gZXh0ZW5kICh0bywgX2Zyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIF9mcm9tKSB7XG4gICAgdG9ba2V5XSA9IF9mcm9tW2tleV07XG4gIH1cbiAgcmV0dXJuIHRvXG59XG5cbi8qKlxuICogTWVyZ2UgYW4gQXJyYXkgb2YgT2JqZWN0cyBpbnRvIGEgc2luZ2xlIE9iamVjdC5cbiAqL1xuZnVuY3Rpb24gdG9PYmplY3QgKGFycikge1xuICB2YXIgcmVzID0ge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXJyLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKGFycltpXSkge1xuICAgICAgZXh0ZW5kKHJlcywgYXJyW2ldKTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKipcbiAqIFBlcmZvcm0gbm8gb3BlcmF0aW9uLlxuICogU3R1YmJpbmcgYXJncyB0byBtYWtlIEZsb3cgaGFwcHkgd2l0aG91dCBsZWF2aW5nIHVzZWxlc3MgdHJhbnNwaWxlZCBjb2RlXG4gKiB3aXRoIC4uLnJlc3QgKGh0dHBzOi8vZmxvdy5vcmcvYmxvZy8yMDE3LzA1LzA3L1N0cmljdC1GdW5jdGlvbi1DYWxsLUFyaXR5LylcbiAqL1xuZnVuY3Rpb24gbm9vcCAoYSwgYiwgYykge31cblxuLyoqXG4gKiBBbHdheXMgcmV0dXJuIGZhbHNlLlxuICovXG52YXIgbm8gPSBmdW5jdGlvbiAoYSwgYiwgYykgeyByZXR1cm4gZmFsc2U7IH07XG5cbi8qKlxuICogUmV0dXJuIHNhbWUgdmFsdWVcbiAqL1xudmFyIGlkZW50aXR5ID0gZnVuY3Rpb24gKF8pIHsgcmV0dXJuIF87IH07XG5cbi8qKlxuICogR2VuZXJhdGUgYSBzdGF0aWMga2V5cyBzdHJpbmcgZnJvbSBjb21waWxlciBtb2R1bGVzLlxuICovXG5mdW5jdGlvbiBnZW5TdGF0aWNLZXlzIChtb2R1bGVzKSB7XG4gIHJldHVybiBtb2R1bGVzLnJlZHVjZShmdW5jdGlvbiAoa2V5cywgbSkge1xuICAgIHJldHVybiBrZXlzLmNvbmNhdChtLnN0YXRpY0tleXMgfHwgW10pXG4gIH0sIFtdKS5qb2luKCcsJylcbn1cblxuLyoqXG4gKiBDaGVjayBpZiB0d28gdmFsdWVzIGFyZSBsb29zZWx5IGVxdWFsIC0gdGhhdCBpcyxcbiAqIGlmIHRoZXkgYXJlIHBsYWluIG9iamVjdHMsIGRvIHRoZXkgaGF2ZSB0aGUgc2FtZSBzaGFwZT9cbiAqL1xuZnVuY3Rpb24gbG9vc2VFcXVhbCAoYSwgYikge1xuICBpZiAoYSA9PT0gYikgeyByZXR1cm4gdHJ1ZSB9XG4gIHZhciBpc09iamVjdEEgPSBpc09iamVjdChhKTtcbiAgdmFyIGlzT2JqZWN0QiA9IGlzT2JqZWN0KGIpO1xuICBpZiAoaXNPYmplY3RBICYmIGlzT2JqZWN0Qikge1xuICAgIHRyeSB7XG4gICAgICB2YXIgaXNBcnJheUEgPSBBcnJheS5pc0FycmF5KGEpO1xuICAgICAgdmFyIGlzQXJyYXlCID0gQXJyYXkuaXNBcnJheShiKTtcbiAgICAgIGlmIChpc0FycmF5QSAmJiBpc0FycmF5Qikge1xuICAgICAgICByZXR1cm4gYS5sZW5ndGggPT09IGIubGVuZ3RoICYmIGEuZXZlcnkoZnVuY3Rpb24gKGUsIGkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChlLCBiW2ldKVxuICAgICAgICB9KVxuICAgICAgfSBlbHNlIGlmICghaXNBcnJheUEgJiYgIWlzQXJyYXlCKSB7XG4gICAgICAgIHZhciBrZXlzQSA9IE9iamVjdC5rZXlzKGEpO1xuICAgICAgICB2YXIga2V5c0IgPSBPYmplY3Qua2V5cyhiKTtcbiAgICAgICAgcmV0dXJuIGtleXNBLmxlbmd0aCA9PT0ga2V5c0IubGVuZ3RoICYmIGtleXNBLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHtcbiAgICAgICAgICByZXR1cm4gbG9vc2VFcXVhbChhW2tleV0sIGJba2V5XSlcbiAgICAgICAgfSlcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWlzT2JqZWN0QSAmJiAhaXNPYmplY3RCKSB7XG4gICAgcmV0dXJuIFN0cmluZyhhKSA9PT0gU3RyaW5nKGIpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbn1cblxuZnVuY3Rpb24gbG9vc2VJbmRleE9mIChhcnIsIHZhbCkge1xuICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgIGlmIChsb29zZUVxdWFsKGFycltpXSwgdmFsKSkgeyByZXR1cm4gaSB9XG4gIH1cbiAgcmV0dXJuIC0xXG59XG5cbi8qKlxuICogRW5zdXJlIGEgZnVuY3Rpb24gaXMgY2FsbGVkIG9ubHkgb25jZS5cbiAqL1xuZnVuY3Rpb24gb25jZSAoZm4pIHtcbiAgdmFyIGNhbGxlZCA9IGZhbHNlO1xuICByZXR1cm4gZnVuY3Rpb24gKCkge1xuICAgIGlmICghY2FsbGVkKSB7XG4gICAgICBjYWxsZWQgPSB0cnVlO1xuICAgICAgZm4uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIFNTUl9BVFRSID0gJ2RhdGEtc2VydmVyLXJlbmRlcmVkJztcblxudmFyIEFTU0VUX1RZUEVTID0gW1xuICAnY29tcG9uZW50JyxcbiAgJ2RpcmVjdGl2ZScsXG4gICdmaWx0ZXInXG5dO1xuXG52YXIgTElGRUNZQ0xFX0hPT0tTID0gW1xuICAnYmVmb3JlQ3JlYXRlJyxcbiAgJ2NyZWF0ZWQnLFxuICAnYmVmb3JlTW91bnQnLFxuICAnbW91bnRlZCcsXG4gICdiZWZvcmVVcGRhdGUnLFxuICAndXBkYXRlZCcsXG4gICdiZWZvcmVEZXN0cm95JyxcbiAgJ2Rlc3Ryb3llZCcsXG4gICdhY3RpdmF0ZWQnLFxuICAnZGVhY3RpdmF0ZWQnLFxuICAnZXJyb3JDYXB0dXJlZCdcbl07XG5cbi8qICAqL1xuXG52YXIgY29uZmlnID0gKHtcbiAgLyoqXG4gICAqIE9wdGlvbiBtZXJnZSBzdHJhdGVnaWVzICh1c2VkIGluIGNvcmUvdXRpbC9vcHRpb25zKVxuICAgKi9cbiAgb3B0aW9uTWVyZ2VTdHJhdGVnaWVzOiBPYmplY3QuY3JlYXRlKG51bGwpLFxuXG4gIC8qKlxuICAgKiBXaGV0aGVyIHRvIHN1cHByZXNzIHdhcm5pbmdzLlxuICAgKi9cbiAgc2lsZW50OiBmYWxzZSxcblxuICAvKipcbiAgICogU2hvdyBwcm9kdWN0aW9uIG1vZGUgdGlwIG1lc3NhZ2Ugb24gYm9vdD9cbiAgICovXG4gIHByb2R1Y3Rpb25UaXA6IHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicsXG5cbiAgLyoqXG4gICAqIFdoZXRoZXIgdG8gZW5hYmxlIGRldnRvb2xzXG4gICAqL1xuICBkZXZ0b29sczogcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyxcblxuICAvKipcbiAgICogV2hldGhlciB0byByZWNvcmQgcGVyZlxuICAgKi9cbiAgcGVyZm9ybWFuY2U6IGZhbHNlLFxuXG4gIC8qKlxuICAgKiBFcnJvciBoYW5kbGVyIGZvciB3YXRjaGVyIGVycm9yc1xuICAgKi9cbiAgZXJyb3JIYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBXYXJuIGhhbmRsZXIgZm9yIHdhdGNoZXIgd2FybnNcbiAgICovXG4gIHdhcm5IYW5kbGVyOiBudWxsLFxuXG4gIC8qKlxuICAgKiBJZ25vcmUgY2VydGFpbiBjdXN0b20gZWxlbWVudHNcbiAgICovXG4gIGlnbm9yZWRFbGVtZW50czogW10sXG5cbiAgLyoqXG4gICAqIEN1c3RvbSB1c2VyIGtleSBhbGlhc2VzIGZvciB2LW9uXG4gICAqL1xuICBrZXlDb2RlczogT2JqZWN0LmNyZWF0ZShudWxsKSxcblxuICAvKipcbiAgICogQ2hlY2sgaWYgYSB0YWcgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgcmVnaXN0ZXJlZCBhcyBhXG4gICAqIGNvbXBvbmVudC4gVGhpcyBpcyBwbGF0Zm9ybS1kZXBlbmRlbnQgYW5kIG1heSBiZSBvdmVyd3JpdHRlbi5cbiAgICovXG4gIGlzUmVzZXJ2ZWRUYWc6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhbiBhdHRyaWJ1dGUgaXMgcmVzZXJ2ZWQgc28gdGhhdCBpdCBjYW5ub3QgYmUgdXNlZCBhcyBhIGNvbXBvbmVudFxuICAgKiBwcm9wLiBUaGlzIGlzIHBsYXRmb3JtLWRlcGVuZGVudCBhbmQgbWF5IGJlIG92ZXJ3cml0dGVuLlxuICAgKi9cbiAgaXNSZXNlcnZlZEF0dHI6IG5vLFxuXG4gIC8qKlxuICAgKiBDaGVjayBpZiBhIHRhZyBpcyBhbiB1bmtub3duIGVsZW1lbnQuXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIGlzVW5rbm93bkVsZW1lbnQ6IG5vLFxuXG4gIC8qKlxuICAgKiBHZXQgdGhlIG5hbWVzcGFjZSBvZiBhbiBlbGVtZW50XG4gICAqL1xuICBnZXRUYWdOYW1lc3BhY2U6IG5vb3AsXG5cbiAgLyoqXG4gICAqIFBhcnNlIHRoZSByZWFsIHRhZyBuYW1lIGZvciB0aGUgc3BlY2lmaWMgcGxhdGZvcm0uXG4gICAqL1xuICBwYXJzZVBsYXRmb3JtVGFnTmFtZTogaWRlbnRpdHksXG5cbiAgLyoqXG4gICAqIENoZWNrIGlmIGFuIGF0dHJpYnV0ZSBtdXN0IGJlIGJvdW5kIHVzaW5nIHByb3BlcnR5LCBlLmcuIHZhbHVlXG4gICAqIFBsYXRmb3JtLWRlcGVuZGVudC5cbiAgICovXG4gIG11c3RVc2VQcm9wOiBubyxcblxuICAvKipcbiAgICogRXhwb3NlZCBmb3IgbGVnYWN5IHJlYXNvbnNcbiAgICovXG4gIF9saWZlY3ljbGVIb29rczogTElGRUNZQ0xFX0hPT0tTXG59KTtcblxuLyogICovXG5cbi8qKlxuICogQ2hlY2sgaWYgYSBzdHJpbmcgc3RhcnRzIHdpdGggJCBvciBfXG4gKi9cbmZ1bmN0aW9uIGlzUmVzZXJ2ZWQgKHN0cikge1xuICB2YXIgYyA9IChzdHIgKyAnJykuY2hhckNvZGVBdCgwKTtcbiAgcmV0dXJuIGMgPT09IDB4MjQgfHwgYyA9PT0gMHg1RlxufVxuXG4vKipcbiAqIERlZmluZSBhIHByb3BlcnR5LlxuICovXG5mdW5jdGlvbiBkZWYgKG9iaiwga2V5LCB2YWwsIGVudW1lcmFibGUpIHtcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG9iaiwga2V5LCB7XG4gICAgdmFsdWU6IHZhbCxcbiAgICBlbnVtZXJhYmxlOiAhIWVudW1lcmFibGUsXG4gICAgd3JpdGFibGU6IHRydWUsXG4gICAgY29uZmlndXJhYmxlOiB0cnVlXG4gIH0pO1xufVxuXG4vKipcbiAqIFBhcnNlIHNpbXBsZSBwYXRoLlxuICovXG52YXIgYmFpbFJFID0gL1teXFx3LiRdLztcbmZ1bmN0aW9uIHBhcnNlUGF0aCAocGF0aCkge1xuICBpZiAoYmFpbFJFLnRlc3QocGF0aCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIgc2VnbWVudHMgPSBwYXRoLnNwbGl0KCcuJyk7XG4gIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzZWdtZW50cy5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKCFvYmopIHsgcmV0dXJuIH1cbiAgICAgIG9iaiA9IG9ialtzZWdtZW50c1tpXV07XG4gICAgfVxuICAgIHJldHVybiBvYmpcbiAgfVxufVxuXG4vKiAgKi9cblxuXG4vLyBjYW4gd2UgdXNlIF9fcHJvdG9fXz9cbnZhciBoYXNQcm90byA9ICdfX3Byb3RvX18nIGluIHt9O1xuXG4vLyBCcm93c2VyIGVudmlyb25tZW50IHNuaWZmaW5nXG52YXIgaW5Ccm93c2VyID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCc7XG52YXIgaW5XZWV4ID0gdHlwZW9mIFdYRW52aXJvbm1lbnQgIT09ICd1bmRlZmluZWQnICYmICEhV1hFbnZpcm9ubWVudC5wbGF0Zm9ybTtcbnZhciB3ZWV4UGxhdGZvcm0gPSBpbldlZXggJiYgV1hFbnZpcm9ubWVudC5wbGF0Zm9ybS50b0xvd2VyQ2FzZSgpO1xudmFyIFVBID0gaW5Ccm93c2VyICYmIHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50LnRvTG93ZXJDYXNlKCk7XG52YXIgaXNJRSA9IFVBICYmIC9tc2llfHRyaWRlbnQvLnRlc3QoVUEpO1xudmFyIGlzSUU5ID0gVUEgJiYgVUEuaW5kZXhPZignbXNpZSA5LjAnKSA+IDA7XG52YXIgaXNFZGdlID0gVUEgJiYgVUEuaW5kZXhPZignZWRnZS8nKSA+IDA7XG52YXIgaXNBbmRyb2lkID0gKFVBICYmIFVBLmluZGV4T2YoJ2FuZHJvaWQnKSA+IDApIHx8ICh3ZWV4UGxhdGZvcm0gPT09ICdhbmRyb2lkJyk7XG52YXIgaXNJT1MgPSAoVUEgJiYgL2lwaG9uZXxpcGFkfGlwb2R8aW9zLy50ZXN0KFVBKSkgfHwgKHdlZXhQbGF0Zm9ybSA9PT0gJ2lvcycpO1xudmFyIGlzQ2hyb21lID0gVUEgJiYgL2Nocm9tZVxcL1xcZCsvLnRlc3QoVUEpICYmICFpc0VkZ2U7XG5cbi8vIEZpcmVmb3ggaGFzIGEgXCJ3YXRjaFwiIGZ1bmN0aW9uIG9uIE9iamVjdC5wcm90b3R5cGUuLi5cbnZhciBuYXRpdmVXYXRjaCA9ICh7fSkud2F0Y2g7XG5cbnZhciBzdXBwb3J0c1Bhc3NpdmUgPSBmYWxzZTtcbmlmIChpbkJyb3dzZXIpIHtcbiAgdHJ5IHtcbiAgICB2YXIgb3B0cyA9IHt9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvcHRzLCAncGFzc2l2ZScsICh7XG4gICAgICBnZXQ6IGZ1bmN0aW9uIGdldCAoKSB7XG4gICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgICAgIHN1cHBvcnRzUGFzc2l2ZSA9IHRydWU7XG4gICAgICB9XG4gICAgfSkpOyAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svZmxvdy9pc3N1ZXMvMjg1XG4gICAgd2luZG93LmFkZEV2ZW50TGlzdGVuZXIoJ3Rlc3QtcGFzc2l2ZScsIG51bGwsIG9wdHMpO1xuICB9IGNhdGNoIChlKSB7fVxufVxuXG4vLyB0aGlzIG5lZWRzIHRvIGJlIGxhenktZXZhbGVkIGJlY2F1c2UgdnVlIG1heSBiZSByZXF1aXJlZCBiZWZvcmVcbi8vIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgY2FuIHNldCBWVUVfRU5WXG52YXIgX2lzU2VydmVyO1xudmFyIGlzU2VydmVyUmVuZGVyaW5nID0gZnVuY3Rpb24gKCkge1xuICBpZiAoX2lzU2VydmVyID09PSB1bmRlZmluZWQpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoIWluQnJvd3NlciAmJiB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgLy8gZGV0ZWN0IHByZXNlbmNlIG9mIHZ1ZS1zZXJ2ZXItcmVuZGVyZXIgYW5kIGF2b2lkXG4gICAgICAvLyBXZWJwYWNrIHNoaW1taW5nIHRoZSBwcm9jZXNzXG4gICAgICBfaXNTZXJ2ZXIgPSBnbG9iYWxbJ3Byb2Nlc3MnXS5lbnYuVlVFX0VOViA9PT0gJ3NlcnZlcic7XG4gICAgfSBlbHNlIHtcbiAgICAgIF9pc1NlcnZlciA9IGZhbHNlO1xuICAgIH1cbiAgfVxuICByZXR1cm4gX2lzU2VydmVyXG59O1xuXG4vLyBkZXRlY3QgZGV2dG9vbHNcbnZhciBkZXZ0b29scyA9IGluQnJvd3NlciAmJiB3aW5kb3cuX19WVUVfREVWVE9PTFNfR0xPQkFMX0hPT0tfXztcblxuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGlzTmF0aXZlIChDdG9yKSB7XG4gIHJldHVybiB0eXBlb2YgQ3RvciA9PT0gJ2Z1bmN0aW9uJyAmJiAvbmF0aXZlIGNvZGUvLnRlc3QoQ3Rvci50b1N0cmluZygpKVxufVxuXG52YXIgaGFzU3ltYm9sID1cbiAgdHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU3ltYm9sKSAmJlxuICB0eXBlb2YgUmVmbGVjdCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUmVmbGVjdC5vd25LZXlzKTtcblxudmFyIF9TZXQ7XG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi8gLy8gJGZsb3ctZGlzYWJsZS1saW5lXG5pZiAodHlwZW9mIFNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoU2V0KSkge1xuICAvLyB1c2UgbmF0aXZlIFNldCB3aGVuIGF2YWlsYWJsZS5cbiAgX1NldCA9IFNldDtcbn0gZWxzZSB7XG4gIC8vIGEgbm9uLXN0YW5kYXJkIFNldCBwb2x5ZmlsbCB0aGF0IG9ubHkgd29ya3Mgd2l0aCBwcmltaXRpdmUga2V5cy5cbiAgX1NldCA9IChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gU2V0ICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9XG4gICAgU2V0LnByb3RvdHlwZS5oYXMgPSBmdW5jdGlvbiBoYXMgKGtleSkge1xuICAgICAgcmV0dXJuIHRoaXMuc2V0W2tleV0gPT09IHRydWVcbiAgICB9O1xuICAgIFNldC5wcm90b3R5cGUuYWRkID0gZnVuY3Rpb24gYWRkIChrZXkpIHtcbiAgICAgIHRoaXMuc2V0W2tleV0gPSB0cnVlO1xuICAgIH07XG4gICAgU2V0LnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uIGNsZWFyICgpIHtcbiAgICAgIHRoaXMuc2V0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB9O1xuXG4gICAgcmV0dXJuIFNldDtcbiAgfSgpKTtcbn1cblxuLyogICovXG5cbnZhciB3YXJuID0gbm9vcDtcbnZhciB0aXAgPSBub29wO1xudmFyIGdlbmVyYXRlQ29tcG9uZW50VHJhY2UgPSAobm9vcCk7IC8vIHdvcmsgYXJvdW5kIGZsb3cgY2hlY2tcbnZhciBmb3JtYXRDb21wb25lbnROYW1lID0gKG5vb3ApO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICB2YXIgaGFzQ29uc29sZSA9IHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJztcbiAgdmFyIGNsYXNzaWZ5UkUgPSAvKD86XnxbLV9dKShcXHcpL2c7XG4gIHZhciBjbGFzc2lmeSA9IGZ1bmN0aW9uIChzdHIpIHsgcmV0dXJuIHN0clxuICAgIC5yZXBsYWNlKGNsYXNzaWZ5UkUsIGZ1bmN0aW9uIChjKSB7IHJldHVybiBjLnRvVXBwZXJDYXNlKCk7IH0pXG4gICAgLnJlcGxhY2UoL1stX10vZywgJycpOyB9O1xuXG4gIHdhcm4gPSBmdW5jdGlvbiAobXNnLCB2bSkge1xuICAgIHZhciB0cmFjZSA9IHZtID8gZ2VuZXJhdGVDb21wb25lbnRUcmFjZSh2bSkgOiAnJztcblxuICAgIGlmIChjb25maWcud2FybkhhbmRsZXIpIHtcbiAgICAgIGNvbmZpZy53YXJuSGFuZGxlci5jYWxsKG51bGwsIG1zZywgdm0sIHRyYWNlKTtcbiAgICB9IGVsc2UgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS5lcnJvcigoXCJbVnVlIHdhcm5dOiBcIiArIG1zZyArIHRyYWNlKSk7XG4gICAgfVxuICB9O1xuXG4gIHRpcCA9IGZ1bmN0aW9uIChtc2csIHZtKSB7XG4gICAgaWYgKGhhc0NvbnNvbGUgJiYgKCFjb25maWcuc2lsZW50KSkge1xuICAgICAgY29uc29sZS53YXJuKFwiW1Z1ZSB0aXBdOiBcIiArIG1zZyArIChcbiAgICAgICAgdm0gPyBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlKHZtKSA6ICcnXG4gICAgICApKTtcbiAgICB9XG4gIH07XG5cbiAgZm9ybWF0Q29tcG9uZW50TmFtZSA9IGZ1bmN0aW9uICh2bSwgaW5jbHVkZUZpbGUpIHtcbiAgICBpZiAodm0uJHJvb3QgPT09IHZtKSB7XG4gICAgICByZXR1cm4gJzxSb290PidcbiAgICB9XG4gICAgdmFyIG9wdGlvbnMgPSB0eXBlb2Ygdm0gPT09ICdmdW5jdGlvbicgJiYgdm0uY2lkICE9IG51bGxcbiAgICAgID8gdm0ub3B0aW9uc1xuICAgICAgOiB2bS5faXNWdWVcbiAgICAgICAgPyB2bS4kb3B0aW9ucyB8fCB2bS5jb25zdHJ1Y3Rvci5vcHRpb25zXG4gICAgICAgIDogdm0gfHwge307XG4gICAgdmFyIG5hbWUgPSBvcHRpb25zLm5hbWUgfHwgb3B0aW9ucy5fY29tcG9uZW50VGFnO1xuICAgIHZhciBmaWxlID0gb3B0aW9ucy5fX2ZpbGU7XG4gICAgaWYgKCFuYW1lICYmIGZpbGUpIHtcbiAgICAgIHZhciBtYXRjaCA9IGZpbGUubWF0Y2goLyhbXi9cXFxcXSspXFwudnVlJC8pO1xuICAgICAgbmFtZSA9IG1hdGNoICYmIG1hdGNoWzFdO1xuICAgIH1cblxuICAgIHJldHVybiAoXG4gICAgICAobmFtZSA/IChcIjxcIiArIChjbGFzc2lmeShuYW1lKSkgKyBcIj5cIikgOiBcIjxBbm9ueW1vdXM+XCIpICtcbiAgICAgIChmaWxlICYmIGluY2x1ZGVGaWxlICE9PSBmYWxzZSA/IChcIiBhdCBcIiArIGZpbGUpIDogJycpXG4gICAgKVxuICB9O1xuXG4gIHZhciByZXBlYXQgPSBmdW5jdGlvbiAoc3RyLCBuKSB7XG4gICAgdmFyIHJlcyA9ICcnO1xuICAgIHdoaWxlIChuKSB7XG4gICAgICBpZiAobiAlIDIgPT09IDEpIHsgcmVzICs9IHN0cjsgfVxuICAgICAgaWYgKG4gPiAxKSB7IHN0ciArPSBzdHI7IH1cbiAgICAgIG4gPj49IDE7XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfTtcblxuICBnZW5lcmF0ZUNvbXBvbmVudFRyYWNlID0gZnVuY3Rpb24gKHZtKSB7XG4gICAgaWYgKHZtLl9pc1Z1ZSAmJiB2bS4kcGFyZW50KSB7XG4gICAgICB2YXIgdHJlZSA9IFtdO1xuICAgICAgdmFyIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZSA9IDA7XG4gICAgICB3aGlsZSAodm0pIHtcbiAgICAgICAgaWYgKHRyZWUubGVuZ3RoID4gMCkge1xuICAgICAgICAgIHZhciBsYXN0ID0gdHJlZVt0cmVlLmxlbmd0aCAtIDFdO1xuICAgICAgICAgIGlmIChsYXN0LmNvbnN0cnVjdG9yID09PSB2bS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAgICAgY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlKys7XG4gICAgICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH0gZWxzZSBpZiAoY3VycmVudFJlY3Vyc2l2ZVNlcXVlbmNlID4gMCkge1xuICAgICAgICAgICAgdHJlZVt0cmVlLmxlbmd0aCAtIDFdID0gW2xhc3QsIGN1cnJlbnRSZWN1cnNpdmVTZXF1ZW5jZV07XG4gICAgICAgICAgICBjdXJyZW50UmVjdXJzaXZlU2VxdWVuY2UgPSAwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0cmVlLnB1c2godm0pO1xuICAgICAgICB2bSA9IHZtLiRwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gJ1xcblxcbmZvdW5kIGluXFxuXFxuJyArIHRyZWVcbiAgICAgICAgLm1hcChmdW5jdGlvbiAodm0sIGkpIHsgcmV0dXJuIChcIlwiICsgKGkgPT09IDAgPyAnLS0tPiAnIDogcmVwZWF0KCcgJywgNSArIGkgKiAyKSkgKyAoQXJyYXkuaXNBcnJheSh2bSlcbiAgICAgICAgICAgID8gKChmb3JtYXRDb21wb25lbnROYW1lKHZtWzBdKSkgKyBcIi4uLiAoXCIgKyAodm1bMV0pICsgXCIgcmVjdXJzaXZlIGNhbGxzKVwiKVxuICAgICAgICAgICAgOiBmb3JtYXRDb21wb25lbnROYW1lKHZtKSkpOyB9KVxuICAgICAgICAuam9pbignXFxuJylcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIChcIlxcblxcbihmb3VuZCBpbiBcIiArIChmb3JtYXRDb21wb25lbnROYW1lKHZtKSkgKyBcIilcIilcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5cbnZhciB1aWQgPSAwO1xuXG4vKipcbiAqIEEgZGVwIGlzIGFuIG9ic2VydmFibGUgdGhhdCBjYW4gaGF2ZSBtdWx0aXBsZVxuICogZGlyZWN0aXZlcyBzdWJzY3JpYmluZyB0byBpdC5cbiAqL1xudmFyIERlcCA9IGZ1bmN0aW9uIERlcCAoKSB7XG4gIHRoaXMuaWQgPSB1aWQrKztcbiAgdGhpcy5zdWJzID0gW107XG59O1xuXG5EZXAucHJvdG90eXBlLmFkZFN1YiA9IGZ1bmN0aW9uIGFkZFN1YiAoc3ViKSB7XG4gIHRoaXMuc3Vicy5wdXNoKHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLnJlbW92ZVN1YiA9IGZ1bmN0aW9uIHJlbW92ZVN1YiAoc3ViKSB7XG4gIHJlbW92ZSh0aGlzLnN1YnMsIHN1Yik7XG59O1xuXG5EZXAucHJvdG90eXBlLmRlcGVuZCA9IGZ1bmN0aW9uIGRlcGVuZCAoKSB7XG4gIGlmIChEZXAudGFyZ2V0KSB7XG4gICAgRGVwLnRhcmdldC5hZGREZXAodGhpcyk7XG4gIH1cbn07XG5cbkRlcC5wcm90b3R5cGUubm90aWZ5ID0gZnVuY3Rpb24gbm90aWZ5ICgpIHtcbiAgLy8gc3RhYmlsaXplIHRoZSBzdWJzY3JpYmVyIGxpc3QgZmlyc3RcbiAgdmFyIHN1YnMgPSB0aGlzLnN1YnMuc2xpY2UoKTtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdWJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIHN1YnNbaV0udXBkYXRlKCk7XG4gIH1cbn07XG5cbi8vIHRoZSBjdXJyZW50IHRhcmdldCB3YXRjaGVyIGJlaW5nIGV2YWx1YXRlZC5cbi8vIHRoaXMgaXMgZ2xvYmFsbHkgdW5pcXVlIGJlY2F1c2UgdGhlcmUgY291bGQgYmUgb25seSBvbmVcbi8vIHdhdGNoZXIgYmVpbmcgZXZhbHVhdGVkIGF0IGFueSB0aW1lLlxuRGVwLnRhcmdldCA9IG51bGw7XG52YXIgdGFyZ2V0U3RhY2sgPSBbXTtcblxuZnVuY3Rpb24gcHVzaFRhcmdldCAoX3RhcmdldCkge1xuICBpZiAoRGVwLnRhcmdldCkgeyB0YXJnZXRTdGFjay5wdXNoKERlcC50YXJnZXQpOyB9XG4gIERlcC50YXJnZXQgPSBfdGFyZ2V0O1xufVxuXG5mdW5jdGlvbiBwb3BUYXJnZXQgKCkge1xuICBEZXAudGFyZ2V0ID0gdGFyZ2V0U3RhY2sucG9wKCk7XG59XG5cbi8qICAqL1xuXG52YXIgVk5vZGUgPSBmdW5jdGlvbiBWTm9kZSAoXG4gIHRhZyxcbiAgZGF0YSxcbiAgY2hpbGRyZW4sXG4gIHRleHQsXG4gIGVsbSxcbiAgY29udGV4dCxcbiAgY29tcG9uZW50T3B0aW9ucyxcbiAgYXN5bmNGYWN0b3J5XG4pIHtcbiAgdGhpcy50YWcgPSB0YWc7XG4gIHRoaXMuZGF0YSA9IGRhdGE7XG4gIHRoaXMuY2hpbGRyZW4gPSBjaGlsZHJlbjtcbiAgdGhpcy50ZXh0ID0gdGV4dDtcbiAgdGhpcy5lbG0gPSBlbG07XG4gIHRoaXMubnMgPSB1bmRlZmluZWQ7XG4gIHRoaXMuY29udGV4dCA9IGNvbnRleHQ7XG4gIHRoaXMuZm5Db250ZXh0ID0gdW5kZWZpbmVkO1xuICB0aGlzLmZuT3B0aW9ucyA9IHVuZGVmaW5lZDtcbiAgdGhpcy5mblNjb3BlSWQgPSB1bmRlZmluZWQ7XG4gIHRoaXMua2V5ID0gZGF0YSAmJiBkYXRhLmtleTtcbiAgdGhpcy5jb21wb25lbnRPcHRpb25zID0gY29tcG9uZW50T3B0aW9ucztcbiAgdGhpcy5jb21wb25lbnRJbnN0YW5jZSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5wYXJlbnQgPSB1bmRlZmluZWQ7XG4gIHRoaXMucmF3ID0gZmFsc2U7XG4gIHRoaXMuaXNTdGF0aWMgPSBmYWxzZTtcbiAgdGhpcy5pc1Jvb3RJbnNlcnQgPSB0cnVlO1xuICB0aGlzLmlzQ29tbWVudCA9IGZhbHNlO1xuICB0aGlzLmlzQ2xvbmVkID0gZmFsc2U7XG4gIHRoaXMuaXNPbmNlID0gZmFsc2U7XG4gIHRoaXMuYXN5bmNGYWN0b3J5ID0gYXN5bmNGYWN0b3J5O1xuICB0aGlzLmFzeW5jTWV0YSA9IHVuZGVmaW5lZDtcbiAgdGhpcy5pc0FzeW5jUGxhY2Vob2xkZXIgPSBmYWxzZTtcbn07XG5cbnZhciBwcm90b3R5cGVBY2Nlc3NvcnMgPSB7IGNoaWxkOiB7IGNvbmZpZ3VyYWJsZTogdHJ1ZSB9IH07XG5cbi8vIERFUFJFQ0FURUQ6IGFsaWFzIGZvciBjb21wb25lbnRJbnN0YW5jZSBmb3IgYmFja3dhcmRzIGNvbXBhdC5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5wcm90b3R5cGVBY2Nlc3NvcnMuY2hpbGQuZ2V0ID0gZnVuY3Rpb24gKCkge1xuICByZXR1cm4gdGhpcy5jb21wb25lbnRJbnN0YW5jZVxufTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoIFZOb2RlLnByb3RvdHlwZSwgcHJvdG90eXBlQWNjZXNzb3JzICk7XG5cbnZhciBjcmVhdGVFbXB0eVZOb2RlID0gZnVuY3Rpb24gKHRleHQpIHtcbiAgaWYgKCB0ZXh0ID09PSB2b2lkIDAgKSB0ZXh0ID0gJyc7XG5cbiAgdmFyIG5vZGUgPSBuZXcgVk5vZGUoKTtcbiAgbm9kZS50ZXh0ID0gdGV4dDtcbiAgbm9kZS5pc0NvbW1lbnQgPSB0cnVlO1xuICByZXR1cm4gbm9kZVxufTtcblxuZnVuY3Rpb24gY3JlYXRlVGV4dFZOb2RlICh2YWwpIHtcbiAgcmV0dXJuIG5ldyBWTm9kZSh1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBTdHJpbmcodmFsKSlcbn1cblxuLy8gb3B0aW1pemVkIHNoYWxsb3cgY2xvbmVcbi8vIHVzZWQgZm9yIHN0YXRpYyBub2RlcyBhbmQgc2xvdCBub2RlcyBiZWNhdXNlIHRoZXkgbWF5IGJlIHJldXNlZCBhY3Jvc3Ncbi8vIG11bHRpcGxlIHJlbmRlcnMsIGNsb25pbmcgdGhlbSBhdm9pZHMgZXJyb3JzIHdoZW4gRE9NIG1hbmlwdWxhdGlvbnMgcmVseVxuLy8gb24gdGhlaXIgZWxtIHJlZmVyZW5jZS5cbmZ1bmN0aW9uIGNsb25lVk5vZGUgKHZub2RlLCBkZWVwKSB7XG4gIHZhciBjb21wb25lbnRPcHRpb25zID0gdm5vZGUuY29tcG9uZW50T3B0aW9ucztcbiAgdmFyIGNsb25lZCA9IG5ldyBWTm9kZShcbiAgICB2bm9kZS50YWcsXG4gICAgdm5vZGUuZGF0YSxcbiAgICB2bm9kZS5jaGlsZHJlbixcbiAgICB2bm9kZS50ZXh0LFxuICAgIHZub2RlLmVsbSxcbiAgICB2bm9kZS5jb250ZXh0LFxuICAgIGNvbXBvbmVudE9wdGlvbnMsXG4gICAgdm5vZGUuYXN5bmNGYWN0b3J5XG4gICk7XG4gIGNsb25lZC5ucyA9IHZub2RlLm5zO1xuICBjbG9uZWQuaXNTdGF0aWMgPSB2bm9kZS5pc1N0YXRpYztcbiAgY2xvbmVkLmtleSA9IHZub2RlLmtleTtcbiAgY2xvbmVkLmlzQ29tbWVudCA9IHZub2RlLmlzQ29tbWVudDtcbiAgY2xvbmVkLmZuQ29udGV4dCA9IHZub2RlLmZuQ29udGV4dDtcbiAgY2xvbmVkLmZuT3B0aW9ucyA9IHZub2RlLmZuT3B0aW9ucztcbiAgY2xvbmVkLmZuU2NvcGVJZCA9IHZub2RlLmZuU2NvcGVJZDtcbiAgY2xvbmVkLmlzQ2xvbmVkID0gdHJ1ZTtcbiAgaWYgKGRlZXApIHtcbiAgICBpZiAodm5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGNsb25lZC5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKHZub2RlLmNoaWxkcmVuLCB0cnVlKTtcbiAgICB9XG4gICAgaWYgKGNvbXBvbmVudE9wdGlvbnMgJiYgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbikge1xuICAgICAgY29tcG9uZW50T3B0aW9ucy5jaGlsZHJlbiA9IGNsb25lVk5vZGVzKGNvbXBvbmVudE9wdGlvbnMuY2hpbGRyZW4sIHRydWUpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gY2xvbmVkXG59XG5cbmZ1bmN0aW9uIGNsb25lVk5vZGVzICh2bm9kZXMsIGRlZXApIHtcbiAgdmFyIGxlbiA9IHZub2Rlcy5sZW5ndGg7XG4gIHZhciByZXMgPSBuZXcgQXJyYXkobGVuKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHJlc1tpXSA9IGNsb25lVk5vZGUodm5vZGVzW2ldLCBkZWVwKTtcbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qXG4gKiBub3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgcGxheSB3ZWxsIHdpdGhcbiAqIGR5bmFtaWNhbGx5IGFjY2Vzc2luZyBtZXRob2RzIG9uIEFycmF5IHByb3RvdHlwZVxuICovXG5cbnZhciBhcnJheVByb3RvID0gQXJyYXkucHJvdG90eXBlO1xudmFyIGFycmF5TWV0aG9kcyA9IE9iamVjdC5jcmVhdGUoYXJyYXlQcm90byk7W1xuICAncHVzaCcsXG4gICdwb3AnLFxuICAnc2hpZnQnLFxuICAndW5zaGlmdCcsXG4gICdzcGxpY2UnLFxuICAnc29ydCcsXG4gICdyZXZlcnNlJ1xuXVxuLmZvckVhY2goZnVuY3Rpb24gKG1ldGhvZCkge1xuICAvLyBjYWNoZSBvcmlnaW5hbCBtZXRob2RcbiAgdmFyIG9yaWdpbmFsID0gYXJyYXlQcm90b1ttZXRob2RdO1xuICBkZWYoYXJyYXlNZXRob2RzLCBtZXRob2QsIGZ1bmN0aW9uIG11dGF0b3IgKCkge1xuICAgIHZhciBhcmdzID0gW10sIGxlbiA9IGFyZ3VtZW50cy5sZW5ndGg7XG4gICAgd2hpbGUgKCBsZW4tLSApIGFyZ3NbIGxlbiBdID0gYXJndW1lbnRzWyBsZW4gXTtcblxuICAgIHZhciByZXN1bHQgPSBvcmlnaW5hbC5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB2YXIgb2IgPSB0aGlzLl9fb2JfXztcbiAgICB2YXIgaW5zZXJ0ZWQ7XG4gICAgc3dpdGNoIChtZXRob2QpIHtcbiAgICAgIGNhc2UgJ3B1c2gnOlxuICAgICAgY2FzZSAndW5zaGlmdCc6XG4gICAgICAgIGluc2VydGVkID0gYXJncztcbiAgICAgICAgYnJlYWtcbiAgICAgIGNhc2UgJ3NwbGljZSc6XG4gICAgICAgIGluc2VydGVkID0gYXJncy5zbGljZSgyKTtcbiAgICAgICAgYnJlYWtcbiAgICB9XG4gICAgaWYgKGluc2VydGVkKSB7IG9iLm9ic2VydmVBcnJheShpbnNlcnRlZCk7IH1cbiAgICAvLyBub3RpZnkgY2hhbmdlXG4gICAgb2IuZGVwLm5vdGlmeSgpO1xuICAgIHJldHVybiByZXN1bHRcbiAgfSk7XG59KTtcblxuLyogICovXG5cbnZhciBhcnJheUtleXMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlOYW1lcyhhcnJheU1ldGhvZHMpO1xuXG4vKipcbiAqIEJ5IGRlZmF1bHQsIHdoZW4gYSByZWFjdGl2ZSBwcm9wZXJ0eSBpcyBzZXQsIHRoZSBuZXcgdmFsdWUgaXNcbiAqIGFsc28gY29udmVydGVkIHRvIGJlY29tZSByZWFjdGl2ZS4gSG93ZXZlciB3aGVuIHBhc3NpbmcgZG93biBwcm9wcyxcbiAqIHdlIGRvbid0IHdhbnQgdG8gZm9yY2UgY29udmVyc2lvbiBiZWNhdXNlIHRoZSB2YWx1ZSBtYXkgYmUgYSBuZXN0ZWQgdmFsdWVcbiAqIHVuZGVyIGEgZnJvemVuIGRhdGEgc3RydWN0dXJlLiBDb252ZXJ0aW5nIGl0IHdvdWxkIGRlZmVhdCB0aGUgb3B0aW1pemF0aW9uLlxuICovXG52YXIgb2JzZXJ2ZXJTdGF0ZSA9IHtcbiAgc2hvdWxkQ29udmVydDogdHJ1ZVxufTtcblxuLyoqXG4gKiBPYnNlcnZlciBjbGFzcyB0aGF0IGFyZSBhdHRhY2hlZCB0byBlYWNoIG9ic2VydmVkXG4gKiBvYmplY3QuIE9uY2UgYXR0YWNoZWQsIHRoZSBvYnNlcnZlciBjb252ZXJ0cyB0YXJnZXRcbiAqIG9iamVjdCdzIHByb3BlcnR5IGtleXMgaW50byBnZXR0ZXIvc2V0dGVycyB0aGF0XG4gKiBjb2xsZWN0IGRlcGVuZGVuY2llcyBhbmQgZGlzcGF0Y2hlcyB1cGRhdGVzLlxuICovXG52YXIgT2JzZXJ2ZXIgPSBmdW5jdGlvbiBPYnNlcnZlciAodmFsdWUpIHtcbiAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICB0aGlzLmRlcCA9IG5ldyBEZXAoKTtcbiAgdGhpcy52bUNvdW50ID0gMDtcbiAgZGVmKHZhbHVlLCAnX19vYl9fJywgdGhpcyk7XG4gIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgIHZhciBhdWdtZW50ID0gaGFzUHJvdG9cbiAgICAgID8gcHJvdG9BdWdtZW50XG4gICAgICA6IGNvcHlBdWdtZW50O1xuICAgIGF1Z21lbnQodmFsdWUsIGFycmF5TWV0aG9kcywgYXJyYXlLZXlzKTtcbiAgICB0aGlzLm9ic2VydmVBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdGhpcy53YWxrKHZhbHVlKTtcbiAgfVxufTtcblxuLyoqXG4gKiBXYWxrIHRocm91Z2ggZWFjaCBwcm9wZXJ0eSBhbmQgY29udmVydCB0aGVtIGludG9cbiAqIGdldHRlci9zZXR0ZXJzLiBUaGlzIG1ldGhvZCBzaG91bGQgb25seSBiZSBjYWxsZWQgd2hlblxuICogdmFsdWUgdHlwZSBpcyBPYmplY3QuXG4gKi9cbk9ic2VydmVyLnByb3RvdHlwZS53YWxrID0gZnVuY3Rpb24gd2FsayAob2JqKSB7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqKTtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBrZXlzLmxlbmd0aDsgaSsrKSB7XG4gICAgZGVmaW5lUmVhY3RpdmUob2JqLCBrZXlzW2ldLCBvYmpba2V5c1tpXV0pO1xuICB9XG59O1xuXG4vKipcbiAqIE9ic2VydmUgYSBsaXN0IG9mIEFycmF5IGl0ZW1zLlxuICovXG5PYnNlcnZlci5wcm90b3R5cGUub2JzZXJ2ZUFycmF5ID0gZnVuY3Rpb24gb2JzZXJ2ZUFycmF5IChpdGVtcykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGl0ZW1zLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIG9ic2VydmUoaXRlbXNbaV0pO1xuICB9XG59O1xuXG4vLyBoZWxwZXJzXG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGludGVyY2VwdGluZ1xuICogdGhlIHByb3RvdHlwZSBjaGFpbiB1c2luZyBfX3Byb3RvX19cbiAqL1xuZnVuY3Rpb24gcHJvdG9BdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICAvKiBlc2xpbnQtZGlzYWJsZSBuby1wcm90byAqL1xuICB0YXJnZXQuX19wcm90b19fID0gc3JjO1xuICAvKiBlc2xpbnQtZW5hYmxlIG5vLXByb3RvICovXG59XG5cbi8qKlxuICogQXVnbWVudCBhbiB0YXJnZXQgT2JqZWN0IG9yIEFycmF5IGJ5IGRlZmluaW5nXG4gKiBoaWRkZW4gcHJvcGVydGllcy5cbiAqL1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbmZ1bmN0aW9uIGNvcHlBdWdtZW50ICh0YXJnZXQsIHNyYywga2V5cykge1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGtleXMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGtleSA9IGtleXNbaV07XG4gICAgZGVmKHRhcmdldCwga2V5LCBzcmNba2V5XSk7XG4gIH1cbn1cblxuLyoqXG4gKiBBdHRlbXB0IHRvIGNyZWF0ZSBhbiBvYnNlcnZlciBpbnN0YW5jZSBmb3IgYSB2YWx1ZSxcbiAqIHJldHVybnMgdGhlIG5ldyBvYnNlcnZlciBpZiBzdWNjZXNzZnVsbHkgb2JzZXJ2ZWQsXG4gKiBvciB0aGUgZXhpc3Rpbmcgb2JzZXJ2ZXIgaWYgdGhlIHZhbHVlIGFscmVhZHkgaGFzIG9uZS5cbiAqL1xuZnVuY3Rpb24gb2JzZXJ2ZSAodmFsdWUsIGFzUm9vdERhdGEpIHtcbiAgaWYgKCFpc09iamVjdCh2YWx1ZSkgfHwgdmFsdWUgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYjtcbiAgaWYgKGhhc093bih2YWx1ZSwgJ19fb2JfXycpICYmIHZhbHVlLl9fb2JfXyBpbnN0YW5jZW9mIE9ic2VydmVyKSB7XG4gICAgb2IgPSB2YWx1ZS5fX29iX187XG4gIH0gZWxzZSBpZiAoXG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ICYmXG4gICAgIWlzU2VydmVyUmVuZGVyaW5nKCkgJiZcbiAgICAoQXJyYXkuaXNBcnJheSh2YWx1ZSkgfHwgaXNQbGFpbk9iamVjdCh2YWx1ZSkpICYmXG4gICAgT2JqZWN0LmlzRXh0ZW5zaWJsZSh2YWx1ZSkgJiZcbiAgICAhdmFsdWUuX2lzVnVlXG4gICkge1xuICAgIG9iID0gbmV3IE9ic2VydmVyKHZhbHVlKTtcbiAgfVxuICBpZiAoYXNSb290RGF0YSAmJiBvYikge1xuICAgIG9iLnZtQ291bnQrKztcbiAgfVxuICByZXR1cm4gb2Jcbn1cblxuLyoqXG4gKiBEZWZpbmUgYSByZWFjdGl2ZSBwcm9wZXJ0eSBvbiBhbiBPYmplY3QuXG4gKi9cbmZ1bmN0aW9uIGRlZmluZVJlYWN0aXZlIChcbiAgb2JqLFxuICBrZXksXG4gIHZhbCxcbiAgY3VzdG9tU2V0dGVyLFxuICBzaGFsbG93XG4pIHtcbiAgdmFyIGRlcCA9IG5ldyBEZXAoKTtcblxuICB2YXIgcHJvcGVydHkgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKG9iaiwga2V5KTtcbiAgaWYgKHByb3BlcnR5ICYmIHByb3BlcnR5LmNvbmZpZ3VyYWJsZSA9PT0gZmFsc2UpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGNhdGVyIGZvciBwcmUtZGVmaW5lZCBnZXR0ZXIvc2V0dGVyc1xuICB2YXIgZ2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuZ2V0O1xuICB2YXIgc2V0dGVyID0gcHJvcGVydHkgJiYgcHJvcGVydHkuc2V0O1xuXG4gIHZhciBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZSh2YWwpO1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkob2JqLCBrZXksIHtcbiAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICBnZXQ6IGZ1bmN0aW9uIHJlYWN0aXZlR2V0dGVyICgpIHtcbiAgICAgIHZhciB2YWx1ZSA9IGdldHRlciA/IGdldHRlci5jYWxsKG9iaikgOiB2YWw7XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICBkZXAuZGVwZW5kKCk7XG4gICAgICAgIGlmIChjaGlsZE9iKSB7XG4gICAgICAgICAgY2hpbGRPYi5kZXAuZGVwZW5kKCk7XG4gICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBkZXBlbmRBcnJheSh2YWx1ZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgICByZXR1cm4gdmFsdWVcbiAgICB9LFxuICAgIHNldDogZnVuY3Rpb24gcmVhY3RpdmVTZXR0ZXIgKG5ld1ZhbCkge1xuICAgICAgdmFyIHZhbHVlID0gZ2V0dGVyID8gZ2V0dGVyLmNhbGwob2JqKSA6IHZhbDtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKG5ld1ZhbCA9PT0gdmFsdWUgfHwgKG5ld1ZhbCAhPT0gbmV3VmFsICYmIHZhbHVlICE9PSB2YWx1ZSkpIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICAvKiBlc2xpbnQtZW5hYmxlIG5vLXNlbGYtY29tcGFyZSAqL1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY3VzdG9tU2V0dGVyKSB7XG4gICAgICAgIGN1c3RvbVNldHRlcigpO1xuICAgICAgfVxuICAgICAgaWYgKHNldHRlcikge1xuICAgICAgICBzZXR0ZXIuY2FsbChvYmosIG5ld1ZhbCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2YWwgPSBuZXdWYWw7XG4gICAgICB9XG4gICAgICBjaGlsZE9iID0gIXNoYWxsb3cgJiYgb2JzZXJ2ZShuZXdWYWwpO1xuICAgICAgZGVwLm5vdGlmeSgpO1xuICAgIH1cbiAgfSk7XG59XG5cbi8qKlxuICogU2V0IGEgcHJvcGVydHkgb24gYW4gb2JqZWN0LiBBZGRzIHRoZSBuZXcgcHJvcGVydHkgYW5kXG4gKiB0cmlnZ2VycyBjaGFuZ2Ugbm90aWZpY2F0aW9uIGlmIHRoZSBwcm9wZXJ0eSBkb2Vzbid0XG4gKiBhbHJlYWR5IGV4aXN0LlxuICovXG5mdW5jdGlvbiBzZXQgKHRhcmdldCwga2V5LCB2YWwpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0Lmxlbmd0aCA9IE1hdGgubWF4KHRhcmdldC5sZW5ndGgsIGtleSk7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEsIHZhbCk7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGlmIChrZXkgaW4gdGFyZ2V0ICYmICEoa2V5IGluIE9iamVjdC5wcm90b3R5cGUpKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGFkZGluZyByZWFjdGl2ZSBwcm9wZXJ0aWVzIHRvIGEgVnVlIGluc3RhbmNlIG9yIGl0cyByb290ICRkYXRhICcgK1xuICAgICAgJ2F0IHJ1bnRpbWUgLSBkZWNsYXJlIGl0IHVwZnJvbnQgaW4gdGhlIGRhdGEgb3B0aW9uLidcbiAgICApO1xuICAgIHJldHVybiB2YWxcbiAgfVxuICBpZiAoIW9iKSB7XG4gICAgdGFyZ2V0W2tleV0gPSB2YWw7XG4gICAgcmV0dXJuIHZhbFxuICB9XG4gIGRlZmluZVJlYWN0aXZlKG9iLnZhbHVlLCBrZXksIHZhbCk7XG4gIG9iLmRlcC5ub3RpZnkoKTtcbiAgcmV0dXJuIHZhbFxufVxuXG4vKipcbiAqIERlbGV0ZSBhIHByb3BlcnR5IGFuZCB0cmlnZ2VyIGNoYW5nZSBpZiBuZWNlc3NhcnkuXG4gKi9cbmZ1bmN0aW9uIGRlbCAodGFyZ2V0LCBrZXkpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodGFyZ2V0KSAmJiBpc1ZhbGlkQXJyYXlJbmRleChrZXkpKSB7XG4gICAgdGFyZ2V0LnNwbGljZShrZXksIDEpO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBvYiA9ICh0YXJnZXQpLl9fb2JfXztcbiAgaWYgKHRhcmdldC5faXNWdWUgfHwgKG9iICYmIG9iLnZtQ291bnQpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgJ0F2b2lkIGRlbGV0aW5nIHByb3BlcnRpZXMgb24gYSBWdWUgaW5zdGFuY2Ugb3IgaXRzIHJvb3QgJGRhdGEgJyArXG4gICAgICAnLSBqdXN0IHNldCBpdCB0byBudWxsLidcbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIGlmICghaGFzT3duKHRhcmdldCwga2V5KSkge1xuICAgIHJldHVyblxuICB9XG4gIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgaWYgKCFvYikge1xuICAgIHJldHVyblxuICB9XG4gIG9iLmRlcC5ub3RpZnkoKTtcbn1cblxuLyoqXG4gKiBDb2xsZWN0IGRlcGVuZGVuY2llcyBvbiBhcnJheSBlbGVtZW50cyB3aGVuIHRoZSBhcnJheSBpcyB0b3VjaGVkLCBzaW5jZVxuICogd2UgY2Fubm90IGludGVyY2VwdCBhcnJheSBlbGVtZW50IGFjY2VzcyBsaWtlIHByb3BlcnR5IGdldHRlcnMuXG4gKi9cbmZ1bmN0aW9uIGRlcGVuZEFycmF5ICh2YWx1ZSkge1xuICBmb3IgKHZhciBlID0gKHZvaWQgMCksIGkgPSAwLCBsID0gdmFsdWUubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZSA9IHZhbHVlW2ldO1xuICAgIGUgJiYgZS5fX29iX18gJiYgZS5fX29iX18uZGVwLmRlcGVuZCgpO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGUpKSB7XG4gICAgICBkZXBlbmRBcnJheShlKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qKlxuICogT3B0aW9uIG92ZXJ3cml0aW5nIHN0cmF0ZWdpZXMgYXJlIGZ1bmN0aW9ucyB0aGF0IGhhbmRsZVxuICogaG93IHRvIG1lcmdlIGEgcGFyZW50IG9wdGlvbiB2YWx1ZSBhbmQgYSBjaGlsZCBvcHRpb25cbiAqIHZhbHVlIGludG8gdGhlIGZpbmFsIHZhbHVlLlxuICovXG52YXIgc3RyYXRzID0gY29uZmlnLm9wdGlvbk1lcmdlU3RyYXRlZ2llcztcblxuLyoqXG4gKiBPcHRpb25zIHdpdGggcmVzdHJpY3Rpb25zXG4gKi9cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHN0cmF0cy5lbCA9IHN0cmF0cy5wcm9wc0RhdGEgPSBmdW5jdGlvbiAocGFyZW50LCBjaGlsZCwgdm0sIGtleSkge1xuICAgIGlmICghdm0pIHtcbiAgICAgIHdhcm4oXG4gICAgICAgIFwib3B0aW9uIFxcXCJcIiArIGtleSArIFwiXFxcIiBjYW4gb25seSBiZSB1c2VkIGR1cmluZyBpbnN0YW5jZSBcIiArXG4gICAgICAgICdjcmVhdGlvbiB3aXRoIHRoZSBgbmV3YCBrZXl3b3JkLidcbiAgICAgICk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0U3RyYXQocGFyZW50LCBjaGlsZClcbiAgfTtcbn1cblxuLyoqXG4gKiBIZWxwZXIgdGhhdCByZWN1cnNpdmVseSBtZXJnZXMgdHdvIGRhdGEgb2JqZWN0cyB0b2dldGhlci5cbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhICh0bywgZnJvbSkge1xuICBpZiAoIWZyb20pIHsgcmV0dXJuIHRvIH1cbiAgdmFyIGtleSwgdG9WYWwsIGZyb21WYWw7XG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZnJvbSk7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgIGtleSA9IGtleXNbaV07XG4gICAgdG9WYWwgPSB0b1trZXldO1xuICAgIGZyb21WYWwgPSBmcm9tW2tleV07XG4gICAgaWYgKCFoYXNPd24odG8sIGtleSkpIHtcbiAgICAgIHNldCh0bywga2V5LCBmcm9tVmFsKTtcbiAgICB9IGVsc2UgaWYgKGlzUGxhaW5PYmplY3QodG9WYWwpICYmIGlzUGxhaW5PYmplY3QoZnJvbVZhbCkpIHtcbiAgICAgIG1lcmdlRGF0YSh0b1ZhbCwgZnJvbVZhbCk7XG4gICAgfVxuICB9XG4gIHJldHVybiB0b1xufVxuXG4vKipcbiAqIERhdGFcbiAqL1xuZnVuY3Rpb24gbWVyZ2VEYXRhT3JGbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIC8vIGluIGEgVnVlLmV4dGVuZCBtZXJnZSwgYm90aCBzaG91bGQgYmUgZnVuY3Rpb25zXG4gICAgaWYgKCFjaGlsZFZhbCkge1xuICAgICAgcmV0dXJuIHBhcmVudFZhbFxuICAgIH1cbiAgICBpZiAoIXBhcmVudFZhbCkge1xuICAgICAgcmV0dXJuIGNoaWxkVmFsXG4gICAgfVxuICAgIC8vIHdoZW4gcGFyZW50VmFsICYgY2hpbGRWYWwgYXJlIGJvdGggcHJlc2VudCxcbiAgICAvLyB3ZSBuZWVkIHRvIHJldHVybiBhIGZ1bmN0aW9uIHRoYXQgcmV0dXJucyB0aGVcbiAgICAvLyBtZXJnZWQgcmVzdWx0IG9mIGJvdGggZnVuY3Rpb25zLi4uIG5vIG5lZWQgdG9cbiAgICAvLyBjaGVjayBpZiBwYXJlbnRWYWwgaXMgYSBmdW5jdGlvbiBoZXJlIGJlY2F1c2VcbiAgICAvLyBpdCBoYXMgdG8gYmUgYSBmdW5jdGlvbiB0byBwYXNzIHByZXZpb3VzIG1lcmdlcy5cbiAgICByZXR1cm4gZnVuY3Rpb24gbWVyZ2VkRGF0YUZuICgpIHtcbiAgICAgIHJldHVybiBtZXJnZURhdGEoXG4gICAgICAgIHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IGNoaWxkVmFsLmNhbGwodGhpcykgOiBjaGlsZFZhbCxcbiAgICAgICAgdHlwZW9mIHBhcmVudFZhbCA9PT0gJ2Z1bmN0aW9uJyA/IHBhcmVudFZhbC5jYWxsKHRoaXMpIDogcGFyZW50VmFsXG4gICAgICApXG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBmdW5jdGlvbiBtZXJnZWRJbnN0YW5jZURhdGFGbiAoKSB7XG4gICAgICAvLyBpbnN0YW5jZSBtZXJnZVxuICAgICAgdmFyIGluc3RhbmNlRGF0YSA9IHR5cGVvZiBjaGlsZFZhbCA9PT0gJ2Z1bmN0aW9uJ1xuICAgICAgICA/IGNoaWxkVmFsLmNhbGwodm0pXG4gICAgICAgIDogY2hpbGRWYWw7XG4gICAgICB2YXIgZGVmYXVsdERhdGEgPSB0eXBlb2YgcGFyZW50VmFsID09PSAnZnVuY3Rpb24nXG4gICAgICAgID8gcGFyZW50VmFsLmNhbGwodm0pXG4gICAgICAgIDogcGFyZW50VmFsO1xuICAgICAgaWYgKGluc3RhbmNlRGF0YSkge1xuICAgICAgICByZXR1cm4gbWVyZ2VEYXRhKGluc3RhbmNlRGF0YSwgZGVmYXVsdERhdGEpXG4gICAgICB9IGVsc2Uge1xuICAgICAgICByZXR1cm4gZGVmYXVsdERhdGFcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuc3RyYXRzLmRhdGEgPSBmdW5jdGlvbiAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtXG4pIHtcbiAgaWYgKCF2bSkge1xuICAgIGlmIChjaGlsZFZhbCAmJiB0eXBlb2YgY2hpbGRWYWwgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ1RoZSBcImRhdGFcIiBvcHRpb24gc2hvdWxkIGJlIGEgZnVuY3Rpb24gJyArXG4gICAgICAgICd0aGF0IHJldHVybnMgYSBwZXItaW5zdGFuY2UgdmFsdWUgaW4gY29tcG9uZW50ICcgK1xuICAgICAgICAnZGVmaW5pdGlvbnMuJyxcbiAgICAgICAgdm1cbiAgICAgICk7XG5cbiAgICAgIHJldHVybiBwYXJlbnRWYWxcbiAgICB9XG4gICAgcmV0dXJuIG1lcmdlRGF0YU9yRm4ocGFyZW50VmFsLCBjaGlsZFZhbClcbiAgfVxuXG4gIHJldHVybiBtZXJnZURhdGFPckZuKHBhcmVudFZhbCwgY2hpbGRWYWwsIHZtKVxufTtcblxuLyoqXG4gKiBIb29rcyBhbmQgcHJvcHMgYXJlIG1lcmdlZCBhcyBhcnJheXMuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlSG9vayAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWxcbikge1xuICByZXR1cm4gY2hpbGRWYWxcbiAgICA/IHBhcmVudFZhbFxuICAgICAgPyBwYXJlbnRWYWwuY29uY2F0KGNoaWxkVmFsKVxuICAgICAgOiBBcnJheS5pc0FycmF5KGNoaWxkVmFsKVxuICAgICAgICA/IGNoaWxkVmFsXG4gICAgICAgIDogW2NoaWxkVmFsXVxuICAgIDogcGFyZW50VmFsXG59XG5cbkxJRkVDWUNMRV9IT09LUy5mb3JFYWNoKGZ1bmN0aW9uIChob29rKSB7XG4gIHN0cmF0c1tob29rXSA9IG1lcmdlSG9vaztcbn0pO1xuXG4vKipcbiAqIEFzc2V0c1xuICpcbiAqIFdoZW4gYSB2bSBpcyBwcmVzZW50IChpbnN0YW5jZSBjcmVhdGlvbiksIHdlIG5lZWQgdG8gZG9cbiAqIGEgdGhyZWUtd2F5IG1lcmdlIGJldHdlZW4gY29uc3RydWN0b3Igb3B0aW9ucywgaW5zdGFuY2VcbiAqIG9wdGlvbnMgYW5kIHBhcmVudCBvcHRpb25zLlxuICovXG5mdW5jdGlvbiBtZXJnZUFzc2V0cyAoXG4gIHBhcmVudFZhbCxcbiAgY2hpbGRWYWwsXG4gIHZtLFxuICBrZXlcbikge1xuICB2YXIgcmVzID0gT2JqZWN0LmNyZWF0ZShwYXJlbnRWYWwgfHwgbnVsbCk7XG4gIGlmIChjaGlsZFZhbCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gICAgcmV0dXJuIGV4dGVuZChyZXMsIGNoaWxkVmFsKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiByZXNcbiAgfVxufVxuXG5BU1NFVF9UWVBFUy5mb3JFYWNoKGZ1bmN0aW9uICh0eXBlKSB7XG4gIHN0cmF0c1t0eXBlICsgJ3MnXSA9IG1lcmdlQXNzZXRzO1xufSk7XG5cbi8qKlxuICogV2F0Y2hlcnMuXG4gKlxuICogV2F0Y2hlcnMgaGFzaGVzIHNob3VsZCBub3Qgb3ZlcndyaXRlIG9uZVxuICogYW5vdGhlciwgc28gd2UgbWVyZ2UgdGhlbSBhcyBhcnJheXMuXG4gKi9cbnN0cmF0cy53YXRjaCA9IGZ1bmN0aW9uIChcbiAgcGFyZW50VmFsLFxuICBjaGlsZFZhbCxcbiAgdm0sXG4gIGtleVxuKSB7XG4gIC8vIHdvcmsgYXJvdW5kIEZpcmVmb3gncyBPYmplY3QucHJvdG90eXBlLndhdGNoLi4uXG4gIGlmIChwYXJlbnRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IHBhcmVudFZhbCA9IHVuZGVmaW5lZDsgfVxuICBpZiAoY2hpbGRWYWwgPT09IG5hdGl2ZVdhdGNoKSB7IGNoaWxkVmFsID0gdW5kZWZpbmVkOyB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNoaWxkVmFsKSB7IHJldHVybiBPYmplY3QuY3JlYXRlKHBhcmVudFZhbCB8fCBudWxsKSB9XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgYXNzZXJ0T2JqZWN0VHlwZShrZXksIGNoaWxkVmFsLCB2bSk7XG4gIH1cbiAgaWYgKCFwYXJlbnRWYWwpIHsgcmV0dXJuIGNoaWxkVmFsIH1cbiAgdmFyIHJldCA9IHt9O1xuICBleHRlbmQocmV0LCBwYXJlbnRWYWwpO1xuICBmb3IgKHZhciBrZXkkMSBpbiBjaGlsZFZhbCkge1xuICAgIHZhciBwYXJlbnQgPSByZXRba2V5JDFdO1xuICAgIHZhciBjaGlsZCA9IGNoaWxkVmFsW2tleSQxXTtcbiAgICBpZiAocGFyZW50ICYmICFBcnJheS5pc0FycmF5KHBhcmVudCkpIHtcbiAgICAgIHBhcmVudCA9IFtwYXJlbnRdO1xuICAgIH1cbiAgICByZXRba2V5JDFdID0gcGFyZW50XG4gICAgICA/IHBhcmVudC5jb25jYXQoY2hpbGQpXG4gICAgICA6IEFycmF5LmlzQXJyYXkoY2hpbGQpID8gY2hpbGQgOiBbY2hpbGRdO1xuICB9XG4gIHJldHVybiByZXRcbn07XG5cbi8qKlxuICogT3RoZXIgb2JqZWN0IGhhc2hlcy5cbiAqL1xuc3RyYXRzLnByb3BzID1cbnN0cmF0cy5tZXRob2RzID1cbnN0cmF0cy5pbmplY3QgPVxuc3RyYXRzLmNvbXB1dGVkID0gZnVuY3Rpb24gKFxuICBwYXJlbnRWYWwsXG4gIGNoaWxkVmFsLFxuICB2bSxcbiAga2V5XG4pIHtcbiAgaWYgKGNoaWxkVmFsICYmIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRPYmplY3RUeXBlKGtleSwgY2hpbGRWYWwsIHZtKTtcbiAgfVxuICBpZiAoIXBhcmVudFZhbCkgeyByZXR1cm4gY2hpbGRWYWwgfVxuICB2YXIgcmV0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgZXh0ZW5kKHJldCwgcGFyZW50VmFsKTtcbiAgaWYgKGNoaWxkVmFsKSB7IGV4dGVuZChyZXQsIGNoaWxkVmFsKTsgfVxuICByZXR1cm4gcmV0XG59O1xuc3RyYXRzLnByb3ZpZGUgPSBtZXJnZURhdGFPckZuO1xuXG4vKipcbiAqIERlZmF1bHQgc3RyYXRlZ3kuXG4gKi9cbnZhciBkZWZhdWx0U3RyYXQgPSBmdW5jdGlvbiAocGFyZW50VmFsLCBjaGlsZFZhbCkge1xuICByZXR1cm4gY2hpbGRWYWwgPT09IHVuZGVmaW5lZFxuICAgID8gcGFyZW50VmFsXG4gICAgOiBjaGlsZFZhbFxufTtcblxuLyoqXG4gKiBWYWxpZGF0ZSBjb21wb25lbnQgbmFtZXNcbiAqL1xuZnVuY3Rpb24gY2hlY2tDb21wb25lbnRzIChvcHRpb25zKSB7XG4gIGZvciAodmFyIGtleSBpbiBvcHRpb25zLmNvbXBvbmVudHMpIHtcbiAgICB2YXIgbG93ZXIgPSBrZXkudG9Mb3dlckNhc2UoKTtcbiAgICBpZiAoaXNCdWlsdEluVGFnKGxvd2VyKSB8fCBjb25maWcuaXNSZXNlcnZlZFRhZyhsb3dlcikpIHtcbiAgICAgIHdhcm4oXG4gICAgICAgICdEbyBub3QgdXNlIGJ1aWx0LWluIG9yIHJlc2VydmVkIEhUTUwgZWxlbWVudHMgYXMgY29tcG9uZW50ICcgK1xuICAgICAgICAnaWQ6ICcgKyBrZXlcbiAgICAgICk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogRW5zdXJlIGFsbCBwcm9wcyBvcHRpb24gc3ludGF4IGFyZSBub3JtYWxpemVkIGludG8gdGhlXG4gKiBPYmplY3QtYmFzZWQgZm9ybWF0LlxuICovXG5mdW5jdGlvbiBub3JtYWxpemVQcm9wcyAob3B0aW9ucywgdm0pIHtcbiAgdmFyIHByb3BzID0gb3B0aW9ucy5wcm9wcztcbiAgaWYgKCFwcm9wcykgeyByZXR1cm4gfVxuICB2YXIgcmVzID0ge307XG4gIHZhciBpLCB2YWwsIG5hbWU7XG4gIGlmIChBcnJheS5pc0FycmF5KHByb3BzKSkge1xuICAgIGkgPSBwcm9wcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdmFsID0gcHJvcHNbaV07XG4gICAgICBpZiAodHlwZW9mIHZhbCA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgbmFtZSA9IGNhbWVsaXplKHZhbCk7XG4gICAgICAgIHJlc1tuYW1lXSA9IHsgdHlwZTogbnVsbCB9O1xuICAgICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIHdhcm4oJ3Byb3BzIG11c3QgYmUgc3RyaW5ncyB3aGVuIHVzaW5nIGFycmF5IHN5bnRheC4nKTtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdChwcm9wcykpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gcHJvcHMpIHtcbiAgICAgIHZhbCA9IHByb3BzW2tleV07XG4gICAgICBuYW1lID0gY2FtZWxpemUoa2V5KTtcbiAgICAgIHJlc1tuYW1lXSA9IGlzUGxhaW5PYmplY3QodmFsKVxuICAgICAgICA/IHZhbFxuICAgICAgICA6IHsgdHlwZTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcInByb3BzXFxcIjogZXhwZWN0ZWQgYW4gQXJyYXkgb3IgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHByb3BzKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICBvcHRpb25zLnByb3BzID0gcmVzO1xufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSBhbGwgaW5qZWN0aW9ucyBpbnRvIE9iamVjdC1iYXNlZCBmb3JtYXRcbiAqL1xuZnVuY3Rpb24gbm9ybWFsaXplSW5qZWN0IChvcHRpb25zLCB2bSkge1xuICB2YXIgaW5qZWN0ID0gb3B0aW9ucy5pbmplY3Q7XG4gIHZhciBub3JtYWxpemVkID0gb3B0aW9ucy5pbmplY3QgPSB7fTtcbiAgaWYgKEFycmF5LmlzQXJyYXkoaW5qZWN0KSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaW5qZWN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICBub3JtYWxpemVkW2luamVjdFtpXV0gPSB7IGZyb206IGluamVjdFtpXSB9O1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc1BsYWluT2JqZWN0KGluamVjdCkpIHtcbiAgICBmb3IgKHZhciBrZXkgaW4gaW5qZWN0KSB7XG4gICAgICB2YXIgdmFsID0gaW5qZWN0W2tleV07XG4gICAgICBub3JtYWxpemVkW2tleV0gPSBpc1BsYWluT2JqZWN0KHZhbClcbiAgICAgICAgPyBleHRlbmQoeyBmcm9tOiBrZXkgfSwgdmFsKVxuICAgICAgICA6IHsgZnJvbTogdmFsIH07XG4gICAgfVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaW5qZWN0KSB7XG4gICAgd2FybihcbiAgICAgIFwiSW52YWxpZCB2YWx1ZSBmb3Igb3B0aW9uIFxcXCJpbmplY3RcXFwiOiBleHBlY3RlZCBhbiBBcnJheSBvciBhbiBPYmplY3QsIFwiICtcbiAgICAgIFwiYnV0IGdvdCBcIiArICh0b1Jhd1R5cGUoaW5qZWN0KSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE5vcm1hbGl6ZSByYXcgZnVuY3Rpb24gZGlyZWN0aXZlcyBpbnRvIG9iamVjdCBmb3JtYXQuXG4gKi9cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMgKG9wdGlvbnMpIHtcbiAgdmFyIGRpcnMgPSBvcHRpb25zLmRpcmVjdGl2ZXM7XG4gIGlmIChkaXJzKSB7XG4gICAgZm9yICh2YXIga2V5IGluIGRpcnMpIHtcbiAgICAgIHZhciBkZWYgPSBkaXJzW2tleV07XG4gICAgICBpZiAodHlwZW9mIGRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBkaXJzW2tleV0gPSB7IGJpbmQ6IGRlZiwgdXBkYXRlOiBkZWYgfTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gYXNzZXJ0T2JqZWN0VHlwZSAobmFtZSwgdmFsdWUsIHZtKSB7XG4gIGlmICghaXNQbGFpbk9iamVjdCh2YWx1ZSkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHZhbHVlIGZvciBvcHRpb24gXFxcIlwiICsgbmFtZSArIFwiXFxcIjogZXhwZWN0ZWQgYW4gT2JqZWN0LCBcIiArXG4gICAgICBcImJ1dCBnb3QgXCIgKyAodG9SYXdUeXBlKHZhbHVlKSkgKyBcIi5cIixcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxufVxuXG4vKipcbiAqIE1lcmdlIHR3byBvcHRpb24gb2JqZWN0cyBpbnRvIGEgbmV3IG9uZS5cbiAqIENvcmUgdXRpbGl0eSB1c2VkIGluIGJvdGggaW5zdGFudGlhdGlvbiBhbmQgaW5oZXJpdGFuY2UuXG4gKi9cbmZ1bmN0aW9uIG1lcmdlT3B0aW9ucyAoXG4gIHBhcmVudCxcbiAgY2hpbGQsXG4gIHZtXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaGVja0NvbXBvbmVudHMoY2hpbGQpO1xuICB9XG5cbiAgaWYgKHR5cGVvZiBjaGlsZCA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIGNoaWxkID0gY2hpbGQub3B0aW9ucztcbiAgfVxuXG4gIG5vcm1hbGl6ZVByb3BzKGNoaWxkLCB2bSk7XG4gIG5vcm1hbGl6ZUluamVjdChjaGlsZCwgdm0pO1xuICBub3JtYWxpemVEaXJlY3RpdmVzKGNoaWxkKTtcbiAgdmFyIGV4dGVuZHNGcm9tID0gY2hpbGQuZXh0ZW5kcztcbiAgaWYgKGV4dGVuZHNGcm9tKSB7XG4gICAgcGFyZW50ID0gbWVyZ2VPcHRpb25zKHBhcmVudCwgZXh0ZW5kc0Zyb20sIHZtKTtcbiAgfVxuICBpZiAoY2hpbGQubWl4aW5zKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjaGlsZC5taXhpbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICBwYXJlbnQgPSBtZXJnZU9wdGlvbnMocGFyZW50LCBjaGlsZC5taXhpbnNbaV0sIHZtKTtcbiAgICB9XG4gIH1cbiAgdmFyIG9wdGlvbnMgPSB7fTtcbiAgdmFyIGtleTtcbiAgZm9yIChrZXkgaW4gcGFyZW50KSB7XG4gICAgbWVyZ2VGaWVsZChrZXkpO1xuICB9XG4gIGZvciAoa2V5IGluIGNoaWxkKSB7XG4gICAgaWYgKCFoYXNPd24ocGFyZW50LCBrZXkpKSB7XG4gICAgICBtZXJnZUZpZWxkKGtleSk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIG1lcmdlRmllbGQgKGtleSkge1xuICAgIHZhciBzdHJhdCA9IHN0cmF0c1trZXldIHx8IGRlZmF1bHRTdHJhdDtcbiAgICBvcHRpb25zW2tleV0gPSBzdHJhdChwYXJlbnRba2V5XSwgY2hpbGRba2V5XSwgdm0sIGtleSk7XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuLyoqXG4gKiBSZXNvbHZlIGFuIGFzc2V0LlxuICogVGhpcyBmdW5jdGlvbiBpcyB1c2VkIGJlY2F1c2UgY2hpbGQgaW5zdGFuY2VzIG5lZWQgYWNjZXNzXG4gKiB0byBhc3NldHMgZGVmaW5lZCBpbiBpdHMgYW5jZXN0b3IgY2hhaW4uXG4gKi9cbmZ1bmN0aW9uIHJlc29sdmVBc3NldCAoXG4gIG9wdGlvbnMsXG4gIHR5cGUsXG4gIGlkLFxuICB3YXJuTWlzc2luZ1xuKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodHlwZW9mIGlkICE9PSAnc3RyaW5nJykge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBhc3NldHMgPSBvcHRpb25zW3R5cGVdO1xuICAvLyBjaGVjayBsb2NhbCByZWdpc3RyYXRpb24gdmFyaWF0aW9ucyBmaXJzdFxuICBpZiAoaGFzT3duKGFzc2V0cywgaWQpKSB7IHJldHVybiBhc3NldHNbaWRdIH1cbiAgdmFyIGNhbWVsaXplZElkID0gY2FtZWxpemUoaWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgY2FtZWxpemVkSWQpKSB7IHJldHVybiBhc3NldHNbY2FtZWxpemVkSWRdIH1cbiAgdmFyIFBhc2NhbENhc2VJZCA9IGNhcGl0YWxpemUoY2FtZWxpemVkSWQpO1xuICBpZiAoaGFzT3duKGFzc2V0cywgUGFzY2FsQ2FzZUlkKSkgeyByZXR1cm4gYXNzZXRzW1Bhc2NhbENhc2VJZF0gfVxuICAvLyBmYWxsYmFjayB0byBwcm90b3R5cGUgY2hhaW5cbiAgdmFyIHJlcyA9IGFzc2V0c1tpZF0gfHwgYXNzZXRzW2NhbWVsaXplZElkXSB8fCBhc3NldHNbUGFzY2FsQ2FzZUlkXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2Fybk1pc3NpbmcgJiYgIXJlcykge1xuICAgIHdhcm4oXG4gICAgICAnRmFpbGVkIHRvIHJlc29sdmUgJyArIHR5cGUuc2xpY2UoMCwgLTEpICsgJzogJyArIGlkLFxuICAgICAgb3B0aW9uc1xuICAgICk7XG4gIH1cbiAgcmV0dXJuIHJlc1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wIChcbiAga2V5LFxuICBwcm9wT3B0aW9ucyxcbiAgcHJvcHNEYXRhLFxuICB2bVxuKSB7XG4gIHZhciBwcm9wID0gcHJvcE9wdGlvbnNba2V5XTtcbiAgdmFyIGFic2VudCA9ICFoYXNPd24ocHJvcHNEYXRhLCBrZXkpO1xuICB2YXIgdmFsdWUgPSBwcm9wc0RhdGFba2V5XTtcbiAgLy8gaGFuZGxlIGJvb2xlYW4gcHJvcHNcbiAgaWYgKGlzVHlwZShCb29sZWFuLCBwcm9wLnR5cGUpKSB7XG4gICAgaWYgKGFic2VudCAmJiAhaGFzT3duKHByb3AsICdkZWZhdWx0JykpIHtcbiAgICAgIHZhbHVlID0gZmFsc2U7XG4gICAgfSBlbHNlIGlmICghaXNUeXBlKFN0cmluZywgcHJvcC50eXBlKSAmJiAodmFsdWUgPT09ICcnIHx8IHZhbHVlID09PSBoeXBoZW5hdGUoa2V5KSkpIHtcbiAgICAgIHZhbHVlID0gdHJ1ZTtcbiAgICB9XG4gIH1cbiAgLy8gY2hlY2sgZGVmYXVsdCB2YWx1ZVxuICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgIHZhbHVlID0gZ2V0UHJvcERlZmF1bHRWYWx1ZSh2bSwgcHJvcCwga2V5KTtcbiAgICAvLyBzaW5jZSB0aGUgZGVmYXVsdCB2YWx1ZSBpcyBhIGZyZXNoIGNvcHksXG4gICAgLy8gbWFrZSBzdXJlIHRvIG9ic2VydmUgaXQuXG4gICAgdmFyIHByZXZTaG91bGRDb252ZXJ0ID0gb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0O1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgb2JzZXJ2ZSh2YWx1ZSk7XG4gICAgb2JzZXJ2ZXJTdGF0ZS5zaG91bGRDb252ZXJ0ID0gcHJldlNob3VsZENvbnZlcnQ7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBhc3NlcnRQcm9wKHByb3AsIGtleSwgdmFsdWUsIHZtLCBhYnNlbnQpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufVxuXG4vKipcbiAqIEdldCB0aGUgZGVmYXVsdCB2YWx1ZSBvZiBhIHByb3AuXG4gKi9cbmZ1bmN0aW9uIGdldFByb3BEZWZhdWx0VmFsdWUgKHZtLCBwcm9wLCBrZXkpIHtcbiAgLy8gbm8gZGVmYXVsdCwgcmV0dXJuIHVuZGVmaW5lZFxuICBpZiAoIWhhc093bihwcm9wLCAnZGVmYXVsdCcpKSB7XG4gICAgcmV0dXJuIHVuZGVmaW5lZFxuICB9XG4gIHZhciBkZWYgPSBwcm9wLmRlZmF1bHQ7XG4gIC8vIHdhcm4gYWdhaW5zdCBub24tZmFjdG9yeSBkZWZhdWx0cyBmb3IgT2JqZWN0ICYgQXJyYXlcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNPYmplY3QoZGVmKSkge1xuICAgIHdhcm4oXG4gICAgICAnSW52YWxpZCBkZWZhdWx0IHZhbHVlIGZvciBwcm9wIFwiJyArIGtleSArICdcIjogJyArXG4gICAgICAnUHJvcHMgd2l0aCB0eXBlIE9iamVjdC9BcnJheSBtdXN0IHVzZSBhIGZhY3RvcnkgZnVuY3Rpb24gJyArXG4gICAgICAndG8gcmV0dXJuIHRoZSBkZWZhdWx0IHZhbHVlLicsXG4gICAgICB2bVxuICAgICk7XG4gIH1cbiAgLy8gdGhlIHJhdyBwcm9wIHZhbHVlIHdhcyBhbHNvIHVuZGVmaW5lZCBmcm9tIHByZXZpb3VzIHJlbmRlcixcbiAgLy8gcmV0dXJuIHByZXZpb3VzIGRlZmF1bHQgdmFsdWUgdG8gYXZvaWQgdW5uZWNlc3Nhcnkgd2F0Y2hlciB0cmlnZ2VyXG4gIGlmICh2bSAmJiB2bS4kb3B0aW9ucy5wcm9wc0RhdGEgJiZcbiAgICB2bS4kb3B0aW9ucy5wcm9wc0RhdGFba2V5XSA9PT0gdW5kZWZpbmVkICYmXG4gICAgdm0uX3Byb3BzW2tleV0gIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICByZXR1cm4gdm0uX3Byb3BzW2tleV1cbiAgfVxuICAvLyBjYWxsIGZhY3RvcnkgZnVuY3Rpb24gZm9yIG5vbi1GdW5jdGlvbiB0eXBlc1xuICAvLyBhIHZhbHVlIGlzIEZ1bmN0aW9uIGlmIGl0cyBwcm90b3R5cGUgaXMgZnVuY3Rpb24gZXZlbiBhY3Jvc3MgZGlmZmVyZW50IGV4ZWN1dGlvbiBjb250ZXh0XG4gIHJldHVybiB0eXBlb2YgZGVmID09PSAnZnVuY3Rpb24nICYmIGdldFR5cGUocHJvcC50eXBlKSAhPT0gJ0Z1bmN0aW9uJ1xuICAgID8gZGVmLmNhbGwodm0pXG4gICAgOiBkZWZcbn1cblxuLyoqXG4gKiBBc3NlcnQgd2hldGhlciBhIHByb3AgaXMgdmFsaWQuXG4gKi9cbmZ1bmN0aW9uIGFzc2VydFByb3AgKFxuICBwcm9wLFxuICBuYW1lLFxuICB2YWx1ZSxcbiAgdm0sXG4gIGFic2VudFxuKSB7XG4gIGlmIChwcm9wLnJlcXVpcmVkICYmIGFic2VudCkge1xuICAgIHdhcm4oXG4gICAgICAnTWlzc2luZyByZXF1aXJlZCBwcm9wOiBcIicgKyBuYW1lICsgJ1wiJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsdWUgPT0gbnVsbCAmJiAhcHJvcC5yZXF1aXJlZCkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciB0eXBlID0gcHJvcC50eXBlO1xuICB2YXIgdmFsaWQgPSAhdHlwZSB8fCB0eXBlID09PSB0cnVlO1xuICB2YXIgZXhwZWN0ZWRUeXBlcyA9IFtdO1xuICBpZiAodHlwZSkge1xuICAgIGlmICghQXJyYXkuaXNBcnJheSh0eXBlKSkge1xuICAgICAgdHlwZSA9IFt0eXBlXTtcbiAgICB9XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlLmxlbmd0aCAmJiAhdmFsaWQ7IGkrKykge1xuICAgICAgdmFyIGFzc2VydGVkVHlwZSA9IGFzc2VydFR5cGUodmFsdWUsIHR5cGVbaV0pO1xuICAgICAgZXhwZWN0ZWRUeXBlcy5wdXNoKGFzc2VydGVkVHlwZS5leHBlY3RlZFR5cGUgfHwgJycpO1xuICAgICAgdmFsaWQgPSBhc3NlcnRlZFR5cGUudmFsaWQ7XG4gICAgfVxuICB9XG4gIGlmICghdmFsaWQpIHtcbiAgICB3YXJuKFxuICAgICAgXCJJbnZhbGlkIHByb3A6IHR5cGUgY2hlY2sgZmFpbGVkIGZvciBwcm9wIFxcXCJcIiArIG5hbWUgKyBcIlxcXCIuXCIgK1xuICAgICAgXCIgRXhwZWN0ZWQgXCIgKyAoZXhwZWN0ZWRUeXBlcy5tYXAoY2FwaXRhbGl6ZSkuam9pbignLCAnKSkgK1xuICAgICAgXCIsIGdvdCBcIiArICh0b1Jhd1R5cGUodmFsdWUpKSArIFwiLlwiLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciB2YWxpZGF0b3IgPSBwcm9wLnZhbGlkYXRvcjtcbiAgaWYgKHZhbGlkYXRvcikge1xuICAgIGlmICghdmFsaWRhdG9yKHZhbHVlKSkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0ludmFsaWQgcHJvcDogY3VzdG9tIHZhbGlkYXRvciBjaGVjayBmYWlsZWQgZm9yIHByb3AgXCInICsgbmFtZSArICdcIi4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHNpbXBsZUNoZWNrUkUgPSAvXihTdHJpbmd8TnVtYmVyfEJvb2xlYW58RnVuY3Rpb258U3ltYm9sKSQvO1xuXG5mdW5jdGlvbiBhc3NlcnRUeXBlICh2YWx1ZSwgdHlwZSkge1xuICB2YXIgdmFsaWQ7XG4gIHZhciBleHBlY3RlZFR5cGUgPSBnZXRUeXBlKHR5cGUpO1xuICBpZiAoc2ltcGxlQ2hlY2tSRS50ZXN0KGV4cGVjdGVkVHlwZSkpIHtcbiAgICB2YXIgdCA9IHR5cGVvZiB2YWx1ZTtcbiAgICB2YWxpZCA9IHQgPT09IGV4cGVjdGVkVHlwZS50b0xvd2VyQ2FzZSgpO1xuICAgIC8vIGZvciBwcmltaXRpdmUgd3JhcHBlciBvYmplY3RzXG4gICAgaWYgKCF2YWxpZCAmJiB0ID09PSAnb2JqZWN0Jykge1xuICAgICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gICAgfVxuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ09iamVjdCcpIHtcbiAgICB2YWxpZCA9IGlzUGxhaW5PYmplY3QodmFsdWUpO1xuICB9IGVsc2UgaWYgKGV4cGVjdGVkVHlwZSA9PT0gJ0FycmF5Jykge1xuICAgIHZhbGlkID0gQXJyYXkuaXNBcnJheSh2YWx1ZSk7XG4gIH0gZWxzZSB7XG4gICAgdmFsaWQgPSB2YWx1ZSBpbnN0YW5jZW9mIHR5cGU7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB2YWxpZDogdmFsaWQsXG4gICAgZXhwZWN0ZWRUeXBlOiBleHBlY3RlZFR5cGVcbiAgfVxufVxuXG4vKipcbiAqIFVzZSBmdW5jdGlvbiBzdHJpbmcgbmFtZSB0byBjaGVjayBidWlsdC1pbiB0eXBlcyxcbiAqIGJlY2F1c2UgYSBzaW1wbGUgZXF1YWxpdHkgY2hlY2sgd2lsbCBmYWlsIHdoZW4gcnVubmluZ1xuICogYWNyb3NzIGRpZmZlcmVudCB2bXMgLyBpZnJhbWVzLlxuICovXG5mdW5jdGlvbiBnZXRUeXBlIChmbikge1xuICB2YXIgbWF0Y2ggPSBmbiAmJiBmbi50b1N0cmluZygpLm1hdGNoKC9eXFxzKmZ1bmN0aW9uIChcXHcrKS8pO1xuICByZXR1cm4gbWF0Y2ggPyBtYXRjaFsxXSA6ICcnXG59XG5cbmZ1bmN0aW9uIGlzVHlwZSAodHlwZSwgZm4pIHtcbiAgaWYgKCFBcnJheS5pc0FycmF5KGZuKSkge1xuICAgIHJldHVybiBnZXRUeXBlKGZuKSA9PT0gZ2V0VHlwZSh0eXBlKVxuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBmbi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIGlmIChnZXRUeXBlKGZuW2ldKSA9PT0gZ2V0VHlwZSh0eXBlKSkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuIGZhbHNlXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBoYW5kbGVFcnJvciAoZXJyLCB2bSwgaW5mbykge1xuICBpZiAodm0pIHtcbiAgICB2YXIgY3VyID0gdm07XG4gICAgd2hpbGUgKChjdXIgPSBjdXIuJHBhcmVudCkpIHtcbiAgICAgIHZhciBob29rcyA9IGN1ci4kb3B0aW9ucy5lcnJvckNhcHR1cmVkO1xuICAgICAgaWYgKGhvb2tzKSB7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaG9va3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGNhcHR1cmUgPSBob29rc1tpXS5jYWxsKGN1ciwgZXJyLCB2bSwgaW5mbykgPT09IGZhbHNlO1xuICAgICAgICAgICAgaWYgKGNhcHR1cmUpIHsgcmV0dXJuIH1cbiAgICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgICBnbG9iYWxIYW5kbGVFcnJvcihlLCBjdXIsICdlcnJvckNhcHR1cmVkIGhvb2snKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgZ2xvYmFsSGFuZGxlRXJyb3IoZXJyLCB2bSwgaW5mbyk7XG59XG5cbmZ1bmN0aW9uIGdsb2JhbEhhbmRsZUVycm9yIChlcnIsIHZtLCBpbmZvKSB7XG4gIGlmIChjb25maWcuZXJyb3JIYW5kbGVyKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjb25maWcuZXJyb3JIYW5kbGVyLmNhbGwobnVsbCwgZXJyLCB2bSwgaW5mbylcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBsb2dFcnJvcihlLCBudWxsLCAnY29uZmlnLmVycm9ySGFuZGxlcicpO1xuICAgIH1cbiAgfVxuICBsb2dFcnJvcihlcnIsIHZtLCBpbmZvKTtcbn1cblxuZnVuY3Rpb24gbG9nRXJyb3IgKGVyciwgdm0sIGluZm8pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuKChcIkVycm9yIGluIFwiICsgaW5mbyArIFwiOiBcXFwiXCIgKyAoZXJyLnRvU3RyaW5nKCkpICsgXCJcXFwiXCIpLCB2bSk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKChpbkJyb3dzZXIgfHwgaW5XZWV4KSAmJiB0eXBlb2YgY29uc29sZSAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICBjb25zb2xlLmVycm9yKGVycik7XG4gIH0gZWxzZSB7XG4gICAgdGhyb3cgZXJyXG4gIH1cbn1cblxuLyogICovXG4vKiBnbG9iYWxzIE1lc3NhZ2VDaGFubmVsICovXG5cbnZhciBjYWxsYmFja3MgPSBbXTtcbnZhciBwZW5kaW5nID0gZmFsc2U7XG5cbmZ1bmN0aW9uIGZsdXNoQ2FsbGJhY2tzICgpIHtcbiAgcGVuZGluZyA9IGZhbHNlO1xuICB2YXIgY29waWVzID0gY2FsbGJhY2tzLnNsaWNlKDApO1xuICBjYWxsYmFja3MubGVuZ3RoID0gMDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjb3BpZXMubGVuZ3RoOyBpKyspIHtcbiAgICBjb3BpZXNbaV0oKTtcbiAgfVxufVxuXG4vLyBIZXJlIHdlIGhhdmUgYXN5bmMgZGVmZXJyaW5nIHdyYXBwZXJzIHVzaW5nIGJvdGggbWljcm8gYW5kIG1hY3JvIHRhc2tzLlxuLy8gSW4gPCAyLjQgd2UgdXNlZCBtaWNybyB0YXNrcyBldmVyeXdoZXJlLCBidXQgdGhlcmUgYXJlIHNvbWUgc2NlbmFyaW9zIHdoZXJlXG4vLyBtaWNybyB0YXNrcyBoYXZlIHRvbyBoaWdoIGEgcHJpb3JpdHkgYW5kIGZpcmVzIGluIGJldHdlZW4gc3VwcG9zZWRseVxuLy8gc2VxdWVudGlhbCBldmVudHMgKGUuZy4gIzQ1MjEsICM2NjkwKSBvciBldmVuIGJldHdlZW4gYnViYmxpbmcgb2YgdGhlIHNhbWVcbi8vIGV2ZW50ICgjNjU2NikuIEhvd2V2ZXIsIHVzaW5nIG1hY3JvIHRhc2tzIGV2ZXJ5d2hlcmUgYWxzbyBoYXMgc3VidGxlIHByb2JsZW1zXG4vLyB3aGVuIHN0YXRlIGlzIGNoYW5nZWQgcmlnaHQgYmVmb3JlIHJlcGFpbnQgKGUuZy4gIzY4MTMsIG91dC1pbiB0cmFuc2l0aW9ucykuXG4vLyBIZXJlIHdlIHVzZSBtaWNybyB0YXNrIGJ5IGRlZmF1bHQsIGJ1dCBleHBvc2UgYSB3YXkgdG8gZm9yY2UgbWFjcm8gdGFzayB3aGVuXG4vLyBuZWVkZWQgKGUuZy4gaW4gZXZlbnQgaGFuZGxlcnMgYXR0YWNoZWQgYnkgdi1vbikuXG52YXIgbWljcm9UaW1lckZ1bmM7XG52YXIgbWFjcm9UaW1lckZ1bmM7XG52YXIgdXNlTWFjcm9UYXNrID0gZmFsc2U7XG5cbi8vIERldGVybWluZSAobWFjcm8pIFRhc2sgZGVmZXIgaW1wbGVtZW50YXRpb24uXG4vLyBUZWNobmljYWxseSBzZXRJbW1lZGlhdGUgc2hvdWxkIGJlIHRoZSBpZGVhbCBjaG9pY2UsIGJ1dCBpdCdzIG9ubHkgYXZhaWxhYmxlXG4vLyBpbiBJRS4gVGhlIG9ubHkgcG9seWZpbGwgdGhhdCBjb25zaXN0ZW50bHkgcXVldWVzIHRoZSBjYWxsYmFjayBhZnRlciBhbGwgRE9NXG4vLyBldmVudHMgdHJpZ2dlcmVkIGluIHRoZSBzYW1lIGxvb3AgaXMgYnkgdXNpbmcgTWVzc2FnZUNoYW5uZWwuXG4vKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbmlmICh0eXBlb2Ygc2V0SW1tZWRpYXRlICE9PSAndW5kZWZpbmVkJyAmJiBpc05hdGl2ZShzZXRJbW1lZGlhdGUpKSB7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHNldEltbWVkaWF0ZShmbHVzaENhbGxiYWNrcyk7XG4gIH07XG59IGVsc2UgaWYgKHR5cGVvZiBNZXNzYWdlQ2hhbm5lbCAhPT0gJ3VuZGVmaW5lZCcgJiYgKFxuICBpc05hdGl2ZShNZXNzYWdlQ2hhbm5lbCkgfHxcbiAgLy8gUGhhbnRvbUpTXG4gIE1lc3NhZ2VDaGFubmVsLnRvU3RyaW5nKCkgPT09ICdbb2JqZWN0IE1lc3NhZ2VDaGFubmVsQ29uc3RydWN0b3JdJ1xuKSkge1xuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gZmx1c2hDYWxsYmFja3M7XG4gIG1hY3JvVGltZXJGdW5jID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UoMSk7XG4gIH07XG59IGVsc2Uge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgbmV4dCAqL1xuICBtYWNyb1RpbWVyRnVuYyA9IGZ1bmN0aW9uICgpIHtcbiAgICBzZXRUaW1lb3V0KGZsdXNoQ2FsbGJhY2tzLCAwKTtcbiAgfTtcbn1cblxuLy8gRGV0ZXJtaW5lIE1pY3JvVGFzayBkZWZlciBpbXBsZW1lbnRhdGlvbi5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0LCAkZmxvdy1kaXNhYmxlLWxpbmUgKi9cbmlmICh0eXBlb2YgUHJvbWlzZSAhPT0gJ3VuZGVmaW5lZCcgJiYgaXNOYXRpdmUoUHJvbWlzZSkpIHtcbiAgdmFyIHAgPSBQcm9taXNlLnJlc29sdmUoKTtcbiAgbWljcm9UaW1lckZ1bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgcC50aGVuKGZsdXNoQ2FsbGJhY2tzKTtcbiAgICAvLyBpbiBwcm9ibGVtYXRpYyBVSVdlYlZpZXdzLCBQcm9taXNlLnRoZW4gZG9lc24ndCBjb21wbGV0ZWx5IGJyZWFrLCBidXRcbiAgICAvLyBpdCBjYW4gZ2V0IHN0dWNrIGluIGEgd2VpcmQgc3RhdGUgd2hlcmUgY2FsbGJhY2tzIGFyZSBwdXNoZWQgaW50byB0aGVcbiAgICAvLyBtaWNyb3Rhc2sgcXVldWUgYnV0IHRoZSBxdWV1ZSBpc24ndCBiZWluZyBmbHVzaGVkLCB1bnRpbCB0aGUgYnJvd3NlclxuICAgIC8vIG5lZWRzIHRvIGRvIHNvbWUgb3RoZXIgd29yaywgZS5nLiBoYW5kbGUgYSB0aW1lci4gVGhlcmVmb3JlIHdlIGNhblxuICAgIC8vIFwiZm9yY2VcIiB0aGUgbWljcm90YXNrIHF1ZXVlIHRvIGJlIGZsdXNoZWQgYnkgYWRkaW5nIGFuIGVtcHR5IHRpbWVyLlxuICAgIGlmIChpc0lPUykgeyBzZXRUaW1lb3V0KG5vb3ApOyB9XG4gIH07XG59IGVsc2Uge1xuICAvLyBmYWxsYmFjayB0byBtYWNyb1xuICBtaWNyb1RpbWVyRnVuYyA9IG1hY3JvVGltZXJGdW5jO1xufVxuXG4vKipcbiAqIFdyYXAgYSBmdW5jdGlvbiBzbyB0aGF0IGlmIGFueSBjb2RlIGluc2lkZSB0cmlnZ2VycyBzdGF0ZSBjaGFuZ2UsXG4gKiB0aGUgY2hhbmdlcyBhcmUgcXVldWVkIHVzaW5nIGEgVGFzayBpbnN0ZWFkIG9mIGEgTWljcm9UYXNrLlxuICovXG5mdW5jdGlvbiB3aXRoTWFjcm9UYXNrIChmbikge1xuICByZXR1cm4gZm4uX3dpdGhUYXNrIHx8IChmbi5fd2l0aFRhc2sgPSBmdW5jdGlvbiAoKSB7XG4gICAgdXNlTWFjcm9UYXNrID0gdHJ1ZTtcbiAgICB2YXIgcmVzID0gZm4uYXBwbHkobnVsbCwgYXJndW1lbnRzKTtcbiAgICB1c2VNYWNyb1Rhc2sgPSBmYWxzZTtcbiAgICByZXR1cm4gcmVzXG4gIH0pXG59XG5cbmZ1bmN0aW9uIG5leHRUaWNrIChjYiwgY3R4KSB7XG4gIHZhciBfcmVzb2x2ZTtcbiAgY2FsbGJhY2tzLnB1c2goZnVuY3Rpb24gKCkge1xuICAgIGlmIChjYikge1xuICAgICAgdHJ5IHtcbiAgICAgICAgY2IuY2FsbChjdHgpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCBjdHgsICduZXh0VGljaycpO1xuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoX3Jlc29sdmUpIHtcbiAgICAgIF9yZXNvbHZlKGN0eCk7XG4gICAgfVxuICB9KTtcbiAgaWYgKCFwZW5kaW5nKSB7XG4gICAgcGVuZGluZyA9IHRydWU7XG4gICAgaWYgKHVzZU1hY3JvVGFzaykge1xuICAgICAgbWFjcm9UaW1lckZ1bmMoKTtcbiAgICB9IGVsc2Uge1xuICAgICAgbWljcm9UaW1lckZ1bmMoKTtcbiAgICB9XG4gIH1cbiAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gIGlmICghY2IgJiYgdHlwZW9mIFByb21pc2UgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICBfcmVzb2x2ZSA9IHJlc29sdmU7XG4gICAgfSlcbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIG1hcms7XG52YXIgbWVhc3VyZTtcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgdmFyIHBlcmYgPSBpbkJyb3dzZXIgJiYgd2luZG93LnBlcmZvcm1hbmNlO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKFxuICAgIHBlcmYgJiZcbiAgICBwZXJmLm1hcmsgJiZcbiAgICBwZXJmLm1lYXN1cmUgJiZcbiAgICBwZXJmLmNsZWFyTWFya3MgJiZcbiAgICBwZXJmLmNsZWFyTWVhc3VyZXNcbiAgKSB7XG4gICAgbWFyayA9IGZ1bmN0aW9uICh0YWcpIHsgcmV0dXJuIHBlcmYubWFyayh0YWcpOyB9O1xuICAgIG1lYXN1cmUgPSBmdW5jdGlvbiAobmFtZSwgc3RhcnRUYWcsIGVuZFRhZykge1xuICAgICAgcGVyZi5tZWFzdXJlKG5hbWUsIHN0YXJ0VGFnLCBlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1hcmtzKHN0YXJ0VGFnKTtcbiAgICAgIHBlcmYuY2xlYXJNYXJrcyhlbmRUYWcpO1xuICAgICAgcGVyZi5jbGVhck1lYXN1cmVzKG5hbWUpO1xuICAgIH07XG4gIH1cbn1cblxuLyogbm90IHR5cGUgY2hlY2tpbmcgdGhpcyBmaWxlIGJlY2F1c2UgZmxvdyBkb2Vzbid0IHBsYXkgd2VsbCB3aXRoIFByb3h5ICovXG5cbnZhciBpbml0UHJveHk7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gIHZhciBhbGxvd2VkR2xvYmFscyA9IG1ha2VNYXAoXG4gICAgJ0luZmluaXR5LHVuZGVmaW5lZCxOYU4saXNGaW5pdGUsaXNOYU4sJyArXG4gICAgJ3BhcnNlRmxvYXQscGFyc2VJbnQsZGVjb2RlVVJJLGRlY29kZVVSSUNvbXBvbmVudCxlbmNvZGVVUkksZW5jb2RlVVJJQ29tcG9uZW50LCcgK1xuICAgICdNYXRoLE51bWJlcixEYXRlLEFycmF5LE9iamVjdCxCb29sZWFuLFN0cmluZyxSZWdFeHAsTWFwLFNldCxKU09OLEludGwsJyArXG4gICAgJ3JlcXVpcmUnIC8vIGZvciBXZWJwYWNrL0Jyb3dzZXJpZnlcbiAgKTtcblxuICB2YXIgd2Fybk5vblByZXNlbnQgPSBmdW5jdGlvbiAodGFyZ2V0LCBrZXkpIHtcbiAgICB3YXJuKFxuICAgICAgXCJQcm9wZXJ0eSBvciBtZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGlzIG5vdCBkZWZpbmVkIG9uIHRoZSBpbnN0YW5jZSBidXQgXCIgK1xuICAgICAgJ3JlZmVyZW5jZWQgZHVyaW5nIHJlbmRlci4gTWFrZSBzdXJlIHRoYXQgdGhpcyBwcm9wZXJ0eSBpcyByZWFjdGl2ZSwgJyArXG4gICAgICAnZWl0aGVyIGluIHRoZSBkYXRhIG9wdGlvbiwgb3IgZm9yIGNsYXNzLWJhc2VkIGNvbXBvbmVudHMsIGJ5ICcgK1xuICAgICAgJ2luaXRpYWxpemluZyB0aGUgcHJvcGVydHkuICcgK1xuICAgICAgJ1NlZTogaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvcmVhY3Rpdml0eS5odG1sI0RlY2xhcmluZy1SZWFjdGl2ZS1Qcm9wZXJ0aWVzLicsXG4gICAgICB0YXJnZXRcbiAgICApO1xuICB9O1xuXG4gIHZhciBoYXNQcm94eSA9XG4gICAgdHlwZW9mIFByb3h5ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIFByb3h5LnRvU3RyaW5nKCkubWF0Y2goL25hdGl2ZSBjb2RlLyk7XG5cbiAgaWYgKGhhc1Byb3h5KSB7XG4gICAgdmFyIGlzQnVpbHRJbk1vZGlmaWVyID0gbWFrZU1hcCgnc3RvcCxwcmV2ZW50LHNlbGYsY3RybCxzaGlmdCxhbHQsbWV0YSxleGFjdCcpO1xuICAgIGNvbmZpZy5rZXlDb2RlcyA9IG5ldyBQcm94eShjb25maWcua2V5Q29kZXMsIHtcbiAgICAgIHNldDogZnVuY3Rpb24gc2V0ICh0YXJnZXQsIGtleSwgdmFsdWUpIHtcbiAgICAgICAgaWYgKGlzQnVpbHRJbk1vZGlmaWVyKGtleSkpIHtcbiAgICAgICAgICB3YXJuKChcIkF2b2lkIG92ZXJ3cml0aW5nIGJ1aWx0LWluIG1vZGlmaWVyIGluIGNvbmZpZy5rZXlDb2RlczogLlwiICsga2V5KSk7XG4gICAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdGFyZ2V0W2tleV0gPSB2YWx1ZTtcbiAgICAgICAgICByZXR1cm4gdHJ1ZVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICB2YXIgaGFzSGFuZGxlciA9IHtcbiAgICBoYXM6IGZ1bmN0aW9uIGhhcyAodGFyZ2V0LCBrZXkpIHtcbiAgICAgIHZhciBoYXMgPSBrZXkgaW4gdGFyZ2V0O1xuICAgICAgdmFyIGlzQWxsb3dlZCA9IGFsbG93ZWRHbG9iYWxzKGtleSkgfHwga2V5LmNoYXJBdCgwKSA9PT0gJ18nO1xuICAgICAgaWYgKCFoYXMgJiYgIWlzQWxsb3dlZCkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gaGFzIHx8ICFpc0FsbG93ZWRcbiAgICB9XG4gIH07XG5cbiAgdmFyIGdldEhhbmRsZXIgPSB7XG4gICAgZ2V0OiBmdW5jdGlvbiBnZXQgKHRhcmdldCwga2V5KSB7XG4gICAgICBpZiAodHlwZW9mIGtleSA9PT0gJ3N0cmluZycgJiYgIShrZXkgaW4gdGFyZ2V0KSkge1xuICAgICAgICB3YXJuTm9uUHJlc2VudCh0YXJnZXQsIGtleSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGFyZ2V0W2tleV1cbiAgICB9XG4gIH07XG5cbiAgaW5pdFByb3h5ID0gZnVuY3Rpb24gaW5pdFByb3h5ICh2bSkge1xuICAgIGlmIChoYXNQcm94eSkge1xuICAgICAgLy8gZGV0ZXJtaW5lIHdoaWNoIHByb3h5IGhhbmRsZXIgdG8gdXNlXG4gICAgICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuICAgICAgdmFyIGhhbmRsZXJzID0gb3B0aW9ucy5yZW5kZXIgJiYgb3B0aW9ucy5yZW5kZXIuX3dpdGhTdHJpcHBlZFxuICAgICAgICA/IGdldEhhbmRsZXJcbiAgICAgICAgOiBoYXNIYW5kbGVyO1xuICAgICAgdm0uX3JlbmRlclByb3h5ID0gbmV3IFByb3h5KHZtLCBoYW5kbGVycyk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZtLl9yZW5kZXJQcm94eSA9IHZtO1xuICAgIH1cbiAgfTtcbn1cblxuLyogICovXG5cbnZhciBzZWVuT2JqZWN0cyA9IG5ldyBfU2V0KCk7XG5cbi8qKlxuICogUmVjdXJzaXZlbHkgdHJhdmVyc2UgYW4gb2JqZWN0IHRvIGV2b2tlIGFsbCBjb252ZXJ0ZWRcbiAqIGdldHRlcnMsIHNvIHRoYXQgZXZlcnkgbmVzdGVkIHByb3BlcnR5IGluc2lkZSB0aGUgb2JqZWN0XG4gKiBpcyBjb2xsZWN0ZWQgYXMgYSBcImRlZXBcIiBkZXBlbmRlbmN5LlxuICovXG5mdW5jdGlvbiB0cmF2ZXJzZSAodmFsKSB7XG4gIF90cmF2ZXJzZSh2YWwsIHNlZW5PYmplY3RzKTtcbiAgc2Vlbk9iamVjdHMuY2xlYXIoKTtcbn1cblxuZnVuY3Rpb24gX3RyYXZlcnNlICh2YWwsIHNlZW4pIHtcbiAgdmFyIGksIGtleXM7XG4gIHZhciBpc0EgPSBBcnJheS5pc0FycmF5KHZhbCk7XG4gIGlmICgoIWlzQSAmJiAhaXNPYmplY3QodmFsKSkgfHwgT2JqZWN0LmlzRnJvemVuKHZhbCkpIHtcbiAgICByZXR1cm5cbiAgfVxuICBpZiAodmFsLl9fb2JfXykge1xuICAgIHZhciBkZXBJZCA9IHZhbC5fX29iX18uZGVwLmlkO1xuICAgIGlmIChzZWVuLmhhcyhkZXBJZCkpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBzZWVuLmFkZChkZXBJZCk7XG4gIH1cbiAgaWYgKGlzQSkge1xuICAgIGkgPSB2YWwubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHsgX3RyYXZlcnNlKHZhbFtpXSwgc2Vlbik7IH1cbiAgfSBlbHNlIHtcbiAgICBrZXlzID0gT2JqZWN0LmtleXModmFsKTtcbiAgICBpID0ga2V5cy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkgeyBfdHJhdmVyc2UodmFsW2tleXNbaV1dLCBzZWVuKTsgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgbm9ybWFsaXplRXZlbnQgPSBjYWNoZWQoZnVuY3Rpb24gKG5hbWUpIHtcbiAgdmFyIHBhc3NpdmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyYnO1xuICBuYW1lID0gcGFzc2l2ZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICB2YXIgb25jZSQkMSA9IG5hbWUuY2hhckF0KDApID09PSAnfic7IC8vIFByZWZpeGVkIGxhc3QsIGNoZWNrZWQgZmlyc3RcbiAgbmFtZSA9IG9uY2UkJDEgPyBuYW1lLnNsaWNlKDEpIDogbmFtZTtcbiAgdmFyIGNhcHR1cmUgPSBuYW1lLmNoYXJBdCgwKSA9PT0gJyEnO1xuICBuYW1lID0gY2FwdHVyZSA/IG5hbWUuc2xpY2UoMSkgOiBuYW1lO1xuICByZXR1cm4ge1xuICAgIG5hbWU6IG5hbWUsXG4gICAgb25jZTogb25jZSQkMSxcbiAgICBjYXB0dXJlOiBjYXB0dXJlLFxuICAgIHBhc3NpdmU6IHBhc3NpdmVcbiAgfVxufSk7XG5cbmZ1bmN0aW9uIGNyZWF0ZUZuSW52b2tlciAoZm5zKSB7XG4gIGZ1bmN0aW9uIGludm9rZXIgKCkge1xuICAgIHZhciBhcmd1bWVudHMkMSA9IGFyZ3VtZW50cztcblxuICAgIHZhciBmbnMgPSBpbnZva2VyLmZucztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShmbnMpKSB7XG4gICAgICB2YXIgY2xvbmVkID0gZm5zLnNsaWNlKCk7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNsb25lZC5sZW5ndGg7IGkrKykge1xuICAgICAgICBjbG9uZWRbaV0uYXBwbHkobnVsbCwgYXJndW1lbnRzJDEpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyByZXR1cm4gaGFuZGxlciByZXR1cm4gdmFsdWUgZm9yIHNpbmdsZSBoYW5kbGVyc1xuICAgICAgcmV0dXJuIGZucy5hcHBseShudWxsLCBhcmd1bWVudHMpXG4gICAgfVxuICB9XG4gIGludm9rZXIuZm5zID0gZm5zO1xuICByZXR1cm4gaW52b2tlclxufVxuXG5mdW5jdGlvbiB1cGRhdGVMaXN0ZW5lcnMgKFxuICBvbixcbiAgb2xkT24sXG4gIGFkZCxcbiAgcmVtb3ZlJCQxLFxuICB2bVxuKSB7XG4gIHZhciBuYW1lLCBjdXIsIG9sZCwgZXZlbnQ7XG4gIGZvciAobmFtZSBpbiBvbikge1xuICAgIGN1ciA9IG9uW25hbWVdO1xuICAgIG9sZCA9IG9sZE9uW25hbWVdO1xuICAgIGV2ZW50ID0gbm9ybWFsaXplRXZlbnQobmFtZSk7XG4gICAgaWYgKGlzVW5kZWYoY3VyKSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkludmFsaWQgaGFuZGxlciBmb3IgZXZlbnQgXFxcIlwiICsgKGV2ZW50Lm5hbWUpICsgXCJcXFwiOiBnb3QgXCIgKyBTdHJpbmcoY3VyKSxcbiAgICAgICAgdm1cbiAgICAgICk7XG4gICAgfSBlbHNlIGlmIChpc1VuZGVmKG9sZCkpIHtcbiAgICAgIGlmIChpc1VuZGVmKGN1ci5mbnMpKSB7XG4gICAgICAgIGN1ciA9IG9uW25hbWVdID0gY3JlYXRlRm5JbnZva2VyKGN1cik7XG4gICAgICB9XG4gICAgICBhZGQoZXZlbnQubmFtZSwgY3VyLCBldmVudC5vbmNlLCBldmVudC5jYXB0dXJlLCBldmVudC5wYXNzaXZlKTtcbiAgICB9IGVsc2UgaWYgKGN1ciAhPT0gb2xkKSB7XG4gICAgICBvbGQuZm5zID0gY3VyO1xuICAgICAgb25bbmFtZV0gPSBvbGQ7XG4gICAgfVxuICB9XG4gIGZvciAobmFtZSBpbiBvbGRPbikge1xuICAgIGlmIChpc1VuZGVmKG9uW25hbWVdKSkge1xuICAgICAgZXZlbnQgPSBub3JtYWxpemVFdmVudChuYW1lKTtcbiAgICAgIHJlbW92ZSQkMShldmVudC5uYW1lLCBvbGRPbltuYW1lXSwgZXZlbnQuY2FwdHVyZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBtZXJnZVZOb2RlSG9vayAoZGVmLCBob29rS2V5LCBob29rKSB7XG4gIGlmIChkZWYgaW5zdGFuY2VvZiBWTm9kZSkge1xuICAgIGRlZiA9IGRlZi5kYXRhLmhvb2sgfHwgKGRlZi5kYXRhLmhvb2sgPSB7fSk7XG4gIH1cbiAgdmFyIGludm9rZXI7XG4gIHZhciBvbGRIb29rID0gZGVmW2hvb2tLZXldO1xuXG4gIGZ1bmN0aW9uIHdyYXBwZWRIb29rICgpIHtcbiAgICBob29rLmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG4gICAgLy8gaW1wb3J0YW50OiByZW1vdmUgbWVyZ2VkIGhvb2sgdG8gZW5zdXJlIGl0J3MgY2FsbGVkIG9ubHkgb25jZVxuICAgIC8vIGFuZCBwcmV2ZW50IG1lbW9yeSBsZWFrXG4gICAgcmVtb3ZlKGludm9rZXIuZm5zLCB3cmFwcGVkSG9vayk7XG4gIH1cblxuICBpZiAoaXNVbmRlZihvbGRIb29rKSkge1xuICAgIC8vIG5vIGV4aXN0aW5nIGhvb2tcbiAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFt3cmFwcGVkSG9va10pO1xuICB9IGVsc2Uge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmIChpc0RlZihvbGRIb29rLmZucykgJiYgaXNUcnVlKG9sZEhvb2subWVyZ2VkKSkge1xuICAgICAgLy8gYWxyZWFkeSBhIG1lcmdlZCBpbnZva2VyXG4gICAgICBpbnZva2VyID0gb2xkSG9vaztcbiAgICAgIGludm9rZXIuZm5zLnB1c2god3JhcHBlZEhvb2spO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyBleGlzdGluZyBwbGFpbiBob29rXG4gICAgICBpbnZva2VyID0gY3JlYXRlRm5JbnZva2VyKFtvbGRIb29rLCB3cmFwcGVkSG9va10pO1xuICAgIH1cbiAgfVxuXG4gIGludm9rZXIubWVyZ2VkID0gdHJ1ZTtcbiAgZGVmW2hvb2tLZXldID0gaW52b2tlcjtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGV4dHJhY3RQcm9wc0Zyb21WTm9kZURhdGEgKFxuICBkYXRhLFxuICBDdG9yLFxuICB0YWdcbikge1xuICAvLyB3ZSBhcmUgb25seSBleHRyYWN0aW5nIHJhdyB2YWx1ZXMgaGVyZS5cbiAgLy8gdmFsaWRhdGlvbiBhbmQgZGVmYXVsdCB2YWx1ZXMgYXJlIGhhbmRsZWQgaW4gdGhlIGNoaWxkXG4gIC8vIGNvbXBvbmVudCBpdHNlbGYuXG4gIHZhciBwcm9wT3B0aW9ucyA9IEN0b3Iub3B0aW9ucy5wcm9wcztcbiAgaWYgKGlzVW5kZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHJlcyA9IHt9O1xuICB2YXIgYXR0cnMgPSBkYXRhLmF0dHJzO1xuICB2YXIgcHJvcHMgPSBkYXRhLnByb3BzO1xuICBpZiAoaXNEZWYoYXR0cnMpIHx8IGlzRGVmKHByb3BzKSkge1xuICAgIGZvciAodmFyIGtleSBpbiBwcm9wT3B0aW9ucykge1xuICAgICAgdmFyIGFsdEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgdmFyIGtleUluTG93ZXJDYXNlID0ga2V5LnRvTG93ZXJDYXNlKCk7XG4gICAgICAgIGlmIChcbiAgICAgICAgICBrZXkgIT09IGtleUluTG93ZXJDYXNlICYmXG4gICAgICAgICAgYXR0cnMgJiYgaGFzT3duKGF0dHJzLCBrZXlJbkxvd2VyQ2FzZSlcbiAgICAgICAgKSB7XG4gICAgICAgICAgdGlwKFxuICAgICAgICAgICAgXCJQcm9wIFxcXCJcIiArIGtleUluTG93ZXJDYXNlICsgXCJcXFwiIGlzIHBhc3NlZCB0byBjb21wb25lbnQgXCIgK1xuICAgICAgICAgICAgKGZvcm1hdENvbXBvbmVudE5hbWUodGFnIHx8IEN0b3IpKSArIFwiLCBidXQgdGhlIGRlY2xhcmVkIHByb3AgbmFtZSBpc1wiICtcbiAgICAgICAgICAgIFwiIFxcXCJcIiArIGtleSArIFwiXFxcIi4gXCIgK1xuICAgICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCBjYW1lbENhc2VkIFwiICtcbiAgICAgICAgICAgIFwicHJvcHMgbmVlZCB0byB1c2UgdGhlaXIga2ViYWItY2FzZSBlcXVpdmFsZW50cyB3aGVuIHVzaW5nIGluLURPTSBcIiArXG4gICAgICAgICAgICBcInRlbXBsYXRlcy4gWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgYWx0S2V5ICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsga2V5ICsgXCJcXFwiLlwiXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgY2hlY2tQcm9wKHJlcywgcHJvcHMsIGtleSwgYWx0S2V5LCB0cnVlKSB8fFxuICAgICAgY2hlY2tQcm9wKHJlcywgYXR0cnMsIGtleSwgYWx0S2V5LCBmYWxzZSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gY2hlY2tQcm9wIChcbiAgcmVzLFxuICBoYXNoLFxuICBrZXksXG4gIGFsdEtleSxcbiAgcHJlc2VydmVcbikge1xuICBpZiAoaXNEZWYoaGFzaCkpIHtcbiAgICBpZiAoaGFzT3duKGhhc2gsIGtleSkpIHtcbiAgICAgIHJlc1trZXldID0gaGFzaFtrZXldO1xuICAgICAgaWYgKCFwcmVzZXJ2ZSkge1xuICAgICAgICBkZWxldGUgaGFzaFtrZXldO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHRydWVcbiAgICB9IGVsc2UgaWYgKGhhc093bihoYXNoLCBhbHRLZXkpKSB7XG4gICAgICByZXNba2V5XSA9IGhhc2hbYWx0S2V5XTtcbiAgICAgIGlmICghcHJlc2VydmUpIHtcbiAgICAgICAgZGVsZXRlIGhhc2hbYWx0S2V5XTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZVxufVxuXG4vKiAgKi9cblxuLy8gVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGF0dGVtcHRzIHRvIG1pbmltaXplIHRoZSBuZWVkIGZvciBub3JtYWxpemF0aW9uIGJ5XG4vLyBzdGF0aWNhbGx5IGFuYWx5emluZyB0aGUgdGVtcGxhdGUgYXQgY29tcGlsZSB0aW1lLlxuLy9cbi8vIEZvciBwbGFpbiBIVE1MIG1hcmt1cCwgbm9ybWFsaXphdGlvbiBjYW4gYmUgY29tcGxldGVseSBza2lwcGVkIGJlY2F1c2UgdGhlXG4vLyBnZW5lcmF0ZWQgcmVuZGVyIGZ1bmN0aW9uIGlzIGd1YXJhbnRlZWQgdG8gcmV0dXJuIEFycmF5PFZOb2RlPi4gVGhlcmUgYXJlXG4vLyB0d28gY2FzZXMgd2hlcmUgZXh0cmEgbm9ybWFsaXphdGlvbiBpcyBuZWVkZWQ6XG5cbi8vIDEuIFdoZW4gdGhlIGNoaWxkcmVuIGNvbnRhaW5zIGNvbXBvbmVudHMgLSBiZWNhdXNlIGEgZnVuY3Rpb25hbCBjb21wb25lbnRcbi8vIG1heSByZXR1cm4gYW4gQXJyYXkgaW5zdGVhZCBvZiBhIHNpbmdsZSByb290LiBJbiB0aGlzIGNhc2UsIGp1c3QgYSBzaW1wbGVcbi8vIG5vcm1hbGl6YXRpb24gaXMgbmVlZGVkIC0gaWYgYW55IGNoaWxkIGlzIGFuIEFycmF5LCB3ZSBmbGF0dGVuIHRoZSB3aG9sZVxuLy8gdGhpbmcgd2l0aCBBcnJheS5wcm90b3R5cGUuY29uY2F0LiBJdCBpcyBndWFyYW50ZWVkIHRvIGJlIG9ubHkgMS1sZXZlbCBkZWVwXG4vLyBiZWNhdXNlIGZ1bmN0aW9uYWwgY29tcG9uZW50cyBhbHJlYWR5IG5vcm1hbGl6ZSB0aGVpciBvd24gY2hpbGRyZW4uXG5mdW5jdGlvbiBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7IGkrKykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuW2ldKSkge1xuICAgICAgcmV0dXJuIEFycmF5LnByb3RvdHlwZS5jb25jYXQuYXBwbHkoW10sIGNoaWxkcmVuKVxuICAgIH1cbiAgfVxuICByZXR1cm4gY2hpbGRyZW5cbn1cblxuLy8gMi4gV2hlbiB0aGUgY2hpbGRyZW4gY29udGFpbnMgY29uc3RydWN0cyB0aGF0IGFsd2F5cyBnZW5lcmF0ZWQgbmVzdGVkIEFycmF5cyxcbi8vIGUuZy4gPHRlbXBsYXRlPiwgPHNsb3Q+LCB2LWZvciwgb3Igd2hlbiB0aGUgY2hpbGRyZW4gaXMgcHJvdmlkZWQgYnkgdXNlclxuLy8gd2l0aCBoYW5kLXdyaXR0ZW4gcmVuZGVyIGZ1bmN0aW9ucyAvIEpTWC4gSW4gc3VjaCBjYXNlcyBhIGZ1bGwgbm9ybWFsaXphdGlvblxuLy8gaXMgbmVlZGVkIHRvIGNhdGVyIHRvIGFsbCBwb3NzaWJsZSB0eXBlcyBvZiBjaGlsZHJlbiB2YWx1ZXMuXG5mdW5jdGlvbiBub3JtYWxpemVDaGlsZHJlbiAoY2hpbGRyZW4pIHtcbiAgcmV0dXJuIGlzUHJpbWl0aXZlKGNoaWxkcmVuKVxuICAgID8gW2NyZWF0ZVRleHRWTm9kZShjaGlsZHJlbildXG4gICAgOiBBcnJheS5pc0FycmF5KGNoaWxkcmVuKVxuICAgICAgPyBub3JtYWxpemVBcnJheUNoaWxkcmVuKGNoaWxkcmVuKVxuICAgICAgOiB1bmRlZmluZWRcbn1cblxuZnVuY3Rpb24gaXNUZXh0Tm9kZSAobm9kZSkge1xuICByZXR1cm4gaXNEZWYobm9kZSkgJiYgaXNEZWYobm9kZS50ZXh0KSAmJiBpc0ZhbHNlKG5vZGUuaXNDb21tZW50KVxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVBcnJheUNoaWxkcmVuIChjaGlsZHJlbiwgbmVzdGVkSW5kZXgpIHtcbiAgdmFyIHJlcyA9IFtdO1xuICB2YXIgaSwgYywgbGFzdEluZGV4LCBsYXN0O1xuICBmb3IgKGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICBjID0gY2hpbGRyZW5baV07XG4gICAgaWYgKGlzVW5kZWYoYykgfHwgdHlwZW9mIGMgPT09ICdib29sZWFuJykgeyBjb250aW51ZSB9XG4gICAgbGFzdEluZGV4ID0gcmVzLmxlbmd0aCAtIDE7XG4gICAgbGFzdCA9IHJlc1tsYXN0SW5kZXhdO1xuICAgIC8vICBuZXN0ZWRcbiAgICBpZiAoQXJyYXkuaXNBcnJheShjKSkge1xuICAgICAgaWYgKGMubGVuZ3RoID4gMCkge1xuICAgICAgICBjID0gbm9ybWFsaXplQXJyYXlDaGlsZHJlbihjLCAoKG5lc3RlZEluZGV4IHx8ICcnKSArIFwiX1wiICsgaSkpO1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIGlmIChpc1RleHROb2RlKGNbMF0pICYmIGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyAoY1swXSkudGV4dCk7XG4gICAgICAgICAgYy5zaGlmdCgpO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoLmFwcGx5KHJlcywgYyk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1ByaW1pdGl2ZShjKSkge1xuICAgICAgaWYgKGlzVGV4dE5vZGUobGFzdCkpIHtcbiAgICAgICAgLy8gbWVyZ2UgYWRqYWNlbnQgdGV4dCBub2Rlc1xuICAgICAgICAvLyB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgU1NSIGh5ZHJhdGlvbiBiZWNhdXNlIHRleHQgbm9kZXMgYXJlXG4gICAgICAgIC8vIGVzc2VudGlhbGx5IG1lcmdlZCB3aGVuIHJlbmRlcmVkIHRvIEhUTUwgc3RyaW5nc1xuICAgICAgICByZXNbbGFzdEluZGV4XSA9IGNyZWF0ZVRleHRWTm9kZShsYXN0LnRleHQgKyBjKTtcbiAgICAgIH0gZWxzZSBpZiAoYyAhPT0gJycpIHtcbiAgICAgICAgLy8gY29udmVydCBwcmltaXRpdmUgdG8gdm5vZGVcbiAgICAgICAgcmVzLnB1c2goY3JlYXRlVGV4dFZOb2RlKGMpKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGlzVGV4dE5vZGUoYykgJiYgaXNUZXh0Tm9kZShsYXN0KSkge1xuICAgICAgICAvLyBtZXJnZSBhZGphY2VudCB0ZXh0IG5vZGVzXG4gICAgICAgIHJlc1tsYXN0SW5kZXhdID0gY3JlYXRlVGV4dFZOb2RlKGxhc3QudGV4dCArIGMudGV4dCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICAvLyBkZWZhdWx0IGtleSBmb3IgbmVzdGVkIGFycmF5IGNoaWxkcmVuIChsaWtlbHkgZ2VuZXJhdGVkIGJ5IHYtZm9yKVxuICAgICAgICBpZiAoaXNUcnVlKGNoaWxkcmVuLl9pc1ZMaXN0KSAmJlxuICAgICAgICAgIGlzRGVmKGMudGFnKSAmJlxuICAgICAgICAgIGlzVW5kZWYoYy5rZXkpICYmXG4gICAgICAgICAgaXNEZWYobmVzdGVkSW5kZXgpKSB7XG4gICAgICAgICAgYy5rZXkgPSBcIl9fdmxpc3RcIiArIG5lc3RlZEluZGV4ICsgXCJfXCIgKyBpICsgXCJfX1wiO1xuICAgICAgICB9XG4gICAgICAgIHJlcy5wdXNoKGMpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBlbnN1cmVDdG9yIChjb21wLCBiYXNlKSB7XG4gIGlmIChcbiAgICBjb21wLl9fZXNNb2R1bGUgfHxcbiAgICAoaGFzU3ltYm9sICYmIGNvbXBbU3ltYm9sLnRvU3RyaW5nVGFnXSA9PT0gJ01vZHVsZScpXG4gICkge1xuICAgIGNvbXAgPSBjb21wLmRlZmF1bHQ7XG4gIH1cbiAgcmV0dXJuIGlzT2JqZWN0KGNvbXApXG4gICAgPyBiYXNlLmV4dGVuZChjb21wKVxuICAgIDogY29tcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVBc3luY1BsYWNlaG9sZGVyIChcbiAgZmFjdG9yeSxcbiAgZGF0YSxcbiAgY29udGV4dCxcbiAgY2hpbGRyZW4sXG4gIHRhZ1xuKSB7XG4gIHZhciBub2RlID0gY3JlYXRlRW1wdHlWTm9kZSgpO1xuICBub2RlLmFzeW5jRmFjdG9yeSA9IGZhY3Rvcnk7XG4gIG5vZGUuYXN5bmNNZXRhID0geyBkYXRhOiBkYXRhLCBjb250ZXh0OiBjb250ZXh0LCBjaGlsZHJlbjogY2hpbGRyZW4sIHRhZzogdGFnIH07XG4gIHJldHVybiBub2RlXG59XG5cbmZ1bmN0aW9uIHJlc29sdmVBc3luY0NvbXBvbmVudCAoXG4gIGZhY3RvcnksXG4gIGJhc2VDdG9yLFxuICBjb250ZXh0XG4pIHtcbiAgaWYgKGlzVHJ1ZShmYWN0b3J5LmVycm9yKSAmJiBpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5lcnJvckNvbXBcbiAgfVxuXG4gIGlmIChpc0RlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgIHJldHVybiBmYWN0b3J5LnJlc29sdmVkXG4gIH1cblxuICBpZiAoaXNUcnVlKGZhY3RvcnkubG9hZGluZykgJiYgaXNEZWYoZmFjdG9yeS5sb2FkaW5nQ29tcCkpIHtcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nQ29tcFxuICB9XG5cbiAgaWYgKGlzRGVmKGZhY3RvcnkuY29udGV4dHMpKSB7XG4gICAgLy8gYWxyZWFkeSBwZW5kaW5nXG4gICAgZmFjdG9yeS5jb250ZXh0cy5wdXNoKGNvbnRleHQpO1xuICB9IGVsc2Uge1xuICAgIHZhciBjb250ZXh0cyA9IGZhY3RvcnkuY29udGV4dHMgPSBbY29udGV4dF07XG4gICAgdmFyIHN5bmMgPSB0cnVlO1xuXG4gICAgdmFyIGZvcmNlUmVuZGVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBjb250ZXh0cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgY29udGV4dHNbaV0uJGZvcmNlVXBkYXRlKCk7XG4gICAgICB9XG4gICAgfTtcblxuICAgIHZhciByZXNvbHZlID0gb25jZShmdW5jdGlvbiAocmVzKSB7XG4gICAgICAvLyBjYWNoZSByZXNvbHZlZFxuICAgICAgZmFjdG9yeS5yZXNvbHZlZCA9IGVuc3VyZUN0b3IocmVzLCBiYXNlQ3Rvcik7XG4gICAgICAvLyBpbnZva2UgY2FsbGJhY2tzIG9ubHkgaWYgdGhpcyBpcyBub3QgYSBzeW5jaHJvbm91cyByZXNvbHZlXG4gICAgICAvLyAoYXN5bmMgcmVzb2x2ZXMgYXJlIHNoaW1tZWQgYXMgc3luY2hyb25vdXMgZHVyaW5nIFNTUilcbiAgICAgIGlmICghc3luYykge1xuICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgfVxuICAgIH0pO1xuXG4gICAgdmFyIHJlamVjdCA9IG9uY2UoZnVuY3Rpb24gKHJlYXNvbikge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgICBcIkZhaWxlZCB0byByZXNvbHZlIGFzeW5jIGNvbXBvbmVudDogXCIgKyAoU3RyaW5nKGZhY3RvcnkpKSArXG4gICAgICAgIChyZWFzb24gPyAoXCJcXG5SZWFzb246IFwiICsgcmVhc29uKSA6ICcnKVxuICAgICAgKTtcbiAgICAgIGlmIChpc0RlZihmYWN0b3J5LmVycm9yQ29tcCkpIHtcbiAgICAgICAgZmFjdG9yeS5lcnJvciA9IHRydWU7XG4gICAgICAgIGZvcmNlUmVuZGVyKCk7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICB2YXIgcmVzID0gZmFjdG9yeShyZXNvbHZlLCByZWplY3QpO1xuXG4gICAgaWYgKGlzT2JqZWN0KHJlcykpIHtcbiAgICAgIGlmICh0eXBlb2YgcmVzLnRoZW4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gKCkgPT4gUHJvbWlzZVxuICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgIHJlcy50aGVuKHJlc29sdmUsIHJlamVjdCk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYocmVzLmNvbXBvbmVudCkgJiYgdHlwZW9mIHJlcy5jb21wb25lbnQudGhlbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICByZXMuY29tcG9uZW50LnRoZW4ocmVzb2x2ZSwgcmVqZWN0KTtcblxuICAgICAgICBpZiAoaXNEZWYocmVzLmVycm9yKSkge1xuICAgICAgICAgIGZhY3RvcnkuZXJyb3JDb21wID0gZW5zdXJlQ3RvcihyZXMuZXJyb3IsIGJhc2VDdG9yKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChpc0RlZihyZXMubG9hZGluZykpIHtcbiAgICAgICAgICBmYWN0b3J5LmxvYWRpbmdDb21wID0gZW5zdXJlQ3RvcihyZXMubG9hZGluZywgYmFzZUN0b3IpO1xuICAgICAgICAgIGlmIChyZXMuZGVsYXkgPT09IDApIHtcbiAgICAgICAgICAgIGZhY3RvcnkubG9hZGluZyA9IHRydWU7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSAmJiBpc1VuZGVmKGZhY3RvcnkuZXJyb3IpKSB7XG4gICAgICAgICAgICAgICAgZmFjdG9yeS5sb2FkaW5nID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBmb3JjZVJlbmRlcigpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9LCByZXMuZGVsYXkgfHwgMjAwKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoaXNEZWYocmVzLnRpbWVvdXQpKSB7XG4gICAgICAgICAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZihmYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICAgICAgICByZWplY3QoXG4gICAgICAgICAgICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJ1xuICAgICAgICAgICAgICAgICAgPyAoXCJ0aW1lb3V0IChcIiArIChyZXMudGltZW91dCkgKyBcIm1zKVwiKVxuICAgICAgICAgICAgICAgICAgOiBudWxsXG4gICAgICAgICAgICAgICk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSwgcmVzLnRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgc3luYyA9IGZhbHNlO1xuICAgIC8vIHJldHVybiBpbiBjYXNlIHJlc29sdmVkIHN5bmNocm9ub3VzbHlcbiAgICByZXR1cm4gZmFjdG9yeS5sb2FkaW5nXG4gICAgICA/IGZhY3RvcnkubG9hZGluZ0NvbXBcbiAgICAgIDogZmFjdG9yeS5yZXNvbHZlZFxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpc0FzeW5jUGxhY2Vob2xkZXIgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUuaXNDb21tZW50ICYmIG5vZGUuYXN5bmNGYWN0b3J5XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBnZXRGaXJzdENvbXBvbmVudENoaWxkIChjaGlsZHJlbikge1xuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IGNoaWxkcmVuW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIChpc0RlZihjLmNvbXBvbmVudE9wdGlvbnMpIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKSkpIHtcbiAgICAgICAgcmV0dXJuIGNcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0RXZlbnRzICh2bSkge1xuICB2bS5fZXZlbnRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgdm0uX2hhc0hvb2tFdmVudCA9IGZhbHNlO1xuICAvLyBpbml0IHBhcmVudCBhdHRhY2hlZCBldmVudHNcbiAgdmFyIGxpc3RlbmVycyA9IHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnM7XG4gIGlmIChsaXN0ZW5lcnMpIHtcbiAgICB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnModm0sIGxpc3RlbmVycyk7XG4gIH1cbn1cblxudmFyIHRhcmdldDtcblxuZnVuY3Rpb24gYWRkIChldmVudCwgZm4sIG9uY2UpIHtcbiAgaWYgKG9uY2UpIHtcbiAgICB0YXJnZXQuJG9uY2UoZXZlbnQsIGZuKTtcbiAgfSBlbHNlIHtcbiAgICB0YXJnZXQuJG9uKGV2ZW50LCBmbik7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDEgKGV2ZW50LCBmbikge1xuICB0YXJnZXQuJG9mZihldmVudCwgZm4pO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVDb21wb25lbnRMaXN0ZW5lcnMgKFxuICB2bSxcbiAgbGlzdGVuZXJzLFxuICBvbGRMaXN0ZW5lcnNcbikge1xuICB0YXJnZXQgPSB2bTtcbiAgdXBkYXRlTGlzdGVuZXJzKGxpc3RlbmVycywgb2xkTGlzdGVuZXJzIHx8IHt9LCBhZGQsIHJlbW92ZSQxLCB2bSk7XG4gIHRhcmdldCA9IHVuZGVmaW5lZDtcbn1cblxuZnVuY3Rpb24gZXZlbnRzTWl4aW4gKFZ1ZSkge1xuICB2YXIgaG9va1JFID0gL15ob29rOi87XG4gIFZ1ZS5wcm90b3R5cGUuJG9uID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gZXZlbnQubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHRoaXMkMS4kb24oZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgKHZtLl9ldmVudHNbZXZlbnRdIHx8ICh2bS5fZXZlbnRzW2V2ZW50XSA9IFtdKSkucHVzaChmbik7XG4gICAgICAvLyBvcHRpbWl6ZSBob29rOmV2ZW50IGNvc3QgYnkgdXNpbmcgYSBib29sZWFuIGZsYWcgbWFya2VkIGF0IHJlZ2lzdHJhdGlvblxuICAgICAgLy8gaW5zdGVhZCBvZiBhIGhhc2ggbG9va3VwXG4gICAgICBpZiAoaG9va1JFLnRlc3QoZXZlbnQpKSB7XG4gICAgICAgIHZtLl9oYXNIb29rRXZlbnQgPSB0cnVlO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRvbmNlID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgZnVuY3Rpb24gb24gKCkge1xuICAgICAgdm0uJG9mZihldmVudCwgb24pO1xuICAgICAgZm4uYXBwbHkodm0sIGFyZ3VtZW50cyk7XG4gICAgfVxuICAgIG9uLmZuID0gZm47XG4gICAgdm0uJG9uKGV2ZW50LCBvbik7XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kb2ZmID0gZnVuY3Rpb24gKGV2ZW50LCBmbikge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gICAgdmFyIHZtID0gdGhpcztcbiAgICAvLyBhbGxcbiAgICBpZiAoIWFyZ3VtZW50cy5sZW5ndGgpIHtcbiAgICAgIHZtLl9ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIC8vIGFycmF5IG9mIGV2ZW50c1xuICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgZm9yICh2YXIgaSA9IDAsIGwgPSBldmVudC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdGhpcyQxLiRvZmYoZXZlbnRbaV0sIGZuKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICAvLyBzcGVjaWZpYyBldmVudFxuICAgIHZhciBjYnMgPSB2bS5fZXZlbnRzW2V2ZW50XTtcbiAgICBpZiAoIWNicykge1xuICAgICAgcmV0dXJuIHZtXG4gICAgfVxuICAgIGlmICghZm4pIHtcbiAgICAgIHZtLl9ldmVudHNbZXZlbnRdID0gbnVsbDtcbiAgICAgIHJldHVybiB2bVxuICAgIH1cbiAgICBpZiAoZm4pIHtcbiAgICAgIC8vIHNwZWNpZmljIGhhbmRsZXJcbiAgICAgIHZhciBjYjtcbiAgICAgIHZhciBpJDEgPSBjYnMubGVuZ3RoO1xuICAgICAgd2hpbGUgKGkkMS0tKSB7XG4gICAgICAgIGNiID0gY2JzW2kkMV07XG4gICAgICAgIGlmIChjYiA9PT0gZm4gfHwgY2IuZm4gPT09IGZuKSB7XG4gICAgICAgICAgY2JzLnNwbGljZShpJDEsIDEpO1xuICAgICAgICAgIGJyZWFrXG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHZtXG4gIH07XG5cbiAgVnVlLnByb3RvdHlwZS4kZW1pdCA9IGZ1bmN0aW9uIChldmVudCkge1xuICAgIHZhciB2bSA9IHRoaXM7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHZhciBsb3dlckNhc2VFdmVudCA9IGV2ZW50LnRvTG93ZXJDYXNlKCk7XG4gICAgICBpZiAobG93ZXJDYXNlRXZlbnQgIT09IGV2ZW50ICYmIHZtLl9ldmVudHNbbG93ZXJDYXNlRXZlbnRdKSB7XG4gICAgICAgIHRpcChcbiAgICAgICAgICBcIkV2ZW50IFxcXCJcIiArIGxvd2VyQ2FzZUV2ZW50ICsgXCJcXFwiIGlzIGVtaXR0ZWQgaW4gY29tcG9uZW50IFwiICtcbiAgICAgICAgICAoZm9ybWF0Q29tcG9uZW50TmFtZSh2bSkpICsgXCIgYnV0IHRoZSBoYW5kbGVyIGlzIHJlZ2lzdGVyZWQgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiLiBcIiArXG4gICAgICAgICAgXCJOb3RlIHRoYXQgSFRNTCBhdHRyaWJ1dGVzIGFyZSBjYXNlLWluc2Vuc2l0aXZlIGFuZCB5b3UgY2Fubm90IHVzZSBcIiArXG4gICAgICAgICAgXCJ2LW9uIHRvIGxpc3RlbiB0byBjYW1lbENhc2UgZXZlbnRzIHdoZW4gdXNpbmcgaW4tRE9NIHRlbXBsYXRlcy4gXCIgK1xuICAgICAgICAgIFwiWW91IHNob3VsZCBwcm9iYWJseSB1c2UgXFxcIlwiICsgKGh5cGhlbmF0ZShldmVudCkpICsgXCJcXFwiIGluc3RlYWQgb2YgXFxcIlwiICsgZXZlbnQgKyBcIlxcXCIuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdmFyIGNicyA9IHZtLl9ldmVudHNbZXZlbnRdO1xuICAgIGlmIChjYnMpIHtcbiAgICAgIGNicyA9IGNicy5sZW5ndGggPiAxID8gdG9BcnJheShjYnMpIDogY2JzO1xuICAgICAgdmFyIGFyZ3MgPSB0b0FycmF5KGFyZ3VtZW50cywgMSk7XG4gICAgICBmb3IgKHZhciBpID0gMCwgbCA9IGNicy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjYnNbaV0uYXBwbHkodm0sIGFyZ3MpO1xuICAgICAgICB9IGNhdGNoIChlKSB7XG4gICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIChcImV2ZW50IGhhbmRsZXIgZm9yIFxcXCJcIiArIGV2ZW50ICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdm1cbiAgfTtcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlc29sdmluZyByYXcgY2hpbGRyZW4gVk5vZGVzIGludG8gYSBzbG90IG9iamVjdC5cbiAqL1xuZnVuY3Rpb24gcmVzb2x2ZVNsb3RzIChcbiAgY2hpbGRyZW4sXG4gIGNvbnRleHRcbikge1xuICB2YXIgc2xvdHMgPSB7fTtcbiAgaWYgKCFjaGlsZHJlbikge1xuICAgIHJldHVybiBzbG90c1xuICB9XG4gIGZvciAodmFyIGkgPSAwLCBsID0gY2hpbGRyZW4ubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgdmFyIGNoaWxkID0gY2hpbGRyZW5baV07XG4gICAgdmFyIGRhdGEgPSBjaGlsZC5kYXRhO1xuICAgIC8vIHJlbW92ZSBzbG90IGF0dHJpYnV0ZSBpZiB0aGUgbm9kZSBpcyByZXNvbHZlZCBhcyBhIFZ1ZSBzbG90IG5vZGVcbiAgICBpZiAoZGF0YSAmJiBkYXRhLmF0dHJzICYmIGRhdGEuYXR0cnMuc2xvdCkge1xuICAgICAgZGVsZXRlIGRhdGEuYXR0cnMuc2xvdDtcbiAgICB9XG4gICAgLy8gbmFtZWQgc2xvdHMgc2hvdWxkIG9ubHkgYmUgcmVzcGVjdGVkIGlmIHRoZSB2bm9kZSB3YXMgcmVuZGVyZWQgaW4gdGhlXG4gICAgLy8gc2FtZSBjb250ZXh0LlxuICAgIGlmICgoY2hpbGQuY29udGV4dCA9PT0gY29udGV4dCB8fCBjaGlsZC5mbkNvbnRleHQgPT09IGNvbnRleHQpICYmXG4gICAgICBkYXRhICYmIGRhdGEuc2xvdCAhPSBudWxsXG4gICAgKSB7XG4gICAgICB2YXIgbmFtZSA9IGNoaWxkLmRhdGEuc2xvdDtcbiAgICAgIHZhciBzbG90ID0gKHNsb3RzW25hbWVdIHx8IChzbG90c1tuYW1lXSA9IFtdKSk7XG4gICAgICBpZiAoY2hpbGQudGFnID09PSAndGVtcGxhdGUnKSB7XG4gICAgICAgIHNsb3QucHVzaC5hcHBseShzbG90LCBjaGlsZC5jaGlsZHJlbik7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBzbG90LnB1c2goY2hpbGQpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAoc2xvdHMuZGVmYXVsdCB8fCAoc2xvdHMuZGVmYXVsdCA9IFtdKSkucHVzaChjaGlsZCk7XG4gICAgfVxuICB9XG4gIC8vIGlnbm9yZSBzbG90cyB0aGF0IGNvbnRhaW5zIG9ubHkgd2hpdGVzcGFjZVxuICBmb3IgKHZhciBuYW1lJDEgaW4gc2xvdHMpIHtcbiAgICBpZiAoc2xvdHNbbmFtZSQxXS5ldmVyeShpc1doaXRlc3BhY2UpKSB7XG4gICAgICBkZWxldGUgc2xvdHNbbmFtZSQxXTtcbiAgICB9XG4gIH1cbiAgcmV0dXJuIHNsb3RzXG59XG5cbmZ1bmN0aW9uIGlzV2hpdGVzcGFjZSAobm9kZSkge1xuICByZXR1cm4gKG5vZGUuaXNDb21tZW50ICYmICFub2RlLmFzeW5jRmFjdG9yeSkgfHwgbm9kZS50ZXh0ID09PSAnICdcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZVNjb3BlZFNsb3RzIChcbiAgZm5zLCAvLyBzZWUgZmxvdy92bm9kZVxuICByZXNcbikge1xuICByZXMgPSByZXMgfHwge307XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgZm5zLmxlbmd0aDsgaSsrKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkoZm5zW2ldKSkge1xuICAgICAgcmVzb2x2ZVNjb3BlZFNsb3RzKGZuc1tpXSwgcmVzKTtcbiAgICB9IGVsc2Uge1xuICAgICAgcmVzW2Zuc1tpXS5rZXldID0gZm5zW2ldLmZuO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbi8qICAqL1xuXG52YXIgYWN0aXZlSW5zdGFuY2UgPSBudWxsO1xudmFyIGlzVXBkYXRpbmdDaGlsZENvbXBvbmVudCA9IGZhbHNlO1xuXG5mdW5jdGlvbiBpbml0TGlmZWN5Y2xlICh2bSkge1xuICB2YXIgb3B0aW9ucyA9IHZtLiRvcHRpb25zO1xuXG4gIC8vIGxvY2F0ZSBmaXJzdCBub24tYWJzdHJhY3QgcGFyZW50XG4gIHZhciBwYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgaWYgKHBhcmVudCAmJiAhb3B0aW9ucy5hYnN0cmFjdCkge1xuICAgIHdoaWxlIChwYXJlbnQuJG9wdGlvbnMuYWJzdHJhY3QgJiYgcGFyZW50LiRwYXJlbnQpIHtcbiAgICAgIHBhcmVudCA9IHBhcmVudC4kcGFyZW50O1xuICAgIH1cbiAgICBwYXJlbnQuJGNoaWxkcmVuLnB1c2godm0pO1xuICB9XG5cbiAgdm0uJHBhcmVudCA9IHBhcmVudDtcbiAgdm0uJHJvb3QgPSBwYXJlbnQgPyBwYXJlbnQuJHJvb3QgOiB2bTtcblxuICB2bS4kY2hpbGRyZW4gPSBbXTtcbiAgdm0uJHJlZnMgPSB7fTtcblxuICB2bS5fd2F0Y2hlciA9IG51bGw7XG4gIHZtLl9pbmFjdGl2ZSA9IG51bGw7XG4gIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICB2bS5faXNNb3VudGVkID0gZmFsc2U7XG4gIHZtLl9pc0Rlc3Ryb3llZCA9IGZhbHNlO1xuICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IGZhbHNlO1xufVxuXG5mdW5jdGlvbiBsaWZlY3ljbGVNaXhpbiAoVnVlKSB7XG4gIFZ1ZS5wcm90b3R5cGUuX3VwZGF0ZSA9IGZ1bmN0aW9uICh2bm9kZSwgaHlkcmF0aW5nKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICdiZWZvcmVVcGRhdGUnKTtcbiAgICB9XG4gICAgdmFyIHByZXZFbCA9IHZtLiRlbDtcbiAgICB2YXIgcHJldlZub2RlID0gdm0uX3Zub2RlO1xuICAgIHZhciBwcmV2QWN0aXZlSW5zdGFuY2UgPSBhY3RpdmVJbnN0YW5jZTtcbiAgICBhY3RpdmVJbnN0YW5jZSA9IHZtO1xuICAgIHZtLl92bm9kZSA9IHZub2RlO1xuICAgIC8vIFZ1ZS5wcm90b3R5cGUuX19wYXRjaF9fIGlzIGluamVjdGVkIGluIGVudHJ5IHBvaW50c1xuICAgIC8vIGJhc2VkIG9uIHRoZSByZW5kZXJpbmcgYmFja2VuZCB1c2VkLlxuICAgIGlmICghcHJldlZub2RlKSB7XG4gICAgICAvLyBpbml0aWFsIHJlbmRlclxuICAgICAgdm0uJGVsID0gdm0uX19wYXRjaF9fKFxuICAgICAgICB2bS4kZWwsIHZub2RlLCBoeWRyYXRpbmcsIGZhbHNlIC8qIHJlbW92ZU9ubHkgKi8sXG4gICAgICAgIHZtLiRvcHRpb25zLl9wYXJlbnRFbG0sXG4gICAgICAgIHZtLiRvcHRpb25zLl9yZWZFbG1cbiAgICAgICk7XG4gICAgICAvLyBubyBuZWVkIGZvciB0aGUgcmVmIG5vZGVzIGFmdGVyIGluaXRpYWwgcGF0Y2hcbiAgICAgIC8vIHRoaXMgcHJldmVudHMga2VlcGluZyBhIGRldGFjaGVkIERPTSB0cmVlIGluIG1lbW9yeSAoIzU4NTEpXG4gICAgICB2bS4kb3B0aW9ucy5fcGFyZW50RWxtID0gdm0uJG9wdGlvbnMuX3JlZkVsbSA9IG51bGw7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHVwZGF0ZXNcbiAgICAgIHZtLiRlbCA9IHZtLl9fcGF0Y2hfXyhwcmV2Vm5vZGUsIHZub2RlKTtcbiAgICB9XG4gICAgYWN0aXZlSW5zdGFuY2UgPSBwcmV2QWN0aXZlSW5zdGFuY2U7XG4gICAgLy8gdXBkYXRlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHByZXZFbCkge1xuICAgICAgcHJldkVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICBpZiAodm0uJGVsKSB7XG4gICAgICB2bS4kZWwuX192dWVfXyA9IHZtO1xuICAgIH1cbiAgICAvLyBpZiBwYXJlbnQgaXMgYW4gSE9DLCB1cGRhdGUgaXRzICRlbCBhcyB3ZWxsXG4gICAgaWYgKHZtLiR2bm9kZSAmJiB2bS4kcGFyZW50ICYmIHZtLiR2bm9kZSA9PT0gdm0uJHBhcmVudC5fdm5vZGUpIHtcbiAgICAgIHZtLiRwYXJlbnQuJGVsID0gdm0uJGVsO1xuICAgIH1cbiAgICAvLyB1cGRhdGVkIGhvb2sgaXMgY2FsbGVkIGJ5IHRoZSBzY2hlZHVsZXIgdG8gZW5zdXJlIHRoYXQgY2hpbGRyZW4gYXJlXG4gICAgLy8gdXBkYXRlZCBpbiBhIHBhcmVudCdzIHVwZGF0ZWQgaG9vay5cbiAgfTtcblxuICBWdWUucHJvdG90eXBlLiRmb3JjZVVwZGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudXBkYXRlKCk7XG4gICAgfVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuJGRlc3Ryb3kgPSBmdW5jdGlvbiAoKSB7XG4gICAgdmFyIHZtID0gdGhpcztcbiAgICBpZiAodm0uX2lzQmVpbmdEZXN0cm95ZWQpIHtcbiAgICAgIHJldHVyblxuICAgIH1cbiAgICBjYWxsSG9vayh2bSwgJ2JlZm9yZURlc3Ryb3knKTtcbiAgICB2bS5faXNCZWluZ0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gcmVtb3ZlIHNlbGYgZnJvbSBwYXJlbnRcbiAgICB2YXIgcGFyZW50ID0gdm0uJHBhcmVudDtcbiAgICBpZiAocGFyZW50ICYmICFwYXJlbnQuX2lzQmVpbmdEZXN0cm95ZWQgJiYgIXZtLiRvcHRpb25zLmFic3RyYWN0KSB7XG4gICAgICByZW1vdmUocGFyZW50LiRjaGlsZHJlbiwgdm0pO1xuICAgIH1cbiAgICAvLyB0ZWFyZG93biB3YXRjaGVyc1xuICAgIGlmICh2bS5fd2F0Y2hlcikge1xuICAgICAgdm0uX3dhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gICAgdmFyIGkgPSB2bS5fd2F0Y2hlcnMubGVuZ3RoO1xuICAgIHdoaWxlIChpLS0pIHtcbiAgICAgIHZtLl93YXRjaGVyc1tpXS50ZWFyZG93bigpO1xuICAgIH1cbiAgICAvLyByZW1vdmUgcmVmZXJlbmNlIGZyb20gZGF0YSBvYlxuICAgIC8vIGZyb3plbiBvYmplY3QgbWF5IG5vdCBoYXZlIG9ic2VydmVyLlxuICAgIGlmICh2bS5fZGF0YS5fX29iX18pIHtcbiAgICAgIHZtLl9kYXRhLl9fb2JfXy52bUNvdW50LS07XG4gICAgfVxuICAgIC8vIGNhbGwgdGhlIGxhc3QgaG9vay4uLlxuICAgIHZtLl9pc0Rlc3Ryb3llZCA9IHRydWU7XG4gICAgLy8gaW52b2tlIGRlc3Ryb3kgaG9va3Mgb24gY3VycmVudCByZW5kZXJlZCB0cmVlXG4gICAgdm0uX19wYXRjaF9fKHZtLl92bm9kZSwgbnVsbCk7XG4gICAgLy8gZmlyZSBkZXN0cm95ZWQgaG9va1xuICAgIGNhbGxIb29rKHZtLCAnZGVzdHJveWVkJyk7XG4gICAgLy8gdHVybiBvZmYgYWxsIGluc3RhbmNlIGxpc3RlbmVycy5cbiAgICB2bS4kb2ZmKCk7XG4gICAgLy8gcmVtb3ZlIF9fdnVlX18gcmVmZXJlbmNlXG4gICAgaWYgKHZtLiRlbCkge1xuICAgICAgdm0uJGVsLl9fdnVlX18gPSBudWxsO1xuICAgIH1cbiAgICAvLyByZWxlYXNlIGNpcmN1bGFyIHJlZmVyZW5jZSAoIzY3NTkpXG4gICAgaWYgKHZtLiR2bm9kZSkge1xuICAgICAgdm0uJHZub2RlLnBhcmVudCA9IG51bGw7XG4gICAgfVxuICB9O1xufVxuXG5mdW5jdGlvbiBtb3VudENvbXBvbmVudCAoXG4gIHZtLFxuICBlbCxcbiAgaHlkcmF0aW5nXG4pIHtcbiAgdm0uJGVsID0gZWw7XG4gIGlmICghdm0uJG9wdGlvbnMucmVuZGVyKSB7XG4gICAgdm0uJG9wdGlvbnMucmVuZGVyID0gY3JlYXRlRW1wdHlWTm9kZTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoKHZtLiRvcHRpb25zLnRlbXBsYXRlICYmIHZtLiRvcHRpb25zLnRlbXBsYXRlLmNoYXJBdCgwKSAhPT0gJyMnKSB8fFxuICAgICAgICB2bS4kb3B0aW9ucy5lbCB8fCBlbCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdZb3UgYXJlIHVzaW5nIHRoZSBydW50aW1lLW9ubHkgYnVpbGQgb2YgVnVlIHdoZXJlIHRoZSB0ZW1wbGF0ZSAnICtcbiAgICAgICAgICAnY29tcGlsZXIgaXMgbm90IGF2YWlsYWJsZS4gRWl0aGVyIHByZS1jb21waWxlIHRoZSB0ZW1wbGF0ZXMgaW50byAnICtcbiAgICAgICAgICAncmVuZGVyIGZ1bmN0aW9ucywgb3IgdXNlIHRoZSBjb21waWxlci1pbmNsdWRlZCBidWlsZC4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgICdGYWlsZWQgdG8gbW91bnQgY29tcG9uZW50OiB0ZW1wbGF0ZSBvciByZW5kZXIgZnVuY3Rpb24gbm90IGRlZmluZWQuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICBjYWxsSG9vayh2bSwgJ2JlZm9yZU1vdW50Jyk7XG5cbiAgdmFyIHVwZGF0ZUNvbXBvbmVudDtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIGNvbmZpZy5wZXJmb3JtYW5jZSAmJiBtYXJrKSB7XG4gICAgdXBkYXRlQ29tcG9uZW50ID0gZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIG5hbWUgPSB2bS5fbmFtZTtcbiAgICAgIHZhciBpZCA9IHZtLl91aWQ7XG4gICAgICB2YXIgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgaWQ7XG4gICAgICB2YXIgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyBpZDtcblxuICAgICAgbWFyayhzdGFydFRhZyk7XG4gICAgICB2YXIgdm5vZGUgPSB2bS5fcmVuZGVyKCk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiByZW5kZXJcIiksIHN0YXJ0VGFnLCBlbmRUYWcpO1xuXG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICAgIHZtLl91cGRhdGUodm5vZGUsIGh5ZHJhdGluZyk7XG4gICAgICBtYXJrKGVuZFRhZyk7XG4gICAgICBtZWFzdXJlKChcInZ1ZSBcIiArIG5hbWUgKyBcIiBwYXRjaFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfTtcbiAgfSBlbHNlIHtcbiAgICB1cGRhdGVDb21wb25lbnQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICB2bS5fdXBkYXRlKHZtLl9yZW5kZXIoKSwgaHlkcmF0aW5nKTtcbiAgICB9O1xuICB9XG5cbiAgLy8gd2Ugc2V0IHRoaXMgdG8gdm0uX3dhdGNoZXIgaW5zaWRlIHRoZSB3YXRjaGVyJ3MgY29uc3RydWN0b3JcbiAgLy8gc2luY2UgdGhlIHdhdGNoZXIncyBpbml0aWFsIHBhdGNoIG1heSBjYWxsICRmb3JjZVVwZGF0ZSAoZS5nLiBpbnNpZGUgY2hpbGRcbiAgLy8gY29tcG9uZW50J3MgbW91bnRlZCBob29rKSwgd2hpY2ggcmVsaWVzIG9uIHZtLl93YXRjaGVyIGJlaW5nIGFscmVhZHkgZGVmaW5lZFxuICBuZXcgV2F0Y2hlcih2bSwgdXBkYXRlQ29tcG9uZW50LCBub29wLCBudWxsLCB0cnVlIC8qIGlzUmVuZGVyV2F0Y2hlciAqLyk7XG4gIGh5ZHJhdGluZyA9IGZhbHNlO1xuXG4gIC8vIG1hbnVhbGx5IG1vdW50ZWQgaW5zdGFuY2UsIGNhbGwgbW91bnRlZCBvbiBzZWxmXG4gIC8vIG1vdW50ZWQgaXMgY2FsbGVkIGZvciByZW5kZXItY3JlYXRlZCBjaGlsZCBjb21wb25lbnRzIGluIGl0cyBpbnNlcnRlZCBob29rXG4gIGlmICh2bS4kdm5vZGUgPT0gbnVsbCkge1xuICAgIHZtLl9pc01vdW50ZWQgPSB0cnVlO1xuICAgIGNhbGxIb29rKHZtLCAnbW91bnRlZCcpO1xuICB9XG4gIHJldHVybiB2bVxufVxuXG5mdW5jdGlvbiB1cGRhdGVDaGlsZENvbXBvbmVudCAoXG4gIHZtLFxuICBwcm9wc0RhdGEsXG4gIGxpc3RlbmVycyxcbiAgcGFyZW50Vm5vZGUsXG4gIHJlbmRlckNoaWxkcmVuXG4pIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgPSB0cnVlO1xuICB9XG5cbiAgLy8gZGV0ZXJtaW5lIHdoZXRoZXIgY29tcG9uZW50IGhhcyBzbG90IGNoaWxkcmVuXG4gIC8vIHdlIG5lZWQgdG8gZG8gdGhpcyBiZWZvcmUgb3ZlcndyaXRpbmcgJG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuXG4gIHZhciBoYXNDaGlsZHJlbiA9ICEhKFxuICAgIHJlbmRlckNoaWxkcmVuIHx8ICAgICAgICAgICAgICAgLy8gaGFzIG5ldyBzdGF0aWMgc2xvdHNcbiAgICB2bS4kb3B0aW9ucy5fcmVuZGVyQ2hpbGRyZW4gfHwgIC8vIGhhcyBvbGQgc3RhdGljIHNsb3RzXG4gICAgcGFyZW50Vm5vZGUuZGF0YS5zY29wZWRTbG90cyB8fCAvLyBoYXMgbmV3IHNjb3BlZCBzbG90c1xuICAgIHZtLiRzY29wZWRTbG90cyAhPT0gZW1wdHlPYmplY3QgLy8gaGFzIG9sZCBzY29wZWQgc2xvdHNcbiAgKTtcblxuICB2bS4kb3B0aW9ucy5fcGFyZW50Vm5vZGUgPSBwYXJlbnRWbm9kZTtcbiAgdm0uJHZub2RlID0gcGFyZW50Vm5vZGU7IC8vIHVwZGF0ZSB2bSdzIHBsYWNlaG9sZGVyIG5vZGUgd2l0aG91dCByZS1yZW5kZXJcblxuICBpZiAodm0uX3Zub2RlKSB7IC8vIHVwZGF0ZSBjaGlsZCB0cmVlJ3MgcGFyZW50XG4gICAgdm0uX3Zub2RlLnBhcmVudCA9IHBhcmVudFZub2RlO1xuICB9XG4gIHZtLiRvcHRpb25zLl9yZW5kZXJDaGlsZHJlbiA9IHJlbmRlckNoaWxkcmVuO1xuXG4gIC8vIHVwZGF0ZSAkYXR0cnMgYW5kICRsaXN0ZW5lcnMgaGFzaFxuICAvLyB0aGVzZSBhcmUgYWxzbyByZWFjdGl2ZSBzbyB0aGV5IG1heSB0cmlnZ2VyIGNoaWxkIHVwZGF0ZSBpZiB0aGUgY2hpbGRcbiAgLy8gdXNlZCB0aGVtIGR1cmluZyByZW5kZXJcbiAgdm0uJGF0dHJzID0gKHBhcmVudFZub2RlLmRhdGEgJiYgcGFyZW50Vm5vZGUuZGF0YS5hdHRycykgfHwgZW1wdHlPYmplY3Q7XG4gIHZtLiRsaXN0ZW5lcnMgPSBsaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3Q7XG5cbiAgLy8gdXBkYXRlIHByb3BzXG4gIGlmIChwcm9wc0RhdGEgJiYgdm0uJG9wdGlvbnMucHJvcHMpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICB2YXIgcHJvcHMgPSB2bS5fcHJvcHM7XG4gICAgdmFyIHByb3BLZXlzID0gdm0uJG9wdGlvbnMuX3Byb3BLZXlzIHx8IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJvcEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBwcm9wS2V5c1tpXTtcbiAgICAgIHByb3BzW2tleV0gPSB2YWxpZGF0ZVByb3Aoa2V5LCB2bS4kb3B0aW9ucy5wcm9wcywgcHJvcHNEYXRhLCB2bSk7XG4gICAgfVxuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gICAgLy8ga2VlcCBhIGNvcHkgb2YgcmF3IHByb3BzRGF0YVxuICAgIHZtLiRvcHRpb25zLnByb3BzRGF0YSA9IHByb3BzRGF0YTtcbiAgfVxuXG4gIC8vIHVwZGF0ZSBsaXN0ZW5lcnNcbiAgaWYgKGxpc3RlbmVycykge1xuICAgIHZhciBvbGRMaXN0ZW5lcnMgPSB2bS4kb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICAgIHZtLiRvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgdXBkYXRlQ29tcG9uZW50TGlzdGVuZXJzKHZtLCBsaXN0ZW5lcnMsIG9sZExpc3RlbmVycyk7XG4gIH1cbiAgLy8gcmVzb2x2ZSBzbG90cyArIGZvcmNlIHVwZGF0ZSBpZiBoYXMgY2hpbGRyZW5cbiAgaWYgKGhhc0NoaWxkcmVuKSB7XG4gICAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKHJlbmRlckNoaWxkcmVuLCBwYXJlbnRWbm9kZS5jb250ZXh0KTtcbiAgICB2bS4kZm9yY2VVcGRhdGUoKTtcbiAgfVxuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ID0gZmFsc2U7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNJbkluYWN0aXZlVHJlZSAodm0pIHtcbiAgd2hpbGUgKHZtICYmICh2bSA9IHZtLiRwYXJlbnQpKSB7XG4gICAgaWYgKHZtLl9pbmFjdGl2ZSkgeyByZXR1cm4gdHJ1ZSB9XG4gIH1cbiAgcmV0dXJuIGZhbHNlXG59XG5cbmZ1bmN0aW9uIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IGZhbHNlO1xuICAgIGlmIChpc0luSW5hY3RpdmVUcmVlKHZtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICB9IGVsc2UgaWYgKHZtLl9kaXJlY3RJbmFjdGl2ZSkge1xuICAgIHJldHVyblxuICB9XG4gIGlmICh2bS5faW5hY3RpdmUgfHwgdm0uX2luYWN0aXZlID09PSBudWxsKSB7XG4gICAgdm0uX2luYWN0aXZlID0gZmFsc2U7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCB2bS4kY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIGFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdhY3RpdmF0ZWQnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQgKHZtLCBkaXJlY3QpIHtcbiAgaWYgKGRpcmVjdCkge1xuICAgIHZtLl9kaXJlY3RJbmFjdGl2ZSA9IHRydWU7XG4gICAgaWYgKGlzSW5JbmFjdGl2ZVRyZWUodm0pKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG4gIH1cbiAgaWYgKCF2bS5faW5hY3RpdmUpIHtcbiAgICB2bS5faW5hY3RpdmUgPSB0cnVlO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdm0uJGNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICBkZWFjdGl2YXRlQ2hpbGRDb21wb25lbnQodm0uJGNoaWxkcmVuW2ldKTtcbiAgICB9XG4gICAgY2FsbEhvb2sodm0sICdkZWFjdGl2YXRlZCcpO1xuICB9XG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rICh2bSwgaG9vaykge1xuICB2YXIgaGFuZGxlcnMgPSB2bS4kb3B0aW9uc1tob29rXTtcbiAgaWYgKGhhbmRsZXJzKSB7XG4gICAgZm9yICh2YXIgaSA9IDAsIGogPSBoYW5kbGVycy5sZW5ndGg7IGkgPCBqOyBpKyspIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIGhhbmRsZXJzW2ldLmNhbGwodm0pO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBoYW5kbGVFcnJvcihlLCB2bSwgKGhvb2sgKyBcIiBob29rXCIpKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHZtLl9oYXNIb29rRXZlbnQpIHtcbiAgICB2bS4kZW1pdCgnaG9vazonICsgaG9vayk7XG4gIH1cbn1cblxuLyogICovXG5cblxudmFyIE1BWF9VUERBVEVfQ09VTlQgPSAxMDA7XG5cbnZhciBxdWV1ZSA9IFtdO1xudmFyIGFjdGl2YXRlZENoaWxkcmVuID0gW107XG52YXIgaGFzID0ge307XG52YXIgY2lyY3VsYXIgPSB7fTtcbnZhciB3YWl0aW5nID0gZmFsc2U7XG52YXIgZmx1c2hpbmcgPSBmYWxzZTtcbnZhciBpbmRleCA9IDA7XG5cbi8qKlxuICogUmVzZXQgdGhlIHNjaGVkdWxlcidzIHN0YXRlLlxuICovXG5mdW5jdGlvbiByZXNldFNjaGVkdWxlclN0YXRlICgpIHtcbiAgaW5kZXggPSBxdWV1ZS5sZW5ndGggPSBhY3RpdmF0ZWRDaGlsZHJlbi5sZW5ndGggPSAwO1xuICBoYXMgPSB7fTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjaXJjdWxhciA9IHt9O1xuICB9XG4gIHdhaXRpbmcgPSBmbHVzaGluZyA9IGZhbHNlO1xufVxuXG4vKipcbiAqIEZsdXNoIGJvdGggcXVldWVzIGFuZCBydW4gdGhlIHdhdGNoZXJzLlxuICovXG5mdW5jdGlvbiBmbHVzaFNjaGVkdWxlclF1ZXVlICgpIHtcbiAgZmx1c2hpbmcgPSB0cnVlO1xuICB2YXIgd2F0Y2hlciwgaWQ7XG5cbiAgLy8gU29ydCBxdWV1ZSBiZWZvcmUgZmx1c2guXG4gIC8vIFRoaXMgZW5zdXJlcyB0aGF0OlxuICAvLyAxLiBDb21wb25lbnRzIGFyZSB1cGRhdGVkIGZyb20gcGFyZW50IHRvIGNoaWxkLiAoYmVjYXVzZSBwYXJlbnQgaXMgYWx3YXlzXG4gIC8vICAgIGNyZWF0ZWQgYmVmb3JlIHRoZSBjaGlsZClcbiAgLy8gMi4gQSBjb21wb25lbnQncyB1c2VyIHdhdGNoZXJzIGFyZSBydW4gYmVmb3JlIGl0cyByZW5kZXIgd2F0Y2hlciAoYmVjYXVzZVxuICAvLyAgICB1c2VyIHdhdGNoZXJzIGFyZSBjcmVhdGVkIGJlZm9yZSB0aGUgcmVuZGVyIHdhdGNoZXIpXG4gIC8vIDMuIElmIGEgY29tcG9uZW50IGlzIGRlc3Ryb3llZCBkdXJpbmcgYSBwYXJlbnQgY29tcG9uZW50J3Mgd2F0Y2hlciBydW4sXG4gIC8vICAgIGl0cyB3YXRjaGVycyBjYW4gYmUgc2tpcHBlZC5cbiAgcXVldWUuc29ydChmdW5jdGlvbiAoYSwgYikgeyByZXR1cm4gYS5pZCAtIGIuaWQ7IH0pO1xuXG4gIC8vIGRvIG5vdCBjYWNoZSBsZW5ndGggYmVjYXVzZSBtb3JlIHdhdGNoZXJzIG1pZ2h0IGJlIHB1c2hlZFxuICAvLyBhcyB3ZSBydW4gZXhpc3Rpbmcgd2F0Y2hlcnNcbiAgZm9yIChpbmRleCA9IDA7IGluZGV4IDwgcXVldWUubGVuZ3RoOyBpbmRleCsrKSB7XG4gICAgd2F0Y2hlciA9IHF1ZXVlW2luZGV4XTtcbiAgICBpZCA9IHdhdGNoZXIuaWQ7XG4gICAgaGFzW2lkXSA9IG51bGw7XG4gICAgd2F0Y2hlci5ydW4oKTtcbiAgICAvLyBpbiBkZXYgYnVpbGQsIGNoZWNrIGFuZCBzdG9wIGNpcmN1bGFyIHVwZGF0ZXMuXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaGFzW2lkXSAhPSBudWxsKSB7XG4gICAgICBjaXJjdWxhcltpZF0gPSAoY2lyY3VsYXJbaWRdIHx8IDApICsgMTtcbiAgICAgIGlmIChjaXJjdWxhcltpZF0gPiBNQVhfVVBEQVRFX0NPVU5UKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ1lvdSBtYXkgaGF2ZSBhbiBpbmZpbml0ZSB1cGRhdGUgbG9vcCAnICsgKFxuICAgICAgICAgICAgd2F0Y2hlci51c2VyXG4gICAgICAgICAgICAgID8gKFwiaW4gd2F0Y2hlciB3aXRoIGV4cHJlc3Npb24gXFxcIlwiICsgKHdhdGNoZXIuZXhwcmVzc2lvbikgKyBcIlxcXCJcIilcbiAgICAgICAgICAgICAgOiBcImluIGEgY29tcG9uZW50IHJlbmRlciBmdW5jdGlvbi5cIlxuICAgICAgICAgICksXG4gICAgICAgICAgd2F0Y2hlci52bVxuICAgICAgICApO1xuICAgICAgICBicmVha1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIC8vIGtlZXAgY29waWVzIG9mIHBvc3QgcXVldWVzIGJlZm9yZSByZXNldHRpbmcgc3RhdGVcbiAgdmFyIGFjdGl2YXRlZFF1ZXVlID0gYWN0aXZhdGVkQ2hpbGRyZW4uc2xpY2UoKTtcbiAgdmFyIHVwZGF0ZWRRdWV1ZSA9IHF1ZXVlLnNsaWNlKCk7XG5cbiAgcmVzZXRTY2hlZHVsZXJTdGF0ZSgpO1xuXG4gIC8vIGNhbGwgY29tcG9uZW50IHVwZGF0ZWQgYW5kIGFjdGl2YXRlZCBob29rc1xuICBjYWxsQWN0aXZhdGVkSG9va3MoYWN0aXZhdGVkUXVldWUpO1xuICBjYWxsVXBkYXRlZEhvb2tzKHVwZGF0ZWRRdWV1ZSk7XG5cbiAgLy8gZGV2dG9vbCBob29rXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZGV2dG9vbHMgJiYgY29uZmlnLmRldnRvb2xzKSB7XG4gICAgZGV2dG9vbHMuZW1pdCgnZmx1c2gnKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjYWxsVXBkYXRlZEhvb2tzIChxdWV1ZSkge1xuICB2YXIgaSA9IHF1ZXVlLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciB3YXRjaGVyID0gcXVldWVbaV07XG4gICAgdmFyIHZtID0gd2F0Y2hlci52bTtcbiAgICBpZiAodm0uX3dhdGNoZXIgPT09IHdhdGNoZXIgJiYgdm0uX2lzTW91bnRlZCkge1xuICAgICAgY2FsbEhvb2sodm0sICd1cGRhdGVkJyk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogUXVldWUgYSBrZXB0LWFsaXZlIGNvbXBvbmVudCB0aGF0IHdhcyBhY3RpdmF0ZWQgZHVyaW5nIHBhdGNoLlxuICogVGhlIHF1ZXVlIHdpbGwgYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSBlbnRpcmUgdHJlZSBoYXMgYmVlbiBwYXRjaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudCAodm0pIHtcbiAgLy8gc2V0dGluZyBfaW5hY3RpdmUgdG8gZmFsc2UgaGVyZSBzbyB0aGF0IGEgcmVuZGVyIGZ1bmN0aW9uIGNhblxuICAvLyByZWx5IG9uIGNoZWNraW5nIHdoZXRoZXIgaXQncyBpbiBhbiBpbmFjdGl2ZSB0cmVlIChlLmcuIHJvdXRlci12aWV3KVxuICB2bS5faW5hY3RpdmUgPSBmYWxzZTtcbiAgYWN0aXZhdGVkQ2hpbGRyZW4ucHVzaCh2bSk7XG59XG5cbmZ1bmN0aW9uIGNhbGxBY3RpdmF0ZWRIb29rcyAocXVldWUpIHtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBxdWV1ZS5sZW5ndGg7IGkrKykge1xuICAgIHF1ZXVlW2ldLl9pbmFjdGl2ZSA9IHRydWU7XG4gICAgYWN0aXZhdGVDaGlsZENvbXBvbmVudChxdWV1ZVtpXSwgdHJ1ZSAvKiB0cnVlICovKTtcbiAgfVxufVxuXG4vKipcbiAqIFB1c2ggYSB3YXRjaGVyIGludG8gdGhlIHdhdGNoZXIgcXVldWUuXG4gKiBKb2JzIHdpdGggZHVwbGljYXRlIElEcyB3aWxsIGJlIHNraXBwZWQgdW5sZXNzIGl0J3NcbiAqIHB1c2hlZCB3aGVuIHRoZSBxdWV1ZSBpcyBiZWluZyBmbHVzaGVkLlxuICovXG5mdW5jdGlvbiBxdWV1ZVdhdGNoZXIgKHdhdGNoZXIpIHtcbiAgdmFyIGlkID0gd2F0Y2hlci5pZDtcbiAgaWYgKGhhc1tpZF0gPT0gbnVsbCkge1xuICAgIGhhc1tpZF0gPSB0cnVlO1xuICAgIGlmICghZmx1c2hpbmcpIHtcbiAgICAgIHF1ZXVlLnB1c2god2F0Y2hlcik7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGlmIGFscmVhZHkgZmx1c2hpbmcsIHNwbGljZSB0aGUgd2F0Y2hlciBiYXNlZCBvbiBpdHMgaWRcbiAgICAgIC8vIGlmIGFscmVhZHkgcGFzdCBpdHMgaWQsIGl0IHdpbGwgYmUgcnVuIG5leHQgaW1tZWRpYXRlbHkuXG4gICAgICB2YXIgaSA9IHF1ZXVlLmxlbmd0aCAtIDE7XG4gICAgICB3aGlsZSAoaSA+IGluZGV4ICYmIHF1ZXVlW2ldLmlkID4gd2F0Y2hlci5pZCkge1xuICAgICAgICBpLS07XG4gICAgICB9XG4gICAgICBxdWV1ZS5zcGxpY2UoaSArIDEsIDAsIHdhdGNoZXIpO1xuICAgIH1cbiAgICAvLyBxdWV1ZSB0aGUgZmx1c2hcbiAgICBpZiAoIXdhaXRpbmcpIHtcbiAgICAgIHdhaXRpbmcgPSB0cnVlO1xuICAgICAgbmV4dFRpY2soZmx1c2hTY2hlZHVsZXJRdWV1ZSk7XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDIgPSAwO1xuXG4vKipcbiAqIEEgd2F0Y2hlciBwYXJzZXMgYW4gZXhwcmVzc2lvbiwgY29sbGVjdHMgZGVwZW5kZW5jaWVzLFxuICogYW5kIGZpcmVzIGNhbGxiYWNrIHdoZW4gdGhlIGV4cHJlc3Npb24gdmFsdWUgY2hhbmdlcy5cbiAqIFRoaXMgaXMgdXNlZCBmb3IgYm90aCB0aGUgJHdhdGNoKCkgYXBpIGFuZCBkaXJlY3RpdmVzLlxuICovXG52YXIgV2F0Y2hlciA9IGZ1bmN0aW9uIFdhdGNoZXIgKFxuICB2bSxcbiAgZXhwT3JGbixcbiAgY2IsXG4gIG9wdGlvbnMsXG4gIGlzUmVuZGVyV2F0Y2hlclxuKSB7XG4gIHRoaXMudm0gPSB2bTtcbiAgaWYgKGlzUmVuZGVyV2F0Y2hlcikge1xuICAgIHZtLl93YXRjaGVyID0gdGhpcztcbiAgfVxuICB2bS5fd2F0Y2hlcnMucHVzaCh0aGlzKTtcbiAgLy8gb3B0aW9uc1xuICBpZiAob3B0aW9ucykge1xuICAgIHRoaXMuZGVlcCA9ICEhb3B0aW9ucy5kZWVwO1xuICAgIHRoaXMudXNlciA9ICEhb3B0aW9ucy51c2VyO1xuICAgIHRoaXMubGF6eSA9ICEhb3B0aW9ucy5sYXp5O1xuICAgIHRoaXMuc3luYyA9ICEhb3B0aW9ucy5zeW5jO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZGVlcCA9IHRoaXMudXNlciA9IHRoaXMubGF6eSA9IHRoaXMuc3luYyA9IGZhbHNlO1xuICB9XG4gIHRoaXMuY2IgPSBjYjtcbiAgdGhpcy5pZCA9ICsrdWlkJDI7IC8vIHVpZCBmb3IgYmF0Y2hpbmdcbiAgdGhpcy5hY3RpdmUgPSB0cnVlO1xuICB0aGlzLmRpcnR5ID0gdGhpcy5sYXp5OyAvLyBmb3IgbGF6eSB3YXRjaGVyc1xuICB0aGlzLmRlcHMgPSBbXTtcbiAgdGhpcy5uZXdEZXBzID0gW107XG4gIHRoaXMuZGVwSWRzID0gbmV3IF9TZXQoKTtcbiAgdGhpcy5uZXdEZXBJZHMgPSBuZXcgX1NldCgpO1xuICB0aGlzLmV4cHJlc3Npb24gPSBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nXG4gICAgPyBleHBPckZuLnRvU3RyaW5nKClcbiAgICA6ICcnO1xuICAvLyBwYXJzZSBleHByZXNzaW9uIGZvciBnZXR0ZXJcbiAgaWYgKHR5cGVvZiBleHBPckZuID09PSAnZnVuY3Rpb24nKSB7XG4gICAgdGhpcy5nZXR0ZXIgPSBleHBPckZuO1xuICB9IGVsc2Uge1xuICAgIHRoaXMuZ2V0dGVyID0gcGFyc2VQYXRoKGV4cE9yRm4pO1xuICAgIGlmICghdGhpcy5nZXR0ZXIpIHtcbiAgICAgIHRoaXMuZ2V0dGVyID0gZnVuY3Rpb24gKCkge307XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgIFwiRmFpbGVkIHdhdGNoaW5nIHBhdGg6IFxcXCJcIiArIGV4cE9yRm4gKyBcIlxcXCIgXCIgK1xuICAgICAgICAnV2F0Y2hlciBvbmx5IGFjY2VwdHMgc2ltcGxlIGRvdC1kZWxpbWl0ZWQgcGF0aHMuICcgK1xuICAgICAgICAnRm9yIGZ1bGwgY29udHJvbCwgdXNlIGEgZnVuY3Rpb24gaW5zdGVhZC4nLFxuICAgICAgICB2bVxuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgdGhpcy52YWx1ZSA9IHRoaXMubGF6eVxuICAgID8gdW5kZWZpbmVkXG4gICAgOiB0aGlzLmdldCgpO1xufTtcblxuLyoqXG4gKiBFdmFsdWF0ZSB0aGUgZ2V0dGVyLCBhbmQgcmUtY29sbGVjdCBkZXBlbmRlbmNpZXMuXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIGdldCAoKSB7XG4gIHB1c2hUYXJnZXQodGhpcyk7XG4gIHZhciB2YWx1ZTtcbiAgdmFyIHZtID0gdGhpcy52bTtcbiAgdHJ5IHtcbiAgICB2YWx1ZSA9IHRoaXMuZ2V0dGVyLmNhbGwodm0sIHZtKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgIGhhbmRsZUVycm9yKGUsIHZtLCAoXCJnZXR0ZXIgZm9yIHdhdGNoZXIgXFxcIlwiICsgKHRoaXMuZXhwcmVzc2lvbikgKyBcIlxcXCJcIikpO1xuICAgIH0gZWxzZSB7XG4gICAgICB0aHJvdyBlXG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIC8vIFwidG91Y2hcIiBldmVyeSBwcm9wZXJ0eSBzbyB0aGV5IGFyZSBhbGwgdHJhY2tlZCBhc1xuICAgIC8vIGRlcGVuZGVuY2llcyBmb3IgZGVlcCB3YXRjaGluZ1xuICAgIGlmICh0aGlzLmRlZXApIHtcbiAgICAgIHRyYXZlcnNlKHZhbHVlKTtcbiAgICB9XG4gICAgcG9wVGFyZ2V0KCk7XG4gICAgdGhpcy5jbGVhbnVwRGVwcygpO1xuICB9XG4gIHJldHVybiB2YWx1ZVxufTtcblxuLyoqXG4gKiBBZGQgYSBkZXBlbmRlbmN5IHRvIHRoaXMgZGlyZWN0aXZlLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5hZGREZXAgPSBmdW5jdGlvbiBhZGREZXAgKGRlcCkge1xuICB2YXIgaWQgPSBkZXAuaWQ7XG4gIGlmICghdGhpcy5uZXdEZXBJZHMuaGFzKGlkKSkge1xuICAgIHRoaXMubmV3RGVwSWRzLmFkZChpZCk7XG4gICAgdGhpcy5uZXdEZXBzLnB1c2goZGVwKTtcbiAgICBpZiAoIXRoaXMuZGVwSWRzLmhhcyhpZCkpIHtcbiAgICAgIGRlcC5hZGRTdWIodGhpcyk7XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIENsZWFuIHVwIGZvciBkZXBlbmRlbmN5IGNvbGxlY3Rpb24uXG4gKi9cbldhdGNoZXIucHJvdG90eXBlLmNsZWFudXBEZXBzID0gZnVuY3Rpb24gY2xlYW51cERlcHMgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHZhciBkZXAgPSB0aGlzJDEuZGVwc1tpXTtcbiAgICBpZiAoIXRoaXMkMS5uZXdEZXBJZHMuaGFzKGRlcC5pZCkpIHtcbiAgICAgIGRlcC5yZW1vdmVTdWIodGhpcyQxKTtcbiAgICB9XG4gIH1cbiAgdmFyIHRtcCA9IHRoaXMuZGVwSWRzO1xuICB0aGlzLmRlcElkcyA9IHRoaXMubmV3RGVwSWRzO1xuICB0aGlzLm5ld0RlcElkcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBJZHMuY2xlYXIoKTtcbiAgdG1wID0gdGhpcy5kZXBzO1xuICB0aGlzLmRlcHMgPSB0aGlzLm5ld0RlcHM7XG4gIHRoaXMubmV3RGVwcyA9IHRtcDtcbiAgdGhpcy5uZXdEZXBzLmxlbmd0aCA9IDA7XG59O1xuXG4vKipcbiAqIFN1YnNjcmliZXIgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgd2hlbiBhIGRlcGVuZGVuY3kgY2hhbmdlcy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUudXBkYXRlID0gZnVuY3Rpb24gdXBkYXRlICgpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgaWYgKHRoaXMubGF6eSkge1xuICAgIHRoaXMuZGlydHkgPSB0cnVlO1xuICB9IGVsc2UgaWYgKHRoaXMuc3luYykge1xuICAgIHRoaXMucnVuKCk7XG4gIH0gZWxzZSB7XG4gICAgcXVldWVXYXRjaGVyKHRoaXMpO1xuICB9XG59O1xuXG4vKipcbiAqIFNjaGVkdWxlciBqb2IgaW50ZXJmYWNlLlxuICogV2lsbCBiZSBjYWxsZWQgYnkgdGhlIHNjaGVkdWxlci5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUucnVuID0gZnVuY3Rpb24gcnVuICgpIHtcbiAgaWYgKHRoaXMuYWN0aXZlKSB7XG4gICAgdmFyIHZhbHVlID0gdGhpcy5nZXQoKTtcbiAgICBpZiAoXG4gICAgICB2YWx1ZSAhPT0gdGhpcy52YWx1ZSB8fFxuICAgICAgLy8gRGVlcCB3YXRjaGVycyBhbmQgd2F0Y2hlcnMgb24gT2JqZWN0L0FycmF5cyBzaG91bGQgZmlyZSBldmVuXG4gICAgICAvLyB3aGVuIHRoZSB2YWx1ZSBpcyB0aGUgc2FtZSwgYmVjYXVzZSB0aGUgdmFsdWUgbWF5XG4gICAgICAvLyBoYXZlIG11dGF0ZWQuXG4gICAgICBpc09iamVjdCh2YWx1ZSkgfHxcbiAgICAgIHRoaXMuZGVlcFxuICAgICkge1xuICAgICAgLy8gc2V0IG5ldyB2YWx1ZVxuICAgICAgdmFyIG9sZFZhbHVlID0gdGhpcy52YWx1ZTtcbiAgICAgIHRoaXMudmFsdWUgPSB2YWx1ZTtcbiAgICAgIGlmICh0aGlzLnVzZXIpIHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICB0aGlzLmNiLmNhbGwodGhpcy52bSwgdmFsdWUsIG9sZFZhbHVlKTtcbiAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgIGhhbmRsZUVycm9yKGUsIHRoaXMudm0sIChcImNhbGxiYWNrIGZvciB3YXRjaGVyIFxcXCJcIiArICh0aGlzLmV4cHJlc3Npb24pICsgXCJcXFwiXCIpKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhpcy5jYi5jYWxsKHRoaXMudm0sIHZhbHVlLCBvbGRWYWx1ZSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59O1xuXG4vKipcbiAqIEV2YWx1YXRlIHRoZSB2YWx1ZSBvZiB0aGUgd2F0Y2hlci5cbiAqIFRoaXMgb25seSBnZXRzIGNhbGxlZCBmb3IgbGF6eSB3YXRjaGVycy5cbiAqL1xuV2F0Y2hlci5wcm90b3R5cGUuZXZhbHVhdGUgPSBmdW5jdGlvbiBldmFsdWF0ZSAoKSB7XG4gIHRoaXMudmFsdWUgPSB0aGlzLmdldCgpO1xuICB0aGlzLmRpcnR5ID0gZmFsc2U7XG59O1xuXG4vKipcbiAqIERlcGVuZCBvbiBhbGwgZGVwcyBjb2xsZWN0ZWQgYnkgdGhpcyB3YXRjaGVyLlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS5kZXBlbmQgPSBmdW5jdGlvbiBkZXBlbmQgKCkge1xuICAgIHZhciB0aGlzJDEgPSB0aGlzO1xuXG4gIHZhciBpID0gdGhpcy5kZXBzLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIHRoaXMkMS5kZXBzW2ldLmRlcGVuZCgpO1xuICB9XG59O1xuXG4vKipcbiAqIFJlbW92ZSBzZWxmIGZyb20gYWxsIGRlcGVuZGVuY2llcycgc3Vic2NyaWJlciBsaXN0LlxuICovXG5XYXRjaGVyLnByb3RvdHlwZS50ZWFyZG93biA9IGZ1bmN0aW9uIHRlYXJkb3duICgpIHtcbiAgICB2YXIgdGhpcyQxID0gdGhpcztcblxuICBpZiAodGhpcy5hY3RpdmUpIHtcbiAgICAvLyByZW1vdmUgc2VsZiBmcm9tIHZtJ3Mgd2F0Y2hlciBsaXN0XG4gICAgLy8gdGhpcyBpcyBhIHNvbWV3aGF0IGV4cGVuc2l2ZSBvcGVyYXRpb24gc28gd2Ugc2tpcCBpdFxuICAgIC8vIGlmIHRoZSB2bSBpcyBiZWluZyBkZXN0cm95ZWQuXG4gICAgaWYgKCF0aGlzLnZtLl9pc0JlaW5nRGVzdHJveWVkKSB7XG4gICAgICByZW1vdmUodGhpcy52bS5fd2F0Y2hlcnMsIHRoaXMpO1xuICAgIH1cbiAgICB2YXIgaSA9IHRoaXMuZGVwcy5sZW5ndGg7XG4gICAgd2hpbGUgKGktLSkge1xuICAgICAgdGhpcyQxLmRlcHNbaV0ucmVtb3ZlU3ViKHRoaXMkMSk7XG4gICAgfVxuICAgIHRoaXMuYWN0aXZlID0gZmFsc2U7XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uID0ge1xuICBlbnVtZXJhYmxlOiB0cnVlLFxuICBjb25maWd1cmFibGU6IHRydWUsXG4gIGdldDogbm9vcCxcbiAgc2V0OiBub29wXG59O1xuXG5mdW5jdGlvbiBwcm94eSAodGFyZ2V0LCBzb3VyY2VLZXksIGtleSkge1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uZ2V0ID0gZnVuY3Rpb24gcHJveHlHZXR0ZXIgKCkge1xuICAgIHJldHVybiB0aGlzW3NvdXJjZUtleV1ba2V5XVxuICB9O1xuICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gcHJveHlTZXR0ZXIgKHZhbCkge1xuICAgIHRoaXNbc291cmNlS2V5XVtrZXldID0gdmFsO1xuICB9O1xuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGluaXRTdGF0ZSAodm0pIHtcbiAgdm0uX3dhdGNoZXJzID0gW107XG4gIHZhciBvcHRzID0gdm0uJG9wdGlvbnM7XG4gIGlmIChvcHRzLnByb3BzKSB7IGluaXRQcm9wcyh2bSwgb3B0cy5wcm9wcyk7IH1cbiAgaWYgKG9wdHMubWV0aG9kcykgeyBpbml0TWV0aG9kcyh2bSwgb3B0cy5tZXRob2RzKTsgfVxuICBpZiAob3B0cy5kYXRhKSB7XG4gICAgaW5pdERhdGEodm0pO1xuICB9IGVsc2Uge1xuICAgIG9ic2VydmUodm0uX2RhdGEgPSB7fSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbiAgfVxuICBpZiAob3B0cy5jb21wdXRlZCkgeyBpbml0Q29tcHV0ZWQodm0sIG9wdHMuY29tcHV0ZWQpOyB9XG4gIGlmIChvcHRzLndhdGNoICYmIG9wdHMud2F0Y2ggIT09IG5hdGl2ZVdhdGNoKSB7XG4gICAgaW5pdFdhdGNoKHZtLCBvcHRzLndhdGNoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0UHJvcHMgKHZtLCBwcm9wc09wdGlvbnMpIHtcbiAgdmFyIHByb3BzRGF0YSA9IHZtLiRvcHRpb25zLnByb3BzRGF0YSB8fCB7fTtcbiAgdmFyIHByb3BzID0gdm0uX3Byb3BzID0ge307XG4gIC8vIGNhY2hlIHByb3Aga2V5cyBzbyB0aGF0IGZ1dHVyZSBwcm9wcyB1cGRhdGVzIGNhbiBpdGVyYXRlIHVzaW5nIEFycmF5XG4gIC8vIGluc3RlYWQgb2YgZHluYW1pYyBvYmplY3Qga2V5IGVudW1lcmF0aW9uLlxuICB2YXIga2V5cyA9IHZtLiRvcHRpb25zLl9wcm9wS2V5cyA9IFtdO1xuICB2YXIgaXNSb290ID0gIXZtLiRwYXJlbnQ7XG4gIC8vIHJvb3QgaW5zdGFuY2UgcHJvcHMgc2hvdWxkIGJlIGNvbnZlcnRlZFxuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBpc1Jvb3Q7XG4gIHZhciBsb29wID0gZnVuY3Rpb24gKCBrZXkgKSB7XG4gICAga2V5cy5wdXNoKGtleSk7XG4gICAgdmFyIHZhbHVlID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcHNPcHRpb25zLCBwcm9wc0RhdGEsIHZtKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICB2YXIgaHlwaGVuYXRlZEtleSA9IGh5cGhlbmF0ZShrZXkpO1xuICAgICAgaWYgKGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoaHlwaGVuYXRlZEtleSkgfHxcbiAgICAgICAgICBjb25maWcuaXNSZXNlcnZlZEF0dHIoaHlwaGVuYXRlZEtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJcXFwiXCIgKyBoeXBoZW5hdGVkS2V5ICsgXCJcXFwiIGlzIGEgcmVzZXJ2ZWQgYXR0cmlidXRlIGFuZCBjYW5ub3QgYmUgdXNlZCBhcyBjb21wb25lbnQgcHJvcC5cIiksXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGRlZmluZVJlYWN0aXZlKHByb3BzLCBrZXksIHZhbHVlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh2bS4kcGFyZW50ICYmICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQpIHtcbiAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgXCJBdm9pZCBtdXRhdGluZyBhIHByb3AgZGlyZWN0bHkgc2luY2UgdGhlIHZhbHVlIHdpbGwgYmUgXCIgK1xuICAgICAgICAgICAgXCJvdmVyd3JpdHRlbiB3aGVuZXZlciB0aGUgcGFyZW50IGNvbXBvbmVudCByZS1yZW5kZXJzLiBcIiArXG4gICAgICAgICAgICBcIkluc3RlYWQsIHVzZSBhIGRhdGEgb3IgY29tcHV0ZWQgcHJvcGVydHkgYmFzZWQgb24gdGhlIHByb3AncyBcIiArXG4gICAgICAgICAgICBcInZhbHVlLiBQcm9wIGJlaW5nIG11dGF0ZWQ6IFxcXCJcIiArIGtleSArIFwiXFxcIlwiLFxuICAgICAgICAgICAgdm1cbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZGVmaW5lUmVhY3RpdmUocHJvcHMsIGtleSwgdmFsdWUpO1xuICAgIH1cbiAgICAvLyBzdGF0aWMgcHJvcHMgYXJlIGFscmVhZHkgcHJveGllZCBvbiB0aGUgY29tcG9uZW50J3MgcHJvdG90eXBlXG4gICAgLy8gZHVyaW5nIFZ1ZS5leHRlbmQoKS4gV2Ugb25seSBuZWVkIHRvIHByb3h5IHByb3BzIGRlZmluZWQgYXRcbiAgICAvLyBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgcHJveHkodm0sIFwiX3Byb3BzXCIsIGtleSk7XG4gICAgfVxuICB9O1xuXG4gIGZvciAodmFyIGtleSBpbiBwcm9wc09wdGlvbnMpIGxvb3AoIGtleSApO1xuICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSB0cnVlO1xufVxuXG5mdW5jdGlvbiBpbml0RGF0YSAodm0pIHtcbiAgdmFyIGRhdGEgPSB2bS4kb3B0aW9ucy5kYXRhO1xuICBkYXRhID0gdm0uX2RhdGEgPSB0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJ1xuICAgID8gZ2V0RGF0YShkYXRhLCB2bSlcbiAgICA6IGRhdGEgfHwge307XG4gIGlmICghaXNQbGFpbk9iamVjdChkYXRhKSkge1xuICAgIGRhdGEgPSB7fTtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAnZGF0YSBmdW5jdGlvbnMgc2hvdWxkIHJldHVybiBhbiBvYmplY3Q6XFxuJyArXG4gICAgICAnaHR0cHM6Ly92dWVqcy5vcmcvdjIvZ3VpZGUvY29tcG9uZW50cy5odG1sI2RhdGEtTXVzdC1CZS1hLUZ1bmN0aW9uJyxcbiAgICAgIHZtXG4gICAgKTtcbiAgfVxuICAvLyBwcm94eSBkYXRhIG9uIGluc3RhbmNlXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMoZGF0YSk7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICB2YXIgbWV0aG9kcyA9IHZtLiRvcHRpb25zLm1ldGhvZHM7XG4gIHZhciBpID0ga2V5cy5sZW5ndGg7XG4gIHdoaWxlIChpLS0pIHtcbiAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKG1ldGhvZHMgJiYgaGFzT3duKG1ldGhvZHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIGRhdGEgcHJvcGVydHkuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgXCJUaGUgZGF0YSBwcm9wZXJ0eSBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaXMgYWxyZWFkeSBkZWNsYXJlZCBhcyBhIHByb3AuIFwiICtcbiAgICAgICAgXCJVc2UgcHJvcCBkZWZhdWx0IHZhbHVlIGluc3RlYWQuXCIsXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoIWlzUmVzZXJ2ZWQoa2V5KSkge1xuICAgICAgcHJveHkodm0sIFwiX2RhdGFcIiwga2V5KTtcbiAgICB9XG4gIH1cbiAgLy8gb2JzZXJ2ZSBkYXRhXG4gIG9ic2VydmUoZGF0YSwgdHJ1ZSAvKiBhc1Jvb3REYXRhICovKTtcbn1cblxuZnVuY3Rpb24gZ2V0RGF0YSAoZGF0YSwgdm0pIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gZGF0YS5jYWxsKHZtLCB2bSlcbiAgfSBjYXRjaCAoZSkge1xuICAgIGhhbmRsZUVycm9yKGUsIHZtLCBcImRhdGEoKVwiKTtcbiAgICByZXR1cm4ge31cbiAgfVxufVxuXG52YXIgY29tcHV0ZWRXYXRjaGVyT3B0aW9ucyA9IHsgbGF6eTogdHJ1ZSB9O1xuXG5mdW5jdGlvbiBpbml0Q29tcHV0ZWQgKHZtLCBjb21wdXRlZCkge1xuICB2YXIgd2F0Y2hlcnMgPSB2bS5fY29tcHV0ZWRXYXRjaGVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIC8vIGNvbXB1dGVkIHByb3BlcnRpZXMgYXJlIGp1c3QgZ2V0dGVycyBkdXJpbmcgU1NSXG4gIHZhciBpc1NTUiA9IGlzU2VydmVyUmVuZGVyaW5nKCk7XG5cbiAgZm9yICh2YXIga2V5IGluIGNvbXB1dGVkKSB7XG4gICAgdmFyIHVzZXJEZWYgPSBjb21wdXRlZFtrZXldO1xuICAgIHZhciBnZXR0ZXIgPSB0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJyA/IHVzZXJEZWYgOiB1c2VyRGVmLmdldDtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBnZXR0ZXIgPT0gbnVsbCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiR2V0dGVyIGlzIG1pc3NpbmcgZm9yIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIi5cIiksXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cblxuICAgIGlmICghaXNTU1IpIHtcbiAgICAgIC8vIGNyZWF0ZSBpbnRlcm5hbCB3YXRjaGVyIGZvciB0aGUgY29tcHV0ZWQgcHJvcGVydHkuXG4gICAgICB3YXRjaGVyc1trZXldID0gbmV3IFdhdGNoZXIoXG4gICAgICAgIHZtLFxuICAgICAgICBnZXR0ZXIgfHwgbm9vcCxcbiAgICAgICAgbm9vcCxcbiAgICAgICAgY29tcHV0ZWRXYXRjaGVyT3B0aW9uc1xuICAgICAgKTtcbiAgICB9XG5cbiAgICAvLyBjb21wb25lbnQtZGVmaW5lZCBjb21wdXRlZCBwcm9wZXJ0aWVzIGFyZSBhbHJlYWR5IGRlZmluZWQgb24gdGhlXG4gICAgLy8gY29tcG9uZW50IHByb3RvdHlwZS4gV2Ugb25seSBuZWVkIHRvIGRlZmluZSBjb21wdXRlZCBwcm9wZXJ0aWVzIGRlZmluZWRcbiAgICAvLyBhdCBpbnN0YW50aWF0aW9uIGhlcmUuXG4gICAgaWYgKCEoa2V5IGluIHZtKSkge1xuICAgICAgZGVmaW5lQ29tcHV0ZWQodm0sIGtleSwgdXNlckRlZik7XG4gICAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoa2V5IGluIHZtLiRkYXRhKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgaW4gZGF0YS5cIiksIHZtKTtcbiAgICAgIH0gZWxzZSBpZiAodm0uJG9wdGlvbnMucHJvcHMgJiYga2V5IGluIHZtLiRvcHRpb25zLnByb3BzKSB7XG4gICAgICAgIHdhcm4oKFwiVGhlIGNvbXB1dGVkIHByb3BlcnR5IFxcXCJcIiArIGtleSArIFwiXFxcIiBpcyBhbHJlYWR5IGRlZmluZWQgYXMgYSBwcm9wLlwiKSwgdm0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBkZWZpbmVDb21wdXRlZCAoXG4gIHRhcmdldCxcbiAga2V5LFxuICB1c2VyRGVmXG4pIHtcbiAgdmFyIHNob3VsZENhY2hlID0gIWlzU2VydmVyUmVuZGVyaW5nKCk7XG4gIGlmICh0eXBlb2YgdXNlckRlZiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5nZXQgPSBzaG91bGRDYWNoZVxuICAgICAgPyBjcmVhdGVDb21wdXRlZEdldHRlcihrZXkpXG4gICAgICA6IHVzZXJEZWY7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IG5vb3A7XG4gIH0gZWxzZSB7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLmdldCA9IHVzZXJEZWYuZ2V0XG4gICAgICA/IHNob3VsZENhY2hlICYmIHVzZXJEZWYuY2FjaGUgIT09IGZhbHNlXG4gICAgICAgID8gY3JlYXRlQ29tcHV0ZWRHZXR0ZXIoa2V5KVxuICAgICAgICA6IHVzZXJEZWYuZ2V0XG4gICAgICA6IG5vb3A7XG4gICAgc2hhcmVkUHJvcGVydHlEZWZpbml0aW9uLnNldCA9IHVzZXJEZWYuc2V0XG4gICAgICA/IHVzZXJEZWYuc2V0XG4gICAgICA6IG5vb3A7XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbi5zZXQgPT09IG5vb3ApIHtcbiAgICBzaGFyZWRQcm9wZXJ0eURlZmluaXRpb24uc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgKFwiQ29tcHV0ZWQgcHJvcGVydHkgXFxcIlwiICsga2V5ICsgXCJcXFwiIHdhcyBhc3NpZ25lZCB0byBidXQgaXQgaGFzIG5vIHNldHRlci5cIiksXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBrZXksIHNoYXJlZFByb3BlcnR5RGVmaW5pdGlvbik7XG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUNvbXB1dGVkR2V0dGVyIChrZXkpIHtcbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXB1dGVkR2V0dGVyICgpIHtcbiAgICB2YXIgd2F0Y2hlciA9IHRoaXMuX2NvbXB1dGVkV2F0Y2hlcnMgJiYgdGhpcy5fY29tcHV0ZWRXYXRjaGVyc1trZXldO1xuICAgIGlmICh3YXRjaGVyKSB7XG4gICAgICBpZiAod2F0Y2hlci5kaXJ0eSkge1xuICAgICAgICB3YXRjaGVyLmV2YWx1YXRlKCk7XG4gICAgICB9XG4gICAgICBpZiAoRGVwLnRhcmdldCkge1xuICAgICAgICB3YXRjaGVyLmRlcGVuZCgpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHdhdGNoZXIudmFsdWVcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdE1ldGhvZHMgKHZtLCBtZXRob2RzKSB7XG4gIHZhciBwcm9wcyA9IHZtLiRvcHRpb25zLnByb3BzO1xuICBmb3IgKHZhciBrZXkgaW4gbWV0aG9kcykge1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAobWV0aG9kc1trZXldID09IG51bGwpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICBcIk1ldGhvZCBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgaGFzIGFuIHVuZGVmaW5lZCB2YWx1ZSBpbiB0aGUgY29tcG9uZW50IGRlZmluaXRpb24uIFwiICtcbiAgICAgICAgICBcIkRpZCB5b3UgcmVmZXJlbmNlIHRoZSBmdW5jdGlvbiBjb3JyZWN0bHk/XCIsXG4gICAgICAgICAgdm1cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIGlmIChwcm9wcyAmJiBoYXNPd24ocHJvcHMsIGtleSkpIHtcbiAgICAgICAgd2FybihcbiAgICAgICAgICAoXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGhhcyBhbHJlYWR5IGJlZW4gZGVmaW5lZCBhcyBhIHByb3AuXCIpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoKGtleSBpbiB2bSkgJiYgaXNSZXNlcnZlZChrZXkpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgXCJNZXRob2QgXFxcIlwiICsga2V5ICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIGFuIGV4aXN0aW5nIFZ1ZSBpbnN0YW5jZSBtZXRob2QuIFwiICtcbiAgICAgICAgICBcIkF2b2lkIGRlZmluaW5nIGNvbXBvbmVudCBtZXRob2RzIHRoYXQgc3RhcnQgd2l0aCBfIG9yICQuXCJcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICB9XG4gICAgdm1ba2V5XSA9IG1ldGhvZHNba2V5XSA9PSBudWxsID8gbm9vcCA6IGJpbmQobWV0aG9kc1trZXldLCB2bSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdFdhdGNoICh2bSwgd2F0Y2gpIHtcbiAgZm9yICh2YXIga2V5IGluIHdhdGNoKSB7XG4gICAgdmFyIGhhbmRsZXIgPSB3YXRjaFtrZXldO1xuICAgIGlmIChBcnJheS5pc0FycmF5KGhhbmRsZXIpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhhbmRsZXIubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyW2ldKTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgY3JlYXRlV2F0Y2hlcih2bSwga2V5LCBoYW5kbGVyKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY3JlYXRlV2F0Y2hlciAoXG4gIHZtLFxuICBrZXlPckZuLFxuICBoYW5kbGVyLFxuICBvcHRpb25zXG4pIHtcbiAgaWYgKGlzUGxhaW5PYmplY3QoaGFuZGxlcikpIHtcbiAgICBvcHRpb25zID0gaGFuZGxlcjtcbiAgICBoYW5kbGVyID0gaGFuZGxlci5oYW5kbGVyO1xuICB9XG4gIGlmICh0eXBlb2YgaGFuZGxlciA9PT0gJ3N0cmluZycpIHtcbiAgICBoYW5kbGVyID0gdm1baGFuZGxlcl07XG4gIH1cbiAgcmV0dXJuIHZtLiR3YXRjaChrZXlPckZuLCBoYW5kbGVyLCBvcHRpb25zKVxufVxuXG5mdW5jdGlvbiBzdGF0ZU1peGluIChWdWUpIHtcbiAgLy8gZmxvdyBzb21laG93IGhhcyBwcm9ibGVtcyB3aXRoIGRpcmVjdGx5IGRlY2xhcmVkIGRlZmluaXRpb24gb2JqZWN0XG4gIC8vIHdoZW4gdXNpbmcgT2JqZWN0LmRlZmluZVByb3BlcnR5LCBzbyB3ZSBoYXZlIHRvIHByb2NlZHVyYWxseSBidWlsZCB1cFxuICAvLyB0aGUgb2JqZWN0IGhlcmUuXG4gIHZhciBkYXRhRGVmID0ge307XG4gIGRhdGFEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fZGF0YSB9O1xuICB2YXIgcHJvcHNEZWYgPSB7fTtcbiAgcHJvcHNEZWYuZ2V0ID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpcy5fcHJvcHMgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBkYXRhRGVmLnNldCA9IGZ1bmN0aW9uIChuZXdEYXRhKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnQXZvaWQgcmVwbGFjaW5nIGluc3RhbmNlIHJvb3QgJGRhdGEuICcgK1xuICAgICAgICAnVXNlIG5lc3RlZCBkYXRhIHByb3BlcnRpZXMgaW5zdGVhZC4nLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH07XG4gICAgcHJvcHNEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcIiRwcm9wcyBpcyByZWFkb25seS5cIiwgdGhpcyk7XG4gICAgfTtcbiAgfVxuICBPYmplY3QuZGVmaW5lUHJvcGVydHkoVnVlLnByb3RvdHlwZSwgJyRkYXRhJywgZGF0YURlZik7XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUucHJvdG90eXBlLCAnJHByb3BzJywgcHJvcHNEZWYpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHNldCA9IHNldDtcbiAgVnVlLnByb3RvdHlwZS4kZGVsZXRlID0gZGVsO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJHdhdGNoID0gZnVuY3Rpb24gKFxuICAgIGV4cE9yRm4sXG4gICAgY2IsXG4gICAgb3B0aW9uc1xuICApIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIGlmIChpc1BsYWluT2JqZWN0KGNiKSkge1xuICAgICAgcmV0dXJuIGNyZWF0ZVdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKVxuICAgIH1cbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBvcHRpb25zLnVzZXIgPSB0cnVlO1xuICAgIHZhciB3YXRjaGVyID0gbmV3IFdhdGNoZXIodm0sIGV4cE9yRm4sIGNiLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5pbW1lZGlhdGUpIHtcbiAgICAgIGNiLmNhbGwodm0sIHdhdGNoZXIudmFsdWUpO1xuICAgIH1cbiAgICByZXR1cm4gZnVuY3Rpb24gdW53YXRjaEZuICgpIHtcbiAgICAgIHdhdGNoZXIudGVhcmRvd24oKTtcbiAgICB9XG4gIH07XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0UHJvdmlkZSAodm0pIHtcbiAgdmFyIHByb3ZpZGUgPSB2bS4kb3B0aW9ucy5wcm92aWRlO1xuICBpZiAocHJvdmlkZSkge1xuICAgIHZtLl9wcm92aWRlZCA9IHR5cGVvZiBwcm92aWRlID09PSAnZnVuY3Rpb24nXG4gICAgICA/IHByb3ZpZGUuY2FsbCh2bSlcbiAgICAgIDogcHJvdmlkZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBpbml0SW5qZWN0aW9ucyAodm0pIHtcbiAgdmFyIHJlc3VsdCA9IHJlc29sdmVJbmplY3Qodm0uJG9wdGlvbnMuaW5qZWN0LCB2bSk7XG4gIGlmIChyZXN1bHQpIHtcbiAgICBvYnNlcnZlclN0YXRlLnNob3VsZENvbnZlcnQgPSBmYWxzZTtcbiAgICBPYmplY3Qua2V5cyhyZXN1bHQpLmZvckVhY2goZnVuY3Rpb24gKGtleSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGRlZmluZVJlYWN0aXZlKHZtLCBrZXksIHJlc3VsdFtrZXldLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgIFwiQXZvaWQgbXV0YXRpbmcgYW4gaW5qZWN0ZWQgdmFsdWUgZGlyZWN0bHkgc2luY2UgdGhlIGNoYW5nZXMgd2lsbCBiZSBcIiArXG4gICAgICAgICAgICBcIm92ZXJ3cml0dGVuIHdoZW5ldmVyIHRoZSBwcm92aWRlZCBjb21wb25lbnQgcmUtcmVuZGVycy4gXCIgK1xuICAgICAgICAgICAgXCJpbmplY3Rpb24gYmVpbmcgbXV0YXRlZDogXFxcIlwiICsga2V5ICsgXCJcXFwiXCIsXG4gICAgICAgICAgICB2bVxuICAgICAgICAgICk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgZGVmaW5lUmVhY3RpdmUodm0sIGtleSwgcmVzdWx0W2tleV0pO1xuICAgICAgfVxuICAgIH0pO1xuICAgIG9ic2VydmVyU3RhdGUuc2hvdWxkQ29udmVydCA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUluamVjdCAoaW5qZWN0LCB2bSkge1xuICBpZiAoaW5qZWN0KSB7XG4gICAgLy8gaW5qZWN0IGlzIDphbnkgYmVjYXVzZSBmbG93IGlzIG5vdCBzbWFydCBlbm91Z2ggdG8gZmlndXJlIG91dCBjYWNoZWRcbiAgICB2YXIgcmVzdWx0ID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIga2V5cyA9IGhhc1N5bWJvbFxuICAgICAgICA/IFJlZmxlY3Qub3duS2V5cyhpbmplY3QpLmZpbHRlcihmdW5jdGlvbiAoa2V5KSB7XG4gICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgICAgICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihpbmplY3QsIGtleSkuZW51bWVyYWJsZVxuICAgICAgICB9KVxuICAgICAgICA6IE9iamVjdC5rZXlzKGluamVjdCk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgdmFyIHByb3ZpZGVLZXkgPSBpbmplY3Rba2V5XS5mcm9tO1xuICAgICAgdmFyIHNvdXJjZSA9IHZtO1xuICAgICAgd2hpbGUgKHNvdXJjZSkge1xuICAgICAgICBpZiAoc291cmNlLl9wcm92aWRlZCAmJiBwcm92aWRlS2V5IGluIHNvdXJjZS5fcHJvdmlkZWQpIHtcbiAgICAgICAgICByZXN1bHRba2V5XSA9IHNvdXJjZS5fcHJvdmlkZWRbcHJvdmlkZUtleV07XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgICBzb3VyY2UgPSBzb3VyY2UuJHBhcmVudDtcbiAgICAgIH1cbiAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgIGlmICgnZGVmYXVsdCcgaW4gaW5qZWN0W2tleV0pIHtcbiAgICAgICAgICB2YXIgcHJvdmlkZURlZmF1bHQgPSBpbmplY3Rba2V5XS5kZWZhdWx0O1xuICAgICAgICAgIHJlc3VsdFtrZXldID0gdHlwZW9mIHByb3ZpZGVEZWZhdWx0ID09PSAnZnVuY3Rpb24nXG4gICAgICAgICAgICA/IHByb3ZpZGVEZWZhdWx0LmNhbGwodm0pXG4gICAgICAgICAgICA6IHByb3ZpZGVEZWZhdWx0O1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB3YXJuKChcIkluamVjdGlvbiBcXFwiXCIgKyBrZXkgKyBcIlxcXCIgbm90IGZvdW5kXCIpLCB2bSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdFxuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZW5kZXJpbmcgdi1mb3IgbGlzdHMuXG4gKi9cbmZ1bmN0aW9uIHJlbmRlckxpc3QgKFxuICB2YWwsXG4gIHJlbmRlclxuKSB7XG4gIHZhciByZXQsIGksIGwsIGtleXMsIGtleTtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsKSB8fCB0eXBlb2YgdmFsID09PSAnc3RyaW5nJykge1xuICAgIHJldCA9IG5ldyBBcnJheSh2YWwubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0gdmFsLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgcmV0W2ldID0gcmVuZGVyKHZhbFtpXSwgaSk7XG4gICAgfVxuICB9IGVsc2UgaWYgKHR5cGVvZiB2YWwgPT09ICdudW1iZXInKSB7XG4gICAgcmV0ID0gbmV3IEFycmF5KHZhbCk7XG4gICAgZm9yIChpID0gMDsgaSA8IHZhbDsgaSsrKSB7XG4gICAgICByZXRbaV0gPSByZW5kZXIoaSArIDEsIGkpO1xuICAgIH1cbiAgfSBlbHNlIGlmIChpc09iamVjdCh2YWwpKSB7XG4gICAga2V5cyA9IE9iamVjdC5rZXlzKHZhbCk7XG4gICAgcmV0ID0gbmV3IEFycmF5KGtleXMubGVuZ3RoKTtcbiAgICBmb3IgKGkgPSAwLCBsID0ga2V5cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIGtleSA9IGtleXNbaV07XG4gICAgICByZXRbaV0gPSByZW5kZXIodmFsW2tleV0sIGtleSwgaSk7XG4gICAgfVxuICB9XG4gIGlmIChpc0RlZihyZXQpKSB7XG4gICAgKHJldCkuX2lzVkxpc3QgPSB0cnVlO1xuICB9XG4gIHJldHVybiByZXRcbn1cblxuLyogICovXG5cbi8qKlxuICogUnVudGltZSBoZWxwZXIgZm9yIHJlbmRlcmluZyA8c2xvdD5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU2xvdCAoXG4gIG5hbWUsXG4gIGZhbGxiYWNrLFxuICBwcm9wcyxcbiAgYmluZE9iamVjdFxuKSB7XG4gIHZhciBzY29wZWRTbG90Rm4gPSB0aGlzLiRzY29wZWRTbG90c1tuYW1lXTtcbiAgdmFyIG5vZGVzO1xuICBpZiAoc2NvcGVkU2xvdEZuKSB7IC8vIHNjb3BlZCBzbG90XG4gICAgcHJvcHMgPSBwcm9wcyB8fCB7fTtcbiAgICBpZiAoYmluZE9iamVjdCkge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgIWlzT2JqZWN0KGJpbmRPYmplY3QpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ3Nsb3Qgdi1iaW5kIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QnLFxuICAgICAgICAgIHRoaXNcbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIHByb3BzID0gZXh0ZW5kKGV4dGVuZCh7fSwgYmluZE9iamVjdCksIHByb3BzKTtcbiAgICB9XG4gICAgbm9kZXMgPSBzY29wZWRTbG90Rm4ocHJvcHMpIHx8IGZhbGxiYWNrO1xuICB9IGVsc2Uge1xuICAgIHZhciBzbG90Tm9kZXMgPSB0aGlzLiRzbG90c1tuYW1lXTtcbiAgICAvLyB3YXJuIGR1cGxpY2F0ZSBzbG90IHVzYWdlXG4gICAgaWYgKHNsb3ROb2Rlcykge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgc2xvdE5vZGVzLl9yZW5kZXJlZCkge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwiRHVwbGljYXRlIHByZXNlbmNlIG9mIHNsb3QgXFxcIlwiICsgbmFtZSArIFwiXFxcIiBmb3VuZCBpbiB0aGUgc2FtZSByZW5kZXIgdHJlZSBcIiArXG4gICAgICAgICAgXCItIHRoaXMgd2lsbCBsaWtlbHkgY2F1c2UgcmVuZGVyIGVycm9ycy5cIixcbiAgICAgICAgICB0aGlzXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBzbG90Tm9kZXMuX3JlbmRlcmVkID0gdHJ1ZTtcbiAgICB9XG4gICAgbm9kZXMgPSBzbG90Tm9kZXMgfHwgZmFsbGJhY2s7XG4gIH1cblxuICB2YXIgdGFyZ2V0ID0gcHJvcHMgJiYgcHJvcHMuc2xvdDtcbiAgaWYgKHRhcmdldCkge1xuICAgIHJldHVybiB0aGlzLiRjcmVhdGVFbGVtZW50KCd0ZW1wbGF0ZScsIHsgc2xvdDogdGFyZ2V0IH0sIG5vZGVzKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBub2Rlc1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciByZXNvbHZpbmcgZmlsdGVyc1xuICovXG5mdW5jdGlvbiByZXNvbHZlRmlsdGVyIChpZCkge1xuICByZXR1cm4gcmVzb2x2ZUFzc2V0KHRoaXMuJG9wdGlvbnMsICdmaWx0ZXJzJywgaWQsIHRydWUpIHx8IGlkZW50aXR5XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIFJ1bnRpbWUgaGVscGVyIGZvciBjaGVja2luZyBrZXlDb2RlcyBmcm9tIGNvbmZpZy5cbiAqIGV4cG9zZWQgYXMgVnVlLnByb3RvdHlwZS5fa1xuICogcGFzc2luZyBpbiBldmVudEtleU5hbWUgYXMgbGFzdCBhcmd1bWVudCBzZXBhcmF0ZWx5IGZvciBiYWNrd2FyZHMgY29tcGF0XG4gKi9cbmZ1bmN0aW9uIGNoZWNrS2V5Q29kZXMgKFxuICBldmVudEtleUNvZGUsXG4gIGtleSxcbiAgYnVpbHRJbkFsaWFzLFxuICBldmVudEtleU5hbWVcbikge1xuICB2YXIga2V5Q29kZXMgPSBjb25maWcua2V5Q29kZXNba2V5XSB8fCBidWlsdEluQWxpYXM7XG4gIGlmIChrZXlDb2Rlcykge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGtleUNvZGVzKSkge1xuICAgICAgcmV0dXJuIGtleUNvZGVzLmluZGV4T2YoZXZlbnRLZXlDb2RlKSA9PT0gLTFcbiAgICB9IGVsc2Uge1xuICAgICAgcmV0dXJuIGtleUNvZGVzICE9PSBldmVudEtleUNvZGVcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXZlbnRLZXlOYW1lKSB7XG4gICAgcmV0dXJuIGh5cGhlbmF0ZShldmVudEtleU5hbWUpICE9PSBrZXlcbiAgfVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgbWVyZ2luZyB2LWJpbmQ9XCJvYmplY3RcIiBpbnRvIGEgVk5vZGUncyBkYXRhLlxuICovXG5mdW5jdGlvbiBiaW5kT2JqZWN0UHJvcHMgKFxuICBkYXRhLFxuICB0YWcsXG4gIHZhbHVlLFxuICBhc1Byb3AsXG4gIGlzU3luY1xuKSB7XG4gIGlmICh2YWx1ZSkge1xuICAgIGlmICghaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LWJpbmQgd2l0aG91dCBhcmd1bWVudCBleHBlY3RzIGFuIE9iamVjdCBvciBBcnJheSB2YWx1ZScsXG4gICAgICAgIHRoaXNcbiAgICAgICk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgICB2YWx1ZSA9IHRvT2JqZWN0KHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHZhciBoYXNoO1xuICAgICAgdmFyIGxvb3AgPSBmdW5jdGlvbiAoIGtleSApIHtcbiAgICAgICAgaWYgKFxuICAgICAgICAgIGtleSA9PT0gJ2NsYXNzJyB8fFxuICAgICAgICAgIGtleSA9PT0gJ3N0eWxlJyB8fFxuICAgICAgICAgIGlzUmVzZXJ2ZWRBdHRyaWJ1dGUoa2V5KVxuICAgICAgICApIHtcbiAgICAgICAgICBoYXNoID0gZGF0YTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2YXIgdHlwZSA9IGRhdGEuYXR0cnMgJiYgZGF0YS5hdHRycy50eXBlO1xuICAgICAgICAgIGhhc2ggPSBhc1Byb3AgfHwgY29uZmlnLm11c3RVc2VQcm9wKHRhZywgdHlwZSwga2V5KVxuICAgICAgICAgICAgPyBkYXRhLmRvbVByb3BzIHx8IChkYXRhLmRvbVByb3BzID0ge30pXG4gICAgICAgICAgICA6IGRhdGEuYXR0cnMgfHwgKGRhdGEuYXR0cnMgPSB7fSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCEoa2V5IGluIGhhc2gpKSB7XG4gICAgICAgICAgaGFzaFtrZXldID0gdmFsdWVba2V5XTtcblxuICAgICAgICAgIGlmIChpc1N5bmMpIHtcbiAgICAgICAgICAgIHZhciBvbiA9IGRhdGEub24gfHwgKGRhdGEub24gPSB7fSk7XG4gICAgICAgICAgICBvblsoXCJ1cGRhdGU6XCIgKyBrZXkpXSA9IGZ1bmN0aW9uICgkZXZlbnQpIHtcbiAgICAgICAgICAgICAgdmFsdWVba2V5XSA9ICRldmVudDtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9O1xuXG4gICAgICBmb3IgKHZhciBrZXkgaW4gdmFsdWUpIGxvb3AoIGtleSApO1xuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3IgcmVuZGVyaW5nIHN0YXRpYyB0cmVlcy5cbiAqL1xuZnVuY3Rpb24gcmVuZGVyU3RhdGljIChcbiAgaW5kZXgsXG4gIGlzSW5Gb3IsXG4gIGlzT25jZVxuKSB7XG4gIC8vIHJlbmRlciBmbnMgZ2VuZXJhdGVkIGJ5IGNvbXBpbGVyIDwgMi41LjQgZG9lcyBub3QgcHJvdmlkZSB2LW9uY2VcbiAgLy8gaW5mb3JtYXRpb24gdG8gcnVudGltZSBzbyBiZSBjb25zZXJ2YXRpdmVcbiAgdmFyIGlzT2xkVmVyc2lvbiA9IGFyZ3VtZW50cy5sZW5ndGggPCAzO1xuICAvLyBpZiBhIHN0YXRpYyB0cmVlIGlzIGdlbmVyYXRlZCBieSB2LW9uY2UsIGl0IGlzIGNhY2hlZCBvbiB0aGUgaW5zdGFuY2U7XG4gIC8vIG90aGVyd2lzZSBpdCBpcyBwdXJlbHkgc3RhdGljIGFuZCBjYW4gYmUgY2FjaGVkIG9uIHRoZSBzaGFyZWQgb3B0aW9uc1xuICAvLyBhY3Jvc3MgYWxsIGluc3RhbmNlcy5cbiAgdmFyIHJlbmRlckZucyA9IHRoaXMuJG9wdGlvbnMuc3RhdGljUmVuZGVyRm5zO1xuICB2YXIgY2FjaGVkID0gaXNPbGRWZXJzaW9uIHx8IGlzT25jZVxuICAgID8gKHRoaXMuX3N0YXRpY1RyZWVzIHx8ICh0aGlzLl9zdGF0aWNUcmVlcyA9IFtdKSlcbiAgICA6IChyZW5kZXJGbnMuY2FjaGVkIHx8IChyZW5kZXJGbnMuY2FjaGVkID0gW10pKTtcbiAgdmFyIHRyZWUgPSBjYWNoZWRbaW5kZXhdO1xuICAvLyBpZiBoYXMgYWxyZWFkeS1yZW5kZXJlZCBzdGF0aWMgdHJlZSBhbmQgbm90IGluc2lkZSB2LWZvcixcbiAgLy8gd2UgY2FuIHJldXNlIHRoZSBzYW1lIHRyZWUgYnkgZG9pbmcgYSBzaGFsbG93IGNsb25lLlxuICBpZiAodHJlZSAmJiAhaXNJbkZvcikge1xuICAgIHJldHVybiBBcnJheS5pc0FycmF5KHRyZWUpXG4gICAgICA/IGNsb25lVk5vZGVzKHRyZWUpXG4gICAgICA6IGNsb25lVk5vZGUodHJlZSlcbiAgfVxuICAvLyBvdGhlcndpc2UsIHJlbmRlciBhIGZyZXNoIHRyZWUuXG4gIHRyZWUgPSBjYWNoZWRbaW5kZXhdID0gcmVuZGVyRm5zW2luZGV4XS5jYWxsKHRoaXMuX3JlbmRlclByb3h5LCBudWxsLCB0aGlzKTtcbiAgbWFya1N0YXRpYyh0cmVlLCAoXCJfX3N0YXRpY19fXCIgKyBpbmRleCksIGZhbHNlKTtcbiAgcmV0dXJuIHRyZWVcbn1cblxuLyoqXG4gKiBSdW50aW1lIGhlbHBlciBmb3Igdi1vbmNlLlxuICogRWZmZWN0aXZlbHkgaXQgbWVhbnMgbWFya2luZyB0aGUgbm9kZSBhcyBzdGF0aWMgd2l0aCBhIHVuaXF1ZSBrZXkuXG4gKi9cbmZ1bmN0aW9uIG1hcmtPbmNlIChcbiAgdHJlZSxcbiAgaW5kZXgsXG4gIGtleVxuKSB7XG4gIG1hcmtTdGF0aWModHJlZSwgKFwiX19vbmNlX19cIiArIGluZGV4ICsgKGtleSA/IChcIl9cIiArIGtleSkgOiBcIlwiKSksIHRydWUpO1xuICByZXR1cm4gdHJlZVxufVxuXG5mdW5jdGlvbiBtYXJrU3RhdGljIChcbiAgdHJlZSxcbiAga2V5LFxuICBpc09uY2Vcbikge1xuICBpZiAoQXJyYXkuaXNBcnJheSh0cmVlKSkge1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdHJlZS5sZW5ndGg7IGkrKykge1xuICAgICAgaWYgKHRyZWVbaV0gJiYgdHlwZW9mIHRyZWVbaV0gIT09ICdzdHJpbmcnKSB7XG4gICAgICAgIG1hcmtTdGF0aWNOb2RlKHRyZWVbaV0sIChrZXkgKyBcIl9cIiArIGkpLCBpc09uY2UpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIHtcbiAgICBtYXJrU3RhdGljTm9kZSh0cmVlLCBrZXksIGlzT25jZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFya1N0YXRpY05vZGUgKG5vZGUsIGtleSwgaXNPbmNlKSB7XG4gIG5vZGUuaXNTdGF0aWMgPSB0cnVlO1xuICBub2RlLmtleSA9IGtleTtcbiAgbm9kZS5pc09uY2UgPSBpc09uY2U7XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBiaW5kT2JqZWN0TGlzdGVuZXJzIChkYXRhLCB2YWx1ZSkge1xuICBpZiAodmFsdWUpIHtcbiAgICBpZiAoIWlzUGxhaW5PYmplY3QodmFsdWUpKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICAgICd2LW9uIHdpdGhvdXQgYXJndW1lbnQgZXhwZWN0cyBhbiBPYmplY3QgdmFsdWUnLFxuICAgICAgICB0aGlzXG4gICAgICApO1xuICAgIH0gZWxzZSB7XG4gICAgICB2YXIgb24gPSBkYXRhLm9uID0gZGF0YS5vbiA/IGV4dGVuZCh7fSwgZGF0YS5vbikgOiB7fTtcbiAgICAgIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgICAgICB2YXIgZXhpc3RpbmcgPSBvbltrZXldO1xuICAgICAgICB2YXIgb3VycyA9IHZhbHVlW2tleV07XG4gICAgICAgIG9uW2tleV0gPSBleGlzdGluZyA/IFtdLmNvbmNhdChleGlzdGluZywgb3VycykgOiBvdXJzO1xuICAgICAgfVxuICAgIH1cbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5zdGFsbFJlbmRlckhlbHBlcnMgKHRhcmdldCkge1xuICB0YXJnZXQuX28gPSBtYXJrT25jZTtcbiAgdGFyZ2V0Ll9uID0gdG9OdW1iZXI7XG4gIHRhcmdldC5fcyA9IHRvU3RyaW5nO1xuICB0YXJnZXQuX2wgPSByZW5kZXJMaXN0O1xuICB0YXJnZXQuX3QgPSByZW5kZXJTbG90O1xuICB0YXJnZXQuX3EgPSBsb29zZUVxdWFsO1xuICB0YXJnZXQuX2kgPSBsb29zZUluZGV4T2Y7XG4gIHRhcmdldC5fbSA9IHJlbmRlclN0YXRpYztcbiAgdGFyZ2V0Ll9mID0gcmVzb2x2ZUZpbHRlcjtcbiAgdGFyZ2V0Ll9rID0gY2hlY2tLZXlDb2RlcztcbiAgdGFyZ2V0Ll9iID0gYmluZE9iamVjdFByb3BzO1xuICB0YXJnZXQuX3YgPSBjcmVhdGVUZXh0Vk5vZGU7XG4gIHRhcmdldC5fZSA9IGNyZWF0ZUVtcHR5Vk5vZGU7XG4gIHRhcmdldC5fdSA9IHJlc29sdmVTY29wZWRTbG90cztcbiAgdGFyZ2V0Ll9nID0gYmluZE9iamVjdExpc3RlbmVycztcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIEZ1bmN0aW9uYWxSZW5kZXJDb250ZXh0IChcbiAgZGF0YSxcbiAgcHJvcHMsXG4gIGNoaWxkcmVuLFxuICBwYXJlbnQsXG4gIEN0b3Jcbikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgdGhpcy5kYXRhID0gZGF0YTtcbiAgdGhpcy5wcm9wcyA9IHByb3BzO1xuICB0aGlzLmNoaWxkcmVuID0gY2hpbGRyZW47XG4gIHRoaXMucGFyZW50ID0gcGFyZW50O1xuICB0aGlzLmxpc3RlbmVycyA9IGRhdGEub24gfHwgZW1wdHlPYmplY3Q7XG4gIHRoaXMuaW5qZWN0aW9ucyA9IHJlc29sdmVJbmplY3Qob3B0aW9ucy5pbmplY3QsIHBhcmVudCk7XG4gIHRoaXMuc2xvdHMgPSBmdW5jdGlvbiAoKSB7IHJldHVybiByZXNvbHZlU2xvdHMoY2hpbGRyZW4sIHBhcmVudCk7IH07XG5cbiAgLy8gZW5zdXJlIHRoZSBjcmVhdGVFbGVtZW50IGZ1bmN0aW9uIGluIGZ1bmN0aW9uYWwgY29tcG9uZW50c1xuICAvLyBnZXRzIGEgdW5pcXVlIGNvbnRleHQgLSB0aGlzIGlzIG5lY2Vzc2FyeSBmb3IgY29ycmVjdCBuYW1lZCBzbG90IGNoZWNrXG4gIHZhciBjb250ZXh0Vm0gPSBPYmplY3QuY3JlYXRlKHBhcmVudCk7XG4gIHZhciBpc0NvbXBpbGVkID0gaXNUcnVlKG9wdGlvbnMuX2NvbXBpbGVkKTtcbiAgdmFyIG5lZWROb3JtYWxpemF0aW9uID0gIWlzQ29tcGlsZWQ7XG5cbiAgLy8gc3VwcG9ydCBmb3IgY29tcGlsZWQgZnVuY3Rpb25hbCB0ZW1wbGF0ZVxuICBpZiAoaXNDb21waWxlZCkge1xuICAgIC8vIGV4cG9zaW5nICRvcHRpb25zIGZvciByZW5kZXJTdGF0aWMoKVxuICAgIHRoaXMuJG9wdGlvbnMgPSBvcHRpb25zO1xuICAgIC8vIHByZS1yZXNvbHZlIHNsb3RzIGZvciByZW5kZXJTbG90KClcbiAgICB0aGlzLiRzbG90cyA9IHRoaXMuc2xvdHMoKTtcbiAgICB0aGlzLiRzY29wZWRTbG90cyA9IGRhdGEuc2NvcGVkU2xvdHMgfHwgZW1wdHlPYmplY3Q7XG4gIH1cblxuICBpZiAob3B0aW9ucy5fc2NvcGVJZCkge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgICAgdmFyIHZub2RlID0gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTtcbiAgICAgIGlmICh2bm9kZSkge1xuICAgICAgICB2bm9kZS5mblNjb3BlSWQgPSBvcHRpb25zLl9zY29wZUlkO1xuICAgICAgICB2bm9kZS5mbkNvbnRleHQgPSBwYXJlbnQ7XG4gICAgICB9XG4gICAgICByZXR1cm4gdm5vZGVcbiAgICB9O1xuICB9IGVsc2Uge1xuICAgIHRoaXMuX2MgPSBmdW5jdGlvbiAoYSwgYiwgYywgZCkgeyByZXR1cm4gY3JlYXRlRWxlbWVudChjb250ZXh0Vm0sIGEsIGIsIGMsIGQsIG5lZWROb3JtYWxpemF0aW9uKTsgfTtcbiAgfVxufVxuXG5pbnN0YWxsUmVuZGVySGVscGVycyhGdW5jdGlvbmFsUmVuZGVyQ29udGV4dC5wcm90b3R5cGUpO1xuXG5mdW5jdGlvbiBjcmVhdGVGdW5jdGlvbmFsQ29tcG9uZW50IChcbiAgQ3RvcixcbiAgcHJvcHNEYXRhLFxuICBkYXRhLFxuICBjb250ZXh0Vm0sXG4gIGNoaWxkcmVuXG4pIHtcbiAgdmFyIG9wdGlvbnMgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBwcm9wcyA9IHt9O1xuICB2YXIgcHJvcE9wdGlvbnMgPSBvcHRpb25zLnByb3BzO1xuICBpZiAoaXNEZWYocHJvcE9wdGlvbnMpKSB7XG4gICAgZm9yICh2YXIga2V5IGluIHByb3BPcHRpb25zKSB7XG4gICAgICBwcm9wc1trZXldID0gdmFsaWRhdGVQcm9wKGtleSwgcHJvcE9wdGlvbnMsIHByb3BzRGF0YSB8fCBlbXB0eU9iamVjdCk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0RlZihkYXRhLmF0dHJzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLmF0dHJzKTsgfVxuICAgIGlmIChpc0RlZihkYXRhLnByb3BzKSkgeyBtZXJnZVByb3BzKHByb3BzLCBkYXRhLnByb3BzKTsgfVxuICB9XG5cbiAgdmFyIHJlbmRlckNvbnRleHQgPSBuZXcgRnVuY3Rpb25hbFJlbmRlckNvbnRleHQoXG4gICAgZGF0YSxcbiAgICBwcm9wcyxcbiAgICBjaGlsZHJlbixcbiAgICBjb250ZXh0Vm0sXG4gICAgQ3RvclxuICApO1xuXG4gIHZhciB2bm9kZSA9IG9wdGlvbnMucmVuZGVyLmNhbGwobnVsbCwgcmVuZGVyQ29udGV4dC5fYywgcmVuZGVyQ29udGV4dCk7XG5cbiAgaWYgKHZub2RlIGluc3RhbmNlb2YgVk5vZGUpIHtcbiAgICB2bm9kZS5mbkNvbnRleHQgPSBjb250ZXh0Vm07XG4gICAgdm5vZGUuZm5PcHRpb25zID0gb3B0aW9ucztcbiAgICBpZiAoZGF0YS5zbG90KSB7XG4gICAgICAodm5vZGUuZGF0YSB8fCAodm5vZGUuZGF0YSA9IHt9KSkuc2xvdCA9IGRhdGEuc2xvdDtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gdm5vZGVcbn1cblxuZnVuY3Rpb24gbWVyZ2VQcm9wcyAodG8sIGZyb20pIHtcbiAgZm9yICh2YXIga2V5IGluIGZyb20pIHtcbiAgICB0b1tjYW1lbGl6ZShrZXkpXSA9IGZyb21ba2V5XTtcbiAgfVxufVxuXG4vKiAgKi9cblxuLy8gaG9va3MgdG8gYmUgaW52b2tlZCBvbiBjb21wb25lbnQgVk5vZGVzIGR1cmluZyBwYXRjaFxudmFyIGNvbXBvbmVudFZOb2RlSG9va3MgPSB7XG4gIGluaXQ6IGZ1bmN0aW9uIGluaXQgKFxuICAgIHZub2RlLFxuICAgIGh5ZHJhdGluZyxcbiAgICBwYXJlbnRFbG0sXG4gICAgcmVmRWxtXG4gICkge1xuICAgIGlmICghdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuY29tcG9uZW50SW5zdGFuY2UuX2lzRGVzdHJveWVkKSB7XG4gICAgICB2YXIgY2hpbGQgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNyZWF0ZUNvbXBvbmVudEluc3RhbmNlRm9yVm5vZGUoXG4gICAgICAgIHZub2RlLFxuICAgICAgICBhY3RpdmVJbnN0YW5jZSxcbiAgICAgICAgcGFyZW50RWxtLFxuICAgICAgICByZWZFbG1cbiAgICAgICk7XG4gICAgICBjaGlsZC4kbW91bnQoaHlkcmF0aW5nID8gdm5vZGUuZWxtIDogdW5kZWZpbmVkLCBoeWRyYXRpbmcpO1xuICAgIH0gZWxzZSBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIC8vIGtlcHQtYWxpdmUgY29tcG9uZW50cywgdHJlYXQgYXMgYSBwYXRjaFxuICAgICAgdmFyIG1vdW50ZWROb2RlID0gdm5vZGU7IC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICAgIGNvbXBvbmVudFZOb2RlSG9va3MucHJlcGF0Y2gobW91bnRlZE5vZGUsIG1vdW50ZWROb2RlKTtcbiAgICB9XG4gIH0sXG5cbiAgcHJlcGF0Y2g6IGZ1bmN0aW9uIHByZXBhdGNoIChvbGRWbm9kZSwgdm5vZGUpIHtcbiAgICB2YXIgb3B0aW9ucyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gICAgdmFyIGNoaWxkID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgPSBvbGRWbm9kZS5jb21wb25lbnRJbnN0YW5jZTtcbiAgICB1cGRhdGVDaGlsZENvbXBvbmVudChcbiAgICAgIGNoaWxkLFxuICAgICAgb3B0aW9ucy5wcm9wc0RhdGEsIC8vIHVwZGF0ZWQgcHJvcHNcbiAgICAgIG9wdGlvbnMubGlzdGVuZXJzLCAvLyB1cGRhdGVkIGxpc3RlbmVyc1xuICAgICAgdm5vZGUsIC8vIG5ldyBwYXJlbnQgdm5vZGVcbiAgICAgIG9wdGlvbnMuY2hpbGRyZW4gLy8gbmV3IGNoaWxkcmVuXG4gICAgKTtcbiAgfSxcblxuICBpbnNlcnQ6IGZ1bmN0aW9uIGluc2VydCAodm5vZGUpIHtcbiAgICB2YXIgY29udGV4dCA9IHZub2RlLmNvbnRleHQ7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkKSB7XG4gICAgICBjb21wb25lbnRJbnN0YW5jZS5faXNNb3VudGVkID0gdHJ1ZTtcbiAgICAgIGNhbGxIb29rKGNvbXBvbmVudEluc3RhbmNlLCAnbW91bnRlZCcpO1xuICAgIH1cbiAgICBpZiAodm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgIGlmIChjb250ZXh0Ll9pc01vdW50ZWQpIHtcbiAgICAgICAgLy8gdnVlLXJvdXRlciMxMjEyXG4gICAgICAgIC8vIER1cmluZyB1cGRhdGVzLCBhIGtlcHQtYWxpdmUgY29tcG9uZW50J3MgY2hpbGQgY29tcG9uZW50cyBtYXlcbiAgICAgICAgLy8gY2hhbmdlLCBzbyBkaXJlY3RseSB3YWxraW5nIHRoZSB0cmVlIGhlcmUgbWF5IGNhbGwgYWN0aXZhdGVkIGhvb2tzXG4gICAgICAgIC8vIG9uIGluY29ycmVjdCBjaGlsZHJlbi4gSW5zdGVhZCB3ZSBwdXNoIHRoZW0gaW50byBhIHF1ZXVlIHdoaWNoIHdpbGxcbiAgICAgICAgLy8gYmUgcHJvY2Vzc2VkIGFmdGVyIHRoZSB3aG9sZSBwYXRjaCBwcm9jZXNzIGVuZGVkLlxuICAgICAgICBxdWV1ZUFjdGl2YXRlZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBhY3RpdmF0ZUNoaWxkQ29tcG9uZW50KGNvbXBvbmVudEluc3RhbmNlLCB0cnVlIC8qIGRpcmVjdCAqLyk7XG4gICAgICB9XG4gICAgfVxuICB9LFxuXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIGRlc3Ryb3kgKHZub2RlKSB7XG4gICAgdmFyIGNvbXBvbmVudEluc3RhbmNlID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgaWYgKCFjb21wb25lbnRJbnN0YW5jZS5faXNEZXN0cm95ZWQpIHtcbiAgICAgIGlmICghdm5vZGUuZGF0YS5rZWVwQWxpdmUpIHtcbiAgICAgICAgY29tcG9uZW50SW5zdGFuY2UuJGRlc3Ryb3koKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGRlYWN0aXZhdGVDaGlsZENvbXBvbmVudChjb21wb25lbnRJbnN0YW5jZSwgdHJ1ZSAvKiBkaXJlY3QgKi8pO1xuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxudmFyIGhvb2tzVG9NZXJnZSA9IE9iamVjdC5rZXlzKGNvbXBvbmVudFZOb2RlSG9va3MpO1xuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnQgKFxuICBDdG9yLFxuICBkYXRhLFxuICBjb250ZXh0LFxuICBjaGlsZHJlbixcbiAgdGFnXG4pIHtcbiAgaWYgKGlzVW5kZWYoQ3RvcikpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIHZhciBiYXNlQ3RvciA9IGNvbnRleHQuJG9wdGlvbnMuX2Jhc2U7XG5cbiAgLy8gcGxhaW4gb3B0aW9ucyBvYmplY3Q6IHR1cm4gaXQgaW50byBhIGNvbnN0cnVjdG9yXG4gIGlmIChpc09iamVjdChDdG9yKSkge1xuICAgIEN0b3IgPSBiYXNlQ3Rvci5leHRlbmQoQ3Rvcik7XG4gIH1cblxuICAvLyBpZiBhdCB0aGlzIHN0YWdlIGl0J3Mgbm90IGEgY29uc3RydWN0b3Igb3IgYW4gYXN5bmMgY29tcG9uZW50IGZhY3RvcnksXG4gIC8vIHJlamVjdC5cbiAgaWYgKHR5cGVvZiBDdG9yICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIHdhcm4oKFwiSW52YWxpZCBDb21wb25lbnQgZGVmaW5pdGlvbjogXCIgKyAoU3RyaW5nKEN0b3IpKSksIGNvbnRleHQpO1xuICAgIH1cbiAgICByZXR1cm5cbiAgfVxuXG4gIC8vIGFzeW5jIGNvbXBvbmVudFxuICB2YXIgYXN5bmNGYWN0b3J5O1xuICBpZiAoaXNVbmRlZihDdG9yLmNpZCkpIHtcbiAgICBhc3luY0ZhY3RvcnkgPSBDdG9yO1xuICAgIEN0b3IgPSByZXNvbHZlQXN5bmNDb21wb25lbnQoYXN5bmNGYWN0b3J5LCBiYXNlQ3RvciwgY29udGV4dCk7XG4gICAgaWYgKEN0b3IgPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gcmV0dXJuIGEgcGxhY2Vob2xkZXIgbm9kZSBmb3IgYXN5bmMgY29tcG9uZW50LCB3aGljaCBpcyByZW5kZXJlZFxuICAgICAgLy8gYXMgYSBjb21tZW50IG5vZGUgYnV0IHByZXNlcnZlcyBhbGwgdGhlIHJhdyBpbmZvcm1hdGlvbiBmb3IgdGhlIG5vZGUuXG4gICAgICAvLyB0aGUgaW5mb3JtYXRpb24gd2lsbCBiZSB1c2VkIGZvciBhc3luYyBzZXJ2ZXItcmVuZGVyaW5nIGFuZCBoeWRyYXRpb24uXG4gICAgICByZXR1cm4gY3JlYXRlQXN5bmNQbGFjZWhvbGRlcihcbiAgICAgICAgYXN5bmNGYWN0b3J5LFxuICAgICAgICBkYXRhLFxuICAgICAgICBjb250ZXh0LFxuICAgICAgICBjaGlsZHJlbixcbiAgICAgICAgdGFnXG4gICAgICApXG4gICAgfVxuICB9XG5cbiAgZGF0YSA9IGRhdGEgfHwge307XG5cbiAgLy8gcmVzb2x2ZSBjb25zdHJ1Y3RvciBvcHRpb25zIGluIGNhc2UgZ2xvYmFsIG1peGlucyBhcmUgYXBwbGllZCBhZnRlclxuICAvLyBjb21wb25lbnQgY29uc3RydWN0b3IgY3JlYXRpb25cbiAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yKTtcblxuICAvLyB0cmFuc2Zvcm0gY29tcG9uZW50IHYtbW9kZWwgZGF0YSBpbnRvIHByb3BzICYgZXZlbnRzXG4gIGlmIChpc0RlZihkYXRhLm1vZGVsKSkge1xuICAgIHRyYW5zZm9ybU1vZGVsKEN0b3Iub3B0aW9ucywgZGF0YSk7XG4gIH1cblxuICAvLyBleHRyYWN0IHByb3BzXG4gIHZhciBwcm9wc0RhdGEgPSBleHRyYWN0UHJvcHNGcm9tVk5vZGVEYXRhKGRhdGEsIEN0b3IsIHRhZyk7XG5cbiAgLy8gZnVuY3Rpb25hbCBjb21wb25lbnRcbiAgaWYgKGlzVHJ1ZShDdG9yLm9wdGlvbnMuZnVuY3Rpb25hbCkpIHtcbiAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb25hbENvbXBvbmVudChDdG9yLCBwcm9wc0RhdGEsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuKVxuICB9XG5cbiAgLy8gZXh0cmFjdCBsaXN0ZW5lcnMsIHNpbmNlIHRoZXNlIG5lZWRzIHRvIGJlIHRyZWF0ZWQgYXNcbiAgLy8gY2hpbGQgY29tcG9uZW50IGxpc3RlbmVycyBpbnN0ZWFkIG9mIERPTSBsaXN0ZW5lcnNcbiAgdmFyIGxpc3RlbmVycyA9IGRhdGEub247XG4gIC8vIHJlcGxhY2Ugd2l0aCBsaXN0ZW5lcnMgd2l0aCAubmF0aXZlIG1vZGlmaWVyXG4gIC8vIHNvIGl0IGdldHMgcHJvY2Vzc2VkIGR1cmluZyBwYXJlbnQgY29tcG9uZW50IHBhdGNoLlxuICBkYXRhLm9uID0gZGF0YS5uYXRpdmVPbjtcblxuICBpZiAoaXNUcnVlKEN0b3Iub3B0aW9ucy5hYnN0cmFjdCkpIHtcbiAgICAvLyBhYnN0cmFjdCBjb21wb25lbnRzIGRvIG5vdCBrZWVwIGFueXRoaW5nXG4gICAgLy8gb3RoZXIgdGhhbiBwcm9wcyAmIGxpc3RlbmVycyAmIHNsb3RcblxuICAgIC8vIHdvcmsgYXJvdW5kIGZsb3dcbiAgICB2YXIgc2xvdCA9IGRhdGEuc2xvdDtcbiAgICBkYXRhID0ge307XG4gICAgaWYgKHNsb3QpIHtcbiAgICAgIGRhdGEuc2xvdCA9IHNsb3Q7XG4gICAgfVxuICB9XG5cbiAgLy8gbWVyZ2UgY29tcG9uZW50IG1hbmFnZW1lbnQgaG9va3Mgb250byB0aGUgcGxhY2Vob2xkZXIgbm9kZVxuICBtZXJnZUhvb2tzKGRhdGEpO1xuXG4gIC8vIHJldHVybiBhIHBsYWNlaG9sZGVyIHZub2RlXG4gIHZhciBuYW1lID0gQ3Rvci5vcHRpb25zLm5hbWUgfHwgdGFnO1xuICB2YXIgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgKFwidnVlLWNvbXBvbmVudC1cIiArIChDdG9yLmNpZCkgKyAobmFtZSA/IChcIi1cIiArIG5hbWUpIDogJycpKSxcbiAgICBkYXRhLCB1bmRlZmluZWQsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0LFxuICAgIHsgQ3RvcjogQ3RvciwgcHJvcHNEYXRhOiBwcm9wc0RhdGEsIGxpc3RlbmVyczogbGlzdGVuZXJzLCB0YWc6IHRhZywgY2hpbGRyZW46IGNoaWxkcmVuIH0sXG4gICAgYXN5bmNGYWN0b3J5XG4gICk7XG4gIHJldHVybiB2bm9kZVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21wb25lbnRJbnN0YW5jZUZvclZub2RlIChcbiAgdm5vZGUsIC8vIHdlIGtub3cgaXQncyBNb3VudGVkQ29tcG9uZW50Vk5vZGUgYnV0IGZsb3cgZG9lc24ndFxuICBwYXJlbnQsIC8vIGFjdGl2ZUluc3RhbmNlIGluIGxpZmVjeWNsZSBzdGF0ZVxuICBwYXJlbnRFbG0sXG4gIHJlZkVsbVxuKSB7XG4gIHZhciB2bm9kZUNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICB2YXIgb3B0aW9ucyA9IHtcbiAgICBfaXNDb21wb25lbnQ6IHRydWUsXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgcHJvcHNEYXRhOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhLFxuICAgIF9jb21wb25lbnRUYWc6IHZub2RlQ29tcG9uZW50T3B0aW9ucy50YWcsXG4gICAgX3BhcmVudFZub2RlOiB2bm9kZSxcbiAgICBfcGFyZW50TGlzdGVuZXJzOiB2bm9kZUNvbXBvbmVudE9wdGlvbnMubGlzdGVuZXJzLFxuICAgIF9yZW5kZXJDaGlsZHJlbjogdm5vZGVDb21wb25lbnRPcHRpb25zLmNoaWxkcmVuLFxuICAgIF9wYXJlbnRFbG06IHBhcmVudEVsbSB8fCBudWxsLFxuICAgIF9yZWZFbG06IHJlZkVsbSB8fCBudWxsXG4gIH07XG4gIC8vIGNoZWNrIGlubGluZS10ZW1wbGF0ZSByZW5kZXIgZnVuY3Rpb25zXG4gIHZhciBpbmxpbmVUZW1wbGF0ZSA9IHZub2RlLmRhdGEuaW5saW5lVGVtcGxhdGU7XG4gIGlmIChpc0RlZihpbmxpbmVUZW1wbGF0ZSkpIHtcbiAgICBvcHRpb25zLnJlbmRlciA9IGlubGluZVRlbXBsYXRlLnJlbmRlcjtcbiAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IGlubGluZVRlbXBsYXRlLnN0YXRpY1JlbmRlckZucztcbiAgfVxuICByZXR1cm4gbmV3IHZub2RlQ29tcG9uZW50T3B0aW9ucy5DdG9yKG9wdGlvbnMpXG59XG5cbmZ1bmN0aW9uIG1lcmdlSG9va3MgKGRhdGEpIHtcbiAgaWYgKCFkYXRhLmhvb2spIHtcbiAgICBkYXRhLmhvb2sgPSB7fTtcbiAgfVxuICBmb3IgKHZhciBpID0gMDsgaSA8IGhvb2tzVG9NZXJnZS5sZW5ndGg7IGkrKykge1xuICAgIHZhciBrZXkgPSBob29rc1RvTWVyZ2VbaV07XG4gICAgdmFyIGZyb21QYXJlbnQgPSBkYXRhLmhvb2tba2V5XTtcbiAgICB2YXIgb3VycyA9IGNvbXBvbmVudFZOb2RlSG9va3Nba2V5XTtcbiAgICBkYXRhLmhvb2tba2V5XSA9IGZyb21QYXJlbnQgPyBtZXJnZUhvb2skMShvdXJzLCBmcm9tUGFyZW50KSA6IG91cnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWVyZ2VIb29rJDEgKG9uZSwgdHdvKSB7XG4gIHJldHVybiBmdW5jdGlvbiAoYSwgYiwgYywgZCkge1xuICAgIG9uZShhLCBiLCBjLCBkKTtcbiAgICB0d28oYSwgYiwgYywgZCk7XG4gIH1cbn1cblxuLy8gdHJhbnNmb3JtIGNvbXBvbmVudCB2LW1vZGVsIGluZm8gKHZhbHVlIGFuZCBjYWxsYmFjaykgaW50b1xuLy8gcHJvcCBhbmQgZXZlbnQgaGFuZGxlciByZXNwZWN0aXZlbHkuXG5mdW5jdGlvbiB0cmFuc2Zvcm1Nb2RlbCAob3B0aW9ucywgZGF0YSkge1xuICB2YXIgcHJvcCA9IChvcHRpb25zLm1vZGVsICYmIG9wdGlvbnMubW9kZWwucHJvcCkgfHwgJ3ZhbHVlJztcbiAgdmFyIGV2ZW50ID0gKG9wdGlvbnMubW9kZWwgJiYgb3B0aW9ucy5tb2RlbC5ldmVudCkgfHwgJ2lucHV0JzsoZGF0YS5wcm9wcyB8fCAoZGF0YS5wcm9wcyA9IHt9KSlbcHJvcF0gPSBkYXRhLm1vZGVsLnZhbHVlO1xuICB2YXIgb24gPSBkYXRhLm9uIHx8IChkYXRhLm9uID0ge30pO1xuICBpZiAoaXNEZWYob25bZXZlbnRdKSkge1xuICAgIG9uW2V2ZW50XSA9IFtkYXRhLm1vZGVsLmNhbGxiYWNrXS5jb25jYXQob25bZXZlbnRdKTtcbiAgfSBlbHNlIHtcbiAgICBvbltldmVudF0gPSBkYXRhLm1vZGVsLmNhbGxiYWNrO1xuICB9XG59XG5cbi8qICAqL1xuXG52YXIgU0lNUExFX05PUk1BTElaRSA9IDE7XG52YXIgQUxXQVlTX05PUk1BTElaRSA9IDI7XG5cbi8vIHdyYXBwZXIgZnVuY3Rpb24gZm9yIHByb3ZpZGluZyBhIG1vcmUgZmxleGlibGUgaW50ZXJmYWNlXG4vLyB3aXRob3V0IGdldHRpbmcgeWVsbGVkIGF0IGJ5IGZsb3dcbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnQgKFxuICBjb250ZXh0LFxuICB0YWcsXG4gIGRhdGEsXG4gIGNoaWxkcmVuLFxuICBub3JtYWxpemF0aW9uVHlwZSxcbiAgYWx3YXlzTm9ybWFsaXplXG4pIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoZGF0YSkgfHwgaXNQcmltaXRpdmUoZGF0YSkpIHtcbiAgICBub3JtYWxpemF0aW9uVHlwZSA9IGNoaWxkcmVuO1xuICAgIGNoaWxkcmVuID0gZGF0YTtcbiAgICBkYXRhID0gdW5kZWZpbmVkO1xuICB9XG4gIGlmIChpc1RydWUoYWx3YXlzTm9ybWFsaXplKSkge1xuICAgIG5vcm1hbGl6YXRpb25UeXBlID0gQUxXQVlTX05PUk1BTElaRTtcbiAgfVxuICByZXR1cm4gX2NyZWF0ZUVsZW1lbnQoY29udGV4dCwgdGFnLCBkYXRhLCBjaGlsZHJlbiwgbm9ybWFsaXphdGlvblR5cGUpXG59XG5cbmZ1bmN0aW9uIF9jcmVhdGVFbGVtZW50IChcbiAgY29udGV4dCxcbiAgdGFnLFxuICBkYXRhLFxuICBjaGlsZHJlbixcbiAgbm9ybWFsaXphdGlvblR5cGVcbikge1xuICBpZiAoaXNEZWYoZGF0YSkgJiYgaXNEZWYoKGRhdGEpLl9fb2JfXykpIHtcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4oXG4gICAgICBcIkF2b2lkIHVzaW5nIG9ic2VydmVkIGRhdGEgb2JqZWN0IGFzIHZub2RlIGRhdGE6IFwiICsgKEpTT04uc3RyaW5naWZ5KGRhdGEpKSArIFwiXFxuXCIgK1xuICAgICAgJ0Fsd2F5cyBjcmVhdGUgZnJlc2ggdm5vZGUgZGF0YSBvYmplY3RzIGluIGVhY2ggcmVuZGVyIScsXG4gICAgICBjb250ZXh0XG4gICAgKTtcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gb2JqZWN0IHN5bnRheCBpbiB2LWJpbmRcbiAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGRhdGEuaXMpKSB7XG4gICAgdGFnID0gZGF0YS5pcztcbiAgfVxuICBpZiAoIXRhZykge1xuICAgIC8vIGluIGNhc2Ugb2YgY29tcG9uZW50IDppcyBzZXQgdG8gZmFsc3kgdmFsdWVcbiAgICByZXR1cm4gY3JlYXRlRW1wdHlWTm9kZSgpXG4gIH1cbiAgLy8gd2FybiBhZ2FpbnN0IG5vbi1wcmltaXRpdmUga2V5XG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgaXNEZWYoZGF0YSkgJiYgaXNEZWYoZGF0YS5rZXkpICYmICFpc1ByaW1pdGl2ZShkYXRhLmtleSlcbiAgKSB7XG4gICAgd2FybihcbiAgICAgICdBdm9pZCB1c2luZyBub24tcHJpbWl0aXZlIHZhbHVlIGFzIGtleSwgJyArXG4gICAgICAndXNlIHN0cmluZy9udW1iZXIgdmFsdWUgaW5zdGVhZC4nLFxuICAgICAgY29udGV4dFxuICAgICk7XG4gIH1cbiAgLy8gc3VwcG9ydCBzaW5nbGUgZnVuY3Rpb24gY2hpbGRyZW4gYXMgZGVmYXVsdCBzY29wZWQgc2xvdFxuICBpZiAoQXJyYXkuaXNBcnJheShjaGlsZHJlbikgJiZcbiAgICB0eXBlb2YgY2hpbGRyZW5bMF0gPT09ICdmdW5jdGlvbidcbiAgKSB7XG4gICAgZGF0YSA9IGRhdGEgfHwge307XG4gICAgZGF0YS5zY29wZWRTbG90cyA9IHsgZGVmYXVsdDogY2hpbGRyZW5bMF0gfTtcbiAgICBjaGlsZHJlbi5sZW5ndGggPSAwO1xuICB9XG4gIGlmIChub3JtYWxpemF0aW9uVHlwZSA9PT0gQUxXQVlTX05PUk1BTElaRSkge1xuICAgIGNoaWxkcmVuID0gbm9ybWFsaXplQ2hpbGRyZW4oY2hpbGRyZW4pO1xuICB9IGVsc2UgaWYgKG5vcm1hbGl6YXRpb25UeXBlID09PSBTSU1QTEVfTk9STUFMSVpFKSB7XG4gICAgY2hpbGRyZW4gPSBzaW1wbGVOb3JtYWxpemVDaGlsZHJlbihjaGlsZHJlbik7XG4gIH1cbiAgdmFyIHZub2RlLCBucztcbiAgaWYgKHR5cGVvZiB0YWcgPT09ICdzdHJpbmcnKSB7XG4gICAgdmFyIEN0b3I7XG4gICAgbnMgPSAoY29udGV4dC4kdm5vZGUgJiYgY29udGV4dC4kdm5vZGUubnMpIHx8IGNvbmZpZy5nZXRUYWdOYW1lc3BhY2UodGFnKTtcbiAgICBpZiAoY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgICAgLy8gcGxhdGZvcm0gYnVpbHQtaW4gZWxlbWVudHNcbiAgICAgIHZub2RlID0gbmV3IFZOb2RlKFxuICAgICAgICBjb25maWcucGFyc2VQbGF0Zm9ybVRhZ05hbWUodGFnKSwgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH0gZWxzZSBpZiAoaXNEZWYoQ3RvciA9IHJlc29sdmVBc3NldChjb250ZXh0LiRvcHRpb25zLCAnY29tcG9uZW50cycsIHRhZykpKSB7XG4gICAgICAvLyBjb21wb25lbnRcbiAgICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KEN0b3IsIGRhdGEsIGNvbnRleHQsIGNoaWxkcmVuLCB0YWcpO1xuICAgIH0gZWxzZSB7XG4gICAgICAvLyB1bmtub3duIG9yIHVubGlzdGVkIG5hbWVzcGFjZWQgZWxlbWVudHNcbiAgICAgIC8vIGNoZWNrIGF0IHJ1bnRpbWUgYmVjYXVzZSBpdCBtYXkgZ2V0IGFzc2lnbmVkIGEgbmFtZXNwYWNlIHdoZW4gaXRzXG4gICAgICAvLyBwYXJlbnQgbm9ybWFsaXplcyBjaGlsZHJlblxuICAgICAgdm5vZGUgPSBuZXcgVk5vZGUoXG4gICAgICAgIHRhZywgZGF0YSwgY2hpbGRyZW4sXG4gICAgICAgIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBjb250ZXh0XG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICAvLyBkaXJlY3QgY29tcG9uZW50IG9wdGlvbnMgLyBjb25zdHJ1Y3RvclxuICAgIHZub2RlID0gY3JlYXRlQ29tcG9uZW50KHRhZywgZGF0YSwgY29udGV4dCwgY2hpbGRyZW4pO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZSkpIHtcbiAgICBpZiAobnMpIHsgYXBwbHlOUyh2bm9kZSwgbnMpOyB9XG4gICAgcmV0dXJuIHZub2RlXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIGNyZWF0ZUVtcHR5Vk5vZGUoKVxuICB9XG59XG5cbmZ1bmN0aW9uIGFwcGx5TlMgKHZub2RlLCBucywgZm9yY2UpIHtcbiAgdm5vZGUubnMgPSBucztcbiAgaWYgKHZub2RlLnRhZyA9PT0gJ2ZvcmVpZ25PYmplY3QnKSB7XG4gICAgLy8gdXNlIGRlZmF1bHQgbmFtZXNwYWNlIGluc2lkZSBmb3JlaWduT2JqZWN0XG4gICAgbnMgPSB1bmRlZmluZWQ7XG4gICAgZm9yY2UgPSB0cnVlO1xuICB9XG4gIGlmIChpc0RlZih2bm9kZS5jaGlsZHJlbikpIHtcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHZub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgdmFyIGNoaWxkID0gdm5vZGUuY2hpbGRyZW5baV07XG4gICAgICBpZiAoaXNEZWYoY2hpbGQudGFnKSAmJiAoaXNVbmRlZihjaGlsZC5ucykgfHwgaXNUcnVlKGZvcmNlKSkpIHtcbiAgICAgICAgYXBwbHlOUyhjaGlsZCwgbnMsIGZvcmNlKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRSZW5kZXIgKHZtKSB7XG4gIHZtLl92bm9kZSA9IG51bGw7IC8vIHRoZSByb290IG9mIHRoZSBjaGlsZCB0cmVlXG4gIHZtLl9zdGF0aWNUcmVlcyA9IG51bGw7IC8vIHYtb25jZSBjYWNoZWQgdHJlZXNcbiAgdmFyIG9wdGlvbnMgPSB2bS4kb3B0aW9ucztcbiAgdmFyIHBhcmVudFZub2RlID0gdm0uJHZub2RlID0gb3B0aW9ucy5fcGFyZW50Vm5vZGU7IC8vIHRoZSBwbGFjZWhvbGRlciBub2RlIGluIHBhcmVudCB0cmVlXG4gIHZhciByZW5kZXJDb250ZXh0ID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuY29udGV4dDtcbiAgdm0uJHNsb3RzID0gcmVzb2x2ZVNsb3RzKG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuLCByZW5kZXJDb250ZXh0KTtcbiAgdm0uJHNjb3BlZFNsb3RzID0gZW1wdHlPYmplY3Q7XG4gIC8vIGJpbmQgdGhlIGNyZWF0ZUVsZW1lbnQgZm4gdG8gdGhpcyBpbnN0YW5jZVxuICAvLyBzbyB0aGF0IHdlIGdldCBwcm9wZXIgcmVuZGVyIGNvbnRleHQgaW5zaWRlIGl0LlxuICAvLyBhcmdzIG9yZGVyOiB0YWcsIGRhdGEsIGNoaWxkcmVuLCBub3JtYWxpemF0aW9uVHlwZSwgYWx3YXlzTm9ybWFsaXplXG4gIC8vIGludGVybmFsIHZlcnNpb24gaXMgdXNlZCBieSByZW5kZXIgZnVuY3Rpb25zIGNvbXBpbGVkIGZyb20gdGVtcGxhdGVzXG4gIHZtLl9jID0gZnVuY3Rpb24gKGEsIGIsIGMsIGQpIHsgcmV0dXJuIGNyZWF0ZUVsZW1lbnQodm0sIGEsIGIsIGMsIGQsIGZhbHNlKTsgfTtcbiAgLy8gbm9ybWFsaXphdGlvbiBpcyBhbHdheXMgYXBwbGllZCBmb3IgdGhlIHB1YmxpYyB2ZXJzaW9uLCB1c2VkIGluXG4gIC8vIHVzZXItd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zLlxuICB2bS4kY3JlYXRlRWxlbWVudCA9IGZ1bmN0aW9uIChhLCBiLCBjLCBkKSB7IHJldHVybiBjcmVhdGVFbGVtZW50KHZtLCBhLCBiLCBjLCBkLCB0cnVlKTsgfTtcblxuICAvLyAkYXR0cnMgJiAkbGlzdGVuZXJzIGFyZSBleHBvc2VkIGZvciBlYXNpZXIgSE9DIGNyZWF0aW9uLlxuICAvLyB0aGV5IG5lZWQgdG8gYmUgcmVhY3RpdmUgc28gdGhhdCBIT0NzIHVzaW5nIHRoZW0gYXJlIGFsd2F5cyB1cGRhdGVkXG4gIHZhciBwYXJlbnREYXRhID0gcGFyZW50Vm5vZGUgJiYgcGFyZW50Vm5vZGUuZGF0YTtcblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgIGRlZmluZVJlYWN0aXZlKHZtLCAnJGF0dHJzJywgcGFyZW50RGF0YSAmJiBwYXJlbnREYXRhLmF0dHJzIHx8IGVtcHR5T2JqZWN0LCBmdW5jdGlvbiAoKSB7XG4gICAgICAhaXNVcGRhdGluZ0NoaWxkQ29tcG9uZW50ICYmIHdhcm4oXCIkYXR0cnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRsaXN0ZW5lcnMnLCBvcHRpb25zLl9wYXJlbnRMaXN0ZW5lcnMgfHwgZW1wdHlPYmplY3QsIGZ1bmN0aW9uICgpIHtcbiAgICAgICFpc1VwZGF0aW5nQ2hpbGRDb21wb25lbnQgJiYgd2FybihcIiRsaXN0ZW5lcnMgaXMgcmVhZG9ubHkuXCIsIHZtKTtcbiAgICB9LCB0cnVlKTtcbiAgfSBlbHNlIHtcbiAgICBkZWZpbmVSZWFjdGl2ZSh2bSwgJyRhdHRycycsIHBhcmVudERhdGEgJiYgcGFyZW50RGF0YS5hdHRycyB8fCBlbXB0eU9iamVjdCwgbnVsbCwgdHJ1ZSk7XG4gICAgZGVmaW5lUmVhY3RpdmUodm0sICckbGlzdGVuZXJzJywgb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzIHx8IGVtcHR5T2JqZWN0LCBudWxsLCB0cnVlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiByZW5kZXJNaXhpbiAoVnVlKSB7XG4gIC8vIGluc3RhbGwgcnVudGltZSBjb252ZW5pZW5jZSBoZWxwZXJzXG4gIGluc3RhbGxSZW5kZXJIZWxwZXJzKFZ1ZS5wcm90b3R5cGUpO1xuXG4gIFZ1ZS5wcm90b3R5cGUuJG5leHRUaWNrID0gZnVuY3Rpb24gKGZuKSB7XG4gICAgcmV0dXJuIG5leHRUaWNrKGZuLCB0aGlzKVxuICB9O1xuXG4gIFZ1ZS5wcm90b3R5cGUuX3JlbmRlciA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIHZhciByZWYgPSB2bS4kb3B0aW9ucztcbiAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICB2YXIgX3BhcmVudFZub2RlID0gcmVmLl9wYXJlbnRWbm9kZTtcblxuICAgIGlmICh2bS5faXNNb3VudGVkKSB7XG4gICAgICAvLyBpZiB0aGUgcGFyZW50IGRpZG4ndCB1cGRhdGUsIHRoZSBzbG90IG5vZGVzIHdpbGwgYmUgdGhlIG9uZXMgZnJvbVxuICAgICAgLy8gbGFzdCByZW5kZXIuIFRoZXkgbmVlZCB0byBiZSBjbG9uZWQgdG8gZW5zdXJlIFwiZnJlc2huZXNzXCIgZm9yIHRoaXMgcmVuZGVyLlxuICAgICAgZm9yICh2YXIga2V5IGluIHZtLiRzbG90cykge1xuICAgICAgICB2YXIgc2xvdCA9IHZtLiRzbG90c1trZXldO1xuICAgICAgICAvLyBfcmVuZGVyZWQgaXMgYSBmbGFnIGFkZGVkIGJ5IHJlbmRlclNsb3QsIGJ1dCBtYXkgbm90IGJlIHByZXNlbnRcbiAgICAgICAgLy8gaWYgdGhlIHNsb3QgaXMgcGFzc2VkIGZyb20gbWFudWFsbHkgd3JpdHRlbiByZW5kZXIgZnVuY3Rpb25zXG4gICAgICAgIGlmIChzbG90Ll9yZW5kZXJlZCB8fCAoc2xvdFswXSAmJiBzbG90WzBdLmVsbSkpIHtcbiAgICAgICAgICB2bS4kc2xvdHNba2V5XSA9IGNsb25lVk5vZGVzKHNsb3QsIHRydWUgLyogZGVlcCAqLyk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICB2bS4kc2NvcGVkU2xvdHMgPSAoX3BhcmVudFZub2RlICYmIF9wYXJlbnRWbm9kZS5kYXRhLnNjb3BlZFNsb3RzKSB8fCBlbXB0eU9iamVjdDtcblxuICAgIC8vIHNldCBwYXJlbnQgdm5vZGUuIHRoaXMgYWxsb3dzIHJlbmRlciBmdW5jdGlvbnMgdG8gaGF2ZSBhY2Nlc3NcbiAgICAvLyB0byB0aGUgZGF0YSBvbiB0aGUgcGxhY2Vob2xkZXIgbm9kZS5cbiAgICB2bS4kdm5vZGUgPSBfcGFyZW50Vm5vZGU7XG4gICAgLy8gcmVuZGVyIHNlbGZcbiAgICB2YXIgdm5vZGU7XG4gICAgdHJ5IHtcbiAgICAgIHZub2RlID0gcmVuZGVyLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyXCIpO1xuICAgICAgLy8gcmV0dXJuIGVycm9yIHJlbmRlciByZXN1bHQsXG4gICAgICAvLyBvciBwcmV2aW91cyB2bm9kZSB0byBwcmV2ZW50IHJlbmRlciBlcnJvciBjYXVzaW5nIGJsYW5rIGNvbXBvbmVudFxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGVsc2UgKi9cbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmICh2bS4kb3B0aW9ucy5yZW5kZXJFcnJvcikge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLiRvcHRpb25zLnJlbmRlckVycm9yLmNhbGwodm0uX3JlbmRlclByb3h5LCB2bS4kY3JlYXRlRWxlbWVudCwgZSk7XG4gICAgICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICAgICAgaGFuZGxlRXJyb3IoZSwgdm0sIFwicmVuZGVyRXJyb3JcIik7XG4gICAgICAgICAgICB2bm9kZSA9IHZtLl92bm9kZTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgdm5vZGUgPSB2bS5fdm5vZGU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHZub2RlID0gdm0uX3Zub2RlO1xuICAgICAgfVxuICAgIH1cbiAgICAvLyByZXR1cm4gZW1wdHkgdm5vZGUgaW4gY2FzZSB0aGUgcmVuZGVyIGZ1bmN0aW9uIGVycm9yZWQgb3V0XG4gICAgaWYgKCEodm5vZGUgaW5zdGFuY2VvZiBWTm9kZSkpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIEFycmF5LmlzQXJyYXkodm5vZGUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ011bHRpcGxlIHJvb3Qgbm9kZXMgcmV0dXJuZWQgZnJvbSByZW5kZXIgZnVuY3Rpb24uIFJlbmRlciBmdW5jdGlvbiAnICtcbiAgICAgICAgICAnc2hvdWxkIHJldHVybiBhIHNpbmdsZSByb290IG5vZGUuJyxcbiAgICAgICAgICB2bVxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgdm5vZGUgPSBjcmVhdGVFbXB0eVZOb2RlKCk7XG4gICAgfVxuICAgIC8vIHNldCBwYXJlbnRcbiAgICB2bm9kZS5wYXJlbnQgPSBfcGFyZW50Vm5vZGU7XG4gICAgcmV0dXJuIHZub2RlXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgdWlkJDEgPSAwO1xuXG5mdW5jdGlvbiBpbml0TWl4aW4gKFZ1ZSkge1xuICBWdWUucHJvdG90eXBlLl9pbml0ID0gZnVuY3Rpb24gKG9wdGlvbnMpIHtcbiAgICB2YXIgdm0gPSB0aGlzO1xuICAgIC8vIGEgdWlkXG4gICAgdm0uX3VpZCA9IHVpZCQxKys7XG5cbiAgICB2YXIgc3RhcnRUYWcsIGVuZFRhZztcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgc3RhcnRUYWcgPSBcInZ1ZS1wZXJmLXN0YXJ0OlwiICsgKHZtLl91aWQpO1xuICAgICAgZW5kVGFnID0gXCJ2dWUtcGVyZi1lbmQ6XCIgKyAodm0uX3VpZCk7XG4gICAgICBtYXJrKHN0YXJ0VGFnKTtcbiAgICB9XG5cbiAgICAvLyBhIGZsYWcgdG8gYXZvaWQgdGhpcyBiZWluZyBvYnNlcnZlZFxuICAgIHZtLl9pc1Z1ZSA9IHRydWU7XG4gICAgLy8gbWVyZ2Ugb3B0aW9uc1xuICAgIGlmIChvcHRpb25zICYmIG9wdGlvbnMuX2lzQ29tcG9uZW50KSB7XG4gICAgICAvLyBvcHRpbWl6ZSBpbnRlcm5hbCBjb21wb25lbnQgaW5zdGFudGlhdGlvblxuICAgICAgLy8gc2luY2UgZHluYW1pYyBvcHRpb25zIG1lcmdpbmcgaXMgcHJldHR5IHNsb3csIGFuZCBub25lIG9mIHRoZVxuICAgICAgLy8gaW50ZXJuYWwgY29tcG9uZW50IG9wdGlvbnMgbmVlZHMgc3BlY2lhbCB0cmVhdG1lbnQuXG4gICAgICBpbml0SW50ZXJuYWxDb21wb25lbnQodm0sIG9wdGlvbnMpO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS4kb3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhcbiAgICAgICAgcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyh2bS5jb25zdHJ1Y3RvciksXG4gICAgICAgIG9wdGlvbnMgfHwge30sXG4gICAgICAgIHZtXG4gICAgICApO1xuICAgIH1cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpbml0UHJveHkodm0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bS5fcmVuZGVyUHJveHkgPSB2bTtcbiAgICB9XG4gICAgLy8gZXhwb3NlIHJlYWwgc2VsZlxuICAgIHZtLl9zZWxmID0gdm07XG4gICAgaW5pdExpZmVjeWNsZSh2bSk7XG4gICAgaW5pdEV2ZW50cyh2bSk7XG4gICAgaW5pdFJlbmRlcih2bSk7XG4gICAgY2FsbEhvb2sodm0sICdiZWZvcmVDcmVhdGUnKTtcbiAgICBpbml0SW5qZWN0aW9ucyh2bSk7IC8vIHJlc29sdmUgaW5qZWN0aW9ucyBiZWZvcmUgZGF0YS9wcm9wc1xuICAgIGluaXRTdGF0ZSh2bSk7XG4gICAgaW5pdFByb3ZpZGUodm0pOyAvLyByZXNvbHZlIHByb3ZpZGUgYWZ0ZXIgZGF0YS9wcm9wc1xuICAgIGNhbGxIb29rKHZtLCAnY3JlYXRlZCcpO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY29uZmlnLnBlcmZvcm1hbmNlICYmIG1hcmspIHtcbiAgICAgIHZtLl9uYW1lID0gZm9ybWF0Q29tcG9uZW50TmFtZSh2bSwgZmFsc2UpO1xuICAgICAgbWFyayhlbmRUYWcpO1xuICAgICAgbWVhc3VyZSgoXCJ2dWUgXCIgKyAodm0uX25hbWUpICsgXCIgaW5pdFwiKSwgc3RhcnRUYWcsIGVuZFRhZyk7XG4gICAgfVxuXG4gICAgaWYgKHZtLiRvcHRpb25zLmVsKSB7XG4gICAgICB2bS4kbW91bnQodm0uJG9wdGlvbnMuZWwpO1xuICAgIH1cbiAgfTtcbn1cblxuZnVuY3Rpb24gaW5pdEludGVybmFsQ29tcG9uZW50ICh2bSwgb3B0aW9ucykge1xuICB2YXIgb3B0cyA9IHZtLiRvcHRpb25zID0gT2JqZWN0LmNyZWF0ZSh2bS5jb25zdHJ1Y3Rvci5vcHRpb25zKTtcbiAgLy8gZG9pbmcgdGhpcyBiZWNhdXNlIGl0J3MgZmFzdGVyIHRoYW4gZHluYW1pYyBlbnVtZXJhdGlvbi5cbiAgb3B0cy5wYXJlbnQgPSBvcHRpb25zLnBhcmVudDtcbiAgb3B0cy5wcm9wc0RhdGEgPSBvcHRpb25zLnByb3BzRGF0YTtcbiAgb3B0cy5fcGFyZW50Vm5vZGUgPSBvcHRpb25zLl9wYXJlbnRWbm9kZTtcbiAgb3B0cy5fcGFyZW50TGlzdGVuZXJzID0gb3B0aW9ucy5fcGFyZW50TGlzdGVuZXJzO1xuICBvcHRzLl9yZW5kZXJDaGlsZHJlbiA9IG9wdGlvbnMuX3JlbmRlckNoaWxkcmVuO1xuICBvcHRzLl9jb21wb25lbnRUYWcgPSBvcHRpb25zLl9jb21wb25lbnRUYWc7XG4gIG9wdHMuX3BhcmVudEVsbSA9IG9wdGlvbnMuX3BhcmVudEVsbTtcbiAgb3B0cy5fcmVmRWxtID0gb3B0aW9ucy5fcmVmRWxtO1xuICBpZiAob3B0aW9ucy5yZW5kZXIpIHtcbiAgICBvcHRzLnJlbmRlciA9IG9wdGlvbnMucmVuZGVyO1xuICAgIG9wdHMuc3RhdGljUmVuZGVyRm5zID0gb3B0aW9ucy5zdGF0aWNSZW5kZXJGbnM7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucztcbiAgaWYgKEN0b3Iuc3VwZXIpIHtcbiAgICB2YXIgc3VwZXJPcHRpb25zID0gcmVzb2x2ZUNvbnN0cnVjdG9yT3B0aW9ucyhDdG9yLnN1cGVyKTtcbiAgICB2YXIgY2FjaGVkU3VwZXJPcHRpb25zID0gQ3Rvci5zdXBlck9wdGlvbnM7XG4gICAgaWYgKHN1cGVyT3B0aW9ucyAhPT0gY2FjaGVkU3VwZXJPcHRpb25zKSB7XG4gICAgICAvLyBzdXBlciBvcHRpb24gY2hhbmdlZCxcbiAgICAgIC8vIG5lZWQgdG8gcmVzb2x2ZSBuZXcgb3B0aW9ucy5cbiAgICAgIEN0b3Iuc3VwZXJPcHRpb25zID0gc3VwZXJPcHRpb25zO1xuICAgICAgLy8gY2hlY2sgaWYgdGhlcmUgYXJlIGFueSBsYXRlLW1vZGlmaWVkL2F0dGFjaGVkIG9wdGlvbnMgKCM0OTc2KVxuICAgICAgdmFyIG1vZGlmaWVkT3B0aW9ucyA9IHJlc29sdmVNb2RpZmllZE9wdGlvbnMoQ3Rvcik7XG4gICAgICAvLyB1cGRhdGUgYmFzZSBleHRlbmQgb3B0aW9uc1xuICAgICAgaWYgKG1vZGlmaWVkT3B0aW9ucykge1xuICAgICAgICBleHRlbmQoQ3Rvci5leHRlbmRPcHRpb25zLCBtb2RpZmllZE9wdGlvbnMpO1xuICAgICAgfVxuICAgICAgb3B0aW9ucyA9IEN0b3Iub3B0aW9ucyA9IG1lcmdlT3B0aW9ucyhzdXBlck9wdGlvbnMsIEN0b3IuZXh0ZW5kT3B0aW9ucyk7XG4gICAgICBpZiAob3B0aW9ucy5uYW1lKSB7XG4gICAgICAgIG9wdGlvbnMuY29tcG9uZW50c1tvcHRpb25zLm5hbWVdID0gQ3RvcjtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgcmV0dXJuIG9wdGlvbnNcbn1cblxuZnVuY3Rpb24gcmVzb2x2ZU1vZGlmaWVkT3B0aW9ucyAoQ3Rvcikge1xuICB2YXIgbW9kaWZpZWQ7XG4gIHZhciBsYXRlc3QgPSBDdG9yLm9wdGlvbnM7XG4gIHZhciBleHRlbmRlZCA9IEN0b3IuZXh0ZW5kT3B0aW9ucztcbiAgdmFyIHNlYWxlZCA9IEN0b3Iuc2VhbGVkT3B0aW9ucztcbiAgZm9yICh2YXIga2V5IGluIGxhdGVzdCkge1xuICAgIGlmIChsYXRlc3Rba2V5XSAhPT0gc2VhbGVkW2tleV0pIHtcbiAgICAgIGlmICghbW9kaWZpZWQpIHsgbW9kaWZpZWQgPSB7fTsgfVxuICAgICAgbW9kaWZpZWRba2V5XSA9IGRlZHVwZShsYXRlc3Rba2V5XSwgZXh0ZW5kZWRba2V5XSwgc2VhbGVkW2tleV0pO1xuICAgIH1cbiAgfVxuICByZXR1cm4gbW9kaWZpZWRcbn1cblxuZnVuY3Rpb24gZGVkdXBlIChsYXRlc3QsIGV4dGVuZGVkLCBzZWFsZWQpIHtcbiAgLy8gY29tcGFyZSBsYXRlc3QgYW5kIHNlYWxlZCB0byBlbnN1cmUgbGlmZWN5Y2xlIGhvb2tzIHdvbid0IGJlIGR1cGxpY2F0ZWRcbiAgLy8gYmV0d2VlbiBtZXJnZXNcbiAgaWYgKEFycmF5LmlzQXJyYXkobGF0ZXN0KSkge1xuICAgIHZhciByZXMgPSBbXTtcbiAgICBzZWFsZWQgPSBBcnJheS5pc0FycmF5KHNlYWxlZCkgPyBzZWFsZWQgOiBbc2VhbGVkXTtcbiAgICBleHRlbmRlZCA9IEFycmF5LmlzQXJyYXkoZXh0ZW5kZWQpID8gZXh0ZW5kZWQgOiBbZXh0ZW5kZWRdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGF0ZXN0Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAvLyBwdXNoIG9yaWdpbmFsIG9wdGlvbnMgYW5kIG5vdCBzZWFsZWQgb3B0aW9ucyB0byBleGNsdWRlIGR1cGxpY2F0ZWQgb3B0aW9uc1xuICAgICAgaWYgKGV4dGVuZGVkLmluZGV4T2YobGF0ZXN0W2ldKSA+PSAwIHx8IHNlYWxlZC5pbmRleE9mKGxhdGVzdFtpXSkgPCAwKSB7XG4gICAgICAgIHJlcy5wdXNoKGxhdGVzdFtpXSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZXNcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gbGF0ZXN0XG4gIH1cbn1cblxuZnVuY3Rpb24gVnVlJDMgKG9wdGlvbnMpIHtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAhKHRoaXMgaW5zdGFuY2VvZiBWdWUkMylcbiAgKSB7XG4gICAgd2FybignVnVlIGlzIGEgY29uc3RydWN0b3IgYW5kIHNob3VsZCBiZSBjYWxsZWQgd2l0aCB0aGUgYG5ld2Aga2V5d29yZCcpO1xuICB9XG4gIHRoaXMuX2luaXQob3B0aW9ucyk7XG59XG5cbmluaXRNaXhpbihWdWUkMyk7XG5zdGF0ZU1peGluKFZ1ZSQzKTtcbmV2ZW50c01peGluKFZ1ZSQzKTtcbmxpZmVjeWNsZU1peGluKFZ1ZSQzKTtcbnJlbmRlck1peGluKFZ1ZSQzKTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRVc2UgKFZ1ZSkge1xuICBWdWUudXNlID0gZnVuY3Rpb24gKHBsdWdpbikge1xuICAgIHZhciBpbnN0YWxsZWRQbHVnaW5zID0gKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgfHwgKHRoaXMuX2luc3RhbGxlZFBsdWdpbnMgPSBbXSkpO1xuICAgIGlmIChpbnN0YWxsZWRQbHVnaW5zLmluZGV4T2YocGx1Z2luKSA+IC0xKSB7XG4gICAgICByZXR1cm4gdGhpc1xuICAgIH1cblxuICAgIC8vIGFkZGl0aW9uYWwgcGFyYW1ldGVyc1xuICAgIHZhciBhcmdzID0gdG9BcnJheShhcmd1bWVudHMsIDEpO1xuICAgIGFyZ3MudW5zaGlmdCh0aGlzKTtcbiAgICBpZiAodHlwZW9mIHBsdWdpbi5pbnN0YWxsID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICBwbHVnaW4uaW5zdGFsbC5hcHBseShwbHVnaW4sIGFyZ3MpO1xuICAgIH0gZWxzZSBpZiAodHlwZW9mIHBsdWdpbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcGx1Z2luLmFwcGx5KG51bGwsIGFyZ3MpO1xuICAgIH1cbiAgICBpbnN0YWxsZWRQbHVnaW5zLnB1c2gocGx1Z2luKTtcbiAgICByZXR1cm4gdGhpc1xuICB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdE1peGluJDEgKFZ1ZSkge1xuICBWdWUubWl4aW4gPSBmdW5jdGlvbiAobWl4aW4pIHtcbiAgICB0aGlzLm9wdGlvbnMgPSBtZXJnZU9wdGlvbnModGhpcy5vcHRpb25zLCBtaXhpbik7XG4gICAgcmV0dXJuIHRoaXNcbiAgfTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGluaXRFeHRlbmQgKFZ1ZSkge1xuICAvKipcbiAgICogRWFjaCBpbnN0YW5jZSBjb25zdHJ1Y3RvciwgaW5jbHVkaW5nIFZ1ZSwgaGFzIGEgdW5pcXVlXG4gICAqIGNpZC4gVGhpcyBlbmFibGVzIHVzIHRvIGNyZWF0ZSB3cmFwcGVkIFwiY2hpbGRcbiAgICogY29uc3RydWN0b3JzXCIgZm9yIHByb3RvdHlwYWwgaW5oZXJpdGFuY2UgYW5kIGNhY2hlIHRoZW0uXG4gICAqL1xuICBWdWUuY2lkID0gMDtcbiAgdmFyIGNpZCA9IDE7XG5cbiAgLyoqXG4gICAqIENsYXNzIGluaGVyaXRhbmNlXG4gICAqL1xuICBWdWUuZXh0ZW5kID0gZnVuY3Rpb24gKGV4dGVuZE9wdGlvbnMpIHtcbiAgICBleHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucyB8fCB7fTtcbiAgICB2YXIgU3VwZXIgPSB0aGlzO1xuICAgIHZhciBTdXBlcklkID0gU3VwZXIuY2lkO1xuICAgIHZhciBjYWNoZWRDdG9ycyA9IGV4dGVuZE9wdGlvbnMuX0N0b3IgfHwgKGV4dGVuZE9wdGlvbnMuX0N0b3IgPSB7fSk7XG4gICAgaWYgKGNhY2hlZEN0b3JzW1N1cGVySWRdKSB7XG4gICAgICByZXR1cm4gY2FjaGVkQ3RvcnNbU3VwZXJJZF1cbiAgICB9XG5cbiAgICB2YXIgbmFtZSA9IGV4dGVuZE9wdGlvbnMubmFtZSB8fCBTdXBlci5vcHRpb25zLm5hbWU7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghL15bYS16QS1aXVtcXHctXSokLy50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHdhcm4oXG4gICAgICAgICAgJ0ludmFsaWQgY29tcG9uZW50IG5hbWU6IFwiJyArIG5hbWUgKyAnXCIuIENvbXBvbmVudCBuYW1lcyAnICtcbiAgICAgICAgICAnY2FuIG9ubHkgY29udGFpbiBhbHBoYW51bWVyaWMgY2hhcmFjdGVycyBhbmQgdGhlIGh5cGhlbiwgJyArXG4gICAgICAgICAgJ2FuZCBtdXN0IHN0YXJ0IHdpdGggYSBsZXR0ZXIuJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBTdWIgPSBmdW5jdGlvbiBWdWVDb21wb25lbnQgKG9wdGlvbnMpIHtcbiAgICAgIHRoaXMuX2luaXQob3B0aW9ucyk7XG4gICAgfTtcbiAgICBTdWIucHJvdG90eXBlID0gT2JqZWN0LmNyZWF0ZShTdXBlci5wcm90b3R5cGUpO1xuICAgIFN1Yi5wcm90b3R5cGUuY29uc3RydWN0b3IgPSBTdWI7XG4gICAgU3ViLmNpZCA9IGNpZCsrO1xuICAgIFN1Yi5vcHRpb25zID0gbWVyZ2VPcHRpb25zKFxuICAgICAgU3VwZXIub3B0aW9ucyxcbiAgICAgIGV4dGVuZE9wdGlvbnNcbiAgICApO1xuICAgIFN1Ylsnc3VwZXInXSA9IFN1cGVyO1xuXG4gICAgLy8gRm9yIHByb3BzIGFuZCBjb21wdXRlZCBwcm9wZXJ0aWVzLCB3ZSBkZWZpbmUgdGhlIHByb3h5IGdldHRlcnMgb25cbiAgICAvLyB0aGUgVnVlIGluc3RhbmNlcyBhdCBleHRlbnNpb24gdGltZSwgb24gdGhlIGV4dGVuZGVkIHByb3RvdHlwZS4gVGhpc1xuICAgIC8vIGF2b2lkcyBPYmplY3QuZGVmaW5lUHJvcGVydHkgY2FsbHMgZm9yIGVhY2ggaW5zdGFuY2UgY3JlYXRlZC5cbiAgICBpZiAoU3ViLm9wdGlvbnMucHJvcHMpIHtcbiAgICAgIGluaXRQcm9wcyQxKFN1Yik7XG4gICAgfVxuICAgIGlmIChTdWIub3B0aW9ucy5jb21wdXRlZCkge1xuICAgICAgaW5pdENvbXB1dGVkJDEoU3ViKTtcbiAgICB9XG5cbiAgICAvLyBhbGxvdyBmdXJ0aGVyIGV4dGVuc2lvbi9taXhpbi9wbHVnaW4gdXNhZ2VcbiAgICBTdWIuZXh0ZW5kID0gU3VwZXIuZXh0ZW5kO1xuICAgIFN1Yi5taXhpbiA9IFN1cGVyLm1peGluO1xuICAgIFN1Yi51c2UgPSBTdXBlci51c2U7XG5cbiAgICAvLyBjcmVhdGUgYXNzZXQgcmVnaXN0ZXJzLCBzbyBleHRlbmRlZCBjbGFzc2VzXG4gICAgLy8gY2FuIGhhdmUgdGhlaXIgcHJpdmF0ZSBhc3NldHMgdG9vLlxuICAgIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICAgIFN1Ylt0eXBlXSA9IFN1cGVyW3R5cGVdO1xuICAgIH0pO1xuICAgIC8vIGVuYWJsZSByZWN1cnNpdmUgc2VsZi1sb29rdXBcbiAgICBpZiAobmFtZSkge1xuICAgICAgU3ViLm9wdGlvbnMuY29tcG9uZW50c1tuYW1lXSA9IFN1YjtcbiAgICB9XG5cbiAgICAvLyBrZWVwIGEgcmVmZXJlbmNlIHRvIHRoZSBzdXBlciBvcHRpb25zIGF0IGV4dGVuc2lvbiB0aW1lLlxuICAgIC8vIGxhdGVyIGF0IGluc3RhbnRpYXRpb24gd2UgY2FuIGNoZWNrIGlmIFN1cGVyJ3Mgb3B0aW9ucyBoYXZlXG4gICAgLy8gYmVlbiB1cGRhdGVkLlxuICAgIFN1Yi5zdXBlck9wdGlvbnMgPSBTdXBlci5vcHRpb25zO1xuICAgIFN1Yi5leHRlbmRPcHRpb25zID0gZXh0ZW5kT3B0aW9ucztcbiAgICBTdWIuc2VhbGVkT3B0aW9ucyA9IGV4dGVuZCh7fSwgU3ViLm9wdGlvbnMpO1xuXG4gICAgLy8gY2FjaGUgY29uc3RydWN0b3JcbiAgICBjYWNoZWRDdG9yc1tTdXBlcklkXSA9IFN1YjtcbiAgICByZXR1cm4gU3ViXG4gIH07XG59XG5cbmZ1bmN0aW9uIGluaXRQcm9wcyQxIChDb21wKSB7XG4gIHZhciBwcm9wcyA9IENvbXAub3B0aW9ucy5wcm9wcztcbiAgZm9yICh2YXIga2V5IGluIHByb3BzKSB7XG4gICAgcHJveHkoQ29tcC5wcm90b3R5cGUsIFwiX3Byb3BzXCIsIGtleSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaW5pdENvbXB1dGVkJDEgKENvbXApIHtcbiAgdmFyIGNvbXB1dGVkID0gQ29tcC5vcHRpb25zLmNvbXB1dGVkO1xuICBmb3IgKHZhciBrZXkgaW4gY29tcHV0ZWQpIHtcbiAgICBkZWZpbmVDb21wdXRlZChDb21wLnByb3RvdHlwZSwga2V5LCBjb21wdXRlZFtrZXldKTtcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gaW5pdEFzc2V0UmVnaXN0ZXJzIChWdWUpIHtcbiAgLyoqXG4gICAqIENyZWF0ZSBhc3NldCByZWdpc3RyYXRpb24gbWV0aG9kcy5cbiAgICovXG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWVbdHlwZV0gPSBmdW5jdGlvbiAoXG4gICAgICBpZCxcbiAgICAgIGRlZmluaXRpb25cbiAgICApIHtcbiAgICAgIGlmICghZGVmaW5pdGlvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5vcHRpb25zW3R5cGUgKyAncyddW2lkXVxuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHR5cGUgPT09ICdjb21wb25lbnQnICYmIGNvbmZpZy5pc1Jlc2VydmVkVGFnKGlkKSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgJ0RvIG5vdCB1c2UgYnVpbHQtaW4gb3IgcmVzZXJ2ZWQgSFRNTCBlbGVtZW50cyBhcyBjb21wb25lbnQgJyArXG4gICAgICAgICAgICAgICdpZDogJyArIGlkXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2NvbXBvbmVudCcgJiYgaXNQbGFpbk9iamVjdChkZWZpbml0aW9uKSkge1xuICAgICAgICAgIGRlZmluaXRpb24ubmFtZSA9IGRlZmluaXRpb24ubmFtZSB8fCBpZDtcbiAgICAgICAgICBkZWZpbml0aW9uID0gdGhpcy5vcHRpb25zLl9iYXNlLmV4dGVuZChkZWZpbml0aW9uKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZSA9PT0gJ2RpcmVjdGl2ZScgJiYgdHlwZW9mIGRlZmluaXRpb24gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICBkZWZpbml0aW9uID0geyBiaW5kOiBkZWZpbml0aW9uLCB1cGRhdGU6IGRlZmluaXRpb24gfTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9wdGlvbnNbdHlwZSArICdzJ11baWRdID0gZGVmaW5pdGlvbjtcbiAgICAgICAgcmV0dXJuIGRlZmluaXRpb25cbiAgICAgIH1cbiAgICB9O1xuICB9KTtcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGdldENvbXBvbmVudE5hbWUgKG9wdHMpIHtcbiAgcmV0dXJuIG9wdHMgJiYgKG9wdHMuQ3Rvci5vcHRpb25zLm5hbWUgfHwgb3B0cy50YWcpXG59XG5cbmZ1bmN0aW9uIG1hdGNoZXMgKHBhdHRlcm4sIG5hbWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkocGF0dGVybikpIHtcbiAgICByZXR1cm4gcGF0dGVybi5pbmRleE9mKG5hbWUpID4gLTFcbiAgfSBlbHNlIGlmICh0eXBlb2YgcGF0dGVybiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gcGF0dGVybi5zcGxpdCgnLCcpLmluZGV4T2YobmFtZSkgPiAtMVxuICB9IGVsc2UgaWYgKGlzUmVnRXhwKHBhdHRlcm4pKSB7XG4gICAgcmV0dXJuIHBhdHRlcm4udGVzdChuYW1lKVxuICB9XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gIHJldHVybiBmYWxzZVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlIChrZWVwQWxpdmVJbnN0YW5jZSwgZmlsdGVyKSB7XG4gIHZhciBjYWNoZSA9IGtlZXBBbGl2ZUluc3RhbmNlLmNhY2hlO1xuICB2YXIga2V5cyA9IGtlZXBBbGl2ZUluc3RhbmNlLmtleXM7XG4gIHZhciBfdm5vZGUgPSBrZWVwQWxpdmVJbnN0YW5jZS5fdm5vZGU7XG4gIGZvciAodmFyIGtleSBpbiBjYWNoZSkge1xuICAgIHZhciBjYWNoZWROb2RlID0gY2FjaGVba2V5XTtcbiAgICBpZiAoY2FjaGVkTm9kZSkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lKGNhY2hlZE5vZGUuY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICBpZiAobmFtZSAmJiAhZmlsdGVyKG5hbWUpKSB7XG4gICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5LCBrZXlzLCBfdm5vZGUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcnVuZUNhY2hlRW50cnkgKFxuICBjYWNoZSxcbiAga2V5LFxuICBrZXlzLFxuICBjdXJyZW50XG4pIHtcbiAgdmFyIGNhY2hlZCQkMSA9IGNhY2hlW2tleV07XG4gIGlmIChjYWNoZWQkJDEgJiYgKCFjdXJyZW50IHx8IGNhY2hlZCQkMS50YWcgIT09IGN1cnJlbnQudGFnKSkge1xuICAgIGNhY2hlZCQkMS5jb21wb25lbnRJbnN0YW5jZS4kZGVzdHJveSgpO1xuICB9XG4gIGNhY2hlW2tleV0gPSBudWxsO1xuICByZW1vdmUoa2V5cywga2V5KTtcbn1cblxudmFyIHBhdHRlcm5UeXBlcyA9IFtTdHJpbmcsIFJlZ0V4cCwgQXJyYXldO1xuXG52YXIgS2VlcEFsaXZlID0ge1xuICBuYW1lOiAna2VlcC1hbGl2ZScsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHByb3BzOiB7XG4gICAgaW5jbHVkZTogcGF0dGVyblR5cGVzLFxuICAgIGV4Y2x1ZGU6IHBhdHRlcm5UeXBlcyxcbiAgICBtYXg6IFtTdHJpbmcsIE51bWJlcl1cbiAgfSxcblxuICBjcmVhdGVkOiBmdW5jdGlvbiBjcmVhdGVkICgpIHtcbiAgICB0aGlzLmNhY2hlID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLmtleXMgPSBbXTtcbiAgfSxcblxuICBkZXN0cm95ZWQ6IGZ1bmN0aW9uIGRlc3Ryb3llZCAoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICBmb3IgKHZhciBrZXkgaW4gdGhpcyQxLmNhY2hlKSB7XG4gICAgICBwcnVuZUNhY2hlRW50cnkodGhpcyQxLmNhY2hlLCBrZXksIHRoaXMkMS5rZXlzKTtcbiAgICB9XG4gIH0sXG5cbiAgd2F0Y2g6IHtcbiAgICBpbmNsdWRlOiBmdW5jdGlvbiBpbmNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuIG1hdGNoZXModmFsLCBuYW1lKTsgfSk7XG4gICAgfSxcbiAgICBleGNsdWRlOiBmdW5jdGlvbiBleGNsdWRlICh2YWwpIHtcbiAgICAgIHBydW5lQ2FjaGUodGhpcywgZnVuY3Rpb24gKG5hbWUpIHsgcmV0dXJuICFtYXRjaGVzKHZhbCwgbmFtZSk7IH0pO1xuICAgIH1cbiAgfSxcblxuICByZW5kZXI6IGZ1bmN0aW9uIHJlbmRlciAoKSB7XG4gICAgdmFyIHNsb3QgPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIHZhciB2bm9kZSA9IGdldEZpcnN0Q29tcG9uZW50Q2hpbGQoc2xvdCk7XG4gICAgdmFyIGNvbXBvbmVudE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICAgIGlmIChjb21wb25lbnRPcHRpb25zKSB7XG4gICAgICAvLyBjaGVjayBwYXR0ZXJuXG4gICAgICB2YXIgbmFtZSA9IGdldENvbXBvbmVudE5hbWUoY29tcG9uZW50T3B0aW9ucyk7XG4gICAgICB2YXIgcmVmID0gdGhpcztcbiAgICAgIHZhciBpbmNsdWRlID0gcmVmLmluY2x1ZGU7XG4gICAgICB2YXIgZXhjbHVkZSA9IHJlZi5leGNsdWRlO1xuICAgICAgaWYgKFxuICAgICAgICAvLyBub3QgaW5jbHVkZWRcbiAgICAgICAgKGluY2x1ZGUgJiYgKCFuYW1lIHx8ICFtYXRjaGVzKGluY2x1ZGUsIG5hbWUpKSkgfHxcbiAgICAgICAgLy8gZXhjbHVkZWRcbiAgICAgICAgKGV4Y2x1ZGUgJiYgbmFtZSAmJiBtYXRjaGVzKGV4Y2x1ZGUsIG5hbWUpKVxuICAgICAgKSB7XG4gICAgICAgIHJldHVybiB2bm9kZVxuICAgICAgfVxuXG4gICAgICB2YXIgcmVmJDEgPSB0aGlzO1xuICAgICAgdmFyIGNhY2hlID0gcmVmJDEuY2FjaGU7XG4gICAgICB2YXIga2V5cyA9IHJlZiQxLmtleXM7XG4gICAgICB2YXIga2V5ID0gdm5vZGUua2V5ID09IG51bGxcbiAgICAgICAgLy8gc2FtZSBjb25zdHJ1Y3RvciBtYXkgZ2V0IHJlZ2lzdGVyZWQgYXMgZGlmZmVyZW50IGxvY2FsIGNvbXBvbmVudHNcbiAgICAgICAgLy8gc28gY2lkIGFsb25lIGlzIG5vdCBlbm91Z2ggKCMzMjY5KVxuICAgICAgICA/IGNvbXBvbmVudE9wdGlvbnMuQ3Rvci5jaWQgKyAoY29tcG9uZW50T3B0aW9ucy50YWcgPyAoXCI6OlwiICsgKGNvbXBvbmVudE9wdGlvbnMudGFnKSkgOiAnJylcbiAgICAgICAgOiB2bm9kZS5rZXk7XG4gICAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgICB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSA9IGNhY2hlW2tleV0uY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICAgIC8vIG1ha2UgY3VycmVudCBrZXkgZnJlc2hlc3RcbiAgICAgICAgcmVtb3ZlKGtleXMsIGtleSk7XG4gICAgICAgIGtleXMucHVzaChrZXkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgY2FjaGVba2V5XSA9IHZub2RlO1xuICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgLy8gcHJ1bmUgb2xkZXN0IGVudHJ5XG4gICAgICAgIGlmICh0aGlzLm1heCAmJiBrZXlzLmxlbmd0aCA+IHBhcnNlSW50KHRoaXMubWF4KSkge1xuICAgICAgICAgIHBydW5lQ2FjaGVFbnRyeShjYWNoZSwga2V5c1swXSwga2V5cywgdGhpcy5fdm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZub2RlLmRhdGEua2VlcEFsaXZlID0gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHZub2RlIHx8IChzbG90ICYmIHNsb3RbMF0pXG4gIH1cbn07XG5cbnZhciBidWlsdEluQ29tcG9uZW50cyA9IHtcbiAgS2VlcEFsaXZlOiBLZWVwQWxpdmVcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBpbml0R2xvYmFsQVBJIChWdWUpIHtcbiAgLy8gY29uZmlnXG4gIHZhciBjb25maWdEZWYgPSB7fTtcbiAgY29uZmlnRGVmLmdldCA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIGNvbmZpZzsgfTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICBjb25maWdEZWYuc2V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgd2FybihcbiAgICAgICAgJ0RvIG5vdCByZXBsYWNlIHRoZSBWdWUuY29uZmlnIG9iamVjdCwgc2V0IGluZGl2aWR1YWwgZmllbGRzIGluc3RlYWQuJ1xuICAgICAgKTtcbiAgICB9O1xuICB9XG4gIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUsICdjb25maWcnLCBjb25maWdEZWYpO1xuXG4gIC8vIGV4cG9zZWQgdXRpbCBtZXRob2RzLlxuICAvLyBOT1RFOiB0aGVzZSBhcmUgbm90IGNvbnNpZGVyZWQgcGFydCBvZiB0aGUgcHVibGljIEFQSSAtIGF2b2lkIHJlbHlpbmcgb25cbiAgLy8gdGhlbSB1bmxlc3MgeW91IGFyZSBhd2FyZSBvZiB0aGUgcmlzay5cbiAgVnVlLnV0aWwgPSB7XG4gICAgd2Fybjogd2FybixcbiAgICBleHRlbmQ6IGV4dGVuZCxcbiAgICBtZXJnZU9wdGlvbnM6IG1lcmdlT3B0aW9ucyxcbiAgICBkZWZpbmVSZWFjdGl2ZTogZGVmaW5lUmVhY3RpdmVcbiAgfTtcblxuICBWdWUuc2V0ID0gc2V0O1xuICBWdWUuZGVsZXRlID0gZGVsO1xuICBWdWUubmV4dFRpY2sgPSBuZXh0VGljaztcblxuICBWdWUub3B0aW9ucyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIEFTU0VUX1RZUEVTLmZvckVhY2goZnVuY3Rpb24gKHR5cGUpIHtcbiAgICBWdWUub3B0aW9uc1t0eXBlICsgJ3MnXSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIH0pO1xuXG4gIC8vIHRoaXMgaXMgdXNlZCB0byBpZGVudGlmeSB0aGUgXCJiYXNlXCIgY29uc3RydWN0b3IgdG8gZXh0ZW5kIGFsbCBwbGFpbi1vYmplY3RcbiAgLy8gY29tcG9uZW50cyB3aXRoIGluIFdlZXgncyBtdWx0aS1pbnN0YW5jZSBzY2VuYXJpb3MuXG4gIFZ1ZS5vcHRpb25zLl9iYXNlID0gVnVlO1xuXG4gIGV4dGVuZChWdWUub3B0aW9ucy5jb21wb25lbnRzLCBidWlsdEluQ29tcG9uZW50cyk7XG5cbiAgaW5pdFVzZShWdWUpO1xuICBpbml0TWl4aW4kMShWdWUpO1xuICBpbml0RXh0ZW5kKFZ1ZSk7XG4gIGluaXRBc3NldFJlZ2lzdGVycyhWdWUpO1xufVxuXG5pbml0R2xvYmFsQVBJKFZ1ZSQzKTtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KFZ1ZSQzLnByb3RvdHlwZSwgJyRpc1NlcnZlcicsIHtcbiAgZ2V0OiBpc1NlcnZlclJlbmRlcmluZ1xufSk7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShWdWUkMy5wcm90b3R5cGUsICckc3NyQ29udGV4dCcsIHtcbiAgZ2V0OiBmdW5jdGlvbiBnZXQgKCkge1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG4gICAgcmV0dXJuIHRoaXMuJHZub2RlICYmIHRoaXMuJHZub2RlLnNzckNvbnRleHRcbiAgfVxufSk7XG5cblZ1ZSQzLnZlcnNpb24gPSAnMi41LjknO1xuXG4vKiAgKi9cblxuLy8gdGhlc2UgYXJlIHJlc2VydmVkIGZvciB3ZWIgYmVjYXVzZSB0aGV5IGFyZSBkaXJlY3RseSBjb21waWxlZCBhd2F5XG4vLyBkdXJpbmcgdGVtcGxhdGUgY29tcGlsYXRpb25cbnZhciBpc1Jlc2VydmVkQXR0ciA9IG1ha2VNYXAoJ3N0eWxlLGNsYXNzJyk7XG5cbi8vIGF0dHJpYnV0ZXMgdGhhdCBzaG91bGQgYmUgdXNpbmcgcHJvcHMgZm9yIGJpbmRpbmdcbnZhciBhY2NlcHRWYWx1ZSA9IG1ha2VNYXAoJ2lucHV0LHRleHRhcmVhLG9wdGlvbixzZWxlY3QscHJvZ3Jlc3MnKTtcbnZhciBtdXN0VXNlUHJvcCA9IGZ1bmN0aW9uICh0YWcsIHR5cGUsIGF0dHIpIHtcbiAgcmV0dXJuIChcbiAgICAoYXR0ciA9PT0gJ3ZhbHVlJyAmJiBhY2NlcHRWYWx1ZSh0YWcpKSAmJiB0eXBlICE9PSAnYnV0dG9uJyB8fFxuICAgIChhdHRyID09PSAnc2VsZWN0ZWQnICYmIHRhZyA9PT0gJ29wdGlvbicpIHx8XG4gICAgKGF0dHIgPT09ICdjaGVja2VkJyAmJiB0YWcgPT09ICdpbnB1dCcpIHx8XG4gICAgKGF0dHIgPT09ICdtdXRlZCcgJiYgdGFnID09PSAndmlkZW8nKVxuICApXG59O1xuXG52YXIgaXNFbnVtZXJhdGVkQXR0ciA9IG1ha2VNYXAoJ2NvbnRlbnRlZGl0YWJsZSxkcmFnZ2FibGUsc3BlbGxjaGVjaycpO1xuXG52YXIgaXNCb29sZWFuQXR0ciA9IG1ha2VNYXAoXG4gICdhbGxvd2Z1bGxzY3JlZW4sYXN5bmMsYXV0b2ZvY3VzLGF1dG9wbGF5LGNoZWNrZWQsY29tcGFjdCxjb250cm9scyxkZWNsYXJlLCcgK1xuICAnZGVmYXVsdCxkZWZhdWx0Y2hlY2tlZCxkZWZhdWx0bXV0ZWQsZGVmYXVsdHNlbGVjdGVkLGRlZmVyLGRpc2FibGVkLCcgK1xuICAnZW5hYmxlZCxmb3Jtbm92YWxpZGF0ZSxoaWRkZW4saW5kZXRlcm1pbmF0ZSxpbmVydCxpc21hcCxpdGVtc2NvcGUsbG9vcCxtdWx0aXBsZSwnICtcbiAgJ211dGVkLG5vaHJlZixub3Jlc2l6ZSxub3NoYWRlLG5vdmFsaWRhdGUsbm93cmFwLG9wZW4scGF1c2VvbmV4aXQscmVhZG9ubHksJyArXG4gICdyZXF1aXJlZCxyZXZlcnNlZCxzY29wZWQsc2VhbWxlc3Msc2VsZWN0ZWQsc29ydGFibGUsdHJhbnNsYXRlLCcgK1xuICAndHJ1ZXNwZWVkLHR5cGVtdXN0bWF0Y2gsdmlzaWJsZSdcbik7XG5cbnZhciB4bGlua05TID0gJ2h0dHA6Ly93d3cudzMub3JnLzE5OTkveGxpbmsnO1xuXG52YXIgaXNYbGluayA9IGZ1bmN0aW9uIChuYW1lKSB7XG4gIHJldHVybiBuYW1lLmNoYXJBdCg1KSA9PT0gJzonICYmIG5hbWUuc2xpY2UoMCwgNSkgPT09ICd4bGluaydcbn07XG5cbnZhciBnZXRYbGlua1Byb3AgPSBmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4gaXNYbGluayhuYW1lKSA/IG5hbWUuc2xpY2UoNiwgbmFtZS5sZW5ndGgpIDogJydcbn07XG5cbnZhciBpc0ZhbHN5QXR0clZhbHVlID0gZnVuY3Rpb24gKHZhbCkge1xuICByZXR1cm4gdmFsID09IG51bGwgfHwgdmFsID09PSBmYWxzZVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIGdlbkNsYXNzRm9yVm5vZGUgKHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIHBhcmVudE5vZGUgPSB2bm9kZTtcbiAgdmFyIGNoaWxkTm9kZSA9IHZub2RlO1xuICB3aGlsZSAoaXNEZWYoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSkge1xuICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGU7XG4gICAgaWYgKGNoaWxkTm9kZS5kYXRhKSB7XG4gICAgICBkYXRhID0gbWVyZ2VDbGFzc0RhdGEoY2hpbGROb2RlLmRhdGEsIGRhdGEpO1xuICAgIH1cbiAgfVxuICB3aGlsZSAoaXNEZWYocGFyZW50Tm9kZSA9IHBhcmVudE5vZGUucGFyZW50KSkge1xuICAgIGlmIChwYXJlbnROb2RlLmRhdGEpIHtcbiAgICAgIGRhdGEgPSBtZXJnZUNsYXNzRGF0YShkYXRhLCBwYXJlbnROb2RlLmRhdGEpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVuZGVyQ2xhc3MoZGF0YS5zdGF0aWNDbGFzcywgZGF0YS5jbGFzcylcbn1cblxuZnVuY3Rpb24gbWVyZ2VDbGFzc0RhdGEgKGNoaWxkLCBwYXJlbnQpIHtcbiAgcmV0dXJuIHtcbiAgICBzdGF0aWNDbGFzczogY29uY2F0KGNoaWxkLnN0YXRpY0NsYXNzLCBwYXJlbnQuc3RhdGljQ2xhc3MpLFxuICAgIGNsYXNzOiBpc0RlZihjaGlsZC5jbGFzcylcbiAgICAgID8gW2NoaWxkLmNsYXNzLCBwYXJlbnQuY2xhc3NdXG4gICAgICA6IHBhcmVudC5jbGFzc1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbmRlckNsYXNzIChcbiAgc3RhdGljQ2xhc3MsXG4gIGR5bmFtaWNDbGFzc1xuKSB7XG4gIGlmIChpc0RlZihzdGF0aWNDbGFzcykgfHwgaXNEZWYoZHluYW1pY0NsYXNzKSkge1xuICAgIHJldHVybiBjb25jYXQoc3RhdGljQ2xhc3MsIHN0cmluZ2lmeUNsYXNzKGR5bmFtaWNDbGFzcykpXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIGNvbmNhdCAoYSwgYikge1xuICByZXR1cm4gYSA/IGIgPyAoYSArICcgJyArIGIpIDogYSA6IChiIHx8ICcnKVxufVxuXG5mdW5jdGlvbiBzdHJpbmdpZnlDbGFzcyAodmFsdWUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KHZhbHVlKVxuICB9XG4gIGlmIChpc09iamVjdCh2YWx1ZSkpIHtcbiAgICByZXR1cm4gc3RyaW5naWZ5T2JqZWN0KHZhbHVlKVxuICB9XG4gIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHZhbHVlXG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgcmV0dXJuICcnXG59XG5cbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIHZhciBzdHJpbmdpZmllZDtcbiAgZm9yICh2YXIgaSA9IDAsIGwgPSB2YWx1ZS5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBpZiAoaXNEZWYoc3RyaW5naWZpZWQgPSBzdHJpbmdpZnlDbGFzcyh2YWx1ZVtpXSkpICYmIHN0cmluZ2lmaWVkICE9PSAnJykge1xuICAgICAgaWYgKHJlcykgeyByZXMgKz0gJyAnOyB9XG4gICAgICByZXMgKz0gc3RyaW5naWZpZWQ7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gc3RyaW5naWZ5T2JqZWN0ICh2YWx1ZSkge1xuICB2YXIgcmVzID0gJyc7XG4gIGZvciAodmFyIGtleSBpbiB2YWx1ZSkge1xuICAgIGlmICh2YWx1ZVtrZXldKSB7XG4gICAgICBpZiAocmVzKSB7IHJlcyArPSAnICc7IH1cbiAgICAgIHJlcyArPSBrZXk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBuYW1lc3BhY2VNYXAgPSB7XG4gIHN2ZzogJ2h0dHA6Ly93d3cudzMub3JnLzIwMDAvc3ZnJyxcbiAgbWF0aDogJ2h0dHA6Ly93d3cudzMub3JnLzE5OTgvTWF0aC9NYXRoTUwnXG59O1xuXG52YXIgaXNIVE1MVGFnID0gbWFrZU1hcChcbiAgJ2h0bWwsYm9keSxiYXNlLGhlYWQsbGluayxtZXRhLHN0eWxlLHRpdGxlLCcgK1xuICAnYWRkcmVzcyxhcnRpY2xlLGFzaWRlLGZvb3RlcixoZWFkZXIsaDEsaDIsaDMsaDQsaDUsaDYsaGdyb3VwLG5hdixzZWN0aW9uLCcgK1xuICAnZGl2LGRkLGRsLGR0LGZpZ2NhcHRpb24sZmlndXJlLHBpY3R1cmUsaHIsaW1nLGxpLG1haW4sb2wscCxwcmUsdWwsJyArXG4gICdhLGIsYWJicixiZGksYmRvLGJyLGNpdGUsY29kZSxkYXRhLGRmbixlbSxpLGtiZCxtYXJrLHEscnAscnQscnRjLHJ1YnksJyArXG4gICdzLHNhbXAsc21hbGwsc3BhbixzdHJvbmcsc3ViLHN1cCx0aW1lLHUsdmFyLHdicixhcmVhLGF1ZGlvLG1hcCx0cmFjayx2aWRlbywnICtcbiAgJ2VtYmVkLG9iamVjdCxwYXJhbSxzb3VyY2UsY2FudmFzLHNjcmlwdCxub3NjcmlwdCxkZWwsaW5zLCcgK1xuICAnY2FwdGlvbixjb2wsY29sZ3JvdXAsdGFibGUsdGhlYWQsdGJvZHksdGQsdGgsdHIsJyArXG4gICdidXR0b24sZGF0YWxpc3QsZmllbGRzZXQsZm9ybSxpbnB1dCxsYWJlbCxsZWdlbmQsbWV0ZXIsb3B0Z3JvdXAsb3B0aW9uLCcgK1xuICAnb3V0cHV0LHByb2dyZXNzLHNlbGVjdCx0ZXh0YXJlYSwnICtcbiAgJ2RldGFpbHMsZGlhbG9nLG1lbnUsbWVudWl0ZW0sc3VtbWFyeSwnICtcbiAgJ2NvbnRlbnQsZWxlbWVudCxzaGFkb3csdGVtcGxhdGUsYmxvY2txdW90ZSxpZnJhbWUsdGZvb3QnXG4pO1xuXG4vLyB0aGlzIG1hcCBpcyBpbnRlbnRpb25hbGx5IHNlbGVjdGl2ZSwgb25seSBjb3ZlcmluZyBTVkcgZWxlbWVudHMgdGhhdCBtYXlcbi8vIGNvbnRhaW4gY2hpbGQgZWxlbWVudHMuXG52YXIgaXNTVkcgPSBtYWtlTWFwKFxuICAnc3ZnLGFuaW1hdGUsY2lyY2xlLGNsaXBwYXRoLGN1cnNvcixkZWZzLGRlc2MsZWxsaXBzZSxmaWx0ZXIsZm9udC1mYWNlLCcgK1xuICAnZm9yZWlnbk9iamVjdCxnLGdseXBoLGltYWdlLGxpbmUsbWFya2VyLG1hc2ssbWlzc2luZy1nbHlwaCxwYXRoLHBhdHRlcm4sJyArXG4gICdwb2x5Z29uLHBvbHlsaW5lLHJlY3Qsc3dpdGNoLHN5bWJvbCx0ZXh0LHRleHRwYXRoLHRzcGFuLHVzZSx2aWV3JyxcbiAgdHJ1ZVxuKTtcblxudmFyIGlzUHJlVGFnID0gZnVuY3Rpb24gKHRhZykgeyByZXR1cm4gdGFnID09PSAncHJlJzsgfTtcblxudmFyIGlzUmVzZXJ2ZWRUYWcgPSBmdW5jdGlvbiAodGFnKSB7XG4gIHJldHVybiBpc0hUTUxUYWcodGFnKSB8fCBpc1NWRyh0YWcpXG59O1xuXG5mdW5jdGlvbiBnZXRUYWdOYW1lc3BhY2UgKHRhZykge1xuICBpZiAoaXNTVkcodGFnKSkge1xuICAgIHJldHVybiAnc3ZnJ1xuICB9XG4gIC8vIGJhc2ljIHN1cHBvcnQgZm9yIE1hdGhNTFxuICAvLyBub3RlIGl0IGRvZXNuJ3Qgc3VwcG9ydCBvdGhlciBNYXRoTUwgZWxlbWVudHMgYmVpbmcgY29tcG9uZW50IHJvb3RzXG4gIGlmICh0YWcgPT09ICdtYXRoJykge1xuICAgIHJldHVybiAnbWF0aCdcbiAgfVxufVxuXG52YXIgdW5rbm93bkVsZW1lbnRDYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5mdW5jdGlvbiBpc1Vua25vd25FbGVtZW50ICh0YWcpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmICghaW5Ccm93c2VyKSB7XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICBpZiAoaXNSZXNlcnZlZFRhZyh0YWcpKSB7XG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgdGFnID0gdGFnLnRvTG93ZXJDYXNlKCk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddICE9IG51bGwpIHtcbiAgICByZXR1cm4gdW5rbm93bkVsZW1lbnRDYWNoZVt0YWddXG4gIH1cbiAgdmFyIGVsID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWcpO1xuICBpZiAodGFnLmluZGV4T2YoJy0nKSA+IC0xKSB7XG4gICAgLy8gaHR0cDovL3N0YWNrb3ZlcmZsb3cuY29tL2EvMjgyMTAzNjQvMTA3MDI0NFxuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gKFxuICAgICAgZWwuY29uc3RydWN0b3IgPT09IHdpbmRvdy5IVE1MVW5rbm93bkVsZW1lbnQgfHxcbiAgICAgIGVsLmNvbnN0cnVjdG9yID09PSB3aW5kb3cuSFRNTEVsZW1lbnRcbiAgICApKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAodW5rbm93bkVsZW1lbnRDYWNoZVt0YWddID0gL0hUTUxVbmtub3duRWxlbWVudC8udGVzdChlbC50b1N0cmluZygpKSlcbiAgfVxufVxuXG52YXIgaXNUZXh0SW5wdXRUeXBlID0gbWFrZU1hcCgndGV4dCxudW1iZXIscGFzc3dvcmQsc2VhcmNoLGVtYWlsLHRlbCx1cmwnKTtcblxuLyogICovXG5cbi8qKlxuICogUXVlcnkgYW4gZWxlbWVudCBzZWxlY3RvciBpZiBpdCdzIG5vdCBhbiBlbGVtZW50IGFscmVhZHkuXG4gKi9cbmZ1bmN0aW9uIHF1ZXJ5IChlbCkge1xuICBpZiAodHlwZW9mIGVsID09PSAnc3RyaW5nJykge1xuICAgIHZhciBzZWxlY3RlZCA9IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoZWwpO1xuICAgIGlmICghc2VsZWN0ZWQpIHtcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgICAgJ0Nhbm5vdCBmaW5kIGVsZW1lbnQ6ICcgKyBlbFxuICAgICAgKTtcbiAgICAgIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKVxuICAgIH1cbiAgICByZXR1cm4gc2VsZWN0ZWRcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZWxcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gY3JlYXRlRWxlbWVudCQxICh0YWdOYW1lLCB2bm9kZSkge1xuICB2YXIgZWxtID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCh0YWdOYW1lKTtcbiAgaWYgKHRhZ05hbWUgIT09ICdzZWxlY3QnKSB7XG4gICAgcmV0dXJuIGVsbVxuICB9XG4gIC8vIGZhbHNlIG9yIG51bGwgd2lsbCByZW1vdmUgdGhlIGF0dHJpYnV0ZSBidXQgdW5kZWZpbmVkIHdpbGwgbm90XG4gIGlmICh2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEuYXR0cnMgJiYgdm5vZGUuZGF0YS5hdHRycy5tdWx0aXBsZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgZWxtLnNldEF0dHJpYnV0ZSgnbXVsdGlwbGUnLCAnbXVsdGlwbGUnKTtcbiAgfVxuICByZXR1cm4gZWxtXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZUVsZW1lbnROUyAobmFtZXNwYWNlLCB0YWdOYW1lKSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVFbGVtZW50TlMobmFtZXNwYWNlTWFwW25hbWVzcGFjZV0sIHRhZ05hbWUpXG59XG5cbmZ1bmN0aW9uIGNyZWF0ZVRleHROb2RlICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZSh0ZXh0KVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21tZW50ICh0ZXh0KSB7XG4gIHJldHVybiBkb2N1bWVudC5jcmVhdGVDb21tZW50KHRleHQpXG59XG5cbmZ1bmN0aW9uIGluc2VydEJlZm9yZSAocGFyZW50Tm9kZSwgbmV3Tm9kZSwgcmVmZXJlbmNlTm9kZSkge1xuICBwYXJlbnROb2RlLmluc2VydEJlZm9yZShuZXdOb2RlLCByZWZlcmVuY2VOb2RlKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlQ2hpbGQgKG5vZGUsIGNoaWxkKSB7XG4gIG5vZGUucmVtb3ZlQ2hpbGQoY2hpbGQpO1xufVxuXG5mdW5jdGlvbiBhcHBlbmRDaGlsZCAobm9kZSwgY2hpbGQpIHtcbiAgbm9kZS5hcHBlbmRDaGlsZChjaGlsZCk7XG59XG5cbmZ1bmN0aW9uIHBhcmVudE5vZGUgKG5vZGUpIHtcbiAgcmV0dXJuIG5vZGUucGFyZW50Tm9kZVxufVxuXG5mdW5jdGlvbiBuZXh0U2libGluZyAobm9kZSkge1xuICByZXR1cm4gbm9kZS5uZXh0U2libGluZ1xufVxuXG5mdW5jdGlvbiB0YWdOYW1lIChub2RlKSB7XG4gIHJldHVybiBub2RlLnRhZ05hbWVcbn1cblxuZnVuY3Rpb24gc2V0VGV4dENvbnRlbnQgKG5vZGUsIHRleHQpIHtcbiAgbm9kZS50ZXh0Q29udGVudCA9IHRleHQ7XG59XG5cbmZ1bmN0aW9uIHNldEF0dHJpYnV0ZSAobm9kZSwga2V5LCB2YWwpIHtcbiAgbm9kZS5zZXRBdHRyaWJ1dGUoa2V5LCB2YWwpO1xufVxuXG5cbnZhciBub2RlT3BzID0gT2JqZWN0LmZyZWV6ZSh7XG5cdGNyZWF0ZUVsZW1lbnQ6IGNyZWF0ZUVsZW1lbnQkMSxcblx0Y3JlYXRlRWxlbWVudE5TOiBjcmVhdGVFbGVtZW50TlMsXG5cdGNyZWF0ZVRleHROb2RlOiBjcmVhdGVUZXh0Tm9kZSxcblx0Y3JlYXRlQ29tbWVudDogY3JlYXRlQ29tbWVudCxcblx0aW5zZXJ0QmVmb3JlOiBpbnNlcnRCZWZvcmUsXG5cdHJlbW92ZUNoaWxkOiByZW1vdmVDaGlsZCxcblx0YXBwZW5kQ2hpbGQ6IGFwcGVuZENoaWxkLFxuXHRwYXJlbnROb2RlOiBwYXJlbnROb2RlLFxuXHRuZXh0U2libGluZzogbmV4dFNpYmxpbmcsXG5cdHRhZ05hbWU6IHRhZ05hbWUsXG5cdHNldFRleHRDb250ZW50OiBzZXRUZXh0Q29udGVudCxcblx0c2V0QXR0cmlidXRlOiBzZXRBdHRyaWJ1dGVcbn0pO1xuXG4vKiAgKi9cblxudmFyIHJlZiA9IHtcbiAgY3JlYXRlOiBmdW5jdGlvbiBjcmVhdGUgKF8sIHZub2RlKSB7XG4gICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICB9LFxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gICAgaWYgKG9sZFZub2RlLmRhdGEucmVmICE9PSB2bm9kZS5kYXRhLnJlZikge1xuICAgICAgcmVnaXN0ZXJSZWYob2xkVm5vZGUsIHRydWUpO1xuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgIH1cbiAgfSxcbiAgZGVzdHJveTogZnVuY3Rpb24gZGVzdHJveSAodm5vZGUpIHtcbiAgICByZWdpc3RlclJlZih2bm9kZSwgdHJ1ZSk7XG4gIH1cbn07XG5cbmZ1bmN0aW9uIHJlZ2lzdGVyUmVmICh2bm9kZSwgaXNSZW1vdmFsKSB7XG4gIHZhciBrZXkgPSB2bm9kZS5kYXRhLnJlZjtcbiAgaWYgKCFrZXkpIHsgcmV0dXJuIH1cblxuICB2YXIgdm0gPSB2bm9kZS5jb250ZXh0O1xuICB2YXIgcmVmID0gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgfHwgdm5vZGUuZWxtO1xuICB2YXIgcmVmcyA9IHZtLiRyZWZzO1xuICBpZiAoaXNSZW1vdmFsKSB7XG4gICAgaWYgKEFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgcmVtb3ZlKHJlZnNba2V5XSwgcmVmKTtcbiAgICB9IGVsc2UgaWYgKHJlZnNba2V5XSA9PT0gcmVmKSB7XG4gICAgICByZWZzW2tleV0gPSB1bmRlZmluZWQ7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmICh2bm9kZS5kYXRhLnJlZkluRm9yKSB7XG4gICAgICBpZiAoIUFycmF5LmlzQXJyYXkocmVmc1trZXldKSkge1xuICAgICAgICByZWZzW2tleV0gPSBbcmVmXTtcbiAgICAgIH0gZWxzZSBpZiAocmVmc1trZXldLmluZGV4T2YocmVmKSA8IDApIHtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIHJlZnNba2V5XS5wdXNoKHJlZik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJlZnNba2V5XSA9IHJlZjtcbiAgICB9XG4gIH1cbn1cblxuLyoqXG4gKiBWaXJ0dWFsIERPTSBwYXRjaGluZyBhbGdvcml0aG0gYmFzZWQgb24gU25hYmJkb20gYnlcbiAqIFNpbW9uIEZyaWlzIFZpbmR1bSAoQHBhbGRlcGluZClcbiAqIExpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgTGljZW5zZVxuICogaHR0cHM6Ly9naXRodWIuY29tL3BhbGRlcGluZC9zbmFiYmRvbS9ibG9iL21hc3Rlci9MSUNFTlNFXG4gKlxuICogbW9kaWZpZWQgYnkgRXZhbiBZb3UgKEB5eXg5OTA4MDMpXG4gKlxuICogTm90IHR5cGUtY2hlY2tpbmcgdGhpcyBiZWNhdXNlIHRoaXMgZmlsZSBpcyBwZXJmLWNyaXRpY2FsIGFuZCB0aGUgY29zdFxuICogb2YgbWFraW5nIGZsb3cgdW5kZXJzdGFuZCBpdCBpcyBub3Qgd29ydGggaXQuXG4gKi9cblxudmFyIGVtcHR5Tm9kZSA9IG5ldyBWTm9kZSgnJywge30sIFtdKTtcblxudmFyIGhvb2tzID0gWydjcmVhdGUnLCAnYWN0aXZhdGUnLCAndXBkYXRlJywgJ3JlbW92ZScsICdkZXN0cm95J107XG5cbmZ1bmN0aW9uIHNhbWVWbm9kZSAoYSwgYikge1xuICByZXR1cm4gKFxuICAgIGEua2V5ID09PSBiLmtleSAmJiAoXG4gICAgICAoXG4gICAgICAgIGEudGFnID09PSBiLnRhZyAmJlxuICAgICAgICBhLmlzQ29tbWVudCA9PT0gYi5pc0NvbW1lbnQgJiZcbiAgICAgICAgaXNEZWYoYS5kYXRhKSA9PT0gaXNEZWYoYi5kYXRhKSAmJlxuICAgICAgICBzYW1lSW5wdXRUeXBlKGEsIGIpXG4gICAgICApIHx8IChcbiAgICAgICAgaXNUcnVlKGEuaXNBc3luY1BsYWNlaG9sZGVyKSAmJlxuICAgICAgICBhLmFzeW5jRmFjdG9yeSA9PT0gYi5hc3luY0ZhY3RvcnkgJiZcbiAgICAgICAgaXNVbmRlZihiLmFzeW5jRmFjdG9yeS5lcnJvcilcbiAgICAgIClcbiAgICApXG4gIClcbn1cblxuZnVuY3Rpb24gc2FtZUlucHV0VHlwZSAoYSwgYikge1xuICBpZiAoYS50YWcgIT09ICdpbnB1dCcpIHsgcmV0dXJuIHRydWUgfVxuICB2YXIgaTtcbiAgdmFyIHR5cGVBID0gaXNEZWYoaSA9IGEuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgdmFyIHR5cGVCID0gaXNEZWYoaSA9IGIuZGF0YSkgJiYgaXNEZWYoaSA9IGkuYXR0cnMpICYmIGkudHlwZTtcbiAgcmV0dXJuIHR5cGVBID09PSB0eXBlQiB8fCBpc1RleHRJbnB1dFR5cGUodHlwZUEpICYmIGlzVGV4dElucHV0VHlwZSh0eXBlQilcbn1cblxuZnVuY3Rpb24gY3JlYXRlS2V5VG9PbGRJZHggKGNoaWxkcmVuLCBiZWdpbklkeCwgZW5kSWR4KSB7XG4gIHZhciBpLCBrZXk7XG4gIHZhciBtYXAgPSB7fTtcbiAgZm9yIChpID0gYmVnaW5JZHg7IGkgPD0gZW5kSWR4OyArK2kpIHtcbiAgICBrZXkgPSBjaGlsZHJlbltpXS5rZXk7XG4gICAgaWYgKGlzRGVmKGtleSkpIHsgbWFwW2tleV0gPSBpOyB9XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG5mdW5jdGlvbiBjcmVhdGVQYXRjaEZ1bmN0aW9uIChiYWNrZW5kKSB7XG4gIHZhciBpLCBqO1xuICB2YXIgY2JzID0ge307XG5cbiAgdmFyIG1vZHVsZXMgPSBiYWNrZW5kLm1vZHVsZXM7XG4gIHZhciBub2RlT3BzID0gYmFja2VuZC5ub2RlT3BzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBob29rcy5sZW5ndGg7ICsraSkge1xuICAgIGNic1tob29rc1tpXV0gPSBbXTtcbiAgICBmb3IgKGogPSAwOyBqIDwgbW9kdWxlcy5sZW5ndGg7ICsraikge1xuICAgICAgaWYgKGlzRGVmKG1vZHVsZXNbal1baG9va3NbaV1dKSkge1xuICAgICAgICBjYnNbaG9va3NbaV1dLnB1c2gobW9kdWxlc1tqXVtob29rc1tpXV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVtcHR5Tm9kZUF0IChlbG0pIHtcbiAgICByZXR1cm4gbmV3IFZOb2RlKG5vZGVPcHMudGFnTmFtZShlbG0pLnRvTG93ZXJDYXNlKCksIHt9LCBbXSwgdW5kZWZpbmVkLCBlbG0pXG4gIH1cblxuICBmdW5jdGlvbiBjcmVhdGVSbUNiIChjaGlsZEVsbSwgbGlzdGVuZXJzKSB7XG4gICAgZnVuY3Rpb24gcmVtb3ZlICgpIHtcbiAgICAgIGlmICgtLXJlbW92ZS5saXN0ZW5lcnMgPT09IDApIHtcbiAgICAgICAgcmVtb3ZlTm9kZShjaGlsZEVsbSk7XG4gICAgICB9XG4gICAgfVxuICAgIHJlbW92ZS5saXN0ZW5lcnMgPSBsaXN0ZW5lcnM7XG4gICAgcmV0dXJuIHJlbW92ZVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlTm9kZSAoZWwpIHtcbiAgICB2YXIgcGFyZW50ID0gbm9kZU9wcy5wYXJlbnROb2RlKGVsKTtcbiAgICAvLyBlbGVtZW50IG1heSBoYXZlIGFscmVhZHkgYmVlbiByZW1vdmVkIGR1ZSB0byB2LWh0bWwgLyB2LXRleHRcbiAgICBpZiAoaXNEZWYocGFyZW50KSkge1xuICAgICAgbm9kZU9wcy5yZW1vdmVDaGlsZChwYXJlbnQsIGVsKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpc1Vua25vd25FbGVtZW50JCQxICh2bm9kZSwgaW5WUHJlKSB7XG4gICAgcmV0dXJuIChcbiAgICAgICFpblZQcmUgJiZcbiAgICAgICF2bm9kZS5ucyAmJlxuICAgICAgIShcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5sZW5ndGggJiZcbiAgICAgICAgY29uZmlnLmlnbm9yZWRFbGVtZW50cy5zb21lKGZ1bmN0aW9uIChpZ25vcmUpIHtcbiAgICAgICAgICByZXR1cm4gaXNSZWdFeHAoaWdub3JlKVxuICAgICAgICAgICAgPyBpZ25vcmUudGVzdCh2bm9kZS50YWcpXG4gICAgICAgICAgICA6IGlnbm9yZSA9PT0gdm5vZGUudGFnXG4gICAgICAgIH0pXG4gICAgICApICYmXG4gICAgICBjb25maWcuaXNVbmtub3duRWxlbWVudCh2bm9kZS50YWcpXG4gICAgKVxuICB9XG5cbiAgdmFyIGNyZWF0aW5nRWxtSW5WUHJlID0gMDtcbiAgZnVuY3Rpb24gY3JlYXRlRWxtICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSwgbmVzdGVkKSB7XG4gICAgdm5vZGUuaXNSb290SW5zZXJ0ID0gIW5lc3RlZDsgLy8gZm9yIHRyYW5zaXRpb24gZW50ZXIgY2hlY2tcbiAgICBpZiAoY3JlYXRlQ29tcG9uZW50KHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgcmVmRWxtKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIHZhciBjaGlsZHJlbiA9IHZub2RlLmNoaWxkcmVuO1xuICAgIHZhciB0YWcgPSB2bm9kZS50YWc7XG4gICAgaWYgKGlzRGVmKHRhZykpIHtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgIGlmIChkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgICAgY3JlYXRpbmdFbG1JblZQcmUrKztcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNVbmtub3duRWxlbWVudCQkMSh2bm9kZSwgY3JlYXRpbmdFbG1JblZQcmUpKSB7XG4gICAgICAgICAgd2FybihcbiAgICAgICAgICAgICdVbmtub3duIGN1c3RvbSBlbGVtZW50OiA8JyArIHRhZyArICc+IC0gZGlkIHlvdSAnICtcbiAgICAgICAgICAgICdyZWdpc3RlciB0aGUgY29tcG9uZW50IGNvcnJlY3RseT8gRm9yIHJlY3Vyc2l2ZSBjb21wb25lbnRzLCAnICtcbiAgICAgICAgICAgICdtYWtlIHN1cmUgdG8gcHJvdmlkZSB0aGUgXCJuYW1lXCIgb3B0aW9uLicsXG4gICAgICAgICAgICB2bm9kZS5jb250ZXh0XG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdm5vZGUuZWxtID0gdm5vZGUubnNcbiAgICAgICAgPyBub2RlT3BzLmNyZWF0ZUVsZW1lbnROUyh2bm9kZS5ucywgdGFnKVxuICAgICAgICA6IG5vZGVPcHMuY3JlYXRlRWxlbWVudCh0YWcsIHZub2RlKTtcbiAgICAgIHNldFNjb3BlKHZub2RlKTtcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICB7XG4gICAgICAgIGNyZWF0ZUNoaWxkcmVuKHZub2RlLCBjaGlsZHJlbiwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgICAgfVxuXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkYXRhICYmIGRhdGEucHJlKSB7XG4gICAgICAgIGNyZWF0aW5nRWxtSW5WUHJlLS07XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChpc1RydWUodm5vZGUuaXNDb21tZW50KSkge1xuICAgICAgdm5vZGUuZWxtID0gbm9kZU9wcy5jcmVhdGVDb21tZW50KHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH0gZWxzZSB7XG4gICAgICB2bm9kZS5lbG0gPSBub2RlT3BzLmNyZWF0ZVRleHROb2RlKHZub2RlLnRleHQpO1xuICAgICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICB2YXIgaSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICB2YXIgaXNSZWFjdGl2YXRlZCA9IGlzRGVmKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpLmtlZXBBbGl2ZTtcbiAgICAgIGlmIChpc0RlZihpID0gaS5ob29rKSAmJiBpc0RlZihpID0gaS5pbml0KSkge1xuICAgICAgICBpKHZub2RlLCBmYWxzZSAvKiBoeWRyYXRpbmcgKi8sIHBhcmVudEVsbSwgcmVmRWxtKTtcbiAgICAgIH1cbiAgICAgIC8vIGFmdGVyIGNhbGxpbmcgdGhlIGluaXQgaG9vaywgaWYgdGhlIHZub2RlIGlzIGEgY2hpbGQgY29tcG9uZW50XG4gICAgICAvLyBpdCBzaG91bGQndmUgY3JlYXRlZCBhIGNoaWxkIGluc3RhbmNlIGFuZCBtb3VudGVkIGl0LiB0aGUgY2hpbGRcbiAgICAgIC8vIGNvbXBvbmVudCBhbHNvIGhhcyBzZXQgdGhlIHBsYWNlaG9sZGVyIHZub2RlJ3MgZWxtLlxuICAgICAgLy8gaW4gdGhhdCBjYXNlIHdlIGNhbiBqdXN0IHJldHVybiB0aGUgZWxlbWVudCBhbmQgYmUgZG9uZS5cbiAgICAgIGlmIChpc0RlZih2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgaW5pdENvbXBvbmVudCh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgaWYgKGlzVHJ1ZShpc1JlYWN0aXZhdGVkKSkge1xuICAgICAgICAgIHJlYWN0aXZhdGVDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgcGFyZW50RWxtLCByZWZFbG0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW5pdENvbXBvbmVudCAodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChpc0RlZih2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQpKSB7XG4gICAgICBpbnNlcnRlZFZub2RlUXVldWUucHVzaC5hcHBseShpbnNlcnRlZFZub2RlUXVldWUsIHZub2RlLmRhdGEucGVuZGluZ0luc2VydCk7XG4gICAgICB2bm9kZS5kYXRhLnBlbmRpbmdJbnNlcnQgPSBudWxsO1xuICAgIH1cbiAgICB2bm9kZS5lbG0gPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZS4kZWw7XG4gICAgaWYgKGlzUGF0Y2hhYmxlKHZub2RlKSkge1xuICAgICAgaW52b2tlQ3JlYXRlSG9va3Modm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICBzZXRTY29wZSh2bm9kZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGVtcHR5IGNvbXBvbmVudCByb290LlxuICAgICAgLy8gc2tpcCBhbGwgZWxlbWVudC1yZWxhdGVkIG1vZHVsZXMgZXhjZXB0IGZvciByZWYgKCMzNDU1KVxuICAgICAgcmVnaXN0ZXJSZWYodm5vZGUpO1xuICAgICAgLy8gbWFrZSBzdXJlIHRvIGludm9rZSB0aGUgaW5zZXJ0IGhvb2tcbiAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiByZWFjdGl2YXRlQ29tcG9uZW50ICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSkge1xuICAgIHZhciBpO1xuICAgIC8vIGhhY2sgZm9yICM0MzM5OiBhIHJlYWN0aXZhdGVkIGNvbXBvbmVudCB3aXRoIGlubmVyIHRyYW5zaXRpb25cbiAgICAvLyBkb2VzIG5vdCB0cmlnZ2VyIGJlY2F1c2UgdGhlIGlubmVyIG5vZGUncyBjcmVhdGVkIGhvb2tzIGFyZSBub3QgY2FsbGVkXG4gICAgLy8gYWdhaW4uIEl0J3Mgbm90IGlkZWFsIHRvIGludm9sdmUgbW9kdWxlLXNwZWNpZmljIGxvZ2ljIGluIGhlcmUgYnV0XG4gICAgLy8gdGhlcmUgZG9lc24ndCBzZWVtIHRvIGJlIGEgYmV0dGVyIHdheSB0byBkbyBpdC5cbiAgICB2YXIgaW5uZXJOb2RlID0gdm5vZGU7XG4gICAgd2hpbGUgKGlubmVyTm9kZS5jb21wb25lbnRJbnN0YW5jZSkge1xuICAgICAgaW5uZXJOb2RlID0gaW5uZXJOb2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICAgIGlmIChpc0RlZihpID0gaW5uZXJOb2RlLmRhdGEpICYmIGlzRGVmKGkgPSBpLnRyYW5zaXRpb24pKSB7XG4gICAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMuYWN0aXZhdGUubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICBjYnMuYWN0aXZhdGVbaV0oZW1wdHlOb2RlLCBpbm5lck5vZGUpO1xuICAgICAgICB9XG4gICAgICAgIGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKGlubmVyTm9kZSk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgfVxuICAgIC8vIHVubGlrZSBhIG5ld2x5IGNyZWF0ZWQgY29tcG9uZW50LFxuICAgIC8vIGEgcmVhY3RpdmF0ZWQga2VlcC1hbGl2ZSBjb21wb25lbnQgZG9lc24ndCBpbnNlcnQgaXRzZWxmXG4gICAgaW5zZXJ0KHBhcmVudEVsbSwgdm5vZGUuZWxtLCByZWZFbG0pO1xuICB9XG5cbiAgZnVuY3Rpb24gaW5zZXJ0IChwYXJlbnQsIGVsbSwgcmVmJCQxKSB7XG4gICAgaWYgKGlzRGVmKHBhcmVudCkpIHtcbiAgICAgIGlmIChpc0RlZihyZWYkJDEpKSB7XG4gICAgICAgIGlmIChyZWYkJDEucGFyZW50Tm9kZSA9PT0gcGFyZW50KSB7XG4gICAgICAgICAgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50LCBlbG0sIHJlZiQkMSk7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIG5vZGVPcHMuYXBwZW5kQ2hpbGQocGFyZW50LCBlbG0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGNyZWF0ZUNoaWxkcmVuICh2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSkge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGNoaWxkcmVuKSkge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBjaGlsZHJlbi5sZW5ndGg7ICsraSkge1xuICAgICAgICBjcmVhdGVFbG0oY2hpbGRyZW5baV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgdm5vZGUuZWxtLCBudWxsLCB0cnVlKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzUHJpbWl0aXZlKHZub2RlLnRleHQpKSB7XG4gICAgICBub2RlT3BzLmFwcGVuZENoaWxkKHZub2RlLmVsbSwgbm9kZU9wcy5jcmVhdGVUZXh0Tm9kZSh2bm9kZS50ZXh0KSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaXNQYXRjaGFibGUgKHZub2RlKSB7XG4gICAgd2hpbGUgKHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICB2bm9kZSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZTtcbiAgICB9XG4gICAgcmV0dXJuIGlzRGVmKHZub2RlLnRhZylcbiAgfVxuXG4gIGZ1bmN0aW9uIGludm9rZUNyZWF0ZUhvb2tzICh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSB7XG4gICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2JzLmNyZWF0ZS5sZW5ndGg7ICsraSQxKSB7XG4gICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCB2bm9kZSk7XG4gICAgfVxuICAgIGkgPSB2bm9kZS5kYXRhLmhvb2s7IC8vIFJldXNlIHZhcmlhYmxlXG4gICAgaWYgKGlzRGVmKGkpKSB7XG4gICAgICBpZiAoaXNEZWYoaS5jcmVhdGUpKSB7IGkuY3JlYXRlKGVtcHR5Tm9kZSwgdm5vZGUpOyB9XG4gICAgICBpZiAoaXNEZWYoaS5pbnNlcnQpKSB7IGluc2VydGVkVm5vZGVRdWV1ZS5wdXNoKHZub2RlKTsgfVxuICAgIH1cbiAgfVxuXG4gIC8vIHNldCBzY29wZSBpZCBhdHRyaWJ1dGUgZm9yIHNjb3BlZCBDU1MuXG4gIC8vIHRoaXMgaXMgaW1wbGVtZW50ZWQgYXMgYSBzcGVjaWFsIGNhc2UgdG8gYXZvaWQgdGhlIG92ZXJoZWFkXG4gIC8vIG9mIGdvaW5nIHRocm91Z2ggdGhlIG5vcm1hbCBhdHRyaWJ1dGUgcGF0Y2hpbmcgcHJvY2Vzcy5cbiAgZnVuY3Rpb24gc2V0U2NvcGUgKHZub2RlKSB7XG4gICAgdmFyIGk7XG4gICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5mblNjb3BlSWQpKSB7XG4gICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGFuY2VzdG9yID0gdm5vZGU7XG4gICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgaWYgKGlzRGVmKGkgPSBhbmNlc3Rvci5jb250ZXh0KSAmJiBpc0RlZihpID0gaS4kb3B0aW9ucy5fc2NvcGVJZCkpIHtcbiAgICAgICAgICBub2RlT3BzLnNldEF0dHJpYnV0ZSh2bm9kZS5lbG0sIGksICcnKTtcbiAgICAgICAgfVxuICAgICAgICBhbmNlc3RvciA9IGFuY2VzdG9yLnBhcmVudDtcbiAgICAgIH1cbiAgICB9XG4gICAgLy8gZm9yIHNsb3QgY29udGVudCB0aGV5IHNob3VsZCBhbHNvIGdldCB0aGUgc2NvcGVJZCBmcm9tIHRoZSBob3N0IGluc3RhbmNlLlxuICAgIGlmIChpc0RlZihpID0gYWN0aXZlSW5zdGFuY2UpICYmXG4gICAgICBpICE9PSB2bm9kZS5jb250ZXh0ICYmXG4gICAgICBpICE9PSB2bm9kZS5mbkNvbnRleHQgJiZcbiAgICAgIGlzRGVmKGkgPSBpLiRvcHRpb25zLl9zY29wZUlkKVxuICAgICkge1xuICAgICAgbm9kZU9wcy5zZXRBdHRyaWJ1dGUodm5vZGUuZWxtLCBpLCAnJyk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gYWRkVm5vZGVzIChwYXJlbnRFbG0sIHJlZkVsbSwgdm5vZGVzLCBzdGFydElkeCwgZW5kSWR4LCBpbnNlcnRlZFZub2RlUXVldWUpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICBjcmVhdGVFbG0odm5vZGVzW3N0YXJ0SWR4XSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gaW52b2tlRGVzdHJveUhvb2sgKHZub2RlKSB7XG4gICAgdmFyIGksIGo7XG4gICAgdmFyIGRhdGEgPSB2bm9kZS5kYXRhO1xuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmRlc3Ryb3kpKSB7IGkodm5vZGUpOyB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHsgY2JzLmRlc3Ryb3lbaV0odm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc0RlZihpID0gdm5vZGUuY2hpbGRyZW4pKSB7XG4gICAgICBmb3IgKGogPSAwOyBqIDwgdm5vZGUuY2hpbGRyZW4ubGVuZ3RoOyArK2opIHtcbiAgICAgICAgaW52b2tlRGVzdHJveUhvb2sodm5vZGUuY2hpbGRyZW5bal0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHJlbW92ZVZub2RlcyAocGFyZW50RWxtLCB2bm9kZXMsIHN0YXJ0SWR4LCBlbmRJZHgpIHtcbiAgICBmb3IgKDsgc3RhcnRJZHggPD0gZW5kSWR4OyArK3N0YXJ0SWR4KSB7XG4gICAgICB2YXIgY2ggPSB2bm9kZXNbc3RhcnRJZHhdO1xuICAgICAgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYoY2gudGFnKSkge1xuICAgICAgICAgIHJlbW92ZUFuZEludm9rZVJlbW92ZUhvb2soY2gpO1xuICAgICAgICAgIGludm9rZURlc3Ryb3lIb29rKGNoKTtcbiAgICAgICAgfSBlbHNlIHsgLy8gVGV4dCBub2RlXG4gICAgICAgICAgcmVtb3ZlTm9kZShjaC5lbG0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayAodm5vZGUsIHJtKSB7XG4gICAgaWYgKGlzRGVmKHJtKSB8fCBpc0RlZih2bm9kZS5kYXRhKSkge1xuICAgICAgdmFyIGk7XG4gICAgICB2YXIgbGlzdGVuZXJzID0gY2JzLnJlbW92ZS5sZW5ndGggKyAxO1xuICAgICAgaWYgKGlzRGVmKHJtKSkge1xuICAgICAgICAvLyB3ZSBoYXZlIGEgcmVjdXJzaXZlbHkgcGFzc2VkIGRvd24gcm0gY2FsbGJhY2tcbiAgICAgICAgLy8gaW5jcmVhc2UgdGhlIGxpc3RlbmVycyBjb3VudFxuICAgICAgICBybS5saXN0ZW5lcnMgKz0gbGlzdGVuZXJzO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gZGlyZWN0bHkgcmVtb3ZpbmdcbiAgICAgICAgcm0gPSBjcmVhdGVSbUNiKHZub2RlLmVsbSwgbGlzdGVuZXJzKTtcbiAgICAgIH1cbiAgICAgIC8vIHJlY3Vyc2l2ZWx5IGludm9rZSBob29rcyBvbiBjaGlsZCBjb21wb25lbnQgcm9vdCBub2RlXG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmNvbXBvbmVudEluc3RhbmNlKSAmJiBpc0RlZihpID0gaS5fdm5vZGUpICYmIGlzRGVmKGkuZGF0YSkpIHtcbiAgICAgICAgcmVtb3ZlQW5kSW52b2tlUmVtb3ZlSG9vayhpLCBybSk7XG4gICAgICB9XG4gICAgICBmb3IgKGkgPSAwOyBpIDwgY2JzLnJlbW92ZS5sZW5ndGg7ICsraSkge1xuICAgICAgICBjYnMucmVtb3ZlW2ldKHZub2RlLCBybSk7XG4gICAgICB9XG4gICAgICBpZiAoaXNEZWYoaSA9IHZub2RlLmRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucmVtb3ZlKSkge1xuICAgICAgICBpKHZub2RlLCBybSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBybSgpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICByZW1vdmVOb2RlKHZub2RlLmVsbSk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gdXBkYXRlQ2hpbGRyZW4gKHBhcmVudEVsbSwgb2xkQ2gsIG5ld0NoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICB2YXIgb2xkU3RhcnRJZHggPSAwO1xuICAgIHZhciBuZXdTdGFydElkeCA9IDA7XG4gICAgdmFyIG9sZEVuZElkeCA9IG9sZENoLmxlbmd0aCAtIDE7XG4gICAgdmFyIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFswXTtcbiAgICB2YXIgb2xkRW5kVm5vZGUgPSBvbGRDaFtvbGRFbmRJZHhdO1xuICAgIHZhciBuZXdFbmRJZHggPSBuZXdDaC5sZW5ndGggLSAxO1xuICAgIHZhciBuZXdTdGFydFZub2RlID0gbmV3Q2hbMF07XG4gICAgdmFyIG5ld0VuZFZub2RlID0gbmV3Q2hbbmV3RW5kSWR4XTtcbiAgICB2YXIgb2xkS2V5VG9JZHgsIGlkeEluT2xkLCB2bm9kZVRvTW92ZSwgcmVmRWxtO1xuXG4gICAgLy8gcmVtb3ZlT25seSBpcyBhIHNwZWNpYWwgZmxhZyB1c2VkIG9ubHkgYnkgPHRyYW5zaXRpb24tZ3JvdXA+XG4gICAgLy8gdG8gZW5zdXJlIHJlbW92ZWQgZWxlbWVudHMgc3RheSBpbiBjb3JyZWN0IHJlbGF0aXZlIHBvc2l0aW9uc1xuICAgIC8vIGR1cmluZyBsZWF2aW5nIHRyYW5zaXRpb25zXG4gICAgdmFyIGNhbk1vdmUgPSAhcmVtb3ZlT25seTtcblxuICAgIHdoaWxlIChvbGRTdGFydElkeCA8PSBvbGRFbmRJZHggJiYgbmV3U3RhcnRJZHggPD0gbmV3RW5kSWR4KSB7XG4gICAgICBpZiAoaXNVbmRlZihvbGRTdGFydFZub2RlKSkge1xuICAgICAgICBvbGRTdGFydFZub2RlID0gb2xkQ2hbKytvbGRTdGFydElkeF07IC8vIFZub2RlIGhhcyBiZWVuIG1vdmVkIGxlZnRcbiAgICAgIH0gZWxzZSBpZiAoaXNVbmRlZihvbGRFbmRWbm9kZSkpIHtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICB9IGVsc2UgaWYgKHNhbWVWbm9kZShvbGRTdGFydFZub2RlLCBuZXdTdGFydFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZFN0YXJ0Vm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIG9sZFN0YXJ0Vm5vZGUgPSBvbGRDaFsrK29sZFN0YXJ0SWR4XTtcbiAgICAgICAgbmV3U3RhcnRWbm9kZSA9IG5ld0NoWysrbmV3U3RhcnRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkRW5kVm5vZGUsIG5ld0VuZFZub2RlKSkge1xuICAgICAgICBwYXRjaFZub2RlKG9sZEVuZFZub2RlLCBuZXdFbmRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld0VuZFZub2RlID0gbmV3Q2hbLS1uZXdFbmRJZHhdO1xuICAgICAgfSBlbHNlIGlmIChzYW1lVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUpKSB7IC8vIFZub2RlIG1vdmVkIHJpZ2h0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkU3RhcnRWbm9kZSwgbmV3RW5kVm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRTdGFydFZub2RlLmVsbSwgbm9kZU9wcy5uZXh0U2libGluZyhvbGRFbmRWbm9kZS5lbG0pKTtcbiAgICAgICAgb2xkU3RhcnRWbm9kZSA9IG9sZENoWysrb2xkU3RhcnRJZHhdO1xuICAgICAgICBuZXdFbmRWbm9kZSA9IG5ld0NoWy0tbmV3RW5kSWR4XTtcbiAgICAgIH0gZWxzZSBpZiAoc2FtZVZub2RlKG9sZEVuZFZub2RlLCBuZXdTdGFydFZub2RlKSkgeyAvLyBWbm9kZSBtb3ZlZCBsZWZ0XG4gICAgICAgIHBhdGNoVm5vZGUob2xkRW5kVm5vZGUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIGNhbk1vdmUgJiYgbm9kZU9wcy5pbnNlcnRCZWZvcmUocGFyZW50RWxtLCBvbGRFbmRWbm9kZS5lbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgb2xkRW5kVm5vZGUgPSBvbGRDaFstLW9sZEVuZElkeF07XG4gICAgICAgIG5ld1N0YXJ0Vm5vZGUgPSBuZXdDaFsrK25ld1N0YXJ0SWR4XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1VuZGVmKG9sZEtleVRvSWR4KSkgeyBvbGRLZXlUb0lkeCA9IGNyZWF0ZUtleVRvT2xkSWR4KG9sZENoLCBvbGRTdGFydElkeCwgb2xkRW5kSWR4KTsgfVxuICAgICAgICBpZHhJbk9sZCA9IGlzRGVmKG5ld1N0YXJ0Vm5vZGUua2V5KVxuICAgICAgICAgID8gb2xkS2V5VG9JZHhbbmV3U3RhcnRWbm9kZS5rZXldXG4gICAgICAgICAgOiBmaW5kSWR4SW5PbGQobmV3U3RhcnRWbm9kZSwgb2xkQ2gsIG9sZFN0YXJ0SWR4LCBvbGRFbmRJZHgpO1xuICAgICAgICBpZiAoaXNVbmRlZihpZHhJbk9sZCkpIHsgLy8gTmV3IGVsZW1lbnRcbiAgICAgICAgICBjcmVhdGVFbG0obmV3U3RhcnRWbm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIG9sZFN0YXJ0Vm5vZGUuZWxtKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICB2bm9kZVRvTW92ZSA9IG9sZENoW2lkeEluT2xkXTtcbiAgICAgICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiAhdm5vZGVUb01vdmUpIHtcbiAgICAgICAgICAgIHdhcm4oXG4gICAgICAgICAgICAgICdJdCBzZWVtcyB0aGVyZSBhcmUgZHVwbGljYXRlIGtleXMgdGhhdCBpcyBjYXVzaW5nIGFuIHVwZGF0ZSBlcnJvci4gJyArXG4gICAgICAgICAgICAgICdNYWtlIHN1cmUgZWFjaCB2LWZvciBpdGVtIGhhcyBhIHVuaXF1ZSBrZXkuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHNhbWVWbm9kZSh2bm9kZVRvTW92ZSwgbmV3U3RhcnRWbm9kZSkpIHtcbiAgICAgICAgICAgIHBhdGNoVm5vZGUodm5vZGVUb01vdmUsIG5ld1N0YXJ0Vm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgICAgICBvbGRDaFtpZHhJbk9sZF0gPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBjYW5Nb3ZlICYmIG5vZGVPcHMuaW5zZXJ0QmVmb3JlKHBhcmVudEVsbSwgdm5vZGVUb01vdmUuZWxtLCBvbGRTdGFydFZub2RlLmVsbSk7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIHNhbWUga2V5IGJ1dCBkaWZmZXJlbnQgZWxlbWVudC4gdHJlYXQgYXMgbmV3IGVsZW1lbnRcbiAgICAgICAgICAgIGNyZWF0ZUVsbShuZXdTdGFydFZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHBhcmVudEVsbSwgb2xkU3RhcnRWbm9kZS5lbG0pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBuZXdTdGFydFZub2RlID0gbmV3Q2hbKytuZXdTdGFydElkeF07XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChvbGRTdGFydElkeCA+IG9sZEVuZElkeCkge1xuICAgICAgcmVmRWxtID0gaXNVbmRlZihuZXdDaFtuZXdFbmRJZHggKyAxXSkgPyBudWxsIDogbmV3Q2hbbmV3RW5kSWR4ICsgMV0uZWxtO1xuICAgICAgYWRkVm5vZGVzKHBhcmVudEVsbSwgcmVmRWxtLCBuZXdDaCwgbmV3U3RhcnRJZHgsIG5ld0VuZElkeCwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICB9IGVsc2UgaWYgKG5ld1N0YXJ0SWR4ID4gbmV3RW5kSWR4KSB7XG4gICAgICByZW1vdmVWbm9kZXMocGFyZW50RWxtLCBvbGRDaCwgb2xkU3RhcnRJZHgsIG9sZEVuZElkeCk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gZmluZElkeEluT2xkIChub2RlLCBvbGRDaCwgc3RhcnQsIGVuZCkge1xuICAgIGZvciAodmFyIGkgPSBzdGFydDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICB2YXIgYyA9IG9sZENoW2ldO1xuICAgICAgaWYgKGlzRGVmKGMpICYmIHNhbWVWbm9kZShub2RlLCBjKSkgeyByZXR1cm4gaSB9XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gcGF0Y2hWbm9kZSAob2xkVm5vZGUsIHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpIHtcbiAgICBpZiAob2xkVm5vZGUgPT09IHZub2RlKSB7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgZWxtID0gdm5vZGUuZWxtID0gb2xkVm5vZGUuZWxtO1xuXG4gICAgaWYgKGlzVHJ1ZShvbGRWbm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIpKSB7XG4gICAgICBpZiAoaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5LnJlc29sdmVkKSkge1xuICAgICAgICBoeWRyYXRlKG9sZFZub2RlLmVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB2bm9kZS5pc0FzeW5jUGxhY2Vob2xkZXIgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gcmV1c2UgZWxlbWVudCBmb3Igc3RhdGljIHRyZWVzLlxuICAgIC8vIG5vdGUgd2Ugb25seSBkbyB0aGlzIGlmIHRoZSB2bm9kZSBpcyBjbG9uZWQgLVxuICAgIC8vIGlmIHRoZSBuZXcgbm9kZSBpcyBub3QgY2xvbmVkIGl0IG1lYW5zIHRoZSByZW5kZXIgZnVuY3Rpb25zIGhhdmUgYmVlblxuICAgIC8vIHJlc2V0IGJ5IHRoZSBob3QtcmVsb2FkLWFwaSBhbmQgd2UgbmVlZCB0byBkbyBhIHByb3BlciByZS1yZW5kZXIuXG4gICAgaWYgKGlzVHJ1ZSh2bm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIGlzVHJ1ZShvbGRWbm9kZS5pc1N0YXRpYykgJiZcbiAgICAgIHZub2RlLmtleSA9PT0gb2xkVm5vZGUua2V5ICYmXG4gICAgICAoaXNUcnVlKHZub2RlLmlzQ2xvbmVkKSB8fCBpc1RydWUodm5vZGUuaXNPbmNlKSlcbiAgICApIHtcbiAgICAgIHZub2RlLmNvbXBvbmVudEluc3RhbmNlID0gb2xkVm5vZGUuY29tcG9uZW50SW5zdGFuY2U7XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaTtcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgaWYgKGlzRGVmKGRhdGEpICYmIGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnByZXBhdGNoKSkge1xuICAgICAgaShvbGRWbm9kZSwgdm5vZGUpO1xuICAgIH1cblxuICAgIHZhciBvbGRDaCA9IG9sZFZub2RlLmNoaWxkcmVuO1xuICAgIHZhciBjaCA9IHZub2RlLmNoaWxkcmVuO1xuICAgIGlmIChpc0RlZihkYXRhKSAmJiBpc1BhdGNoYWJsZSh2bm9kZSkpIHtcbiAgICAgIGZvciAoaSA9IDA7IGkgPCBjYnMudXBkYXRlLmxlbmd0aDsgKytpKSB7IGNicy51cGRhdGVbaV0ob2xkVm5vZGUsIHZub2RlKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLnVwZGF0ZSkpIHsgaShvbGRWbm9kZSwgdm5vZGUpOyB9XG4gICAgfVxuICAgIGlmIChpc1VuZGVmKHZub2RlLnRleHQpKSB7XG4gICAgICBpZiAoaXNEZWYob2xkQ2gpICYmIGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAob2xkQ2ggIT09IGNoKSB7IHVwZGF0ZUNoaWxkcmVuKGVsbSwgb2xkQ2gsIGNoLCBpbnNlcnRlZFZub2RlUXVldWUsIHJlbW92ZU9ubHkpOyB9XG4gICAgICB9IGVsc2UgaWYgKGlzRGVmKGNoKSkge1xuICAgICAgICBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHsgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTsgfVxuICAgICAgICBhZGRWbm9kZXMoZWxtLCBudWxsLCBjaCwgMCwgY2gubGVuZ3RoIC0gMSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkQ2gpKSB7XG4gICAgICAgIHJlbW92ZVZub2RlcyhlbG0sIG9sZENoLCAwLCBvbGRDaC5sZW5ndGggLSAxKTtcbiAgICAgIH0gZWxzZSBpZiAoaXNEZWYob2xkVm5vZGUudGV4dCkpIHtcbiAgICAgICAgbm9kZU9wcy5zZXRUZXh0Q29udGVudChlbG0sICcnKTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKG9sZFZub2RlLnRleHQgIT09IHZub2RlLnRleHQpIHtcbiAgICAgIG5vZGVPcHMuc2V0VGV4dENvbnRlbnQoZWxtLCB2bm9kZS50ZXh0KTtcbiAgICB9XG4gICAgaWYgKGlzRGVmKGRhdGEpKSB7XG4gICAgICBpZiAoaXNEZWYoaSA9IGRhdGEuaG9vaykgJiYgaXNEZWYoaSA9IGkucG9zdHBhdGNoKSkgeyBpKG9sZFZub2RlLCB2bm9kZSk7IH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBpbnZva2VJbnNlcnRIb29rICh2bm9kZSwgcXVldWUsIGluaXRpYWwpIHtcbiAgICAvLyBkZWxheSBpbnNlcnQgaG9va3MgZm9yIGNvbXBvbmVudCByb290IG5vZGVzLCBpbnZva2UgdGhlbSBhZnRlciB0aGVcbiAgICAvLyBlbGVtZW50IGlzIHJlYWxseSBpbnNlcnRlZFxuICAgIGlmIChpc1RydWUoaW5pdGlhbCkgJiYgaXNEZWYodm5vZGUucGFyZW50KSkge1xuICAgICAgdm5vZGUucGFyZW50LmRhdGEucGVuZGluZ0luc2VydCA9IHF1ZXVlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XG4gICAgICAgIHF1ZXVlW2ldLmRhdGEuaG9vay5pbnNlcnQocXVldWVbaV0pO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHZhciBoeWRyYXRpb25CYWlsZWQgPSBmYWxzZTtcbiAgLy8gbGlzdCBvZiBtb2R1bGVzIHRoYXQgY2FuIHNraXAgY3JlYXRlIGhvb2sgZHVyaW5nIGh5ZHJhdGlvbiBiZWNhdXNlIHRoZXlcbiAgLy8gYXJlIGFscmVhZHkgcmVuZGVyZWQgb24gdGhlIGNsaWVudCBvciBoYXMgbm8gbmVlZCBmb3IgaW5pdGlhbGl6YXRpb25cbiAgLy8gTm90ZTogc3R5bGUgaXMgZXhjbHVkZWQgYmVjYXVzZSBpdCByZWxpZXMgb24gaW5pdGlhbCBjbG9uZSBmb3IgZnV0dXJlXG4gIC8vIGRlZXAgdXBkYXRlcyAoIzcwNjMpLlxuICB2YXIgaXNSZW5kZXJlZE1vZHVsZSA9IG1ha2VNYXAoJ2F0dHJzLGNsYXNzLHN0YXRpY0NsYXNzLHN0YXRpY1N0eWxlLGtleScpO1xuXG4gIC8vIE5vdGU6IHRoaXMgaXMgYSBicm93c2VyLW9ubHkgZnVuY3Rpb24gc28gd2UgY2FuIGFzc3VtZSBlbG1zIGFyZSBET00gbm9kZXMuXG4gIGZ1bmN0aW9uIGh5ZHJhdGUgKGVsbSwgdm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSB7XG4gICAgdmFyIGk7XG4gICAgdmFyIHRhZyA9IHZub2RlLnRhZztcbiAgICB2YXIgZGF0YSA9IHZub2RlLmRhdGE7XG4gICAgdmFyIGNoaWxkcmVuID0gdm5vZGUuY2hpbGRyZW47XG4gICAgaW5WUHJlID0gaW5WUHJlIHx8IChkYXRhICYmIGRhdGEucHJlKTtcbiAgICB2bm9kZS5lbG0gPSBlbG07XG5cbiAgICBpZiAoaXNUcnVlKHZub2RlLmlzQ29tbWVudCkgJiYgaXNEZWYodm5vZGUuYXN5bmNGYWN0b3J5KSkge1xuICAgICAgdm5vZGUuaXNBc3luY1BsYWNlaG9sZGVyID0gdHJ1ZTtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICAgIC8vIGFzc2VydCBub2RlIG1hdGNoXG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgIGlmICghYXNzZXJ0Tm9kZU1hdGNoKGVsbSwgdm5vZGUsIGluVlByZSkpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhLmhvb2spICYmIGlzRGVmKGkgPSBpLmluaXQpKSB7IGkodm5vZGUsIHRydWUgLyogaHlkcmF0aW5nICovKTsgfVxuICAgICAgaWYgKGlzRGVmKGkgPSB2bm9kZS5jb21wb25lbnRJbnN0YW5jZSkpIHtcbiAgICAgICAgLy8gY2hpbGQgY29tcG9uZW50LiBpdCBzaG91bGQgaGF2ZSBoeWRyYXRlZCBpdHMgb3duIHRyZWUuXG4gICAgICAgIGluaXRDb21wb25lbnQodm5vZGUsIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIHJldHVybiB0cnVlXG4gICAgICB9XG4gICAgfVxuICAgIGlmIChpc0RlZih0YWcpKSB7XG4gICAgICBpZiAoaXNEZWYoY2hpbGRyZW4pKSB7XG4gICAgICAgIC8vIGVtcHR5IGVsZW1lbnQsIGFsbG93IGNsaWVudCB0byBwaWNrIHVwIGFuZCBwb3B1bGF0ZSBjaGlsZHJlblxuICAgICAgICBpZiAoIWVsbS5oYXNDaGlsZE5vZGVzKCkpIHtcbiAgICAgICAgICBjcmVhdGVDaGlsZHJlbih2bm9kZSwgY2hpbGRyZW4sIGluc2VydGVkVm5vZGVRdWV1ZSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgLy8gdi1odG1sIGFuZCBkb21Qcm9wczogaW5uZXJIVE1MXG4gICAgICAgICAgaWYgKGlzRGVmKGkgPSBkYXRhKSAmJiBpc0RlZihpID0gaS5kb21Qcm9wcykgJiYgaXNEZWYoaSA9IGkuaW5uZXJIVE1MKSkge1xuICAgICAgICAgICAgaWYgKGkgIT09IGVsbS5pbm5lckhUTUwpIHtcbiAgICAgICAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICAgICAgICAgICAgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnICYmXG4gICAgICAgICAgICAgICAgIWh5ZHJhdGlvbkJhaWxlZFxuICAgICAgICAgICAgICApIHtcbiAgICAgICAgICAgICAgICBoeWRyYXRpb25CYWlsZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2FybignUGFyZW50OiAnLCBlbG0pO1xuICAgICAgICAgICAgICAgIGNvbnNvbGUud2Fybignc2VydmVyIGlubmVySFRNTDogJywgaSk7XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuKCdjbGllbnQgaW5uZXJIVE1MOiAnLCBlbG0uaW5uZXJIVE1MKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgLy8gaXRlcmF0ZSBhbmQgY29tcGFyZSBjaGlsZHJlbiBsaXN0c1xuICAgICAgICAgICAgdmFyIGNoaWxkcmVuTWF0Y2ggPSB0cnVlO1xuICAgICAgICAgICAgdmFyIGNoaWxkTm9kZSA9IGVsbS5maXJzdENoaWxkO1xuICAgICAgICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgY2hpbGRyZW4ubGVuZ3RoOyBpJDErKykge1xuICAgICAgICAgICAgICBpZiAoIWNoaWxkTm9kZSB8fCAhaHlkcmF0ZShjaGlsZE5vZGUsIGNoaWxkcmVuW2kkMV0sIGluc2VydGVkVm5vZGVRdWV1ZSwgaW5WUHJlKSkge1xuICAgICAgICAgICAgICAgIGNoaWxkcmVuTWF0Y2ggPSBmYWxzZTtcbiAgICAgICAgICAgICAgICBicmVha1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGNoaWxkTm9kZSA9IGNoaWxkTm9kZS5uZXh0U2libGluZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIGlmIGNoaWxkTm9kZSBpcyBub3QgbnVsbCwgaXQgbWVhbnMgdGhlIGFjdHVhbCBjaGlsZE5vZGVzIGxpc3QgaXNcbiAgICAgICAgICAgIC8vIGxvbmdlciB0aGFuIHRoZSB2aXJ0dWFsIGNoaWxkcmVuIGxpc3QuXG4gICAgICAgICAgICBpZiAoIWNoaWxkcmVuTWF0Y2ggfHwgY2hpbGROb2RlKSB7XG4gICAgICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgICAgICAgIHR5cGVvZiBjb25zb2xlICE9PSAndW5kZWZpbmVkJyAmJlxuICAgICAgICAgICAgICAgICFoeWRyYXRpb25CYWlsZWRcbiAgICAgICAgICAgICAgKSB7XG4gICAgICAgICAgICAgICAgaHlkcmF0aW9uQmFpbGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ1BhcmVudDogJywgZWxtKTtcbiAgICAgICAgICAgICAgICBjb25zb2xlLndhcm4oJ01pc21hdGNoaW5nIGNoaWxkTm9kZXMgdnMuIFZOb2RlczogJywgZWxtLmNoaWxkTm9kZXMsIGNoaWxkcmVuKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICByZXR1cm4gZmFsc2VcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChpc0RlZihkYXRhKSkge1xuICAgICAgICB2YXIgZnVsbEludm9rZSA9IGZhbHNlO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgIGlmICghaXNSZW5kZXJlZE1vZHVsZShrZXkpKSB7XG4gICAgICAgICAgICBmdWxsSW52b2tlID0gdHJ1ZTtcbiAgICAgICAgICAgIGludm9rZUNyZWF0ZUhvb2tzKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUpO1xuICAgICAgICAgICAgYnJlYWtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFmdWxsSW52b2tlICYmIGRhdGFbJ2NsYXNzJ10pIHtcbiAgICAgICAgICAvLyBlbnN1cmUgY29sbGVjdGluZyBkZXBzIGZvciBkZWVwIGNsYXNzIGJpbmRpbmdzIGZvciBmdXR1cmUgdXBkYXRlc1xuICAgICAgICAgIHRyYXZlcnNlKGRhdGFbJ2NsYXNzJ10pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChlbG0uZGF0YSAhPT0gdm5vZGUudGV4dCkge1xuICAgICAgZWxtLmRhdGEgPSB2bm9kZS50ZXh0O1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZVxuICB9XG5cbiAgZnVuY3Rpb24gYXNzZXJ0Tm9kZU1hdGNoIChub2RlLCB2bm9kZSwgaW5WUHJlKSB7XG4gICAgaWYgKGlzRGVmKHZub2RlLnRhZykpIHtcbiAgICAgIHJldHVybiB2bm9kZS50YWcuaW5kZXhPZigndnVlLWNvbXBvbmVudCcpID09PSAwIHx8IChcbiAgICAgICAgIWlzVW5rbm93bkVsZW1lbnQkJDEodm5vZGUsIGluVlByZSkgJiZcbiAgICAgICAgdm5vZGUudGFnLnRvTG93ZXJDYXNlKCkgPT09IChub2RlLnRhZ05hbWUgJiYgbm9kZS50YWdOYW1lLnRvTG93ZXJDYXNlKCkpXG4gICAgICApXG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiBub2RlLm5vZGVUeXBlID09PSAodm5vZGUuaXNDb21tZW50ID8gOCA6IDMpXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIHBhdGNoIChvbGRWbm9kZSwgdm5vZGUsIGh5ZHJhdGluZywgcmVtb3ZlT25seSwgcGFyZW50RWxtLCByZWZFbG0pIHtcbiAgICBpZiAoaXNVbmRlZih2bm9kZSkpIHtcbiAgICAgIGlmIChpc0RlZihvbGRWbm9kZSkpIHsgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpOyB9XG4gICAgICByZXR1cm5cbiAgICB9XG5cbiAgICB2YXIgaXNJbml0aWFsUGF0Y2ggPSBmYWxzZTtcbiAgICB2YXIgaW5zZXJ0ZWRWbm9kZVF1ZXVlID0gW107XG5cbiAgICBpZiAoaXNVbmRlZihvbGRWbm9kZSkpIHtcbiAgICAgIC8vIGVtcHR5IG1vdW50IChsaWtlbHkgYXMgY29tcG9uZW50KSwgY3JlYXRlIG5ldyByb290IGVsZW1lbnRcbiAgICAgIGlzSW5pdGlhbFBhdGNoID0gdHJ1ZTtcbiAgICAgIGNyZWF0ZUVsbSh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBwYXJlbnRFbG0sIHJlZkVsbSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBpc1JlYWxFbGVtZW50ID0gaXNEZWYob2xkVm5vZGUubm9kZVR5cGUpO1xuICAgICAgaWYgKCFpc1JlYWxFbGVtZW50ICYmIHNhbWVWbm9kZShvbGRWbm9kZSwgdm5vZGUpKSB7XG4gICAgICAgIC8vIHBhdGNoIGV4aXN0aW5nIHJvb3Qgbm9kZVxuICAgICAgICBwYXRjaFZub2RlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCByZW1vdmVPbmx5KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlmIChpc1JlYWxFbGVtZW50KSB7XG4gICAgICAgICAgLy8gbW91bnRpbmcgdG8gYSByZWFsIGVsZW1lbnRcbiAgICAgICAgICAvLyBjaGVjayBpZiB0aGlzIGlzIHNlcnZlci1yZW5kZXJlZCBjb250ZW50IGFuZCBpZiB3ZSBjYW4gcGVyZm9ybVxuICAgICAgICAgIC8vIGEgc3VjY2Vzc2Z1bCBoeWRyYXRpb24uXG4gICAgICAgICAgaWYgKG9sZFZub2RlLm5vZGVUeXBlID09PSAxICYmIG9sZFZub2RlLmhhc0F0dHJpYnV0ZShTU1JfQVRUUikpIHtcbiAgICAgICAgICAgIG9sZFZub2RlLnJlbW92ZUF0dHJpYnV0ZShTU1JfQVRUUik7XG4gICAgICAgICAgICBoeWRyYXRpbmcgPSB0cnVlO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAoaXNUcnVlKGh5ZHJhdGluZykpIHtcbiAgICAgICAgICAgIGlmIChoeWRyYXRlKG9sZFZub2RlLCB2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlKSkge1xuICAgICAgICAgICAgICBpbnZva2VJbnNlcnRIb29rKHZub2RlLCBpbnNlcnRlZFZub2RlUXVldWUsIHRydWUpO1xuICAgICAgICAgICAgICByZXR1cm4gb2xkVm5vZGVcbiAgICAgICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgICAgICB3YXJuKFxuICAgICAgICAgICAgICAgICdUaGUgY2xpZW50LXNpZGUgcmVuZGVyZWQgdmlydHVhbCBET00gdHJlZSBpcyBub3QgbWF0Y2hpbmcgJyArXG4gICAgICAgICAgICAgICAgJ3NlcnZlci1yZW5kZXJlZCBjb250ZW50LiBUaGlzIGlzIGxpa2VseSBjYXVzZWQgYnkgaW5jb3JyZWN0ICcgK1xuICAgICAgICAgICAgICAgICdIVE1MIG1hcmt1cCwgZm9yIGV4YW1wbGUgbmVzdGluZyBibG9jay1sZXZlbCBlbGVtZW50cyBpbnNpZGUgJyArXG4gICAgICAgICAgICAgICAgJzxwPiwgb3IgbWlzc2luZyA8dGJvZHk+LiBCYWlsaW5nIGh5ZHJhdGlvbiBhbmQgcGVyZm9ybWluZyAnICtcbiAgICAgICAgICAgICAgICAnZnVsbCBjbGllbnQtc2lkZSByZW5kZXIuJ1xuICAgICAgICAgICAgICApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBlaXRoZXIgbm90IHNlcnZlci1yZW5kZXJlZCwgb3IgaHlkcmF0aW9uIGZhaWxlZC5cbiAgICAgICAgICAvLyBjcmVhdGUgYW4gZW1wdHkgbm9kZSBhbmQgcmVwbGFjZSBpdFxuICAgICAgICAgIG9sZFZub2RlID0gZW1wdHlOb2RlQXQob2xkVm5vZGUpO1xuICAgICAgICB9XG5cbiAgICAgICAgLy8gcmVwbGFjaW5nIGV4aXN0aW5nIGVsZW1lbnRcbiAgICAgICAgdmFyIG9sZEVsbSA9IG9sZFZub2RlLmVsbTtcbiAgICAgICAgdmFyIHBhcmVudEVsbSQxID0gbm9kZU9wcy5wYXJlbnROb2RlKG9sZEVsbSk7XG5cbiAgICAgICAgLy8gY3JlYXRlIG5ldyBub2RlXG4gICAgICAgIGNyZWF0ZUVsbShcbiAgICAgICAgICB2bm9kZSxcbiAgICAgICAgICBpbnNlcnRlZFZub2RlUXVldWUsXG4gICAgICAgICAgLy8gZXh0cmVtZWx5IHJhcmUgZWRnZSBjYXNlOiBkbyBub3QgaW5zZXJ0IGlmIG9sZCBlbGVtZW50IGlzIGluIGFcbiAgICAgICAgICAvLyBsZWF2aW5nIHRyYW5zaXRpb24uIE9ubHkgaGFwcGVucyB3aGVuIGNvbWJpbmluZyB0cmFuc2l0aW9uICtcbiAgICAgICAgICAvLyBrZWVwLWFsaXZlICsgSE9Dcy4gKCM0NTkwKVxuICAgICAgICAgIG9sZEVsbS5fbGVhdmVDYiA/IG51bGwgOiBwYXJlbnRFbG0kMSxcbiAgICAgICAgICBub2RlT3BzLm5leHRTaWJsaW5nKG9sZEVsbSlcbiAgICAgICAgKTtcblxuICAgICAgICAvLyB1cGRhdGUgcGFyZW50IHBsYWNlaG9sZGVyIG5vZGUgZWxlbWVudCwgcmVjdXJzaXZlbHlcbiAgICAgICAgaWYgKGlzRGVmKHZub2RlLnBhcmVudCkpIHtcbiAgICAgICAgICB2YXIgYW5jZXN0b3IgPSB2bm9kZS5wYXJlbnQ7XG4gICAgICAgICAgdmFyIHBhdGNoYWJsZSA9IGlzUGF0Y2hhYmxlKHZub2RlKTtcbiAgICAgICAgICB3aGlsZSAoYW5jZXN0b3IpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2JzLmRlc3Ryb3kubGVuZ3RoOyArK2kpIHtcbiAgICAgICAgICAgICAgY2JzLmRlc3Ryb3lbaV0oYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IuZWxtID0gdm5vZGUuZWxtO1xuICAgICAgICAgICAgaWYgKHBhdGNoYWJsZSkge1xuICAgICAgICAgICAgICBmb3IgKHZhciBpJDEgPSAwOyBpJDEgPCBjYnMuY3JlYXRlLmxlbmd0aDsgKytpJDEpIHtcbiAgICAgICAgICAgICAgICBjYnMuY3JlYXRlW2kkMV0oZW1wdHlOb2RlLCBhbmNlc3Rvcik7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgLy8gIzY1MTNcbiAgICAgICAgICAgICAgLy8gaW52b2tlIGluc2VydCBob29rcyB0aGF0IG1heSBoYXZlIGJlZW4gbWVyZ2VkIGJ5IGNyZWF0ZSBob29rcy5cbiAgICAgICAgICAgICAgLy8gZS5nLiBmb3IgZGlyZWN0aXZlcyB0aGF0IHVzZXMgdGhlIFwiaW5zZXJ0ZWRcIiBob29rLlxuICAgICAgICAgICAgICB2YXIgaW5zZXJ0ID0gYW5jZXN0b3IuZGF0YS5ob29rLmluc2VydDtcbiAgICAgICAgICAgICAgaWYgKGluc2VydC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICAvLyBzdGFydCBhdCBpbmRleCAxIHRvIGF2b2lkIHJlLWludm9raW5nIGNvbXBvbmVudCBtb3VudGVkIGhvb2tcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpJDIgPSAxOyBpJDIgPCBpbnNlcnQuZm5zLmxlbmd0aDsgaSQyKyspIHtcbiAgICAgICAgICAgICAgICAgIGluc2VydC5mbnNbaSQyXSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVnaXN0ZXJSZWYoYW5jZXN0b3IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgYW5jZXN0b3IgPSBhbmNlc3Rvci5wYXJlbnQ7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gZGVzdHJveSBvbGQgbm9kZVxuICAgICAgICBpZiAoaXNEZWYocGFyZW50RWxtJDEpKSB7XG4gICAgICAgICAgcmVtb3ZlVm5vZGVzKHBhcmVudEVsbSQxLCBbb2xkVm5vZGVdLCAwLCAwKTtcbiAgICAgICAgfSBlbHNlIGlmIChpc0RlZihvbGRWbm9kZS50YWcpKSB7XG4gICAgICAgICAgaW52b2tlRGVzdHJveUhvb2sob2xkVm5vZGUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaW52b2tlSW5zZXJ0SG9vayh2bm9kZSwgaW5zZXJ0ZWRWbm9kZVF1ZXVlLCBpc0luaXRpYWxQYXRjaCk7XG4gICAgcmV0dXJuIHZub2RlLmVsbVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgZGlyZWN0aXZlcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVEaXJlY3RpdmVzLFxuICB1cGRhdGU6IHVwZGF0ZURpcmVjdGl2ZXMsXG4gIGRlc3Ryb3k6IGZ1bmN0aW9uIHVuYmluZERpcmVjdGl2ZXMgKHZub2RlKSB7XG4gICAgdXBkYXRlRGlyZWN0aXZlcyh2bm9kZSwgZW1wdHlOb2RlKTtcbiAgfVxufTtcblxuZnVuY3Rpb24gdXBkYXRlRGlyZWN0aXZlcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChvbGRWbm9kZS5kYXRhLmRpcmVjdGl2ZXMgfHwgdm5vZGUuZGF0YS5kaXJlY3RpdmVzKSB7XG4gICAgX3VwZGF0ZShvbGRWbm9kZSwgdm5vZGUpO1xuICB9XG59XG5cbmZ1bmN0aW9uIF91cGRhdGUgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgaXNDcmVhdGUgPSBvbGRWbm9kZSA9PT0gZW1wdHlOb2RlO1xuICB2YXIgaXNEZXN0cm95ID0gdm5vZGUgPT09IGVtcHR5Tm9kZTtcbiAgdmFyIG9sZERpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEob2xkVm5vZGUuZGF0YS5kaXJlY3RpdmVzLCBvbGRWbm9kZS5jb250ZXh0KTtcbiAgdmFyIG5ld0RpcnMgPSBub3JtYWxpemVEaXJlY3RpdmVzJDEodm5vZGUuZGF0YS5kaXJlY3RpdmVzLCB2bm9kZS5jb250ZXh0KTtcblxuICB2YXIgZGlyc1dpdGhJbnNlcnQgPSBbXTtcbiAgdmFyIGRpcnNXaXRoUG9zdHBhdGNoID0gW107XG5cbiAgdmFyIGtleSwgb2xkRGlyLCBkaXI7XG4gIGZvciAoa2V5IGluIG5ld0RpcnMpIHtcbiAgICBvbGREaXIgPSBvbGREaXJzW2tleV07XG4gICAgZGlyID0gbmV3RGlyc1trZXldO1xuICAgIGlmICghb2xkRGlyKSB7XG4gICAgICAvLyBuZXcgZGlyZWN0aXZlLCBiaW5kXG4gICAgICBjYWxsSG9vayQxKGRpciwgJ2JpbmQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgaWYgKGRpci5kZWYgJiYgZGlyLmRlZi5pbnNlcnRlZCkge1xuICAgICAgICBkaXJzV2l0aEluc2VydC5wdXNoKGRpcik7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGV4aXN0aW5nIGRpcmVjdGl2ZSwgdXBkYXRlXG4gICAgICBkaXIub2xkVmFsdWUgPSBvbGREaXIudmFsdWU7XG4gICAgICBjYWxsSG9vayQxKGRpciwgJ3VwZGF0ZScsIHZub2RlLCBvbGRWbm9kZSk7XG4gICAgICBpZiAoZGlyLmRlZiAmJiBkaXIuZGVmLmNvbXBvbmVudFVwZGF0ZWQpIHtcbiAgICAgICAgZGlyc1dpdGhQb3N0cGF0Y2gucHVzaChkaXIpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aEluc2VydC5sZW5ndGgpIHtcbiAgICB2YXIgY2FsbEluc2VydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhJbnNlcnQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aEluc2VydFtpXSwgJ2luc2VydGVkJywgdm5vZGUsIG9sZFZub2RlKTtcbiAgICAgIH1cbiAgICB9O1xuICAgIGlmIChpc0NyZWF0ZSkge1xuICAgICAgbWVyZ2VWTm9kZUhvb2sodm5vZGUsICdpbnNlcnQnLCBjYWxsSW5zZXJ0KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY2FsbEluc2VydCgpO1xuICAgIH1cbiAgfVxuXG4gIGlmIChkaXJzV2l0aFBvc3RwYXRjaC5sZW5ndGgpIHtcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgZGlyc1dpdGhQb3N0cGF0Y2gubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgY2FsbEhvb2skMShkaXJzV2l0aFBvc3RwYXRjaFtpXSwgJ2NvbXBvbmVudFVwZGF0ZWQnLCB2bm9kZSwgb2xkVm5vZGUpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG5cbiAgaWYgKCFpc0NyZWF0ZSkge1xuICAgIGZvciAoa2V5IGluIG9sZERpcnMpIHtcbiAgICAgIGlmICghbmV3RGlyc1trZXldKSB7XG4gICAgICAgIC8vIG5vIGxvbmdlciBwcmVzZW50LCB1bmJpbmRcbiAgICAgICAgY2FsbEhvb2skMShvbGREaXJzW2tleV0sICd1bmJpbmQnLCBvbGRWbm9kZSwgb2xkVm5vZGUsIGlzRGVzdHJveSk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBlbXB0eU1vZGlmaWVycyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbmZ1bmN0aW9uIG5vcm1hbGl6ZURpcmVjdGl2ZXMkMSAoXG4gIGRpcnMsXG4gIHZtXG4pIHtcbiAgdmFyIHJlcyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gIGlmICghZGlycykge1xuICAgIHJldHVybiByZXNcbiAgfVxuICB2YXIgaSwgZGlyO1xuICBmb3IgKGkgPSAwOyBpIDwgZGlycy5sZW5ndGg7IGkrKykge1xuICAgIGRpciA9IGRpcnNbaV07XG4gICAgaWYgKCFkaXIubW9kaWZpZXJzKSB7XG4gICAgICBkaXIubW9kaWZpZXJzID0gZW1wdHlNb2RpZmllcnM7XG4gICAgfVxuICAgIHJlc1tnZXRSYXdEaXJOYW1lKGRpcildID0gZGlyO1xuICAgIGRpci5kZWYgPSByZXNvbHZlQXNzZXQodm0uJG9wdGlvbnMsICdkaXJlY3RpdmVzJywgZGlyLm5hbWUsIHRydWUpO1xuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gZ2V0UmF3RGlyTmFtZSAoZGlyKSB7XG4gIHJldHVybiBkaXIucmF3TmFtZSB8fCAoKGRpci5uYW1lKSArIFwiLlwiICsgKE9iamVjdC5rZXlzKGRpci5tb2RpZmllcnMgfHwge30pLmpvaW4oJy4nKSkpXG59XG5cbmZ1bmN0aW9uIGNhbGxIb29rJDEgKGRpciwgaG9vaywgdm5vZGUsIG9sZFZub2RlLCBpc0Rlc3Ryb3kpIHtcbiAgdmFyIGZuID0gZGlyLmRlZiAmJiBkaXIuZGVmW2hvb2tdO1xuICBpZiAoZm4pIHtcbiAgICB0cnkge1xuICAgICAgZm4odm5vZGUuZWxtLCBkaXIsIHZub2RlLCBvbGRWbm9kZSwgaXNEZXN0cm95KTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICBoYW5kbGVFcnJvcihlLCB2bm9kZS5jb250ZXh0LCAoXCJkaXJlY3RpdmUgXCIgKyAoZGlyLm5hbWUpICsgXCIgXCIgKyBob29rICsgXCIgaG9va1wiKSk7XG4gICAgfVxuICB9XG59XG5cbnZhciBiYXNlTW9kdWxlcyA9IFtcbiAgcmVmLFxuICBkaXJlY3RpdmVzXG5dO1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQXR0cnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgb3B0cyA9IHZub2RlLmNvbXBvbmVudE9wdGlvbnM7XG4gIGlmIChpc0RlZihvcHRzKSAmJiBvcHRzLkN0b3Iub3B0aW9ucy5pbmhlcml0QXR0cnMgPT09IGZhbHNlKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgaWYgKGlzVW5kZWYob2xkVm5vZGUuZGF0YS5hdHRycykgJiYgaXNVbmRlZih2bm9kZS5kYXRhLmF0dHJzKSkge1xuICAgIHJldHVyblxuICB9XG4gIHZhciBrZXksIGN1ciwgb2xkO1xuICB2YXIgZWxtID0gdm5vZGUuZWxtO1xuICB2YXIgb2xkQXR0cnMgPSBvbGRWbm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICB2YXIgYXR0cnMgPSB2bm9kZS5kYXRhLmF0dHJzIHx8IHt9O1xuICAvLyBjbG9uZSBvYnNlcnZlZCBvYmplY3RzLCBhcyB0aGUgdXNlciBwcm9iYWJseSB3YW50cyB0byBtdXRhdGUgaXRcbiAgaWYgKGlzRGVmKGF0dHJzLl9fb2JfXykpIHtcbiAgICBhdHRycyA9IHZub2RlLmRhdGEuYXR0cnMgPSBleHRlbmQoe30sIGF0dHJzKTtcbiAgfVxuXG4gIGZvciAoa2V5IGluIGF0dHJzKSB7XG4gICAgY3VyID0gYXR0cnNba2V5XTtcbiAgICBvbGQgPSBvbGRBdHRyc1trZXldO1xuICAgIGlmIChvbGQgIT09IGN1cikge1xuICAgICAgc2V0QXR0cihlbG0sIGtleSwgY3VyKTtcbiAgICB9XG4gIH1cbiAgLy8gIzQzOTE6IGluIElFOSwgc2V0dGluZyB0eXBlIGNhbiByZXNldCB2YWx1ZSBmb3IgaW5wdXRbdHlwZT1yYWRpb11cbiAgLy8gIzY2NjY6IElFL0VkZ2UgZm9yY2VzIHByb2dyZXNzIHZhbHVlIGRvd24gdG8gMSBiZWZvcmUgc2V0dGluZyBhIG1heFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKChpc0lFIHx8IGlzRWRnZSkgJiYgYXR0cnMudmFsdWUgIT09IG9sZEF0dHJzLnZhbHVlKSB7XG4gICAgc2V0QXR0cihlbG0sICd2YWx1ZScsIGF0dHJzLnZhbHVlKTtcbiAgfVxuICBmb3IgKGtleSBpbiBvbGRBdHRycykge1xuICAgIGlmIChpc1VuZGVmKGF0dHJzW2tleV0pKSB7XG4gICAgICBpZiAoaXNYbGluayhrZXkpKSB7XG4gICAgICAgIGVsbS5yZW1vdmVBdHRyaWJ1dGVOUyh4bGlua05TLCBnZXRYbGlua1Byb3Aoa2V5KSk7XG4gICAgICB9IGVsc2UgaWYgKCFpc0VudW1lcmF0ZWRBdHRyKGtleSkpIHtcbiAgICAgICAgZWxtLnJlbW92ZUF0dHJpYnV0ZShrZXkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBzZXRBdHRyIChlbCwga2V5LCB2YWx1ZSkge1xuICBpZiAoaXNCb29sZWFuQXR0cihrZXkpKSB7XG4gICAgLy8gc2V0IGF0dHJpYnV0ZSBmb3IgYmxhbmsgdmFsdWVcbiAgICAvLyBlLmcuIDxvcHRpb24gZGlzYWJsZWQ+U2VsZWN0IG9uZTwvb3B0aW9uPlxuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIHRlY2huaWNhbGx5IGFsbG93ZnVsbHNjcmVlbiBpcyBhIGJvb2xlYW4gYXR0cmlidXRlIGZvciA8aWZyYW1lPixcbiAgICAgIC8vIGJ1dCBGbGFzaCBleHBlY3RzIGEgdmFsdWUgb2YgXCJ0cnVlXCIgd2hlbiB1c2VkIG9uIDxlbWJlZD4gdGFnXG4gICAgICB2YWx1ZSA9IGtleSA9PT0gJ2FsbG93ZnVsbHNjcmVlbicgJiYgZWwudGFnTmFtZSA9PT0gJ0VNQkVEJ1xuICAgICAgICA/ICd0cnVlJ1xuICAgICAgICA6IGtleTtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoaXNFbnVtZXJhdGVkQXR0cihrZXkpKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKGtleSwgaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkgfHwgdmFsdWUgPT09ICdmYWxzZScgPyAnZmFsc2UnIDogJ3RydWUnKTtcbiAgfSBlbHNlIGlmIChpc1hsaW5rKGtleSkpIHtcbiAgICBpZiAoaXNGYWxzeUF0dHJWYWx1ZSh2YWx1ZSkpIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZU5TKHhsaW5rTlMsIGdldFhsaW5rUHJvcChrZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc2V0QXR0cmlidXRlTlMoeGxpbmtOUywga2V5LCB2YWx1ZSk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIGlmIChpc0ZhbHN5QXR0clZhbHVlKHZhbHVlKSkge1xuICAgICAgZWwucmVtb3ZlQXR0cmlidXRlKGtleSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vICM3MTM4OiBJRTEwICYgMTEgZmlyZXMgaW5wdXQgZXZlbnQgd2hlbiBzZXR0aW5nIHBsYWNlaG9sZGVyIG9uXG4gICAgICAvLyA8dGV4dGFyZWE+Li4uIGJsb2NrIHRoZSBmaXJzdCBpbnB1dCBldmVudCBhbmQgcmVtb3ZlIHRoZSBibG9ja2VyXG4gICAgICAvLyBpbW1lZGlhdGVseS5cbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKFxuICAgICAgICBpc0lFICYmICFpc0lFOSAmJlxuICAgICAgICBlbC50YWdOYW1lID09PSAnVEVYVEFSRUEnICYmXG4gICAgICAgIGtleSA9PT0gJ3BsYWNlaG9sZGVyJyAmJiAhZWwuX19pZXBoXG4gICAgICApIHtcbiAgICAgICAgdmFyIGJsb2NrZXIgPSBmdW5jdGlvbiAoZSkge1xuICAgICAgICAgIGUuc3RvcEltbWVkaWF0ZVByb3BhZ2F0aW9uKCk7XG4gICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgfTtcbiAgICAgICAgZWwuYWRkRXZlbnRMaXN0ZW5lcignaW5wdXQnLCBibG9ja2VyKTtcbiAgICAgICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgICAgIGVsLl9faWVwaCA9IHRydWU7IC8qIElFIHBsYWNlaG9sZGVyIHBhdGNoZWQgKi9cbiAgICAgIH1cbiAgICAgIGVsLnNldEF0dHJpYnV0ZShrZXksIHZhbHVlKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGF0dHJzID0ge1xuICBjcmVhdGU6IHVwZGF0ZUF0dHJzLFxuICB1cGRhdGU6IHVwZGF0ZUF0dHJzXG59O1xuXG4vKiAgKi9cblxuZnVuY3Rpb24gdXBkYXRlQ2xhc3MgKG9sZFZub2RlLCB2bm9kZSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuICBpZiAoXG4gICAgaXNVbmRlZihkYXRhLnN0YXRpY0NsYXNzKSAmJlxuICAgIGlzVW5kZWYoZGF0YS5jbGFzcykgJiYgKFxuICAgICAgaXNVbmRlZihvbGREYXRhKSB8fCAoXG4gICAgICAgIGlzVW5kZWYob2xkRGF0YS5zdGF0aWNDbGFzcykgJiZcbiAgICAgICAgaXNVbmRlZihvbGREYXRhLmNsYXNzKVxuICAgICAgKVxuICAgIClcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY2xzID0gZ2VuQ2xhc3NGb3JWbm9kZSh2bm9kZSk7XG5cbiAgLy8gaGFuZGxlIHRyYW5zaXRpb24gY2xhc3Nlc1xuICB2YXIgdHJhbnNpdGlvbkNsYXNzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzO1xuICBpZiAoaXNEZWYodHJhbnNpdGlvbkNsYXNzKSkge1xuICAgIGNscyA9IGNvbmNhdChjbHMsIHN0cmluZ2lmeUNsYXNzKHRyYW5zaXRpb25DbGFzcykpO1xuICB9XG5cbiAgLy8gc2V0IHRoZSBjbGFzc1xuICBpZiAoY2xzICE9PSBlbC5fcHJldkNsYXNzKSB7XG4gICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGNscyk7XG4gICAgZWwuX3ByZXZDbGFzcyA9IGNscztcbiAgfVxufVxuXG52YXIga2xhc3MgPSB7XG4gIGNyZWF0ZTogdXBkYXRlQ2xhc3MsXG4gIHVwZGF0ZTogdXBkYXRlQ2xhc3Ncbn07XG5cbi8qICAqL1xuXG52YXIgdmFsaWREaXZpc2lvbkNoYXJSRSA9IC9bXFx3KS4rXFwtXyRcXF1dLztcblxuZnVuY3Rpb24gcGFyc2VGaWx0ZXJzIChleHApIHtcbiAgdmFyIGluU2luZ2xlID0gZmFsc2U7XG4gIHZhciBpbkRvdWJsZSA9IGZhbHNlO1xuICB2YXIgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlO1xuICB2YXIgaW5SZWdleCA9IGZhbHNlO1xuICB2YXIgY3VybHkgPSAwO1xuICB2YXIgc3F1YXJlID0gMDtcbiAgdmFyIHBhcmVuID0gMDtcbiAgdmFyIGxhc3RGaWx0ZXJJbmRleCA9IDA7XG4gIHZhciBjLCBwcmV2LCBpLCBleHByZXNzaW9uLCBmaWx0ZXJzO1xuXG4gIGZvciAoaSA9IDA7IGkgPCBleHAubGVuZ3RoOyBpKyspIHtcbiAgICBwcmV2ID0gYztcbiAgICBjID0gZXhwLmNoYXJDb2RlQXQoaSk7XG4gICAgaWYgKGluU2luZ2xlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyNyAmJiBwcmV2ICE9PSAweDVDKSB7IGluU2luZ2xlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluRG91YmxlKSB7XG4gICAgICBpZiAoYyA9PT0gMHgyMiAmJiBwcmV2ICE9PSAweDVDKSB7IGluRG91YmxlID0gZmFsc2U7IH1cbiAgICB9IGVsc2UgaWYgKGluVGVtcGxhdGVTdHJpbmcpIHtcbiAgICAgIGlmIChjID09PSAweDYwICYmIHByZXYgIT09IDB4NUMpIHsgaW5UZW1wbGF0ZVN0cmluZyA9IGZhbHNlOyB9XG4gICAgfSBlbHNlIGlmIChpblJlZ2V4KSB7XG4gICAgICBpZiAoYyA9PT0gMHgyZiAmJiBwcmV2ICE9PSAweDVDKSB7IGluUmVnZXggPSBmYWxzZTsgfVxuICAgIH0gZWxzZSBpZiAoXG4gICAgICBjID09PSAweDdDICYmIC8vIHBpcGVcbiAgICAgIGV4cC5jaGFyQ29kZUF0KGkgKyAxKSAhPT0gMHg3QyAmJlxuICAgICAgZXhwLmNoYXJDb2RlQXQoaSAtIDEpICE9PSAweDdDICYmXG4gICAgICAhY3VybHkgJiYgIXNxdWFyZSAmJiAhcGFyZW5cbiAgICApIHtcbiAgICAgIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgLy8gZmlyc3QgZmlsdGVyLCBlbmQgb2YgZXhwcmVzc2lvblxuICAgICAgICBsYXN0RmlsdGVySW5kZXggPSBpICsgMTtcbiAgICAgICAgZXhwcmVzc2lvbiA9IGV4cC5zbGljZSgwLCBpKS50cmltKCk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBwdXNoRmlsdGVyKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHN3aXRjaCAoYykge1xuICAgICAgICBjYXNlIDB4MjI6IGluRG91YmxlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyBcIlxuICAgICAgICBjYXNlIDB4Mjc6IGluU2luZ2xlID0gdHJ1ZTsgYnJlYWsgICAgICAgICAvLyAnXG4gICAgICAgIGNhc2UgMHg2MDogaW5UZW1wbGF0ZVN0cmluZyA9IHRydWU7IGJyZWFrIC8vIGBcbiAgICAgICAgY2FzZSAweDI4OiBwYXJlbisrOyBicmVhayAgICAgICAgICAgICAgICAgLy8gKFxuICAgICAgICBjYXNlIDB4Mjk6IHBhcmVuLS07IGJyZWFrICAgICAgICAgICAgICAgICAvLyApXG4gICAgICAgIGNhc2UgMHg1Qjogc3F1YXJlKys7IGJyZWFrICAgICAgICAgICAgICAgIC8vIFtcbiAgICAgICAgY2FzZSAweDVEOiBzcXVhcmUtLTsgYnJlYWsgICAgICAgICAgICAgICAgLy8gXVxuICAgICAgICBjYXNlIDB4N0I6IGN1cmx5Kys7IGJyZWFrICAgICAgICAgICAgICAgICAvLyB7XG4gICAgICAgIGNhc2UgMHg3RDogY3VybHktLTsgYnJlYWsgICAgICAgICAgICAgICAgIC8vIH1cbiAgICAgIH1cbiAgICAgIGlmIChjID09PSAweDJmKSB7IC8vIC9cbiAgICAgICAgdmFyIGogPSBpIC0gMTtcbiAgICAgICAgdmFyIHAgPSAodm9pZCAwKTtcbiAgICAgICAgLy8gZmluZCBmaXJzdCBub24td2hpdGVzcGFjZSBwcmV2IGNoYXJcbiAgICAgICAgZm9yICg7IGogPj0gMDsgai0tKSB7XG4gICAgICAgICAgcCA9IGV4cC5jaGFyQXQoaik7XG4gICAgICAgICAgaWYgKHAgIT09ICcgJykgeyBicmVhayB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFwIHx8ICF2YWxpZERpdmlzaW9uQ2hhclJFLnRlc3QocCkpIHtcbiAgICAgICAgICBpblJlZ2V4ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmIChleHByZXNzaW9uID09PSB1bmRlZmluZWQpIHtcbiAgICBleHByZXNzaW9uID0gZXhwLnNsaWNlKDAsIGkpLnRyaW0oKTtcbiAgfSBlbHNlIGlmIChsYXN0RmlsdGVySW5kZXggIT09IDApIHtcbiAgICBwdXNoRmlsdGVyKCk7XG4gIH1cblxuICBmdW5jdGlvbiBwdXNoRmlsdGVyICgpIHtcbiAgICAoZmlsdGVycyB8fCAoZmlsdGVycyA9IFtdKSkucHVzaChleHAuc2xpY2UobGFzdEZpbHRlckluZGV4LCBpKS50cmltKCkpO1xuICAgIGxhc3RGaWx0ZXJJbmRleCA9IGkgKyAxO1xuICB9XG5cbiAgaWYgKGZpbHRlcnMpIHtcbiAgICBmb3IgKGkgPSAwOyBpIDwgZmlsdGVycy5sZW5ndGg7IGkrKykge1xuICAgICAgZXhwcmVzc2lvbiA9IHdyYXBGaWx0ZXIoZXhwcmVzc2lvbiwgZmlsdGVyc1tpXSk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGV4cHJlc3Npb25cbn1cblxuZnVuY3Rpb24gd3JhcEZpbHRlciAoZXhwLCBmaWx0ZXIpIHtcbiAgdmFyIGkgPSBmaWx0ZXIuaW5kZXhPZignKCcpO1xuICBpZiAoaSA8IDApIHtcbiAgICAvLyBfZjogcmVzb2x2ZUZpbHRlclxuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBmaWx0ZXIgKyBcIlxcXCIpKFwiICsgZXhwICsgXCIpXCIpXG4gIH0gZWxzZSB7XG4gICAgdmFyIG5hbWUgPSBmaWx0ZXIuc2xpY2UoMCwgaSk7XG4gICAgdmFyIGFyZ3MgPSBmaWx0ZXIuc2xpY2UoaSArIDEpO1xuICAgIHJldHVybiAoXCJfZihcXFwiXCIgKyBuYW1lICsgXCJcXFwiKShcIiArIGV4cCArIFwiLFwiICsgYXJncylcbiAgfVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmFzZVdhcm4gKG1zZykge1xuICBjb25zb2xlLmVycm9yKChcIltWdWUgY29tcGlsZXJdOiBcIiArIG1zZykpO1xufVxuXG5mdW5jdGlvbiBwbHVja01vZHVsZUZ1bmN0aW9uIChcbiAgbW9kdWxlcyxcbiAga2V5XG4pIHtcbiAgcmV0dXJuIG1vZHVsZXNcbiAgICA/IG1vZHVsZXMubWFwKGZ1bmN0aW9uIChtKSB7IHJldHVybiBtW2tleV07IH0pLmZpbHRlcihmdW5jdGlvbiAoXykgeyByZXR1cm4gXzsgfSlcbiAgICA6IFtdXG59XG5cbmZ1bmN0aW9uIGFkZFByb3AgKGVsLCBuYW1lLCB2YWx1ZSkge1xuICAoZWwucHJvcHMgfHwgKGVsLnByb3BzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRBdHRyIChlbCwgbmFtZSwgdmFsdWUpIHtcbiAgKGVsLmF0dHJzIHx8IChlbC5hdHRycyA9IFtdKSkucHVzaCh7IG5hbWU6IG5hbWUsIHZhbHVlOiB2YWx1ZSB9KTtcbn1cblxuZnVuY3Rpb24gYWRkRGlyZWN0aXZlIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJhd05hbWUsXG4gIHZhbHVlLFxuICBhcmcsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIChlbC5kaXJlY3RpdmVzIHx8IChlbC5kaXJlY3RpdmVzID0gW10pKS5wdXNoKHsgbmFtZTogbmFtZSwgcmF3TmFtZTogcmF3TmFtZSwgdmFsdWU6IHZhbHVlLCBhcmc6IGFyZywgbW9kaWZpZXJzOiBtb2RpZmllcnMgfSk7XG59XG5cbmZ1bmN0aW9uIGFkZEhhbmRsZXIgKFxuICBlbCxcbiAgbmFtZSxcbiAgdmFsdWUsXG4gIG1vZGlmaWVycyxcbiAgaW1wb3J0YW50LFxuICB3YXJuXG4pIHtcbiAgbW9kaWZpZXJzID0gbW9kaWZpZXJzIHx8IGVtcHR5T2JqZWN0O1xuICAvLyB3YXJuIHByZXZlbnQgYW5kIHBhc3NpdmUgbW9kaWZpZXJcbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChcbiAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4gJiZcbiAgICBtb2RpZmllcnMucHJldmVudCAmJiBtb2RpZmllcnMucGFzc2l2ZVxuICApIHtcbiAgICB3YXJuKFxuICAgICAgJ3Bhc3NpdmUgYW5kIHByZXZlbnQgY2FuXFwndCBiZSB1c2VkIHRvZ2V0aGVyLiAnICtcbiAgICAgICdQYXNzaXZlIGhhbmRsZXIgY2FuXFwndCBwcmV2ZW50IGRlZmF1bHQgZXZlbnQuJ1xuICAgICk7XG4gIH1cblxuICAvLyBjaGVjayBjYXB0dXJlIG1vZGlmaWVyXG4gIGlmIChtb2RpZmllcnMuY2FwdHVyZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMuY2FwdHVyZTtcbiAgICBuYW1lID0gJyEnICsgbmFtZTsgLy8gbWFyayB0aGUgZXZlbnQgYXMgY2FwdHVyZWRcbiAgfVxuICBpZiAobW9kaWZpZXJzLm9uY2UpIHtcbiAgICBkZWxldGUgbW9kaWZpZXJzLm9uY2U7XG4gICAgbmFtZSA9ICd+JyArIG5hbWU7IC8vIG1hcmsgdGhlIGV2ZW50IGFzIG9uY2VcbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKG1vZGlmaWVycy5wYXNzaXZlKSB7XG4gICAgZGVsZXRlIG1vZGlmaWVycy5wYXNzaXZlO1xuICAgIG5hbWUgPSAnJicgKyBuYW1lOyAvLyBtYXJrIHRoZSBldmVudCBhcyBwYXNzaXZlXG4gIH1cblxuICAvLyBub3JtYWxpemUgY2xpY2sucmlnaHQgYW5kIGNsaWNrLm1pZGRsZSBzaW5jZSB0aGV5IGRvbid0IGFjdHVhbGx5IGZpcmVcbiAgLy8gdGhpcyBpcyB0ZWNobmljYWxseSBicm93c2VyLXNwZWNpZmljLCBidXQgYXQgbGVhc3QgZm9yIG5vdyBicm93c2VycyBhcmVcbiAgLy8gdGhlIG9ubHkgdGFyZ2V0IGVudnMgdGhhdCBoYXZlIHJpZ2h0L21pZGRsZSBjbGlja3MuXG4gIGlmIChuYW1lID09PSAnY2xpY2snKSB7XG4gICAgaWYgKG1vZGlmaWVycy5yaWdodCkge1xuICAgICAgbmFtZSA9ICdjb250ZXh0bWVudSc7XG4gICAgICBkZWxldGUgbW9kaWZpZXJzLnJpZ2h0O1xuICAgIH0gZWxzZSBpZiAobW9kaWZpZXJzLm1pZGRsZSkge1xuICAgICAgbmFtZSA9ICdtb3VzZXVwJztcbiAgICB9XG4gIH1cblxuICB2YXIgZXZlbnRzO1xuICBpZiAobW9kaWZpZXJzLm5hdGl2ZSkge1xuICAgIGRlbGV0ZSBtb2RpZmllcnMubmF0aXZlO1xuICAgIGV2ZW50cyA9IGVsLm5hdGl2ZUV2ZW50cyB8fCAoZWwubmF0aXZlRXZlbnRzID0ge30pO1xuICB9IGVsc2Uge1xuICAgIGV2ZW50cyA9IGVsLmV2ZW50cyB8fCAoZWwuZXZlbnRzID0ge30pO1xuICB9XG5cbiAgdmFyIG5ld0hhbmRsZXIgPSB7IHZhbHVlOiB2YWx1ZSB9O1xuICBpZiAobW9kaWZpZXJzICE9PSBlbXB0eU9iamVjdCkge1xuICAgIG5ld0hhbmRsZXIubW9kaWZpZXJzID0gbW9kaWZpZXJzO1xuICB9XG5cbiAgdmFyIGhhbmRsZXJzID0gZXZlbnRzW25hbWVdO1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKEFycmF5LmlzQXJyYXkoaGFuZGxlcnMpKSB7XG4gICAgaW1wb3J0YW50ID8gaGFuZGxlcnMudW5zaGlmdChuZXdIYW5kbGVyKSA6IGhhbmRsZXJzLnB1c2gobmV3SGFuZGxlcik7XG4gIH0gZWxzZSBpZiAoaGFuZGxlcnMpIHtcbiAgICBldmVudHNbbmFtZV0gPSBpbXBvcnRhbnQgPyBbbmV3SGFuZGxlciwgaGFuZGxlcnNdIDogW2hhbmRsZXJzLCBuZXdIYW5kbGVyXTtcbiAgfSBlbHNlIHtcbiAgICBldmVudHNbbmFtZV0gPSBuZXdIYW5kbGVyO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldEJpbmRpbmdBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIGdldFN0YXRpY1xuKSB7XG4gIHZhciBkeW5hbWljVmFsdWUgPVxuICAgIGdldEFuZFJlbW92ZUF0dHIoZWwsICc6JyArIG5hbWUpIHx8XG4gICAgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtYmluZDonICsgbmFtZSk7XG4gIGlmIChkeW5hbWljVmFsdWUgIT0gbnVsbCkge1xuICAgIHJldHVybiBwYXJzZUZpbHRlcnMoZHluYW1pY1ZhbHVlKVxuICB9IGVsc2UgaWYgKGdldFN0YXRpYyAhPT0gZmFsc2UpIHtcbiAgICB2YXIgc3RhdGljVmFsdWUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCBuYW1lKTtcbiAgICBpZiAoc3RhdGljVmFsdWUgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHN0YXRpY1ZhbHVlKVxuICAgIH1cbiAgfVxufVxuXG4vLyBub3RlOiB0aGlzIG9ubHkgcmVtb3ZlcyB0aGUgYXR0ciBmcm9tIHRoZSBBcnJheSAoYXR0cnNMaXN0KSBzbyB0aGF0IGl0XG4vLyBkb2Vzbid0IGdldCBwcm9jZXNzZWQgYnkgcHJvY2Vzc0F0dHJzLlxuLy8gQnkgZGVmYXVsdCBpdCBkb2VzIE5PVCByZW1vdmUgaXQgZnJvbSB0aGUgbWFwIChhdHRyc01hcCkgYmVjYXVzZSB0aGUgbWFwIGlzXG4vLyBuZWVkZWQgZHVyaW5nIGNvZGVnZW4uXG5mdW5jdGlvbiBnZXRBbmRSZW1vdmVBdHRyIChcbiAgZWwsXG4gIG5hbWUsXG4gIHJlbW92ZUZyb21NYXBcbikge1xuICB2YXIgdmFsO1xuICBpZiAoKHZhbCA9IGVsLmF0dHJzTWFwW25hbWVdKSAhPSBudWxsKSB7XG4gICAgdmFyIGxpc3QgPSBlbC5hdHRyc0xpc3Q7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBsaXN0Lmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgaWYgKGxpc3RbaV0ubmFtZSA9PT0gbmFtZSkge1xuICAgICAgICBsaXN0LnNwbGljZShpLCAxKTtcbiAgICAgICAgYnJlYWtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKHJlbW92ZUZyb21NYXApIHtcbiAgICBkZWxldGUgZWwuYXR0cnNNYXBbbmFtZV07XG4gIH1cbiAgcmV0dXJuIHZhbFxufVxuXG4vKiAgKi9cblxuLyoqXG4gKiBDcm9zcy1wbGF0Zm9ybSBjb2RlIGdlbmVyYXRpb24gZm9yIGNvbXBvbmVudCB2LW1vZGVsXG4gKi9cbmZ1bmN0aW9uIGdlbkNvbXBvbmVudE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcblxuICB2YXIgYmFzZVZhbHVlRXhwcmVzc2lvbiA9ICckJHYnO1xuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gYmFzZVZhbHVlRXhwcmVzc2lvbjtcbiAgaWYgKHRyaW0pIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPVxuICAgICAgXCIodHlwZW9mIFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiID09PSAnc3RyaW5nJ1wiICtcbiAgICAgICAgXCI/IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiLnRyaW0oKVwiICtcbiAgICAgICAgXCI6IFwiICsgYmFzZVZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG4gIGlmIChudW1iZXIpIHtcbiAgICB2YWx1ZUV4cHJlc3Npb24gPSBcIl9uKFwiICsgdmFsdWVFeHByZXNzaW9uICsgXCIpXCI7XG4gIH1cbiAgdmFyIGFzc2lnbm1lbnQgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcblxuICBlbC5tb2RlbCA9IHtcbiAgICB2YWx1ZTogKFwiKFwiICsgdmFsdWUgKyBcIilcIiksXG4gICAgZXhwcmVzc2lvbjogKFwiXFxcIlwiICsgdmFsdWUgKyBcIlxcXCJcIiksXG4gICAgY2FsbGJhY2s6IChcImZ1bmN0aW9uIChcIiArIGJhc2VWYWx1ZUV4cHJlc3Npb24gKyBcIikge1wiICsgYXNzaWdubWVudCArIFwifVwiKVxuICB9O1xufVxuXG4vKipcbiAqIENyb3NzLXBsYXRmb3JtIGNvZGVnZW4gaGVscGVyIGZvciBnZW5lcmF0aW5nIHYtbW9kZWwgdmFsdWUgYXNzaWdubWVudCBjb2RlLlxuICovXG5mdW5jdGlvbiBnZW5Bc3NpZ25tZW50Q29kZSAoXG4gIHZhbHVlLFxuICBhc3NpZ25tZW50XG4pIHtcbiAgdmFyIHJlcyA9IHBhcnNlTW9kZWwodmFsdWUpO1xuICBpZiAocmVzLmtleSA9PT0gbnVsbCkge1xuICAgIHJldHVybiAodmFsdWUgKyBcIj1cIiArIGFzc2lnbm1lbnQpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIiRzZXQoXCIgKyAocmVzLmV4cCkgKyBcIiwgXCIgKyAocmVzLmtleSkgKyBcIiwgXCIgKyBhc3NpZ25tZW50ICsgXCIpXCIpXG4gIH1cbn1cblxuLyoqXG4gKiBQYXJzZSBhIHYtbW9kZWwgZXhwcmVzc2lvbiBpbnRvIGEgYmFzZSBwYXRoIGFuZCBhIGZpbmFsIGtleSBzZWdtZW50LlxuICogSGFuZGxlcyBib3RoIGRvdC1wYXRoIGFuZCBwb3NzaWJsZSBzcXVhcmUgYnJhY2tldHMuXG4gKlxuICogUG9zc2libGUgY2FzZXM6XG4gKlxuICogLSB0ZXN0XG4gKiAtIHRlc3Rba2V5XVxuICogLSB0ZXN0W3Rlc3QxW2tleV1dXG4gKiAtIHRlc3RbXCJhXCJdW2tleV1cbiAqIC0geHh4LnRlc3RbYVthXS50ZXN0MVtrZXldXVxuICogLSB0ZXN0Lnh4eC5hW1wiYXNhXCJdW3Rlc3QxW2tleV1dXG4gKlxuICovXG5cbnZhciBsZW47XG52YXIgc3RyO1xudmFyIGNocjtcbnZhciBpbmRleCQxO1xudmFyIGV4cHJlc3Npb25Qb3M7XG52YXIgZXhwcmVzc2lvbkVuZFBvcztcblxuXG5cbmZ1bmN0aW9uIHBhcnNlTW9kZWwgKHZhbCkge1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuXG4gIGlmICh2YWwuaW5kZXhPZignWycpIDwgMCB8fCB2YWwubGFzdEluZGV4T2YoJ10nKSA8IGxlbiAtIDEpIHtcbiAgICBpbmRleCQxID0gdmFsLmxhc3RJbmRleE9mKCcuJyk7XG4gICAgaWYgKGluZGV4JDEgPiAtMSkge1xuICAgICAgcmV0dXJuIHtcbiAgICAgICAgZXhwOiB2YWwuc2xpY2UoMCwgaW5kZXgkMSksXG4gICAgICAgIGtleTogJ1wiJyArIHZhbC5zbGljZShpbmRleCQxICsgMSkgKyAnXCInXG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHJldHVybiB7XG4gICAgICAgIGV4cDogdmFsLFxuICAgICAgICBrZXk6IG51bGxcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBzdHIgPSB2YWw7XG4gIGluZGV4JDEgPSBleHByZXNzaW9uUG9zID0gZXhwcmVzc2lvbkVuZFBvcyA9IDA7XG5cbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgIH0gZWxzZSBpZiAoY2hyID09PSAweDVCKSB7XG4gICAgICBwYXJzZUJyYWNrZXQoY2hyKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4ge1xuICAgIGV4cDogdmFsLnNsaWNlKDAsIGV4cHJlc3Npb25Qb3MpLFxuICAgIGtleTogdmFsLnNsaWNlKGV4cHJlc3Npb25Qb3MgKyAxLCBleHByZXNzaW9uRW5kUG9zKVxuICB9XG59XG5cbmZ1bmN0aW9uIG5leHQgKCkge1xuICByZXR1cm4gc3RyLmNoYXJDb2RlQXQoKytpbmRleCQxKVxufVxuXG5mdW5jdGlvbiBlb2YgKCkge1xuICByZXR1cm4gaW5kZXgkMSA+PSBsZW5cbn1cblxuZnVuY3Rpb24gaXNTdHJpbmdTdGFydCAoY2hyKSB7XG4gIHJldHVybiBjaHIgPT09IDB4MjIgfHwgY2hyID09PSAweDI3XG59XG5cbmZ1bmN0aW9uIHBhcnNlQnJhY2tldCAoY2hyKSB7XG4gIHZhciBpbkJyYWNrZXQgPSAxO1xuICBleHByZXNzaW9uUG9zID0gaW5kZXgkMTtcbiAgd2hpbGUgKCFlb2YoKSkge1xuICAgIGNociA9IG5leHQoKTtcbiAgICBpZiAoaXNTdHJpbmdTdGFydChjaHIpKSB7XG4gICAgICBwYXJzZVN0cmluZyhjaHIpO1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKGNociA9PT0gMHg1QikgeyBpbkJyYWNrZXQrKzsgfVxuICAgIGlmIChjaHIgPT09IDB4NUQpIHsgaW5CcmFja2V0LS07IH1cbiAgICBpZiAoaW5CcmFja2V0ID09PSAwKSB7XG4gICAgICBleHByZXNzaW9uRW5kUG9zID0gaW5kZXgkMTtcbiAgICAgIGJyZWFrXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlU3RyaW5nIChjaHIpIHtcbiAgdmFyIHN0cmluZ1F1b3RlID0gY2hyO1xuICB3aGlsZSAoIWVvZigpKSB7XG4gICAgY2hyID0gbmV4dCgpO1xuICAgIGlmIChjaHIgPT09IHN0cmluZ1F1b3RlKSB7XG4gICAgICBicmVha1xuICAgIH1cbiAgfVxufVxuXG4vKiAgKi9cblxudmFyIHdhcm4kMTtcblxuLy8gaW4gc29tZSBjYXNlcywgdGhlIGV2ZW50IHVzZWQgaGFzIHRvIGJlIGRldGVybWluZWQgYXQgcnVudGltZVxuLy8gc28gd2UgdXNlZCBzb21lIHJlc2VydmVkIHRva2VucyBkdXJpbmcgY29tcGlsZS5cbnZhciBSQU5HRV9UT0tFTiA9ICdfX3InO1xudmFyIENIRUNLQk9YX1JBRElPX1RPS0VOID0gJ19fYyc7XG5cbmZ1bmN0aW9uIG1vZGVsIChcbiAgZWwsXG4gIGRpcixcbiAgX3dhcm5cbikge1xuICB3YXJuJDEgPSBfd2FybjtcbiAgdmFyIHZhbHVlID0gZGlyLnZhbHVlO1xuICB2YXIgbW9kaWZpZXJzID0gZGlyLm1vZGlmaWVycztcbiAgdmFyIHRhZyA9IGVsLnRhZztcbiAgdmFyIHR5cGUgPSBlbC5hdHRyc01hcC50eXBlO1xuXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgLy8gaW5wdXRzIHdpdGggdHlwZT1cImZpbGVcIiBhcmUgcmVhZCBvbmx5IGFuZCBzZXR0aW5nIHRoZSBpbnB1dCdzXG4gICAgLy8gdmFsdWUgd2lsbCB0aHJvdyBhbiBlcnJvci5cbiAgICBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdmaWxlJykge1xuICAgICAgd2FybiQxKFxuICAgICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIiB0eXBlPVxcXCJmaWxlXFxcIj46XFxuXCIgK1xuICAgICAgICBcIkZpbGUgaW5wdXRzIGFyZSByZWFkIG9ubHkuIFVzZSBhIHYtb246Y2hhbmdlIGxpc3RlbmVyIGluc3RlYWQuXCJcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgaWYgKGVsLmNvbXBvbmVudCkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICBnZW5TZWxlY3QoZWwsIHZhbHVlLCBtb2RpZmllcnMpO1xuICB9IGVsc2UgaWYgKHRhZyA9PT0gJ2lucHV0JyAmJiB0eXBlID09PSAnY2hlY2tib3gnKSB7XG4gICAgZ2VuQ2hlY2tib3hNb2RlbChlbCwgdmFsdWUsIG1vZGlmaWVycyk7XG4gIH0gZWxzZSBpZiAodGFnID09PSAnaW5wdXQnICYmIHR5cGUgPT09ICdyYWRpbycpIHtcbiAgICBnZW5SYWRpb01vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICh0YWcgPT09ICdpbnB1dCcgfHwgdGFnID09PSAndGV4dGFyZWEnKSB7XG4gICAgZ2VuRGVmYXVsdE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgfSBlbHNlIGlmICghY29uZmlnLmlzUmVzZXJ2ZWRUYWcodGFnKSkge1xuICAgIGdlbkNvbXBvbmVudE1vZGVsKGVsLCB2YWx1ZSwgbW9kaWZpZXJzKTtcbiAgICAvLyBjb21wb25lbnQgdi1tb2RlbCBkb2Vzbid0IG5lZWQgZXh0cmEgcnVudGltZVxuICAgIHJldHVybiBmYWxzZVxuICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICB3YXJuJDEoXG4gICAgICBcIjxcIiArIChlbC50YWcpICsgXCIgdi1tb2RlbD1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIj46IFwiICtcbiAgICAgIFwidi1tb2RlbCBpcyBub3Qgc3VwcG9ydGVkIG9uIHRoaXMgZWxlbWVudCB0eXBlLiBcIiArXG4gICAgICAnSWYgeW91IGFyZSB3b3JraW5nIHdpdGggY29udGVudGVkaXRhYmxlLCBpdFxcJ3MgcmVjb21tZW5kZWQgdG8gJyArXG4gICAgICAnd3JhcCBhIGxpYnJhcnkgZGVkaWNhdGVkIGZvciB0aGF0IHB1cnBvc2UgaW5zaWRlIGEgY3VzdG9tIGNvbXBvbmVudC4nXG4gICAgKTtcbiAgfVxuXG4gIC8vIGVuc3VyZSBydW50aW1lIGRpcmVjdGl2ZSBtZXRhZGF0YVxuICByZXR1cm4gdHJ1ZVxufVxuXG5mdW5jdGlvbiBnZW5DaGVja2JveE1vZGVsIChcbiAgZWwsXG4gIHZhbHVlLFxuICBtb2RpZmllcnNcbikge1xuICB2YXIgbnVtYmVyID0gbW9kaWZpZXJzICYmIG1vZGlmaWVycy5udW1iZXI7XG4gIHZhciB2YWx1ZUJpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ3ZhbHVlJykgfHwgJ251bGwnO1xuICB2YXIgdHJ1ZVZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndHJ1ZS12YWx1ZScpIHx8ICd0cnVlJztcbiAgdmFyIGZhbHNlVmFsdWVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdmYWxzZS12YWx1ZScpIHx8ICdmYWxzZSc7XG4gIGFkZFByb3AoZWwsICdjaGVja2VkJyxcbiAgICBcIkFycmF5LmlzQXJyYXkoXCIgKyB2YWx1ZSArIFwiKVwiICtcbiAgICAgIFwiP19pKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKT4tMVwiICsgKFxuICAgICAgICB0cnVlVmFsdWVCaW5kaW5nID09PSAndHJ1ZSdcbiAgICAgICAgICA/IChcIjooXCIgKyB2YWx1ZSArIFwiKVwiKVxuICAgICAgICAgIDogKFwiOl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHRydWVWYWx1ZUJpbmRpbmcgKyBcIilcIilcbiAgICAgIClcbiAgKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsXG4gICAgXCJ2YXIgJCRhPVwiICsgdmFsdWUgKyBcIixcIiArXG4gICAgICAgICckJGVsPSRldmVudC50YXJnZXQsJyArXG4gICAgICAgIFwiJCRjPSQkZWwuY2hlY2tlZD8oXCIgKyB0cnVlVmFsdWVCaW5kaW5nICsgXCIpOihcIiArIGZhbHNlVmFsdWVCaW5kaW5nICsgXCIpO1wiICtcbiAgICAnaWYoQXJyYXkuaXNBcnJheSgkJGEpKXsnICtcbiAgICAgIFwidmFyICQkdj1cIiArIChudW1iZXIgPyAnX24oJyArIHZhbHVlQmluZGluZyArICcpJyA6IHZhbHVlQmluZGluZykgKyBcIixcIiArXG4gICAgICAgICAgJyQkaT1faSgkJGEsJCR2KTsnICtcbiAgICAgIFwiaWYoJCRlbC5jaGVja2VkKXskJGk8MCYmKFwiICsgdmFsdWUgKyBcIj0kJGEuY29uY2F0KFskJHZdKSl9XCIgK1xuICAgICAgXCJlbHNleyQkaT4tMSYmKFwiICsgdmFsdWUgKyBcIj0kJGEuc2xpY2UoMCwkJGkpLmNvbmNhdCgkJGEuc2xpY2UoJCRpKzEpKSl9XCIgK1xuICAgIFwifWVsc2V7XCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsICckJGMnKSkgKyBcIn1cIixcbiAgICBudWxsLCB0cnVlXG4gICk7XG59XG5cbmZ1bmN0aW9uIGdlblJhZGlvTW9kZWwgKFxuICAgIGVsLFxuICAgIHZhbHVlLFxuICAgIG1vZGlmaWVyc1xuKSB7XG4gIHZhciBudW1iZXIgPSBtb2RpZmllcnMgJiYgbW9kaWZpZXJzLm51bWJlcjtcbiAgdmFyIHZhbHVlQmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAndmFsdWUnKSB8fCAnbnVsbCc7XG4gIHZhbHVlQmluZGluZyA9IG51bWJlciA/IChcIl9uKFwiICsgdmFsdWVCaW5kaW5nICsgXCIpXCIpIDogdmFsdWVCaW5kaW5nO1xuICBhZGRQcm9wKGVsLCAnY2hlY2tlZCcsIChcIl9xKFwiICsgdmFsdWUgKyBcIixcIiArIHZhbHVlQmluZGluZyArIFwiKVwiKSk7XG4gIGFkZEhhbmRsZXIoZWwsICdjaGFuZ2UnLCBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVCaW5kaW5nKSwgbnVsbCwgdHJ1ZSk7XG59XG5cbmZ1bmN0aW9uIGdlblNlbGVjdCAoXG4gICAgZWwsXG4gICAgdmFsdWUsXG4gICAgbW9kaWZpZXJzXG4pIHtcbiAgdmFyIG51bWJlciA9IG1vZGlmaWVycyAmJiBtb2RpZmllcnMubnVtYmVyO1xuICB2YXIgc2VsZWN0ZWRWYWwgPSBcIkFycmF5LnByb3RvdHlwZS5maWx0ZXJcIiArXG4gICAgXCIuY2FsbCgkZXZlbnQudGFyZ2V0Lm9wdGlvbnMsZnVuY3Rpb24obyl7cmV0dXJuIG8uc2VsZWN0ZWR9KVwiICtcbiAgICBcIi5tYXAoZnVuY3Rpb24obyl7dmFyIHZhbCA9IFxcXCJfdmFsdWVcXFwiIGluIG8gPyBvLl92YWx1ZSA6IG8udmFsdWU7XCIgK1xuICAgIFwicmV0dXJuIFwiICsgKG51bWJlciA/ICdfbih2YWwpJyA6ICd2YWwnKSArIFwifSlcIjtcblxuICB2YXIgYXNzaWdubWVudCA9ICckZXZlbnQudGFyZ2V0Lm11bHRpcGxlID8gJCRzZWxlY3RlZFZhbCA6ICQkc2VsZWN0ZWRWYWxbMF0nO1xuICB2YXIgY29kZSA9IFwidmFyICQkc2VsZWN0ZWRWYWwgPSBcIiArIHNlbGVjdGVkVmFsICsgXCI7XCI7XG4gIGNvZGUgPSBjb2RlICsgXCIgXCIgKyAoZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIGFzc2lnbm1lbnQpKTtcbiAgYWRkSGFuZGxlcihlbCwgJ2NoYW5nZScsIGNvZGUsIG51bGwsIHRydWUpO1xufVxuXG5mdW5jdGlvbiBnZW5EZWZhdWx0TW9kZWwgKFxuICBlbCxcbiAgdmFsdWUsXG4gIG1vZGlmaWVyc1xuKSB7XG4gIHZhciB0eXBlID0gZWwuYXR0cnNNYXAudHlwZTtcblxuICAvLyB3YXJuIGlmIHYtYmluZDp2YWx1ZSBjb25mbGljdHMgd2l0aCB2LW1vZGVsXG4gIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgdmFyIHZhbHVlJDEgPSBlbC5hdHRyc01hcFsndi1iaW5kOnZhbHVlJ10gfHwgZWwuYXR0cnNNYXBbJzp2YWx1ZSddO1xuICAgIGlmICh2YWx1ZSQxKSB7XG4gICAgICB2YXIgYmluZGluZyA9IGVsLmF0dHJzTWFwWyd2LWJpbmQ6dmFsdWUnXSA/ICd2LWJpbmQ6dmFsdWUnIDogJzp2YWx1ZSc7XG4gICAgICB3YXJuJDEoXG4gICAgICAgIGJpbmRpbmcgKyBcIj1cXFwiXCIgKyB2YWx1ZSQxICsgXCJcXFwiIGNvbmZsaWN0cyB3aXRoIHYtbW9kZWwgb24gdGhlIHNhbWUgZWxlbWVudCBcIiArXG4gICAgICAgICdiZWNhdXNlIHRoZSBsYXR0ZXIgYWxyZWFkeSBleHBhbmRzIHRvIGEgdmFsdWUgYmluZGluZyBpbnRlcm5hbGx5J1xuICAgICAgKTtcbiAgICB9XG4gIH1cblxuICB2YXIgcmVmID0gbW9kaWZpZXJzIHx8IHt9O1xuICB2YXIgbGF6eSA9IHJlZi5sYXp5O1xuICB2YXIgbnVtYmVyID0gcmVmLm51bWJlcjtcbiAgdmFyIHRyaW0gPSByZWYudHJpbTtcbiAgdmFyIG5lZWRDb21wb3NpdGlvbkd1YXJkID0gIWxhenkgJiYgdHlwZSAhPT0gJ3JhbmdlJztcbiAgdmFyIGV2ZW50ID0gbGF6eVxuICAgID8gJ2NoYW5nZSdcbiAgICA6IHR5cGUgPT09ICdyYW5nZSdcbiAgICAgID8gUkFOR0VfVE9LRU5cbiAgICAgIDogJ2lucHV0JztcblxuICB2YXIgdmFsdWVFeHByZXNzaW9uID0gJyRldmVudC50YXJnZXQudmFsdWUnO1xuICBpZiAodHJpbSkge1xuICAgIHZhbHVlRXhwcmVzc2lvbiA9IFwiJGV2ZW50LnRhcmdldC52YWx1ZS50cmltKClcIjtcbiAgfVxuICBpZiAobnVtYmVyKSB7XG4gICAgdmFsdWVFeHByZXNzaW9uID0gXCJfbihcIiArIHZhbHVlRXhwcmVzc2lvbiArIFwiKVwiO1xuICB9XG5cbiAgdmFyIGNvZGUgPSBnZW5Bc3NpZ25tZW50Q29kZSh2YWx1ZSwgdmFsdWVFeHByZXNzaW9uKTtcbiAgaWYgKG5lZWRDb21wb3NpdGlvbkd1YXJkKSB7XG4gICAgY29kZSA9IFwiaWYoJGV2ZW50LnRhcmdldC5jb21wb3NpbmcpcmV0dXJuO1wiICsgY29kZTtcbiAgfVxuXG4gIGFkZFByb3AoZWwsICd2YWx1ZScsIChcIihcIiArIHZhbHVlICsgXCIpXCIpKTtcbiAgYWRkSGFuZGxlcihlbCwgZXZlbnQsIGNvZGUsIG51bGwsIHRydWUpO1xuICBpZiAodHJpbSB8fCBudW1iZXIpIHtcbiAgICBhZGRIYW5kbGVyKGVsLCAnYmx1cicsICckZm9yY2VVcGRhdGUoKScpO1xuICB9XG59XG5cbi8qICAqL1xuXG4vLyBub3JtYWxpemUgdi1tb2RlbCBldmVudCB0b2tlbnMgdGhhdCBjYW4gb25seSBiZSBkZXRlcm1pbmVkIGF0IHJ1bnRpbWUuXG4vLyBpdCdzIGltcG9ydGFudCB0byBwbGFjZSB0aGUgZXZlbnQgYXMgdGhlIGZpcnN0IGluIHRoZSBhcnJheSBiZWNhdXNlXG4vLyB0aGUgd2hvbGUgcG9pbnQgaXMgZW5zdXJpbmcgdGhlIHYtbW9kZWwgY2FsbGJhY2sgZ2V0cyBjYWxsZWQgYmVmb3JlXG4vLyB1c2VyLWF0dGFjaGVkIGhhbmRsZXJzLlxuZnVuY3Rpb24gbm9ybWFsaXplRXZlbnRzIChvbikge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW1JBTkdFX1RPS0VOXSkpIHtcbiAgICAvLyBJRSBpbnB1dFt0eXBlPXJhbmdlXSBvbmx5IHN1cHBvcnRzIGBjaGFuZ2VgIGV2ZW50XG4gICAgdmFyIGV2ZW50ID0gaXNJRSA/ICdjaGFuZ2UnIDogJ2lucHV0JztcbiAgICBvbltldmVudF0gPSBbXS5jb25jYXQob25bUkFOR0VfVE9LRU5dLCBvbltldmVudF0gfHwgW10pO1xuICAgIGRlbGV0ZSBvbltSQU5HRV9UT0tFTl07XG4gIH1cbiAgLy8gVGhpcyB3YXMgb3JpZ2luYWxseSBpbnRlbmRlZCB0byBmaXggIzQ1MjEgYnV0IG5vIGxvbmdlciBuZWNlc3NhcnlcbiAgLy8gYWZ0ZXIgMi41LiBLZWVwaW5nIGl0IGZvciBiYWNrd2FyZHMgY29tcGF0IHdpdGggZ2VuZXJhdGVkIGNvZGUgZnJvbSA8IDIuNFxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKG9uW0NIRUNLQk9YX1JBRElPX1RPS0VOXSkpIHtcbiAgICBvbi5jaGFuZ2UgPSBbXS5jb25jYXQob25bQ0hFQ0tCT1hfUkFESU9fVE9LRU5dLCBvbi5jaGFuZ2UgfHwgW10pO1xuICAgIGRlbGV0ZSBvbltDSEVDS0JPWF9SQURJT19UT0tFTl07XG4gIH1cbn1cblxudmFyIHRhcmdldCQxO1xuXG5mdW5jdGlvbiBjcmVhdGVPbmNlSGFuZGxlciAoaGFuZGxlciwgZXZlbnQsIGNhcHR1cmUpIHtcbiAgdmFyIF90YXJnZXQgPSB0YXJnZXQkMTsgLy8gc2F2ZSBjdXJyZW50IHRhcmdldCBlbGVtZW50IGluIGNsb3N1cmVcbiAgcmV0dXJuIGZ1bmN0aW9uIG9uY2VIYW5kbGVyICgpIHtcbiAgICB2YXIgcmVzID0gaGFuZGxlci5hcHBseShudWxsLCBhcmd1bWVudHMpO1xuICAgIGlmIChyZXMgIT09IG51bGwpIHtcbiAgICAgIHJlbW92ZSQyKGV2ZW50LCBvbmNlSGFuZGxlciwgY2FwdHVyZSwgX3RhcmdldCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZCQxIChcbiAgZXZlbnQsXG4gIGhhbmRsZXIsXG4gIG9uY2UkJDEsXG4gIGNhcHR1cmUsXG4gIHBhc3NpdmVcbikge1xuICBoYW5kbGVyID0gd2l0aE1hY3JvVGFzayhoYW5kbGVyKTtcbiAgaWYgKG9uY2UkJDEpIHsgaGFuZGxlciA9IGNyZWF0ZU9uY2VIYW5kbGVyKGhhbmRsZXIsIGV2ZW50LCBjYXB0dXJlKTsgfVxuICB0YXJnZXQkMS5hZGRFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIsXG4gICAgc3VwcG9ydHNQYXNzaXZlXG4gICAgICA/IHsgY2FwdHVyZTogY2FwdHVyZSwgcGFzc2l2ZTogcGFzc2l2ZSB9XG4gICAgICA6IGNhcHR1cmVcbiAgKTtcbn1cblxuZnVuY3Rpb24gcmVtb3ZlJDIgKFxuICBldmVudCxcbiAgaGFuZGxlcixcbiAgY2FwdHVyZSxcbiAgX3RhcmdldFxuKSB7XG4gIChfdGFyZ2V0IHx8IHRhcmdldCQxKS5yZW1vdmVFdmVudExpc3RlbmVyKFxuICAgIGV2ZW50LFxuICAgIGhhbmRsZXIuX3dpdGhUYXNrIHx8IGhhbmRsZXIsXG4gICAgY2FwdHVyZVxuICApO1xufVxuXG5mdW5jdGlvbiB1cGRhdGVET01MaXN0ZW5lcnMgKG9sZFZub2RlLCB2bm9kZSkge1xuICBpZiAoaXNVbmRlZihvbGRWbm9kZS5kYXRhLm9uKSAmJiBpc1VuZGVmKHZub2RlLmRhdGEub24pKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIG9uID0gdm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdmFyIG9sZE9uID0gb2xkVm5vZGUuZGF0YS5vbiB8fCB7fTtcbiAgdGFyZ2V0JDEgPSB2bm9kZS5lbG07XG4gIG5vcm1hbGl6ZUV2ZW50cyhvbik7XG4gIHVwZGF0ZUxpc3RlbmVycyhvbiwgb2xkT24sIGFkZCQxLCByZW1vdmUkMiwgdm5vZGUuY29udGV4dCk7XG4gIHRhcmdldCQxID0gdW5kZWZpbmVkO1xufVxuXG52YXIgZXZlbnRzID0ge1xuICBjcmVhdGU6IHVwZGF0ZURPTUxpc3RlbmVycyxcbiAgdXBkYXRlOiB1cGRhdGVET01MaXN0ZW5lcnNcbn07XG5cbi8qICAqL1xuXG5mdW5jdGlvbiB1cGRhdGVET01Qcm9wcyAob2xkVm5vZGUsIHZub2RlKSB7XG4gIGlmIChpc1VuZGVmKG9sZFZub2RlLmRhdGEuZG9tUHJvcHMpICYmIGlzVW5kZWYodm5vZGUuZGF0YS5kb21Qcm9wcykpIHtcbiAgICByZXR1cm5cbiAgfVxuICB2YXIga2V5LCBjdXI7XG4gIHZhciBlbG0gPSB2bm9kZS5lbG07XG4gIHZhciBvbGRQcm9wcyA9IG9sZFZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIHZhciBwcm9wcyA9IHZub2RlLmRhdGEuZG9tUHJvcHMgfHwge307XG4gIC8vIGNsb25lIG9ic2VydmVkIG9iamVjdHMsIGFzIHRoZSB1c2VyIHByb2JhYmx5IHdhbnRzIHRvIG11dGF0ZSBpdFxuICBpZiAoaXNEZWYocHJvcHMuX19vYl9fKSkge1xuICAgIHByb3BzID0gdm5vZGUuZGF0YS5kb21Qcm9wcyA9IGV4dGVuZCh7fSwgcHJvcHMpO1xuICB9XG5cbiAgZm9yIChrZXkgaW4gb2xkUHJvcHMpIHtcbiAgICBpZiAoaXNVbmRlZihwcm9wc1trZXldKSkge1xuICAgICAgZWxtW2tleV0gPSAnJztcbiAgICB9XG4gIH1cbiAgZm9yIChrZXkgaW4gcHJvcHMpIHtcbiAgICBjdXIgPSBwcm9wc1trZXldO1xuICAgIC8vIGlnbm9yZSBjaGlsZHJlbiBpZiB0aGUgbm9kZSBoYXMgdGV4dENvbnRlbnQgb3IgaW5uZXJIVE1MLFxuICAgIC8vIGFzIHRoZXNlIHdpbGwgdGhyb3cgYXdheSBleGlzdGluZyBET00gbm9kZXMgYW5kIGNhdXNlIHJlbW92YWwgZXJyb3JzXG4gICAgLy8gb24gc3Vic2VxdWVudCBwYXRjaGVzICgjMzM2MClcbiAgICBpZiAoa2V5ID09PSAndGV4dENvbnRlbnQnIHx8IGtleSA9PT0gJ2lubmVySFRNTCcpIHtcbiAgICAgIGlmICh2bm9kZS5jaGlsZHJlbikgeyB2bm9kZS5jaGlsZHJlbi5sZW5ndGggPSAwOyB9XG4gICAgICBpZiAoY3VyID09PSBvbGRQcm9wc1trZXldKSB7IGNvbnRpbnVlIH1cbiAgICAgIC8vICM2NjAxIHdvcmsgYXJvdW5kIENocm9tZSB2ZXJzaW9uIDw9IDU1IGJ1ZyB3aGVyZSBzaW5nbGUgdGV4dE5vZGVcbiAgICAgIC8vIHJlcGxhY2VkIGJ5IGlubmVySFRNTC90ZXh0Q29udGVudCByZXRhaW5zIGl0cyBwYXJlbnROb2RlIHByb3BlcnR5XG4gICAgICBpZiAoZWxtLmNoaWxkTm9kZXMubGVuZ3RoID09PSAxKSB7XG4gICAgICAgIGVsbS5yZW1vdmVDaGlsZChlbG0uY2hpbGROb2Rlc1swXSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSA9PT0gJ3ZhbHVlJykge1xuICAgICAgLy8gc3RvcmUgdmFsdWUgYXMgX3ZhbHVlIGFzIHdlbGwgc2luY2VcbiAgICAgIC8vIG5vbi1zdHJpbmcgdmFsdWVzIHdpbGwgYmUgc3RyaW5naWZpZWRcbiAgICAgIGVsbS5fdmFsdWUgPSBjdXI7XG4gICAgICAvLyBhdm9pZCByZXNldHRpbmcgY3Vyc29yIHBvc2l0aW9uIHdoZW4gdmFsdWUgaXMgdGhlIHNhbWVcbiAgICAgIHZhciBzdHJDdXIgPSBpc1VuZGVmKGN1cikgPyAnJyA6IFN0cmluZyhjdXIpO1xuICAgICAgaWYgKHNob3VsZFVwZGF0ZVZhbHVlKGVsbSwgc3RyQ3VyKSkge1xuICAgICAgICBlbG0udmFsdWUgPSBzdHJDdXI7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsbVtrZXldID0gY3VyO1xuICAgIH1cbiAgfVxufVxuXG4vLyBjaGVjayBwbGF0Zm9ybXMvd2ViL3V0aWwvYXR0cnMuanMgYWNjZXB0VmFsdWVcblxuXG5mdW5jdGlvbiBzaG91bGRVcGRhdGVWYWx1ZSAoZWxtLCBjaGVja1ZhbCkge1xuICByZXR1cm4gKCFlbG0uY29tcG9zaW5nICYmIChcbiAgICBlbG0udGFnTmFtZSA9PT0gJ09QVElPTicgfHxcbiAgICBpc0RpcnR5KGVsbSwgY2hlY2tWYWwpIHx8XG4gICAgaXNJbnB1dENoYW5nZWQoZWxtLCBjaGVja1ZhbClcbiAgKSlcbn1cblxuZnVuY3Rpb24gaXNEaXJ0eSAoZWxtLCBjaGVja1ZhbCkge1xuICAvLyByZXR1cm4gdHJ1ZSB3aGVuIHRleHRib3ggKC5udW1iZXIgYW5kIC50cmltKSBsb3NlcyBmb2N1cyBhbmQgaXRzIHZhbHVlIGlzXG4gIC8vIG5vdCBlcXVhbCB0byB0aGUgdXBkYXRlZCB2YWx1ZVxuICB2YXIgbm90SW5Gb2N1cyA9IHRydWU7XG4gIC8vICM2MTU3XG4gIC8vIHdvcmsgYXJvdW5kIElFIGJ1ZyB3aGVuIGFjY2Vzc2luZyBkb2N1bWVudC5hY3RpdmVFbGVtZW50IGluIGFuIGlmcmFtZVxuICB0cnkgeyBub3RJbkZvY3VzID0gZG9jdW1lbnQuYWN0aXZlRWxlbWVudCAhPT0gZWxtOyB9IGNhdGNoIChlKSB7fVxuICByZXR1cm4gbm90SW5Gb2N1cyAmJiBlbG0udmFsdWUgIT09IGNoZWNrVmFsXG59XG5cbmZ1bmN0aW9uIGlzSW5wdXRDaGFuZ2VkIChlbG0sIG5ld1ZhbCkge1xuICB2YXIgdmFsdWUgPSBlbG0udmFsdWU7XG4gIHZhciBtb2RpZmllcnMgPSBlbG0uX3ZNb2RpZmllcnM7IC8vIGluamVjdGVkIGJ5IHYtbW9kZWwgcnVudGltZVxuICBpZiAoaXNEZWYobW9kaWZpZXJzKSAmJiBtb2RpZmllcnMubnVtYmVyKSB7XG4gICAgcmV0dXJuIHRvTnVtYmVyKHZhbHVlKSAhPT0gdG9OdW1iZXIobmV3VmFsKVxuICB9XG4gIGlmIChpc0RlZihtb2RpZmllcnMpICYmIG1vZGlmaWVycy50cmltKSB7XG4gICAgcmV0dXJuIHZhbHVlLnRyaW0oKSAhPT0gbmV3VmFsLnRyaW0oKVxuICB9XG4gIHJldHVybiB2YWx1ZSAhPT0gbmV3VmFsXG59XG5cbnZhciBkb21Qcm9wcyA9IHtcbiAgY3JlYXRlOiB1cGRhdGVET01Qcm9wcyxcbiAgdXBkYXRlOiB1cGRhdGVET01Qcm9wc1xufTtcblxuLyogICovXG5cbnZhciBwYXJzZVN0eWxlVGV4dCA9IGNhY2hlZChmdW5jdGlvbiAoY3NzVGV4dCkge1xuICB2YXIgcmVzID0ge307XG4gIHZhciBsaXN0RGVsaW1pdGVyID0gLzsoPyFbXihdKlxcKSkvZztcbiAgdmFyIHByb3BlcnR5RGVsaW1pdGVyID0gLzooLispLztcbiAgY3NzVGV4dC5zcGxpdChsaXN0RGVsaW1pdGVyKS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgaWYgKGl0ZW0pIHtcbiAgICAgIHZhciB0bXAgPSBpdGVtLnNwbGl0KHByb3BlcnR5RGVsaW1pdGVyKTtcbiAgICAgIHRtcC5sZW5ndGggPiAxICYmIChyZXNbdG1wWzBdLnRyaW0oKV0gPSB0bXBbMV0udHJpbSgpKTtcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gcmVzXG59KTtcblxuLy8gbWVyZ2Ugc3RhdGljIGFuZCBkeW5hbWljIHN0eWxlIGRhdGEgb24gdGhlIHNhbWUgdm5vZGVcbmZ1bmN0aW9uIG5vcm1hbGl6ZVN0eWxlRGF0YSAoZGF0YSkge1xuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcoZGF0YS5zdHlsZSk7XG4gIC8vIHN0YXRpYyBzdHlsZSBpcyBwcmUtcHJvY2Vzc2VkIGludG8gYW4gb2JqZWN0IGR1cmluZyBjb21waWxhdGlvblxuICAvLyBhbmQgaXMgYWx3YXlzIGEgZnJlc2ggb2JqZWN0LCBzbyBpdCdzIHNhZmUgdG8gbWVyZ2UgaW50byBpdFxuICByZXR1cm4gZGF0YS5zdGF0aWNTdHlsZVxuICAgID8gZXh0ZW5kKGRhdGEuc3RhdGljU3R5bGUsIHN0eWxlKVxuICAgIDogc3R5bGVcbn1cblxuLy8gbm9ybWFsaXplIHBvc3NpYmxlIGFycmF5IC8gc3RyaW5nIHZhbHVlcyBpbnRvIE9iamVjdFxuZnVuY3Rpb24gbm9ybWFsaXplU3R5bGVCaW5kaW5nIChiaW5kaW5nU3R5bGUpIHtcbiAgaWYgKEFycmF5LmlzQXJyYXkoYmluZGluZ1N0eWxlKSkge1xuICAgIHJldHVybiB0b09iamVjdChiaW5kaW5nU3R5bGUpXG4gIH1cbiAgaWYgKHR5cGVvZiBiaW5kaW5nU3R5bGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIHBhcnNlU3R5bGVUZXh0KGJpbmRpbmdTdHlsZSlcbiAgfVxuICByZXR1cm4gYmluZGluZ1N0eWxlXG59XG5cbi8qKlxuICogcGFyZW50IGNvbXBvbmVudCBzdHlsZSBzaG91bGQgYmUgYWZ0ZXIgY2hpbGQnc1xuICogc28gdGhhdCBwYXJlbnQgY29tcG9uZW50J3Mgc3R5bGUgY291bGQgb3ZlcnJpZGUgaXRcbiAqL1xuZnVuY3Rpb24gZ2V0U3R5bGUgKHZub2RlLCBjaGVja0NoaWxkKSB7XG4gIHZhciByZXMgPSB7fTtcbiAgdmFyIHN0eWxlRGF0YTtcblxuICBpZiAoY2hlY2tDaGlsZCkge1xuICAgIHZhciBjaGlsZE5vZGUgPSB2bm9kZTtcbiAgICB3aGlsZSAoY2hpbGROb2RlLmNvbXBvbmVudEluc3RhbmNlKSB7XG4gICAgICBjaGlsZE5vZGUgPSBjaGlsZE5vZGUuY29tcG9uZW50SW5zdGFuY2UuX3Zub2RlO1xuICAgICAgaWYgKGNoaWxkTm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEoY2hpbGROb2RlLmRhdGEpKSkge1xuICAgICAgICBleHRlbmQocmVzLCBzdHlsZURhdGEpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGlmICgoc3R5bGVEYXRhID0gbm9ybWFsaXplU3R5bGVEYXRhKHZub2RlLmRhdGEpKSkge1xuICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gIH1cblxuICB2YXIgcGFyZW50Tm9kZSA9IHZub2RlO1xuICB3aGlsZSAoKHBhcmVudE5vZGUgPSBwYXJlbnROb2RlLnBhcmVudCkpIHtcbiAgICBpZiAocGFyZW50Tm9kZS5kYXRhICYmIChzdHlsZURhdGEgPSBub3JtYWxpemVTdHlsZURhdGEocGFyZW50Tm9kZS5kYXRhKSkpIHtcbiAgICAgIGV4dGVuZChyZXMsIHN0eWxlRGF0YSk7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuLyogICovXG5cbnZhciBjc3NWYXJSRSA9IC9eLS0vO1xudmFyIGltcG9ydGFudFJFID0gL1xccyohaW1wb3J0YW50JC87XG52YXIgc2V0UHJvcCA9IGZ1bmN0aW9uIChlbCwgbmFtZSwgdmFsKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoY3NzVmFyUkUudGVzdChuYW1lKSkge1xuICAgIGVsLnN0eWxlLnNldFByb3BlcnR5KG5hbWUsIHZhbCk7XG4gIH0gZWxzZSBpZiAoaW1wb3J0YW50UkUudGVzdCh2YWwpKSB7XG4gICAgZWwuc3R5bGUuc2V0UHJvcGVydHkobmFtZSwgdmFsLnJlcGxhY2UoaW1wb3J0YW50UkUsICcnKSwgJ2ltcG9ydGFudCcpO1xuICB9IGVsc2Uge1xuICAgIHZhciBub3JtYWxpemVkTmFtZSA9IG5vcm1hbGl6ZShuYW1lKTtcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWwpKSB7XG4gICAgICAvLyBTdXBwb3J0IHZhbHVlcyBhcnJheSBjcmVhdGVkIGJ5IGF1dG9wcmVmaXhlciwgZS5nLlxuICAgICAgLy8ge2Rpc3BsYXk6IFtcIi13ZWJraXQtYm94XCIsIFwiLW1zLWZsZXhib3hcIiwgXCJmbGV4XCJdfVxuICAgICAgLy8gU2V0IHRoZW0gb25lIGJ5IG9uZSwgYW5kIHRoZSBicm93c2VyIHdpbGwgb25seSBzZXQgdGhvc2UgaXQgY2FuIHJlY29nbml6ZVxuICAgICAgZm9yICh2YXIgaSA9IDAsIGxlbiA9IHZhbC5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgICAgICBlbC5zdHlsZVtub3JtYWxpemVkTmFtZV0gPSB2YWxbaV07XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnN0eWxlW25vcm1hbGl6ZWROYW1lXSA9IHZhbDtcbiAgICB9XG4gIH1cbn07XG5cbnZhciB2ZW5kb3JOYW1lcyA9IFsnV2Via2l0JywgJ01veicsICdtcyddO1xuXG52YXIgZW1wdHlTdHlsZTtcbnZhciBub3JtYWxpemUgPSBjYWNoZWQoZnVuY3Rpb24gKHByb3ApIHtcbiAgZW1wdHlTdHlsZSA9IGVtcHR5U3R5bGUgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jykuc3R5bGU7XG4gIHByb3AgPSBjYW1lbGl6ZShwcm9wKTtcbiAgaWYgKHByb3AgIT09ICdmaWx0ZXInICYmIChwcm9wIGluIGVtcHR5U3R5bGUpKSB7XG4gICAgcmV0dXJuIHByb3BcbiAgfVxuICB2YXIgY2FwTmFtZSA9IHByb3AuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBwcm9wLnNsaWNlKDEpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHZlbmRvck5hbWVzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSB2ZW5kb3JOYW1lc1tpXSArIGNhcE5hbWU7XG4gICAgaWYgKG5hbWUgaW4gZW1wdHlTdHlsZSkge1xuICAgICAgcmV0dXJuIG5hbWVcbiAgICB9XG4gIH1cbn0pO1xuXG5mdW5jdGlvbiB1cGRhdGVTdHlsZSAob2xkVm5vZGUsIHZub2RlKSB7XG4gIHZhciBkYXRhID0gdm5vZGUuZGF0YTtcbiAgdmFyIG9sZERhdGEgPSBvbGRWbm9kZS5kYXRhO1xuXG4gIGlmIChpc1VuZGVmKGRhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYoZGF0YS5zdHlsZSkgJiZcbiAgICBpc1VuZGVmKG9sZERhdGEuc3RhdGljU3R5bGUpICYmIGlzVW5kZWYob2xkRGF0YS5zdHlsZSlcbiAgKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3VyLCBuYW1lO1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG4gIHZhciBvbGRTdGF0aWNTdHlsZSA9IG9sZERhdGEuc3RhdGljU3R5bGU7XG4gIHZhciBvbGRTdHlsZUJpbmRpbmcgPSBvbGREYXRhLm5vcm1hbGl6ZWRTdHlsZSB8fCBvbGREYXRhLnN0eWxlIHx8IHt9O1xuXG4gIC8vIGlmIHN0YXRpYyBzdHlsZSBleGlzdHMsIHN0eWxlYmluZGluZyBhbHJlYWR5IG1lcmdlZCBpbnRvIGl0IHdoZW4gZG9pbmcgbm9ybWFsaXplU3R5bGVEYXRhXG4gIHZhciBvbGRTdHlsZSA9IG9sZFN0YXRpY1N0eWxlIHx8IG9sZFN0eWxlQmluZGluZztcblxuICB2YXIgc3R5bGUgPSBub3JtYWxpemVTdHlsZUJpbmRpbmcodm5vZGUuZGF0YS5zdHlsZSkgfHwge307XG5cbiAgLy8gc3RvcmUgbm9ybWFsaXplZCBzdHlsZSB1bmRlciBhIGRpZmZlcmVudCBrZXkgZm9yIG5leHQgZGlmZlxuICAvLyBtYWtlIHN1cmUgdG8gY2xvbmUgaXQgaWYgaXQncyByZWFjdGl2ZSwgc2luY2UgdGhlIHVzZXIgbGlrZWx5IHdhbnRzXG4gIC8vIHRvIG11dGF0ZSBpdC5cbiAgdm5vZGUuZGF0YS5ub3JtYWxpemVkU3R5bGUgPSBpc0RlZihzdHlsZS5fX29iX18pXG4gICAgPyBleHRlbmQoe30sIHN0eWxlKVxuICAgIDogc3R5bGU7XG5cbiAgdmFyIG5ld1N0eWxlID0gZ2V0U3R5bGUodm5vZGUsIHRydWUpO1xuXG4gIGZvciAobmFtZSBpbiBvbGRTdHlsZSkge1xuICAgIGlmIChpc1VuZGVmKG5ld1N0eWxlW25hbWVdKSkge1xuICAgICAgc2V0UHJvcChlbCwgbmFtZSwgJycpO1xuICAgIH1cbiAgfVxuICBmb3IgKG5hbWUgaW4gbmV3U3R5bGUpIHtcbiAgICBjdXIgPSBuZXdTdHlsZVtuYW1lXTtcbiAgICBpZiAoY3VyICE9PSBvbGRTdHlsZVtuYW1lXSkge1xuICAgICAgLy8gaWU5IHNldHRpbmcgdG8gbnVsbCBoYXMgbm8gZWZmZWN0LCBtdXN0IHVzZSBlbXB0eSBzdHJpbmdcbiAgICAgIHNldFByb3AoZWwsIG5hbWUsIGN1ciA9PSBudWxsID8gJycgOiBjdXIpO1xuICAgIH1cbiAgfVxufVxuXG52YXIgc3R5bGUgPSB7XG4gIGNyZWF0ZTogdXBkYXRlU3R5bGUsXG4gIHVwZGF0ZTogdXBkYXRlU3R5bGVcbn07XG5cbi8qICAqL1xuXG4vKipcbiAqIEFkZCBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIGFkZENsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LmFkZChjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5hZGQoY2xzKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgdmFyIGN1ciA9IFwiIFwiICsgKGVsLmdldEF0dHJpYnV0ZSgnY2xhc3MnKSB8fCAnJykgKyBcIiBcIjtcbiAgICBpZiAoY3VyLmluZGV4T2YoJyAnICsgY2xzICsgJyAnKSA8IDApIHtcbiAgICAgIGVsLnNldEF0dHJpYnV0ZSgnY2xhc3MnLCAoY3VyICsgY2xzKS50cmltKCkpO1xuICAgIH1cbiAgfVxufVxuXG4vKipcbiAqIFJlbW92ZSBjbGFzcyB3aXRoIGNvbXBhdGliaWxpdHkgZm9yIFNWRyBzaW5jZSBjbGFzc0xpc3QgaXMgbm90IHN1cHBvcnRlZCBvblxuICogU1ZHIGVsZW1lbnRzIGluIElFXG4gKi9cbmZ1bmN0aW9uIHJlbW92ZUNsYXNzIChlbCwgY2xzKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoIWNscyB8fCAhKGNscyA9IGNscy50cmltKCkpKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAoZWwuY2xhc3NMaXN0KSB7XG4gICAgaWYgKGNscy5pbmRleE9mKCcgJykgPiAtMSkge1xuICAgICAgY2xzLnNwbGl0KC9cXHMrLykuZm9yRWFjaChmdW5jdGlvbiAoYykgeyByZXR1cm4gZWwuY2xhc3NMaXN0LnJlbW92ZShjKTsgfSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmNsYXNzTGlzdC5yZW1vdmUoY2xzKTtcbiAgICB9XG4gICAgaWYgKCFlbC5jbGFzc0xpc3QubGVuZ3RoKSB7XG4gICAgICBlbC5yZW1vdmVBdHRyaWJ1dGUoJ2NsYXNzJyk7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHZhciBjdXIgPSBcIiBcIiArIChlbC5nZXRBdHRyaWJ1dGUoJ2NsYXNzJykgfHwgJycpICsgXCIgXCI7XG4gICAgdmFyIHRhciA9ICcgJyArIGNscyArICcgJztcbiAgICB3aGlsZSAoY3VyLmluZGV4T2YodGFyKSA+PSAwKSB7XG4gICAgICBjdXIgPSBjdXIucmVwbGFjZSh0YXIsICcgJyk7XG4gICAgfVxuICAgIGN1ciA9IGN1ci50cmltKCk7XG4gICAgaWYgKGN1cikge1xuICAgICAgZWwuc2V0QXR0cmlidXRlKCdjbGFzcycsIGN1cik7XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLnJlbW92ZUF0dHJpYnV0ZSgnY2xhc3MnKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIHJlc29sdmVUcmFuc2l0aW9uIChkZWYpIHtcbiAgaWYgKCFkZWYpIHtcbiAgICByZXR1cm5cbiAgfVxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICBpZiAodHlwZW9mIGRlZiA9PT0gJ29iamVjdCcpIHtcbiAgICB2YXIgcmVzID0ge307XG4gICAgaWYgKGRlZi5jc3MgIT09IGZhbHNlKSB7XG4gICAgICBleHRlbmQocmVzLCBhdXRvQ3NzVHJhbnNpdGlvbihkZWYubmFtZSB8fCAndicpKTtcbiAgICB9XG4gICAgZXh0ZW5kKHJlcywgZGVmKTtcbiAgICByZXR1cm4gcmVzXG4gIH0gZWxzZSBpZiAodHlwZW9mIGRlZiA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gYXV0b0Nzc1RyYW5zaXRpb24oZGVmKVxuICB9XG59XG5cbnZhciBhdXRvQ3NzVHJhbnNpdGlvbiA9IGNhY2hlZChmdW5jdGlvbiAobmFtZSkge1xuICByZXR1cm4ge1xuICAgIGVudGVyQ2xhc3M6IChuYW1lICsgXCItZW50ZXJcIiksXG4gICAgZW50ZXJUb0NsYXNzOiAobmFtZSArIFwiLWVudGVyLXRvXCIpLFxuICAgIGVudGVyQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItZW50ZXItYWN0aXZlXCIpLFxuICAgIGxlYXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmVcIiksXG4gICAgbGVhdmVUb0NsYXNzOiAobmFtZSArIFwiLWxlYXZlLXRvXCIpLFxuICAgIGxlYXZlQWN0aXZlQ2xhc3M6IChuYW1lICsgXCItbGVhdmUtYWN0aXZlXCIpXG4gIH1cbn0pO1xuXG52YXIgaGFzVHJhbnNpdGlvbiA9IGluQnJvd3NlciAmJiAhaXNJRTk7XG52YXIgVFJBTlNJVElPTiA9ICd0cmFuc2l0aW9uJztcbnZhciBBTklNQVRJT04gPSAnYW5pbWF0aW9uJztcblxuLy8gVHJhbnNpdGlvbiBwcm9wZXJ0eS9ldmVudCBzbmlmZmluZ1xudmFyIHRyYW5zaXRpb25Qcm9wID0gJ3RyYW5zaXRpb24nO1xudmFyIHRyYW5zaXRpb25FbmRFdmVudCA9ICd0cmFuc2l0aW9uZW5kJztcbnZhciBhbmltYXRpb25Qcm9wID0gJ2FuaW1hdGlvbic7XG52YXIgYW5pbWF0aW9uRW5kRXZlbnQgPSAnYW5pbWF0aW9uZW5kJztcbmlmIChoYXNUcmFuc2l0aW9uKSB7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAod2luZG93Lm9udHJhbnNpdGlvbmVuZCA9PT0gdW5kZWZpbmVkICYmXG4gICAgd2luZG93Lm9ud2Via2l0dHJhbnNpdGlvbmVuZCAhPT0gdW5kZWZpbmVkXG4gICkge1xuICAgIHRyYW5zaXRpb25Qcm9wID0gJ1dlYmtpdFRyYW5zaXRpb24nO1xuICAgIHRyYW5zaXRpb25FbmRFdmVudCA9ICd3ZWJraXRUcmFuc2l0aW9uRW5kJztcbiAgfVxuICBpZiAod2luZG93Lm9uYW5pbWF0aW9uZW5kID09PSB1bmRlZmluZWQgJiZcbiAgICB3aW5kb3cub253ZWJraXRhbmltYXRpb25lbmQgIT09IHVuZGVmaW5lZFxuICApIHtcbiAgICBhbmltYXRpb25Qcm9wID0gJ1dlYmtpdEFuaW1hdGlvbic7XG4gICAgYW5pbWF0aW9uRW5kRXZlbnQgPSAnd2Via2l0QW5pbWF0aW9uRW5kJztcbiAgfVxufVxuXG4vLyBiaW5kaW5nIHRvIHdpbmRvdyBpcyBuZWNlc3NhcnkgdG8gbWFrZSBob3QgcmVsb2FkIHdvcmsgaW4gSUUgaW4gc3RyaWN0IG1vZGVcbnZhciByYWYgPSBpbkJyb3dzZXJcbiAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lXG4gICAgPyB3aW5kb3cucmVxdWVzdEFuaW1hdGlvbkZyYW1lLmJpbmQod2luZG93KVxuICAgIDogc2V0VGltZW91dFxuICA6IC8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovIGZ1bmN0aW9uIChmbikgeyByZXR1cm4gZm4oKTsgfTtcblxuZnVuY3Rpb24gbmV4dEZyYW1lIChmbikge1xuICByYWYoZnVuY3Rpb24gKCkge1xuICAgIHJhZihmbik7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRUcmFuc2l0aW9uQ2xhc3MgKGVsLCBjbHMpIHtcbiAgdmFyIHRyYW5zaXRpb25DbGFzc2VzID0gZWwuX3RyYW5zaXRpb25DbGFzc2VzIHx8IChlbC5fdHJhbnNpdGlvbkNsYXNzZXMgPSBbXSk7XG4gIGlmICh0cmFuc2l0aW9uQ2xhc3Nlcy5pbmRleE9mKGNscykgPCAwKSB7XG4gICAgdHJhbnNpdGlvbkNsYXNzZXMucHVzaChjbHMpO1xuICAgIGFkZENsYXNzKGVsLCBjbHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlbW92ZVRyYW5zaXRpb25DbGFzcyAoZWwsIGNscykge1xuICBpZiAoZWwuX3RyYW5zaXRpb25DbGFzc2VzKSB7XG4gICAgcmVtb3ZlKGVsLl90cmFuc2l0aW9uQ2xhc3NlcywgY2xzKTtcbiAgfVxuICByZW1vdmVDbGFzcyhlbCwgY2xzKTtcbn1cblxuZnVuY3Rpb24gd2hlblRyYW5zaXRpb25FbmRzIChcbiAgZWwsXG4gIGV4cGVjdGVkVHlwZSxcbiAgY2Jcbikge1xuICB2YXIgcmVmID0gZ2V0VHJhbnNpdGlvbkluZm8oZWwsIGV4cGVjdGVkVHlwZSk7XG4gIHZhciB0eXBlID0gcmVmLnR5cGU7XG4gIHZhciB0aW1lb3V0ID0gcmVmLnRpbWVvdXQ7XG4gIHZhciBwcm9wQ291bnQgPSByZWYucHJvcENvdW50O1xuICBpZiAoIXR5cGUpIHsgcmV0dXJuIGNiKCkgfVxuICB2YXIgZXZlbnQgPSB0eXBlID09PSBUUkFOU0lUSU9OID8gdHJhbnNpdGlvbkVuZEV2ZW50IDogYW5pbWF0aW9uRW5kRXZlbnQ7XG4gIHZhciBlbmRlZCA9IDA7XG4gIHZhciBlbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xuICAgIGNiKCk7XG4gIH07XG4gIHZhciBvbkVuZCA9IGZ1bmN0aW9uIChlKSB7XG4gICAgaWYgKGUudGFyZ2V0ID09PSBlbCkge1xuICAgICAgaWYgKCsrZW5kZWQgPj0gcHJvcENvdW50KSB7XG4gICAgICAgIGVuZCgpO1xuICAgICAgfVxuICAgIH1cbiAgfTtcbiAgc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVuZGVkIDwgcHJvcENvdW50KSB7XG4gICAgICBlbmQoKTtcbiAgICB9XG4gIH0sIHRpbWVvdXQgKyAxKTtcbiAgZWwuYWRkRXZlbnRMaXN0ZW5lcihldmVudCwgb25FbmQpO1xufVxuXG52YXIgdHJhbnNmb3JtUkUgPSAvXFxiKHRyYW5zZm9ybXxhbGwpKCx8JCkvO1xuXG5mdW5jdGlvbiBnZXRUcmFuc2l0aW9uSW5mbyAoZWwsIGV4cGVjdGVkVHlwZSkge1xuICB2YXIgc3R5bGVzID0gd2luZG93LmdldENvbXB1dGVkU3R5bGUoZWwpO1xuICB2YXIgdHJhbnNpdGlvbkRlbGF5cyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEZWxheSddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1t0cmFuc2l0aW9uUHJvcCArICdEdXJhdGlvbiddLnNwbGl0KCcsICcpO1xuICB2YXIgdHJhbnNpdGlvblRpbWVvdXQgPSBnZXRUaW1lb3V0KHRyYW5zaXRpb25EZWxheXMsIHRyYW5zaXRpb25EdXJhdGlvbnMpO1xuICB2YXIgYW5pbWF0aW9uRGVsYXlzID0gc3R5bGVzW2FuaW1hdGlvblByb3AgKyAnRGVsYXknXS5zcGxpdCgnLCAnKTtcbiAgdmFyIGFuaW1hdGlvbkR1cmF0aW9ucyA9IHN0eWxlc1thbmltYXRpb25Qcm9wICsgJ0R1cmF0aW9uJ10uc3BsaXQoJywgJyk7XG4gIHZhciBhbmltYXRpb25UaW1lb3V0ID0gZ2V0VGltZW91dChhbmltYXRpb25EZWxheXMsIGFuaW1hdGlvbkR1cmF0aW9ucyk7XG5cbiAgdmFyIHR5cGU7XG4gIHZhciB0aW1lb3V0ID0gMDtcbiAgdmFyIHByb3BDb3VudCA9IDA7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZXhwZWN0ZWRUeXBlID09PSBUUkFOU0lUSU9OKSB7XG4gICAgaWYgKHRyYW5zaXRpb25UaW1lb3V0ID4gMCkge1xuICAgICAgdHlwZSA9IFRSQU5TSVRJT047XG4gICAgICB0aW1lb3V0ID0gdHJhbnNpdGlvblRpbWVvdXQ7XG4gICAgICBwcm9wQ291bnQgPSB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aDtcbiAgICB9XG4gIH0gZWxzZSBpZiAoZXhwZWN0ZWRUeXBlID09PSBBTklNQVRJT04pIHtcbiAgICBpZiAoYW5pbWF0aW9uVGltZW91dCA+IDApIHtcbiAgICAgIHR5cGUgPSBBTklNQVRJT047XG4gICAgICB0aW1lb3V0ID0gYW5pbWF0aW9uVGltZW91dDtcbiAgICAgIHByb3BDb3VudCA9IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGg7XG4gICAgfVxuICB9IGVsc2Uge1xuICAgIHRpbWVvdXQgPSBNYXRoLm1heCh0cmFuc2l0aW9uVGltZW91dCwgYW5pbWF0aW9uVGltZW91dCk7XG4gICAgdHlwZSA9IHRpbWVvdXQgPiAwXG4gICAgICA/IHRyYW5zaXRpb25UaW1lb3V0ID4gYW5pbWF0aW9uVGltZW91dFxuICAgICAgICA/IFRSQU5TSVRJT05cbiAgICAgICAgOiBBTklNQVRJT05cbiAgICAgIDogbnVsbDtcbiAgICBwcm9wQ291bnQgPSB0eXBlXG4gICAgICA/IHR5cGUgPT09IFRSQU5TSVRJT05cbiAgICAgICAgPyB0cmFuc2l0aW9uRHVyYXRpb25zLmxlbmd0aFxuICAgICAgICA6IGFuaW1hdGlvbkR1cmF0aW9ucy5sZW5ndGhcbiAgICAgIDogMDtcbiAgfVxuICB2YXIgaGFzVHJhbnNmb3JtID1cbiAgICB0eXBlID09PSBUUkFOU0lUSU9OICYmXG4gICAgdHJhbnNmb3JtUkUudGVzdChzdHlsZXNbdHJhbnNpdGlvblByb3AgKyAnUHJvcGVydHknXSk7XG4gIHJldHVybiB7XG4gICAgdHlwZTogdHlwZSxcbiAgICB0aW1lb3V0OiB0aW1lb3V0LFxuICAgIHByb3BDb3VudDogcHJvcENvdW50LFxuICAgIGhhc1RyYW5zZm9ybTogaGFzVHJhbnNmb3JtXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0VGltZW91dCAoZGVsYXlzLCBkdXJhdGlvbnMpIHtcbiAgLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cbiAgd2hpbGUgKGRlbGF5cy5sZW5ndGggPCBkdXJhdGlvbnMubGVuZ3RoKSB7XG4gICAgZGVsYXlzID0gZGVsYXlzLmNvbmNhdChkZWxheXMpO1xuICB9XG5cbiAgcmV0dXJuIE1hdGgubWF4LmFwcGx5KG51bGwsIGR1cmF0aW9ucy5tYXAoZnVuY3Rpb24gKGQsIGkpIHtcbiAgICByZXR1cm4gdG9NcyhkKSArIHRvTXMoZGVsYXlzW2ldKVxuICB9KSlcbn1cblxuZnVuY3Rpb24gdG9NcyAocykge1xuICByZXR1cm4gTnVtYmVyKHMuc2xpY2UoMCwgLTEpKSAqIDEwMDBcbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGVudGVyICh2bm9kZSwgdG9nZ2xlRGlzcGxheSkge1xuICB2YXIgZWwgPSB2bm9kZS5lbG07XG5cbiAgLy8gY2FsbCBsZWF2ZSBjYWxsYmFjayBub3dcbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIGVsLl9sZWF2ZUNiLmNhbmNlbGxlZCA9IHRydWU7XG4gICAgZWwuX2xlYXZlQ2IoKTtcbiAgfVxuXG4gIHZhciBkYXRhID0gcmVzb2x2ZVRyYW5zaXRpb24odm5vZGUuZGF0YS50cmFuc2l0aW9uKTtcbiAgaWYgKGlzVW5kZWYoZGF0YSkpIHtcbiAgICByZXR1cm5cbiAgfVxuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpIHx8IGVsLm5vZGVUeXBlICE9PSAxKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgY3NzID0gZGF0YS5jc3M7XG4gIHZhciB0eXBlID0gZGF0YS50eXBlO1xuICB2YXIgZW50ZXJDbGFzcyA9IGRhdGEuZW50ZXJDbGFzcztcbiAgdmFyIGVudGVyVG9DbGFzcyA9IGRhdGEuZW50ZXJUb0NsYXNzO1xuICB2YXIgZW50ZXJBY3RpdmVDbGFzcyA9IGRhdGEuZW50ZXJBY3RpdmVDbGFzcztcbiAgdmFyIGFwcGVhckNsYXNzID0gZGF0YS5hcHBlYXJDbGFzcztcbiAgdmFyIGFwcGVhclRvQ2xhc3MgPSBkYXRhLmFwcGVhclRvQ2xhc3M7XG4gIHZhciBhcHBlYXJBY3RpdmVDbGFzcyA9IGRhdGEuYXBwZWFyQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVFbnRlciA9IGRhdGEuYmVmb3JlRW50ZXI7XG4gIHZhciBlbnRlciA9IGRhdGEuZW50ZXI7XG4gIHZhciBhZnRlckVudGVyID0gZGF0YS5hZnRlckVudGVyO1xuICB2YXIgZW50ZXJDYW5jZWxsZWQgPSBkYXRhLmVudGVyQ2FuY2VsbGVkO1xuICB2YXIgYmVmb3JlQXBwZWFyID0gZGF0YS5iZWZvcmVBcHBlYXI7XG4gIHZhciBhcHBlYXIgPSBkYXRhLmFwcGVhcjtcbiAgdmFyIGFmdGVyQXBwZWFyID0gZGF0YS5hZnRlckFwcGVhcjtcbiAgdmFyIGFwcGVhckNhbmNlbGxlZCA9IGRhdGEuYXBwZWFyQ2FuY2VsbGVkO1xuICB2YXIgZHVyYXRpb24gPSBkYXRhLmR1cmF0aW9uO1xuXG4gIC8vIGFjdGl2ZUluc3RhbmNlIHdpbGwgYWx3YXlzIGJlIHRoZSA8dHJhbnNpdGlvbj4gY29tcG9uZW50IG1hbmFnaW5nIHRoaXNcbiAgLy8gdHJhbnNpdGlvbi4gT25lIGVkZ2UgY2FzZSB0byBjaGVjayBpcyB3aGVuIHRoZSA8dHJhbnNpdGlvbj4gaXMgcGxhY2VkXG4gIC8vIGFzIHRoZSByb290IG5vZGUgb2YgYSBjaGlsZCBjb21wb25lbnQuIEluIHRoYXQgY2FzZSB3ZSBuZWVkIHRvIGNoZWNrXG4gIC8vIDx0cmFuc2l0aW9uPidzIHBhcmVudCBmb3IgYXBwZWFyIGNoZWNrLlxuICB2YXIgY29udGV4dCA9IGFjdGl2ZUluc3RhbmNlO1xuICB2YXIgdHJhbnNpdGlvbk5vZGUgPSBhY3RpdmVJbnN0YW5jZS4kdm5vZGU7XG4gIHdoaWxlICh0cmFuc2l0aW9uTm9kZSAmJiB0cmFuc2l0aW9uTm9kZS5wYXJlbnQpIHtcbiAgICB0cmFuc2l0aW9uTm9kZSA9IHRyYW5zaXRpb25Ob2RlLnBhcmVudDtcbiAgICBjb250ZXh0ID0gdHJhbnNpdGlvbk5vZGUuY29udGV4dDtcbiAgfVxuXG4gIHZhciBpc0FwcGVhciA9ICFjb250ZXh0Ll9pc01vdW50ZWQgfHwgIXZub2RlLmlzUm9vdEluc2VydDtcblxuICBpZiAoaXNBcHBlYXIgJiYgIWFwcGVhciAmJiBhcHBlYXIgIT09ICcnKSB7XG4gICAgcmV0dXJuXG4gIH1cblxuICB2YXIgc3RhcnRDbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhckNsYXNzXG4gICAgPyBhcHBlYXJDbGFzc1xuICAgIDogZW50ZXJDbGFzcztcbiAgdmFyIGFjdGl2ZUNsYXNzID0gaXNBcHBlYXIgJiYgYXBwZWFyQWN0aXZlQ2xhc3NcbiAgICA/IGFwcGVhckFjdGl2ZUNsYXNzXG4gICAgOiBlbnRlckFjdGl2ZUNsYXNzO1xuICB2YXIgdG9DbGFzcyA9IGlzQXBwZWFyICYmIGFwcGVhclRvQ2xhc3NcbiAgICA/IGFwcGVhclRvQ2xhc3NcbiAgICA6IGVudGVyVG9DbGFzcztcblxuICB2YXIgYmVmb3JlRW50ZXJIb29rID0gaXNBcHBlYXJcbiAgICA/IChiZWZvcmVBcHBlYXIgfHwgYmVmb3JlRW50ZXIpXG4gICAgOiBiZWZvcmVFbnRlcjtcbiAgdmFyIGVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAodHlwZW9mIGFwcGVhciA9PT0gJ2Z1bmN0aW9uJyA/IGFwcGVhciA6IGVudGVyKVxuICAgIDogZW50ZXI7XG4gIHZhciBhZnRlckVudGVySG9vayA9IGlzQXBwZWFyXG4gICAgPyAoYWZ0ZXJBcHBlYXIgfHwgYWZ0ZXJFbnRlcilcbiAgICA6IGFmdGVyRW50ZXI7XG4gIHZhciBlbnRlckNhbmNlbGxlZEhvb2sgPSBpc0FwcGVhclxuICAgID8gKGFwcGVhckNhbmNlbGxlZCB8fCBlbnRlckNhbmNlbGxlZClcbiAgICA6IGVudGVyQ2FuY2VsbGVkO1xuXG4gIHZhciBleHBsaWNpdEVudGVyRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24uZW50ZXJcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBleHBsaWNpdEVudGVyRHVyYXRpb24gIT0gbnVsbCkge1xuICAgIGNoZWNrRHVyYXRpb24oZXhwbGljaXRFbnRlckR1cmF0aW9uLCAnZW50ZXInLCB2bm9kZSk7XG4gIH1cblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgoZW50ZXJIb29rKTtcblxuICB2YXIgY2IgPSBlbC5fZW50ZXJDYiA9IG9uY2UoZnVuY3Rpb24gKCkge1xuICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIHRvQ2xhc3MpO1xuICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBhY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICB9XG4gICAgICBlbnRlckNhbmNlbGxlZEhvb2sgJiYgZW50ZXJDYW5jZWxsZWRIb29rKGVsKTtcbiAgICB9IGVsc2Uge1xuICAgICAgYWZ0ZXJFbnRlckhvb2sgJiYgYWZ0ZXJFbnRlckhvb2soZWwpO1xuICAgIH1cbiAgICBlbC5fZW50ZXJDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmICghdm5vZGUuZGF0YS5zaG93KSB7XG4gICAgLy8gcmVtb3ZlIHBlbmRpbmcgbGVhdmUgZWxlbWVudCBvbiBlbnRlciBieSBpbmplY3RpbmcgYW4gaW5zZXJ0IGhvb2tcbiAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ2luc2VydCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBwYXJlbnQgPSBlbC5wYXJlbnROb2RlO1xuICAgICAgdmFyIHBlbmRpbmdOb2RlID0gcGFyZW50ICYmIHBhcmVudC5fcGVuZGluZyAmJiBwYXJlbnQuX3BlbmRpbmdbdm5vZGUua2V5XTtcbiAgICAgIGlmIChwZW5kaW5nTm9kZSAmJlxuICAgICAgICBwZW5kaW5nTm9kZS50YWcgPT09IHZub2RlLnRhZyAmJlxuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2JcbiAgICAgICkge1xuICAgICAgICBwZW5kaW5nTm9kZS5lbG0uX2xlYXZlQ2IoKTtcbiAgICAgIH1cbiAgICAgIGVudGVySG9vayAmJiBlbnRlckhvb2soZWwsIGNiKTtcbiAgICB9KTtcbiAgfVxuXG4gIC8vIHN0YXJ0IGVudGVyIHRyYW5zaXRpb25cbiAgYmVmb3JlRW50ZXJIb29rICYmIGJlZm9yZUVudGVySG9vayhlbCk7XG4gIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBzdGFydENsYXNzKTtcbiAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGFjdGl2ZUNsYXNzKTtcbiAgICBuZXh0RnJhbWUoZnVuY3Rpb24gKCkge1xuICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCB0b0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgc3RhcnRDbGFzcyk7XG4gICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICBpZiAoaXNWYWxpZER1cmF0aW9uKGV4cGxpY2l0RW50ZXJEdXJhdGlvbikpIHtcbiAgICAgICAgICBzZXRUaW1lb3V0KGNiLCBleHBsaWNpdEVudGVyRHVyYXRpb24pO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHdoZW5UcmFuc2l0aW9uRW5kcyhlbCwgdHlwZSwgY2IpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAodm5vZGUuZGF0YS5zaG93KSB7XG4gICAgdG9nZ2xlRGlzcGxheSAmJiB0b2dnbGVEaXNwbGF5KCk7XG4gICAgZW50ZXJIb29rICYmIGVudGVySG9vayhlbCwgY2IpO1xuICB9XG5cbiAgaWYgKCFleHBlY3RzQ1NTICYmICF1c2VyV2FudHNDb250cm9sKSB7XG4gICAgY2IoKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBsZWF2ZSAodm5vZGUsIHJtKSB7XG4gIHZhciBlbCA9IHZub2RlLmVsbTtcblxuICAvLyBjYWxsIGVudGVyIGNhbGxiYWNrIG5vd1xuICBpZiAoaXNEZWYoZWwuX2VudGVyQ2IpKSB7XG4gICAgZWwuX2VudGVyQ2IuY2FuY2VsbGVkID0gdHJ1ZTtcbiAgICBlbC5fZW50ZXJDYigpO1xuICB9XG5cbiAgdmFyIGRhdGEgPSByZXNvbHZlVHJhbnNpdGlvbih2bm9kZS5kYXRhLnRyYW5zaXRpb24pO1xuICBpZiAoaXNVbmRlZihkYXRhKSB8fCBlbC5ub2RlVHlwZSAhPT0gMSkge1xuICAgIHJldHVybiBybSgpXG4gIH1cblxuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGlzRGVmKGVsLl9sZWF2ZUNiKSkge1xuICAgIHJldHVyblxuICB9XG5cbiAgdmFyIGNzcyA9IGRhdGEuY3NzO1xuICB2YXIgdHlwZSA9IGRhdGEudHlwZTtcbiAgdmFyIGxlYXZlQ2xhc3MgPSBkYXRhLmxlYXZlQ2xhc3M7XG4gIHZhciBsZWF2ZVRvQ2xhc3MgPSBkYXRhLmxlYXZlVG9DbGFzcztcbiAgdmFyIGxlYXZlQWN0aXZlQ2xhc3MgPSBkYXRhLmxlYXZlQWN0aXZlQ2xhc3M7XG4gIHZhciBiZWZvcmVMZWF2ZSA9IGRhdGEuYmVmb3JlTGVhdmU7XG4gIHZhciBsZWF2ZSA9IGRhdGEubGVhdmU7XG4gIHZhciBhZnRlckxlYXZlID0gZGF0YS5hZnRlckxlYXZlO1xuICB2YXIgbGVhdmVDYW5jZWxsZWQgPSBkYXRhLmxlYXZlQ2FuY2VsbGVkO1xuICB2YXIgZGVsYXlMZWF2ZSA9IGRhdGEuZGVsYXlMZWF2ZTtcbiAgdmFyIGR1cmF0aW9uID0gZGF0YS5kdXJhdGlvbjtcblxuICB2YXIgZXhwZWN0c0NTUyA9IGNzcyAhPT0gZmFsc2UgJiYgIWlzSUU5O1xuICB2YXIgdXNlcldhbnRzQ29udHJvbCA9IGdldEhvb2tBcmd1bWVudHNMZW5ndGgobGVhdmUpO1xuXG4gIHZhciBleHBsaWNpdExlYXZlRHVyYXRpb24gPSB0b051bWJlcihcbiAgICBpc09iamVjdChkdXJhdGlvbilcbiAgICAgID8gZHVyYXRpb24ubGVhdmVcbiAgICAgIDogZHVyYXRpb25cbiAgKTtcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBpc0RlZihleHBsaWNpdExlYXZlRHVyYXRpb24pKSB7XG4gICAgY2hlY2tEdXJhdGlvbihleHBsaWNpdExlYXZlRHVyYXRpb24sICdsZWF2ZScsIHZub2RlKTtcbiAgfVxuXG4gIHZhciBjYiA9IGVsLl9sZWF2ZUNiID0gb25jZShmdW5jdGlvbiAoKSB7XG4gICAgaWYgKGVsLnBhcmVudE5vZGUgJiYgZWwucGFyZW50Tm9kZS5fcGVuZGluZykge1xuICAgICAgZWwucGFyZW50Tm9kZS5fcGVuZGluZ1t2bm9kZS5rZXldID0gbnVsbDtcbiAgICB9XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVUb0NsYXNzKTtcbiAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVBY3RpdmVDbGFzcyk7XG4gICAgfVxuICAgIGlmIChjYi5jYW5jZWxsZWQpIHtcbiAgICAgIGlmIChleHBlY3RzQ1NTKSB7XG4gICAgICAgIHJlbW92ZVRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICB9XG4gICAgICBsZWF2ZUNhbmNlbGxlZCAmJiBsZWF2ZUNhbmNlbGxlZChlbCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgICBhZnRlckxlYXZlICYmIGFmdGVyTGVhdmUoZWwpO1xuICAgIH1cbiAgICBlbC5fbGVhdmVDYiA9IG51bGw7XG4gIH0pO1xuXG4gIGlmIChkZWxheUxlYXZlKSB7XG4gICAgZGVsYXlMZWF2ZShwZXJmb3JtTGVhdmUpO1xuICB9IGVsc2Uge1xuICAgIHBlcmZvcm1MZWF2ZSgpO1xuICB9XG5cbiAgZnVuY3Rpb24gcGVyZm9ybUxlYXZlICgpIHtcbiAgICAvLyB0aGUgZGVsYXllZCBsZWF2ZSBtYXkgaGF2ZSBhbHJlYWR5IGJlZW4gY2FuY2VsbGVkXG4gICAgaWYgKGNiLmNhbmNlbGxlZCkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIC8vIHJlY29yZCBsZWF2aW5nIGVsZW1lbnRcbiAgICBpZiAoIXZub2RlLmRhdGEuc2hvdykge1xuICAgICAgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgfHwgKGVsLnBhcmVudE5vZGUuX3BlbmRpbmcgPSB7fSkpWyh2bm9kZS5rZXkpXSA9IHZub2RlO1xuICAgIH1cbiAgICBiZWZvcmVMZWF2ZSAmJiBiZWZvcmVMZWF2ZShlbCk7XG4gICAgaWYgKGV4cGVjdHNDU1MpIHtcbiAgICAgIGFkZFRyYW5zaXRpb25DbGFzcyhlbCwgbGVhdmVDbGFzcyk7XG4gICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQWN0aXZlQ2xhc3MpO1xuICAgICAgbmV4dEZyYW1lKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgYWRkVHJhbnNpdGlvbkNsYXNzKGVsLCBsZWF2ZVRvQ2xhc3MpO1xuICAgICAgICByZW1vdmVUcmFuc2l0aW9uQ2xhc3MoZWwsIGxlYXZlQ2xhc3MpO1xuICAgICAgICBpZiAoIWNiLmNhbmNlbGxlZCAmJiAhdXNlcldhbnRzQ29udHJvbCkge1xuICAgICAgICAgIGlmIChpc1ZhbGlkRHVyYXRpb24oZXhwbGljaXRMZWF2ZUR1cmF0aW9uKSkge1xuICAgICAgICAgICAgc2V0VGltZW91dChjYiwgZXhwbGljaXRMZWF2ZUR1cmF0aW9uKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgd2hlblRyYW5zaXRpb25FbmRzKGVsLCB0eXBlLCBjYik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9KTtcbiAgICB9XG4gICAgbGVhdmUgJiYgbGVhdmUoZWwsIGNiKTtcbiAgICBpZiAoIWV4cGVjdHNDU1MgJiYgIXVzZXJXYW50c0NvbnRyb2wpIHtcbiAgICAgIGNiKCk7XG4gICAgfVxuICB9XG59XG5cbi8vIG9ubHkgdXNlZCBpbiBkZXYgbW9kZVxuZnVuY3Rpb24gY2hlY2tEdXJhdGlvbiAodmFsLCBuYW1lLCB2bm9kZSkge1xuICBpZiAodHlwZW9mIHZhbCAhPT0gJ251bWJlcicpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgbm90IGEgdmFsaWQgbnVtYmVyIC0gXCIgK1xuICAgICAgXCJnb3QgXCIgKyAoSlNPTi5zdHJpbmdpZnkodmFsKSkgKyBcIi5cIixcbiAgICAgIHZub2RlLmNvbnRleHRcbiAgICApO1xuICB9IGVsc2UgaWYgKGlzTmFOKHZhbCkpIHtcbiAgICB3YXJuKFxuICAgICAgXCI8dHJhbnNpdGlvbj4gZXhwbGljaXQgXCIgKyBuYW1lICsgXCIgZHVyYXRpb24gaXMgTmFOIC0gXCIgK1xuICAgICAgJ3RoZSBkdXJhdGlvbiBleHByZXNzaW9uIG1pZ2h0IGJlIGluY29ycmVjdC4nLFxuICAgICAgdm5vZGUuY29udGV4dFxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNWYWxpZER1cmF0aW9uICh2YWwpIHtcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInICYmICFpc05hTih2YWwpXG59XG5cbi8qKlxuICogTm9ybWFsaXplIGEgdHJhbnNpdGlvbiBob29rJ3MgYXJndW1lbnQgbGVuZ3RoLiBUaGUgaG9vayBtYXkgYmU6XG4gKiAtIGEgbWVyZ2VkIGhvb2sgKGludm9rZXIpIHdpdGggdGhlIG9yaWdpbmFsIGluIC5mbnNcbiAqIC0gYSB3cmFwcGVkIGNvbXBvbmVudCBtZXRob2QgKGNoZWNrIC5fbGVuZ3RoKVxuICogLSBhIHBsYWluIGZ1bmN0aW9uICgubGVuZ3RoKVxuICovXG5mdW5jdGlvbiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoIChmbikge1xuICBpZiAoaXNVbmRlZihmbikpIHtcbiAgICByZXR1cm4gZmFsc2VcbiAgfVxuICB2YXIgaW52b2tlckZucyA9IGZuLmZucztcbiAgaWYgKGlzRGVmKGludm9rZXJGbnMpKSB7XG4gICAgLy8gaW52b2tlclxuICAgIHJldHVybiBnZXRIb29rQXJndW1lbnRzTGVuZ3RoKFxuICAgICAgQXJyYXkuaXNBcnJheShpbnZva2VyRm5zKVxuICAgICAgICA/IGludm9rZXJGbnNbMF1cbiAgICAgICAgOiBpbnZva2VyRm5zXG4gICAgKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiAoZm4uX2xlbmd0aCB8fCBmbi5sZW5ndGgpID4gMVxuICB9XG59XG5cbmZ1bmN0aW9uIF9lbnRlciAoXywgdm5vZGUpIHtcbiAgaWYgKHZub2RlLmRhdGEuc2hvdyAhPT0gdHJ1ZSkge1xuICAgIGVudGVyKHZub2RlKTtcbiAgfVxufVxuXG52YXIgdHJhbnNpdGlvbiA9IGluQnJvd3NlciA/IHtcbiAgY3JlYXRlOiBfZW50ZXIsXG4gIGFjdGl2YXRlOiBfZW50ZXIsXG4gIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlJCQxICh2bm9kZSwgcm0pIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgZWxzZSAqL1xuICAgIGlmICh2bm9kZS5kYXRhLnNob3cgIT09IHRydWUpIHtcbiAgICAgIGxlYXZlKHZub2RlLCBybSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHJtKCk7XG4gICAgfVxuICB9XG59IDoge307XG5cbnZhciBwbGF0Zm9ybU1vZHVsZXMgPSBbXG4gIGF0dHJzLFxuICBrbGFzcyxcbiAgZXZlbnRzLFxuICBkb21Qcm9wcyxcbiAgc3R5bGUsXG4gIHRyYW5zaXRpb25cbl07XG5cbi8qICAqL1xuXG4vLyB0aGUgZGlyZWN0aXZlIG1vZHVsZSBzaG91bGQgYmUgYXBwbGllZCBsYXN0LCBhZnRlciBhbGxcbi8vIGJ1aWx0LWluIG1vZHVsZXMgaGF2ZSBiZWVuIGFwcGxpZWQuXG52YXIgbW9kdWxlcyA9IHBsYXRmb3JtTW9kdWxlcy5jb25jYXQoYmFzZU1vZHVsZXMpO1xuXG52YXIgcGF0Y2ggPSBjcmVhdGVQYXRjaEZ1bmN0aW9uKHsgbm9kZU9wczogbm9kZU9wcywgbW9kdWxlczogbW9kdWxlcyB9KTtcblxuLyoqXG4gKiBOb3QgdHlwZSBjaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBmbG93IGRvZXNuJ3QgbGlrZSBhdHRhY2hpbmdcbiAqIHByb3BlcnRpZXMgdG8gRWxlbWVudHMuXG4gKi9cblxuLyogaXN0YW5idWwgaWdub3JlIGlmICovXG5pZiAoaXNJRTkpIHtcbiAgLy8gaHR0cDovL3d3dy5tYXR0czQxMS5jb20vcG9zdC9pbnRlcm5ldC1leHBsb3Jlci05LW9uaW5wdXQvXG4gIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoJ3NlbGVjdGlvbmNoYW5nZScsIGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgZWwgPSBkb2N1bWVudC5hY3RpdmVFbGVtZW50O1xuICAgIGlmIChlbCAmJiBlbC52bW9kZWwpIHtcbiAgICAgIHRyaWdnZXIoZWwsICdpbnB1dCcpO1xuICAgIH1cbiAgfSk7XG59XG5cbnZhciBkaXJlY3RpdmUgPSB7XG4gIGluc2VydGVkOiBmdW5jdGlvbiBpbnNlcnRlZCAoZWwsIGJpbmRpbmcsIHZub2RlLCBvbGRWbm9kZSkge1xuICAgIGlmICh2bm9kZS50YWcgPT09ICdzZWxlY3QnKSB7XG4gICAgICAvLyAjNjkwM1xuICAgICAgaWYgKG9sZFZub2RlLmVsbSAmJiAhb2xkVm5vZGUuZWxtLl92T3B0aW9ucykge1xuICAgICAgICBtZXJnZVZOb2RlSG9vayh2bm9kZSwgJ3Bvc3RwYXRjaCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBkaXJlY3RpdmUuY29tcG9uZW50VXBkYXRlZChlbCwgYmluZGluZywgdm5vZGUpO1xuICAgICAgICB9KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIH1cbiAgICAgIGVsLl92T3B0aW9ucyA9IFtdLm1hcC5jYWxsKGVsLm9wdGlvbnMsIGdldFZhbHVlKTtcbiAgICB9IGVsc2UgaWYgKHZub2RlLnRhZyA9PT0gJ3RleHRhcmVhJyB8fCBpc1RleHRJbnB1dFR5cGUoZWwudHlwZSkpIHtcbiAgICAgIGVsLl92TW9kaWZpZXJzID0gYmluZGluZy5tb2RpZmllcnM7XG4gICAgICBpZiAoIWJpbmRpbmcubW9kaWZpZXJzLmxhenkpIHtcbiAgICAgICAgLy8gU2FmYXJpIDwgMTAuMiAmIFVJV2ViVmlldyBkb2Vzbid0IGZpcmUgY29tcG9zaXRpb25lbmQgd2hlblxuICAgICAgICAvLyBzd2l0Y2hpbmcgZm9jdXMgYmVmb3JlIGNvbmZpcm1pbmcgY29tcG9zaXRpb24gY2hvaWNlXG4gICAgICAgIC8vIHRoaXMgYWxzbyBmaXhlcyB0aGUgaXNzdWUgd2hlcmUgc29tZSBicm93c2VycyBlLmcuIGlPUyBDaHJvbWVcbiAgICAgICAgLy8gZmlyZXMgXCJjaGFuZ2VcIiBpbnN0ZWFkIG9mIFwiaW5wdXRcIiBvbiBhdXRvY29tcGxldGUuXG4gICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NoYW5nZScsIG9uQ29tcG9zaXRpb25FbmQpO1xuICAgICAgICBpZiAoIWlzQW5kcm9pZCkge1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uc3RhcnQnLCBvbkNvbXBvc2l0aW9uU3RhcnQpO1xuICAgICAgICAgIGVsLmFkZEV2ZW50TGlzdGVuZXIoJ2NvbXBvc2l0aW9uZW5kJywgb25Db21wb3NpdGlvbkVuZCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICAgIGlmIChpc0lFOSkge1xuICAgICAgICAgIGVsLnZtb2RlbCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG4gIH0sXG5cbiAgY29tcG9uZW50VXBkYXRlZDogZnVuY3Rpb24gY29tcG9uZW50VXBkYXRlZCAoZWwsIGJpbmRpbmcsIHZub2RlKSB7XG4gICAgaWYgKHZub2RlLnRhZyA9PT0gJ3NlbGVjdCcpIHtcbiAgICAgIHNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bm9kZS5jb250ZXh0KTtcbiAgICAgIC8vIGluIGNhc2UgdGhlIG9wdGlvbnMgcmVuZGVyZWQgYnkgdi1mb3IgaGF2ZSBjaGFuZ2VkLFxuICAgICAgLy8gaXQncyBwb3NzaWJsZSB0aGF0IHRoZSB2YWx1ZSBpcyBvdXQtb2Ytc3luYyB3aXRoIHRoZSByZW5kZXJlZCBvcHRpb25zLlxuICAgICAgLy8gZGV0ZWN0IHN1Y2ggY2FzZXMgYW5kIGZpbHRlciBvdXQgdmFsdWVzIHRoYXQgbm8gbG9uZ2VyIGhhcyBhIG1hdGNoaW5nXG4gICAgICAvLyBvcHRpb24gaW4gdGhlIERPTS5cbiAgICAgIHZhciBwcmV2T3B0aW9ucyA9IGVsLl92T3B0aW9ucztcbiAgICAgIHZhciBjdXJPcHRpb25zID0gZWwuX3ZPcHRpb25zID0gW10ubWFwLmNhbGwoZWwub3B0aW9ucywgZ2V0VmFsdWUpO1xuICAgICAgaWYgKGN1ck9wdGlvbnMuc29tZShmdW5jdGlvbiAobywgaSkgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgcHJldk9wdGlvbnNbaV0pOyB9KSkge1xuICAgICAgICAvLyB0cmlnZ2VyIGNoYW5nZSBldmVudCBpZlxuICAgICAgICAvLyBubyBtYXRjaGluZyBvcHRpb24gZm91bmQgZm9yIGF0IGxlYXN0IG9uZSB2YWx1ZVxuICAgICAgICB2YXIgbmVlZFJlc2V0ID0gZWwubXVsdGlwbGVcbiAgICAgICAgICA/IGJpbmRpbmcudmFsdWUuc29tZShmdW5jdGlvbiAodikgeyByZXR1cm4gaGFzTm9NYXRjaGluZ09wdGlvbih2LCBjdXJPcHRpb25zKTsgfSlcbiAgICAgICAgICA6IGJpbmRpbmcudmFsdWUgIT09IGJpbmRpbmcub2xkVmFsdWUgJiYgaGFzTm9NYXRjaGluZ09wdGlvbihiaW5kaW5nLnZhbHVlLCBjdXJPcHRpb25zKTtcbiAgICAgICAgaWYgKG5lZWRSZXNldCkge1xuICAgICAgICAgIHRyaWdnZXIoZWwsICdjaGFuZ2UnKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufTtcblxuZnVuY3Rpb24gc2V0U2VsZWN0ZWQgKGVsLCBiaW5kaW5nLCB2bSkge1xuICBhY3R1YWxseVNldFNlbGVjdGVkKGVsLCBiaW5kaW5nLCB2bSk7XG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoaXNJRSB8fCBpc0VkZ2UpIHtcbiAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgIGFjdHVhbGx5U2V0U2VsZWN0ZWQoZWwsIGJpbmRpbmcsIHZtKTtcbiAgICB9LCAwKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBhY3R1YWxseVNldFNlbGVjdGVkIChlbCwgYmluZGluZywgdm0pIHtcbiAgdmFyIHZhbHVlID0gYmluZGluZy52YWx1ZTtcbiAgdmFyIGlzTXVsdGlwbGUgPSBlbC5tdWx0aXBsZTtcbiAgaWYgKGlzTXVsdGlwbGUgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiB3YXJuKFxuICAgICAgXCI8c2VsZWN0IG11bHRpcGxlIHYtbW9kZWw9XFxcIlwiICsgKGJpbmRpbmcuZXhwcmVzc2lvbikgKyBcIlxcXCI+IFwiICtcbiAgICAgIFwiZXhwZWN0cyBhbiBBcnJheSB2YWx1ZSBmb3IgaXRzIGJpbmRpbmcsIGJ1dCBnb3QgXCIgKyAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHZhbHVlKS5zbGljZSg4LCAtMSkpLFxuICAgICAgdm1cbiAgICApO1xuICAgIHJldHVyblxuICB9XG4gIHZhciBzZWxlY3RlZCwgb3B0aW9uO1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGVsLm9wdGlvbnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgb3B0aW9uID0gZWwub3B0aW9uc1tpXTtcbiAgICBpZiAoaXNNdWx0aXBsZSkge1xuICAgICAgc2VsZWN0ZWQgPSBsb29zZUluZGV4T2YodmFsdWUsIGdldFZhbHVlKG9wdGlvbikpID4gLTE7XG4gICAgICBpZiAob3B0aW9uLnNlbGVjdGVkICE9PSBzZWxlY3RlZCkge1xuICAgICAgICBvcHRpb24uc2VsZWN0ZWQgPSBzZWxlY3RlZDtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKGxvb3NlRXF1YWwoZ2V0VmFsdWUob3B0aW9uKSwgdmFsdWUpKSB7XG4gICAgICAgIGlmIChlbC5zZWxlY3RlZEluZGV4ICE9PSBpKSB7XG4gICAgICAgICAgZWwuc2VsZWN0ZWRJbmRleCA9IGk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgfVxuICB9XG4gIGlmICghaXNNdWx0aXBsZSkge1xuICAgIGVsLnNlbGVjdGVkSW5kZXggPSAtMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNOb01hdGNoaW5nT3B0aW9uICh2YWx1ZSwgb3B0aW9ucykge1xuICByZXR1cm4gb3B0aW9ucy5ldmVyeShmdW5jdGlvbiAobykgeyByZXR1cm4gIWxvb3NlRXF1YWwobywgdmFsdWUpOyB9KVxufVxuXG5mdW5jdGlvbiBnZXRWYWx1ZSAob3B0aW9uKSB7XG4gIHJldHVybiAnX3ZhbHVlJyBpbiBvcHRpb25cbiAgICA/IG9wdGlvbi5fdmFsdWVcbiAgICA6IG9wdGlvbi52YWx1ZVxufVxuXG5mdW5jdGlvbiBvbkNvbXBvc2l0aW9uU3RhcnQgKGUpIHtcbiAgZS50YXJnZXQuY29tcG9zaW5nID0gdHJ1ZTtcbn1cblxuZnVuY3Rpb24gb25Db21wb3NpdGlvbkVuZCAoZSkge1xuICAvLyBwcmV2ZW50IHRyaWdnZXJpbmcgYW4gaW5wdXQgZXZlbnQgZm9yIG5vIHJlYXNvblxuICBpZiAoIWUudGFyZ2V0LmNvbXBvc2luZykgeyByZXR1cm4gfVxuICBlLnRhcmdldC5jb21wb3NpbmcgPSBmYWxzZTtcbiAgdHJpZ2dlcihlLnRhcmdldCwgJ2lucHV0Jyk7XG59XG5cbmZ1bmN0aW9uIHRyaWdnZXIgKGVsLCB0eXBlKSB7XG4gIHZhciBlID0gZG9jdW1lbnQuY3JlYXRlRXZlbnQoJ0hUTUxFdmVudHMnKTtcbiAgZS5pbml0RXZlbnQodHlwZSwgdHJ1ZSwgdHJ1ZSk7XG4gIGVsLmRpc3BhdGNoRXZlbnQoZSk7XG59XG5cbi8qICAqL1xuXG4vLyByZWN1cnNpdmVseSBzZWFyY2ggZm9yIHBvc3NpYmxlIHRyYW5zaXRpb24gZGVmaW5lZCBpbnNpZGUgdGhlIGNvbXBvbmVudCByb290XG5mdW5jdGlvbiBsb2NhdGVOb2RlICh2bm9kZSkge1xuICByZXR1cm4gdm5vZGUuY29tcG9uZW50SW5zdGFuY2UgJiYgKCF2bm9kZS5kYXRhIHx8ICF2bm9kZS5kYXRhLnRyYW5zaXRpb24pXG4gICAgPyBsb2NhdGVOb2RlKHZub2RlLmNvbXBvbmVudEluc3RhbmNlLl92bm9kZSlcbiAgICA6IHZub2RlXG59XG5cbnZhciBzaG93ID0ge1xuICBiaW5kOiBmdW5jdGlvbiBiaW5kIChlbCwgcmVmLCB2bm9kZSkge1xuICAgIHZhciB2YWx1ZSA9IHJlZi52YWx1ZTtcblxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICB2YXIgb3JpZ2luYWxEaXNwbGF5ID0gZWwuX192T3JpZ2luYWxEaXNwbGF5ID1cbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPT09ICdub25lJyA/ICcnIDogZWwuc3R5bGUuZGlzcGxheTtcbiAgICBpZiAodmFsdWUgJiYgdHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGVudGVyKHZub2RlLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBvcmlnaW5hbERpc3BsYXk7XG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gb3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1cGRhdGU6IGZ1bmN0aW9uIHVwZGF0ZSAoZWwsIHJlZiwgdm5vZGUpIHtcbiAgICB2YXIgdmFsdWUgPSByZWYudmFsdWU7XG4gICAgdmFyIG9sZFZhbHVlID0gcmVmLm9sZFZhbHVlO1xuXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKHZhbHVlID09PSBvbGRWYWx1ZSkgeyByZXR1cm4gfVxuICAgIHZub2RlID0gbG9jYXRlTm9kZSh2bm9kZSk7XG4gICAgdmFyIHRyYW5zaXRpb24kJDEgPSB2bm9kZS5kYXRhICYmIHZub2RlLmRhdGEudHJhbnNpdGlvbjtcbiAgICBpZiAodHJhbnNpdGlvbiQkMSkge1xuICAgICAgdm5vZGUuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICBlbnRlcih2bm9kZSwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgICAgIH0pO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbGVhdmUodm5vZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICBlbC5zdHlsZS5kaXNwbGF5ID0gJ25vbmUnO1xuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgZWwuc3R5bGUuZGlzcGxheSA9IHZhbHVlID8gZWwuX192T3JpZ2luYWxEaXNwbGF5IDogJ25vbmUnO1xuICAgIH1cbiAgfSxcblxuICB1bmJpbmQ6IGZ1bmN0aW9uIHVuYmluZCAoXG4gICAgZWwsXG4gICAgYmluZGluZyxcbiAgICB2bm9kZSxcbiAgICBvbGRWbm9kZSxcbiAgICBpc0Rlc3Ryb3lcbiAgKSB7XG4gICAgaWYgKCFpc0Rlc3Ryb3kpIHtcbiAgICAgIGVsLnN0eWxlLmRpc3BsYXkgPSBlbC5fX3ZPcmlnaW5hbERpc3BsYXk7XG4gICAgfVxuICB9XG59O1xuXG52YXIgcGxhdGZvcm1EaXJlY3RpdmVzID0ge1xuICBtb2RlbDogZGlyZWN0aXZlLFxuICBzaG93OiBzaG93XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBhIHNpbmdsZSBlbGVtZW50L2NvbXBvbmVudC5cbi8vIHN1cHBvcnRzIHRyYW5zaXRpb24gbW9kZSAob3V0LWluIC8gaW4tb3V0KVxuXG52YXIgdHJhbnNpdGlvblByb3BzID0ge1xuICBuYW1lOiBTdHJpbmcsXG4gIGFwcGVhcjogQm9vbGVhbixcbiAgY3NzOiBCb29sZWFuLFxuICBtb2RlOiBTdHJpbmcsXG4gIHR5cGU6IFN0cmluZyxcbiAgZW50ZXJDbGFzczogU3RyaW5nLFxuICBsZWF2ZUNsYXNzOiBTdHJpbmcsXG4gIGVudGVyVG9DbGFzczogU3RyaW5nLFxuICBsZWF2ZVRvQ2xhc3M6IFN0cmluZyxcbiAgZW50ZXJBY3RpdmVDbGFzczogU3RyaW5nLFxuICBsZWF2ZUFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhckFjdGl2ZUNsYXNzOiBTdHJpbmcsXG4gIGFwcGVhclRvQ2xhc3M6IFN0cmluZyxcbiAgZHVyYXRpb246IFtOdW1iZXIsIFN0cmluZywgT2JqZWN0XVxufTtcblxuLy8gaW4gY2FzZSB0aGUgY2hpbGQgaXMgYWxzbyBhbiBhYnN0cmFjdCBjb21wb25lbnQsIGUuZy4gPGtlZXAtYWxpdmU+XG4vLyB3ZSB3YW50IHRvIHJlY3Vyc2l2ZWx5IHJldHJpZXZlIHRoZSByZWFsIGNvbXBvbmVudCB0byBiZSByZW5kZXJlZFxuZnVuY3Rpb24gZ2V0UmVhbENoaWxkICh2bm9kZSkge1xuICB2YXIgY29tcE9wdGlvbnMgPSB2bm9kZSAmJiB2bm9kZS5jb21wb25lbnRPcHRpb25zO1xuICBpZiAoY29tcE9wdGlvbnMgJiYgY29tcE9wdGlvbnMuQ3Rvci5vcHRpb25zLmFic3RyYWN0KSB7XG4gICAgcmV0dXJuIGdldFJlYWxDaGlsZChnZXRGaXJzdENvbXBvbmVudENoaWxkKGNvbXBPcHRpb25zLmNoaWxkcmVuKSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gdm5vZGVcbiAgfVxufVxuXG5mdW5jdGlvbiBleHRyYWN0VHJhbnNpdGlvbkRhdGEgKGNvbXApIHtcbiAgdmFyIGRhdGEgPSB7fTtcbiAgdmFyIG9wdGlvbnMgPSBjb21wLiRvcHRpb25zO1xuICAvLyBwcm9wc1xuICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucy5wcm9wc0RhdGEpIHtcbiAgICBkYXRhW2tleV0gPSBjb21wW2tleV07XG4gIH1cbiAgLy8gZXZlbnRzLlxuICAvLyBleHRyYWN0IGxpc3RlbmVycyBhbmQgcGFzcyB0aGVtIGRpcmVjdGx5IHRvIHRoZSB0cmFuc2l0aW9uIG1ldGhvZHNcbiAgdmFyIGxpc3RlbmVycyA9IG9wdGlvbnMuX3BhcmVudExpc3RlbmVycztcbiAgZm9yICh2YXIga2V5JDEgaW4gbGlzdGVuZXJzKSB7XG4gICAgZGF0YVtjYW1lbGl6ZShrZXkkMSldID0gbGlzdGVuZXJzW2tleSQxXTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBwbGFjZWhvbGRlciAoaCwgcmF3Q2hpbGQpIHtcbiAgaWYgKC9cXGQta2VlcC1hbGl2ZSQvLnRlc3QocmF3Q2hpbGQudGFnKSkge1xuICAgIHJldHVybiBoKCdrZWVwLWFsaXZlJywge1xuICAgICAgcHJvcHM6IHJhd0NoaWxkLmNvbXBvbmVudE9wdGlvbnMucHJvcHNEYXRhXG4gICAgfSlcbiAgfVxufVxuXG5mdW5jdGlvbiBoYXNQYXJlbnRUcmFuc2l0aW9uICh2bm9kZSkge1xuICB3aGlsZSAoKHZub2RlID0gdm5vZGUucGFyZW50KSkge1xuICAgIGlmICh2bm9kZS5kYXRhLnRyYW5zaXRpb24pIHtcbiAgICAgIHJldHVybiB0cnVlXG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGlzU2FtZUNoaWxkIChjaGlsZCwgb2xkQ2hpbGQpIHtcbiAgcmV0dXJuIG9sZENoaWxkLmtleSA9PT0gY2hpbGQua2V5ICYmIG9sZENoaWxkLnRhZyA9PT0gY2hpbGQudGFnXG59XG5cbnZhciBUcmFuc2l0aW9uID0ge1xuICBuYW1lOiAndHJhbnNpdGlvbicsXG4gIHByb3BzOiB0cmFuc2l0aW9uUHJvcHMsXG4gIGFic3RyYWN0OiB0cnVlLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRoaXMkMSA9IHRoaXM7XG5cbiAgICB2YXIgY2hpbGRyZW4gPSB0aGlzLiRzbG90cy5kZWZhdWx0O1xuICAgIGlmICghY2hpbGRyZW4pIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIGZpbHRlciBvdXQgdGV4dCBub2RlcyAocG9zc2libGUgd2hpdGVzcGFjZXMpXG4gICAgY2hpbGRyZW4gPSBjaGlsZHJlbi5maWx0ZXIoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIGMudGFnIHx8IGlzQXN5bmNQbGFjZWhvbGRlcihjKTsgfSk7XG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgaWYgKCFjaGlsZHJlbi5sZW5ndGgpIHtcbiAgICAgIHJldHVyblxuICAgIH1cblxuICAgIC8vIHdhcm4gbXVsdGlwbGUgZWxlbWVudHNcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjaGlsZHJlbi5sZW5ndGggPiAxKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnPHRyYW5zaXRpb24+IGNhbiBvbmx5IGJlIHVzZWQgb24gYSBzaW5nbGUgZWxlbWVudC4gVXNlICcgK1xuICAgICAgICAnPHRyYW5zaXRpb24tZ3JvdXA+IGZvciBsaXN0cy4nLFxuICAgICAgICB0aGlzLiRwYXJlbnRcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFyIG1vZGUgPSB0aGlzLm1vZGU7XG5cbiAgICAvLyB3YXJuIGludmFsaWQgbW9kZVxuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmXG4gICAgICBtb2RlICYmIG1vZGUgIT09ICdpbi1vdXQnICYmIG1vZGUgIT09ICdvdXQtaW4nXG4gICAgKSB7XG4gICAgICB3YXJuKFxuICAgICAgICAnaW52YWxpZCA8dHJhbnNpdGlvbj4gbW9kZTogJyArIG1vZGUsXG4gICAgICAgIHRoaXMuJHBhcmVudFxuICAgICAgKTtcbiAgICB9XG5cbiAgICB2YXIgcmF3Q2hpbGQgPSBjaGlsZHJlblswXTtcblxuICAgIC8vIGlmIHRoaXMgaXMgYSBjb21wb25lbnQgcm9vdCBub2RlIGFuZCB0aGUgY29tcG9uZW50J3NcbiAgICAvLyBwYXJlbnQgY29udGFpbmVyIG5vZGUgYWxzbyBoYXMgdHJhbnNpdGlvbiwgc2tpcC5cbiAgICBpZiAoaGFzUGFyZW50VHJhbnNpdGlvbih0aGlzLiR2bm9kZSkpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIC8vIGFwcGx5IHRyYW5zaXRpb24gZGF0YSB0byBjaGlsZFxuICAgIC8vIHVzZSBnZXRSZWFsQ2hpbGQoKSB0byBpZ25vcmUgYWJzdHJhY3QgY29tcG9uZW50cyBlLmcuIGtlZXAtYWxpdmVcbiAgICB2YXIgY2hpbGQgPSBnZXRSZWFsQ2hpbGQocmF3Q2hpbGQpO1xuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgIGlmICghY2hpbGQpIHtcbiAgICAgIHJldHVybiByYXdDaGlsZFxuICAgIH1cblxuICAgIGlmICh0aGlzLl9sZWF2aW5nKSB7XG4gICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgfVxuXG4gICAgLy8gZW5zdXJlIGEga2V5IHRoYXQgaXMgdW5pcXVlIHRvIHRoZSB2bm9kZSB0eXBlIGFuZCB0byB0aGlzIHRyYW5zaXRpb25cbiAgICAvLyBjb21wb25lbnQgaW5zdGFuY2UuIFRoaXMga2V5IHdpbGwgYmUgdXNlZCB0byByZW1vdmUgcGVuZGluZyBsZWF2aW5nIG5vZGVzXG4gICAgLy8gZHVyaW5nIGVudGVyaW5nLlxuICAgIHZhciBpZCA9IFwiX190cmFuc2l0aW9uLVwiICsgKHRoaXMuX3VpZCkgKyBcIi1cIjtcbiAgICBjaGlsZC5rZXkgPSBjaGlsZC5rZXkgPT0gbnVsbFxuICAgICAgPyBjaGlsZC5pc0NvbW1lbnRcbiAgICAgICAgPyBpZCArICdjb21tZW50J1xuICAgICAgICA6IGlkICsgY2hpbGQudGFnXG4gICAgICA6IGlzUHJpbWl0aXZlKGNoaWxkLmtleSlcbiAgICAgICAgPyAoU3RyaW5nKGNoaWxkLmtleSkuaW5kZXhPZihpZCkgPT09IDAgPyBjaGlsZC5rZXkgOiBpZCArIGNoaWxkLmtleSlcbiAgICAgICAgOiBjaGlsZC5rZXk7XG5cbiAgICB2YXIgZGF0YSA9IChjaGlsZC5kYXRhIHx8IChjaGlsZC5kYXRhID0ge30pKS50cmFuc2l0aW9uID0gZXh0cmFjdFRyYW5zaXRpb25EYXRhKHRoaXMpO1xuICAgIHZhciBvbGRSYXdDaGlsZCA9IHRoaXMuX3Zub2RlO1xuICAgIHZhciBvbGRDaGlsZCA9IGdldFJlYWxDaGlsZChvbGRSYXdDaGlsZCk7XG5cbiAgICAvLyBtYXJrIHYtc2hvd1xuICAgIC8vIHNvIHRoYXQgdGhlIHRyYW5zaXRpb24gbW9kdWxlIGNhbiBoYW5kIG92ZXIgdGhlIGNvbnRyb2wgdG8gdGhlIGRpcmVjdGl2ZVxuICAgIGlmIChjaGlsZC5kYXRhLmRpcmVjdGl2ZXMgJiYgY2hpbGQuZGF0YS5kaXJlY3RpdmVzLnNvbWUoZnVuY3Rpb24gKGQpIHsgcmV0dXJuIGQubmFtZSA9PT0gJ3Nob3cnOyB9KSkge1xuICAgICAgY2hpbGQuZGF0YS5zaG93ID0gdHJ1ZTtcbiAgICB9XG5cbiAgICBpZiAoXG4gICAgICBvbGRDaGlsZCAmJlxuICAgICAgb2xkQ2hpbGQuZGF0YSAmJlxuICAgICAgIWlzU2FtZUNoaWxkKGNoaWxkLCBvbGRDaGlsZCkgJiZcbiAgICAgICFpc0FzeW5jUGxhY2Vob2xkZXIob2xkQ2hpbGQpICYmXG4gICAgICAvLyAjNjY4NyBjb21wb25lbnQgcm9vdCBpcyBhIGNvbW1lbnQgbm9kZVxuICAgICAgIShvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZSAmJiBvbGRDaGlsZC5jb21wb25lbnRJbnN0YW5jZS5fdm5vZGUuaXNDb21tZW50KVxuICAgICkge1xuICAgICAgLy8gcmVwbGFjZSBvbGQgY2hpbGQgdHJhbnNpdGlvbiBkYXRhIHdpdGggZnJlc2ggb25lXG4gICAgICAvLyBpbXBvcnRhbnQgZm9yIGR5bmFtaWMgdHJhbnNpdGlvbnMhXG4gICAgICB2YXIgb2xkRGF0YSA9IG9sZENoaWxkLmRhdGEudHJhbnNpdGlvbiA9IGV4dGVuZCh7fSwgZGF0YSk7XG4gICAgICAvLyBoYW5kbGUgdHJhbnNpdGlvbiBtb2RlXG4gICAgICBpZiAobW9kZSA9PT0gJ291dC1pbicpIHtcbiAgICAgICAgLy8gcmV0dXJuIHBsYWNlaG9sZGVyIG5vZGUgYW5kIHF1ZXVlIHVwZGF0ZSB3aGVuIGxlYXZlIGZpbmlzaGVzXG4gICAgICAgIHRoaXMuX2xlYXZpbmcgPSB0cnVlO1xuICAgICAgICBtZXJnZVZOb2RlSG9vayhvbGREYXRhLCAnYWZ0ZXJMZWF2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICB0aGlzJDEuX2xlYXZpbmcgPSBmYWxzZTtcbiAgICAgICAgICB0aGlzJDEuJGZvcmNlVXBkYXRlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gcGxhY2Vob2xkZXIoaCwgcmF3Q2hpbGQpXG4gICAgICB9IGVsc2UgaWYgKG1vZGUgPT09ICdpbi1vdXQnKSB7XG4gICAgICAgIGlmIChpc0FzeW5jUGxhY2Vob2xkZXIoY2hpbGQpKSB7XG4gICAgICAgICAgcmV0dXJuIG9sZFJhd0NoaWxkXG4gICAgICAgIH1cbiAgICAgICAgdmFyIGRlbGF5ZWRMZWF2ZTtcbiAgICAgICAgdmFyIHBlcmZvcm1MZWF2ZSA9IGZ1bmN0aW9uICgpIHsgZGVsYXllZExlYXZlKCk7IH07XG4gICAgICAgIG1lcmdlVk5vZGVIb29rKGRhdGEsICdhZnRlckVudGVyJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2soZGF0YSwgJ2VudGVyQ2FuY2VsbGVkJywgcGVyZm9ybUxlYXZlKTtcbiAgICAgICAgbWVyZ2VWTm9kZUhvb2sob2xkRGF0YSwgJ2RlbGF5TGVhdmUnLCBmdW5jdGlvbiAobGVhdmUpIHsgZGVsYXllZExlYXZlID0gbGVhdmU7IH0pO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiByYXdDaGlsZFxuICB9XG59O1xuXG4vKiAgKi9cblxuLy8gUHJvdmlkZXMgdHJhbnNpdGlvbiBzdXBwb3J0IGZvciBsaXN0IGl0ZW1zLlxuLy8gc3VwcG9ydHMgbW92ZSB0cmFuc2l0aW9ucyB1c2luZyB0aGUgRkxJUCB0ZWNobmlxdWUuXG5cbi8vIEJlY2F1c2UgdGhlIHZkb20ncyBjaGlsZHJlbiB1cGRhdGUgYWxnb3JpdGhtIGlzIFwidW5zdGFibGVcIiAtIGkuZS5cbi8vIGl0IGRvZXNuJ3QgZ3VhcmFudGVlIHRoZSByZWxhdGl2ZSBwb3NpdGlvbmluZyBvZiByZW1vdmVkIGVsZW1lbnRzLFxuLy8gd2UgZm9yY2UgdHJhbnNpdGlvbi1ncm91cCB0byB1cGRhdGUgaXRzIGNoaWxkcmVuIGludG8gdHdvIHBhc3Nlczpcbi8vIGluIHRoZSBmaXJzdCBwYXNzLCB3ZSByZW1vdmUgYWxsIG5vZGVzIHRoYXQgbmVlZCB0byBiZSByZW1vdmVkLFxuLy8gdHJpZ2dlcmluZyB0aGVpciBsZWF2aW5nIHRyYW5zaXRpb247IGluIHRoZSBzZWNvbmQgcGFzcywgd2UgaW5zZXJ0L21vdmVcbi8vIGludG8gdGhlIGZpbmFsIGRlc2lyZWQgc3RhdGUuIFRoaXMgd2F5IGluIHRoZSBzZWNvbmQgcGFzcyByZW1vdmVkXG4vLyBub2RlcyB3aWxsIHJlbWFpbiB3aGVyZSB0aGV5IHNob3VsZCBiZS5cblxudmFyIHByb3BzID0gZXh0ZW5kKHtcbiAgdGFnOiBTdHJpbmcsXG4gIG1vdmVDbGFzczogU3RyaW5nXG59LCB0cmFuc2l0aW9uUHJvcHMpO1xuXG5kZWxldGUgcHJvcHMubW9kZTtcblxudmFyIFRyYW5zaXRpb25Hcm91cCA9IHtcbiAgcHJvcHM6IHByb3BzLFxuXG4gIHJlbmRlcjogZnVuY3Rpb24gcmVuZGVyIChoKSB7XG4gICAgdmFyIHRhZyA9IHRoaXMudGFnIHx8IHRoaXMuJHZub2RlLmRhdGEudGFnIHx8ICdzcGFuJztcbiAgICB2YXIgbWFwID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB2YXIgcHJldkNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW4gPSB0aGlzLmNoaWxkcmVuO1xuICAgIHZhciByYXdDaGlsZHJlbiA9IHRoaXMuJHNsb3RzLmRlZmF1bHQgfHwgW107XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5jaGlsZHJlbiA9IFtdO1xuICAgIHZhciB0cmFuc2l0aW9uRGF0YSA9IGV4dHJhY3RUcmFuc2l0aW9uRGF0YSh0aGlzKTtcblxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcmF3Q2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBjID0gcmF3Q2hpbGRyZW5baV07XG4gICAgICBpZiAoYy50YWcpIHtcbiAgICAgICAgaWYgKGMua2V5ICE9IG51bGwgJiYgU3RyaW5nKGMua2V5KS5pbmRleE9mKCdfX3ZsaXN0JykgIT09IDApIHtcbiAgICAgICAgICBjaGlsZHJlbi5wdXNoKGMpO1xuICAgICAgICAgIG1hcFtjLmtleV0gPSBjXG4gICAgICAgICAgOyhjLmRhdGEgfHwgKGMuZGF0YSA9IHt9KSkudHJhbnNpdGlvbiA9IHRyYW5zaXRpb25EYXRhO1xuICAgICAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgICB2YXIgb3B0cyA9IGMuY29tcG9uZW50T3B0aW9ucztcbiAgICAgICAgICB2YXIgbmFtZSA9IG9wdHMgPyAob3B0cy5DdG9yLm9wdGlvbnMubmFtZSB8fCBvcHRzLnRhZyB8fCAnJykgOiBjLnRhZztcbiAgICAgICAgICB3YXJuKChcIjx0cmFuc2l0aW9uLWdyb3VwPiBjaGlsZHJlbiBtdXN0IGJlIGtleWVkOiA8XCIgKyBuYW1lICsgXCI+XCIpKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChwcmV2Q2hpbGRyZW4pIHtcbiAgICAgIHZhciBrZXB0ID0gW107XG4gICAgICB2YXIgcmVtb3ZlZCA9IFtdO1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcHJldkNoaWxkcmVuLmxlbmd0aDsgaSQxKyspIHtcbiAgICAgICAgdmFyIGMkMSA9IHByZXZDaGlsZHJlbltpJDFdO1xuICAgICAgICBjJDEuZGF0YS50cmFuc2l0aW9uID0gdHJhbnNpdGlvbkRhdGE7XG4gICAgICAgIGMkMS5kYXRhLnBvcyA9IGMkMS5lbG0uZ2V0Qm91bmRpbmdDbGllbnRSZWN0KCk7XG4gICAgICAgIGlmIChtYXBbYyQxLmtleV0pIHtcbiAgICAgICAgICBrZXB0LnB1c2goYyQxKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZW1vdmVkLnB1c2goYyQxKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgdGhpcy5rZXB0ID0gaCh0YWcsIG51bGwsIGtlcHQpO1xuICAgICAgdGhpcy5yZW1vdmVkID0gcmVtb3ZlZDtcbiAgICB9XG5cbiAgICByZXR1cm4gaCh0YWcsIG51bGwsIGNoaWxkcmVuKVxuICB9LFxuXG4gIGJlZm9yZVVwZGF0ZTogZnVuY3Rpb24gYmVmb3JlVXBkYXRlICgpIHtcbiAgICAvLyBmb3JjZSByZW1vdmluZyBwYXNzXG4gICAgdGhpcy5fX3BhdGNoX18oXG4gICAgICB0aGlzLl92bm9kZSxcbiAgICAgIHRoaXMua2VwdCxcbiAgICAgIGZhbHNlLCAvLyBoeWRyYXRpbmdcbiAgICAgIHRydWUgLy8gcmVtb3ZlT25seSAoIWltcG9ydGFudCwgYXZvaWRzIHVubmVjZXNzYXJ5IG1vdmVzKVxuICAgICk7XG4gICAgdGhpcy5fdm5vZGUgPSB0aGlzLmtlcHQ7XG4gIH0sXG5cbiAgdXBkYXRlZDogZnVuY3Rpb24gdXBkYXRlZCAoKSB7XG4gICAgdmFyIGNoaWxkcmVuID0gdGhpcy5wcmV2Q2hpbGRyZW47XG4gICAgdmFyIG1vdmVDbGFzcyA9IHRoaXMubW92ZUNsYXNzIHx8ICgodGhpcy5uYW1lIHx8ICd2JykgKyAnLW1vdmUnKTtcbiAgICBpZiAoIWNoaWxkcmVuLmxlbmd0aCB8fCAhdGhpcy5oYXNNb3ZlKGNoaWxkcmVuWzBdLmVsbSwgbW92ZUNsYXNzKSkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuXG4gICAgLy8gd2UgZGl2aWRlIHRoZSB3b3JrIGludG8gdGhyZWUgbG9vcHMgdG8gYXZvaWQgbWl4aW5nIERPTSByZWFkcyBhbmQgd3JpdGVzXG4gICAgLy8gaW4gZWFjaCBpdGVyYXRpb24gLSB3aGljaCBoZWxwcyBwcmV2ZW50IGxheW91dCB0aHJhc2hpbmcuXG4gICAgY2hpbGRyZW4uZm9yRWFjaChjYWxsUGVuZGluZ0Nicyk7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChyZWNvcmRQb3NpdGlvbik7XG4gICAgY2hpbGRyZW4uZm9yRWFjaChhcHBseVRyYW5zbGF0aW9uKTtcblxuICAgIC8vIGZvcmNlIHJlZmxvdyB0byBwdXQgZXZlcnl0aGluZyBpbiBwb3NpdGlvblxuICAgIC8vIGFzc2lnbiB0byB0aGlzIHRvIGF2b2lkIGJlaW5nIHJlbW92ZWQgaW4gdHJlZS1zaGFraW5nXG4gICAgLy8gJGZsb3ctZGlzYWJsZS1saW5lXG4gICAgdGhpcy5fcmVmbG93ID0gZG9jdW1lbnQuYm9keS5vZmZzZXRIZWlnaHQ7XG5cbiAgICBjaGlsZHJlbi5mb3JFYWNoKGZ1bmN0aW9uIChjKSB7XG4gICAgICBpZiAoYy5kYXRhLm1vdmVkKSB7XG4gICAgICAgIHZhciBlbCA9IGMuZWxtO1xuICAgICAgICB2YXIgcyA9IGVsLnN0eWxlO1xuICAgICAgICBhZGRUcmFuc2l0aW9uQ2xhc3MoZWwsIG1vdmVDbGFzcyk7XG4gICAgICAgIHMudHJhbnNmb3JtID0gcy5XZWJraXRUcmFuc2Zvcm0gPSBzLnRyYW5zaXRpb25EdXJhdGlvbiA9ICcnO1xuICAgICAgICBlbC5hZGRFdmVudExpc3RlbmVyKHRyYW5zaXRpb25FbmRFdmVudCwgZWwuX21vdmVDYiA9IGZ1bmN0aW9uIGNiIChlKSB7XG4gICAgICAgICAgaWYgKCFlIHx8IC90cmFuc2Zvcm0kLy50ZXN0KGUucHJvcGVydHlOYW1lKSkge1xuICAgICAgICAgICAgZWwucmVtb3ZlRXZlbnRMaXN0ZW5lcih0cmFuc2l0aW9uRW5kRXZlbnQsIGNiKTtcbiAgICAgICAgICAgIGVsLl9tb3ZlQ2IgPSBudWxsO1xuICAgICAgICAgICAgcmVtb3ZlVHJhbnNpdGlvbkNsYXNzKGVsLCBtb3ZlQ2xhc3MpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH0sXG5cbiAgbWV0aG9kczoge1xuICAgIGhhc01vdmU6IGZ1bmN0aW9uIGhhc01vdmUgKGVsLCBtb3ZlQ2xhc3MpIHtcbiAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgaWYgKCFoYXNUcmFuc2l0aW9uKSB7XG4gICAgICAgIHJldHVybiBmYWxzZVxuICAgICAgfVxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAodGhpcy5faGFzTW92ZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5faGFzTW92ZVxuICAgICAgfVxuICAgICAgLy8gRGV0ZWN0IHdoZXRoZXIgYW4gZWxlbWVudCB3aXRoIHRoZSBtb3ZlIGNsYXNzIGFwcGxpZWQgaGFzXG4gICAgICAvLyBDU1MgdHJhbnNpdGlvbnMuIFNpbmNlIHRoZSBlbGVtZW50IG1heSBiZSBpbnNpZGUgYW4gZW50ZXJpbmdcbiAgICAgIC8vIHRyYW5zaXRpb24gYXQgdGhpcyB2ZXJ5IG1vbWVudCwgd2UgbWFrZSBhIGNsb25lIG9mIGl0IGFuZCByZW1vdmVcbiAgICAgIC8vIGFsbCBvdGhlciB0cmFuc2l0aW9uIGNsYXNzZXMgYXBwbGllZCB0byBlbnN1cmUgb25seSB0aGUgbW92ZSBjbGFzc1xuICAgICAgLy8gaXMgYXBwbGllZC5cbiAgICAgIHZhciBjbG9uZSA9IGVsLmNsb25lTm9kZSgpO1xuICAgICAgaWYgKGVsLl90cmFuc2l0aW9uQ2xhc3Nlcykge1xuICAgICAgICBlbC5fdHJhbnNpdGlvbkNsYXNzZXMuZm9yRWFjaChmdW5jdGlvbiAoY2xzKSB7IHJlbW92ZUNsYXNzKGNsb25lLCBjbHMpOyB9KTtcbiAgICAgIH1cbiAgICAgIGFkZENsYXNzKGNsb25lLCBtb3ZlQ2xhc3MpO1xuICAgICAgY2xvbmUuc3R5bGUuZGlzcGxheSA9ICdub25lJztcbiAgICAgIHRoaXMuJGVsLmFwcGVuZENoaWxkKGNsb25lKTtcbiAgICAgIHZhciBpbmZvID0gZ2V0VHJhbnNpdGlvbkluZm8oY2xvbmUpO1xuICAgICAgdGhpcy4kZWwucmVtb3ZlQ2hpbGQoY2xvbmUpO1xuICAgICAgcmV0dXJuICh0aGlzLl9oYXNNb3ZlID0gaW5mby5oYXNUcmFuc2Zvcm0pXG4gICAgfVxuICB9XG59O1xuXG5mdW5jdGlvbiBjYWxsUGVuZGluZ0NicyAoYykge1xuICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgaWYgKGMuZWxtLl9tb3ZlQ2IpIHtcbiAgICBjLmVsbS5fbW92ZUNiKCk7XG4gIH1cbiAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gIGlmIChjLmVsbS5fZW50ZXJDYikge1xuICAgIGMuZWxtLl9lbnRlckNiKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gcmVjb3JkUG9zaXRpb24gKGMpIHtcbiAgYy5kYXRhLm5ld1BvcyA9IGMuZWxtLmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xufVxuXG5mdW5jdGlvbiBhcHBseVRyYW5zbGF0aW9uIChjKSB7XG4gIHZhciBvbGRQb3MgPSBjLmRhdGEucG9zO1xuICB2YXIgbmV3UG9zID0gYy5kYXRhLm5ld1BvcztcbiAgdmFyIGR4ID0gb2xkUG9zLmxlZnQgLSBuZXdQb3MubGVmdDtcbiAgdmFyIGR5ID0gb2xkUG9zLnRvcCAtIG5ld1Bvcy50b3A7XG4gIGlmIChkeCB8fCBkeSkge1xuICAgIGMuZGF0YS5tb3ZlZCA9IHRydWU7XG4gICAgdmFyIHMgPSBjLmVsbS5zdHlsZTtcbiAgICBzLnRyYW5zZm9ybSA9IHMuV2Via2l0VHJhbnNmb3JtID0gXCJ0cmFuc2xhdGUoXCIgKyBkeCArIFwicHgsXCIgKyBkeSArIFwicHgpXCI7XG4gICAgcy50cmFuc2l0aW9uRHVyYXRpb24gPSAnMHMnO1xuICB9XG59XG5cbnZhciBwbGF0Zm9ybUNvbXBvbmVudHMgPSB7XG4gIFRyYW5zaXRpb246IFRyYW5zaXRpb24sXG4gIFRyYW5zaXRpb25Hcm91cDogVHJhbnNpdGlvbkdyb3VwXG59O1xuXG4vKiAgKi9cblxuLy8gaW5zdGFsbCBwbGF0Zm9ybSBzcGVjaWZpYyB1dGlsc1xuVnVlJDMuY29uZmlnLm11c3RVc2VQcm9wID0gbXVzdFVzZVByb3A7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZFRhZyA9IGlzUmVzZXJ2ZWRUYWc7XG5WdWUkMy5jb25maWcuaXNSZXNlcnZlZEF0dHIgPSBpc1Jlc2VydmVkQXR0cjtcblZ1ZSQzLmNvbmZpZy5nZXRUYWdOYW1lc3BhY2UgPSBnZXRUYWdOYW1lc3BhY2U7XG5WdWUkMy5jb25maWcuaXNVbmtub3duRWxlbWVudCA9IGlzVW5rbm93bkVsZW1lbnQ7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcnVudGltZSBkaXJlY3RpdmVzICYgY29tcG9uZW50c1xuZXh0ZW5kKFZ1ZSQzLm9wdGlvbnMuZGlyZWN0aXZlcywgcGxhdGZvcm1EaXJlY3RpdmVzKTtcbmV4dGVuZChWdWUkMy5vcHRpb25zLmNvbXBvbmVudHMsIHBsYXRmb3JtQ29tcG9uZW50cyk7XG5cbi8vIGluc3RhbGwgcGxhdGZvcm0gcGF0Y2ggZnVuY3Rpb25cblZ1ZSQzLnByb3RvdHlwZS5fX3BhdGNoX18gPSBpbkJyb3dzZXIgPyBwYXRjaCA6IG5vb3A7XG5cbi8vIHB1YmxpYyBtb3VudCBtZXRob2RcblZ1ZSQzLnByb3RvdHlwZS4kbW91bnQgPSBmdW5jdGlvbiAoXG4gIGVsLFxuICBoeWRyYXRpbmdcbikge1xuICBlbCA9IGVsICYmIGluQnJvd3NlciA/IHF1ZXJ5KGVsKSA6IHVuZGVmaW5lZDtcbiAgcmV0dXJuIG1vdW50Q29tcG9uZW50KHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vLyBkZXZ0b29scyBnbG9iYWwgaG9va1xuLyogaXN0YW5idWwgaWdub3JlIG5leHQgKi9cblZ1ZSQzLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgaWYgKGNvbmZpZy5kZXZ0b29scykge1xuICAgIGlmIChkZXZ0b29scykge1xuICAgICAgZGV2dG9vbHMuZW1pdCgnaW5pdCcsIFZ1ZSQzKTtcbiAgICB9IGVsc2UgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgaXNDaHJvbWUpIHtcbiAgICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgICAnRG93bmxvYWQgdGhlIFZ1ZSBEZXZ0b29scyBleHRlbnNpb24gZm9yIGEgYmV0dGVyIGRldmVsb3BtZW50IGV4cGVyaWVuY2U6XFxuJyArXG4gICAgICAgICdodHRwczovL2dpdGh1Yi5jb20vdnVlanMvdnVlLWRldnRvb2xzJ1xuICAgICAgKTtcbiAgICB9XG4gIH1cbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICBjb25maWcucHJvZHVjdGlvblRpcCAhPT0gZmFsc2UgJiZcbiAgICBpbkJyb3dzZXIgJiYgdHlwZW9mIGNvbnNvbGUgIT09ICd1bmRlZmluZWQnXG4gICkge1xuICAgIGNvbnNvbGVbY29uc29sZS5pbmZvID8gJ2luZm8nIDogJ2xvZyddKFxuICAgICAgXCJZb3UgYXJlIHJ1bm5pbmcgVnVlIGluIGRldmVsb3BtZW50IG1vZGUuXFxuXCIgK1xuICAgICAgXCJNYWtlIHN1cmUgdG8gdHVybiBvbiBwcm9kdWN0aW9uIG1vZGUgd2hlbiBkZXBsb3lpbmcgZm9yIHByb2R1Y3Rpb24uXFxuXCIgK1xuICAgICAgXCJTZWUgbW9yZSB0aXBzIGF0IGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2RlcGxveW1lbnQuaHRtbFwiXG4gICAgKTtcbiAgfVxufSwgMCk7XG5cbi8qICAqL1xuXG52YXIgZGVmYXVsdFRhZ1JFID0gL1xce1xceygoPzoufFxcbikrPylcXH1cXH0vZztcbnZhciByZWdleEVzY2FwZVJFID0gL1stLiorP14ke30oKXxbXFxdXFwvXFxcXF0vZztcblxudmFyIGJ1aWxkUmVnZXggPSBjYWNoZWQoZnVuY3Rpb24gKGRlbGltaXRlcnMpIHtcbiAgdmFyIG9wZW4gPSBkZWxpbWl0ZXJzWzBdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICB2YXIgY2xvc2UgPSBkZWxpbWl0ZXJzWzFdLnJlcGxhY2UocmVnZXhFc2NhcGVSRSwgJ1xcXFwkJicpO1xuICByZXR1cm4gbmV3IFJlZ0V4cChvcGVuICsgJygoPzoufFxcXFxuKSs/KScgKyBjbG9zZSwgJ2cnKVxufSk7XG5cbmZ1bmN0aW9uIHBhcnNlVGV4dCAoXG4gIHRleHQsXG4gIGRlbGltaXRlcnNcbikge1xuICB2YXIgdGFnUkUgPSBkZWxpbWl0ZXJzID8gYnVpbGRSZWdleChkZWxpbWl0ZXJzKSA6IGRlZmF1bHRUYWdSRTtcbiAgaWYgKCF0YWdSRS50ZXN0KHRleHQpKSB7XG4gICAgcmV0dXJuXG4gIH1cbiAgdmFyIHRva2VucyA9IFtdO1xuICB2YXIgbGFzdEluZGV4ID0gdGFnUkUubGFzdEluZGV4ID0gMDtcbiAgdmFyIG1hdGNoLCBpbmRleDtcbiAgd2hpbGUgKChtYXRjaCA9IHRhZ1JFLmV4ZWModGV4dCkpKSB7XG4gICAgaW5kZXggPSBtYXRjaC5pbmRleDtcbiAgICAvLyBwdXNoIHRleHQgdG9rZW5cbiAgICBpZiAoaW5kZXggPiBsYXN0SW5kZXgpIHtcbiAgICAgIHRva2Vucy5wdXNoKEpTT04uc3RyaW5naWZ5KHRleHQuc2xpY2UobGFzdEluZGV4LCBpbmRleCkpKTtcbiAgICB9XG4gICAgLy8gdGFnIHRva2VuXG4gICAgdmFyIGV4cCA9IHBhcnNlRmlsdGVycyhtYXRjaFsxXS50cmltKCkpO1xuICAgIHRva2Vucy5wdXNoKChcIl9zKFwiICsgZXhwICsgXCIpXCIpKTtcbiAgICBsYXN0SW5kZXggPSBpbmRleCArIG1hdGNoWzBdLmxlbmd0aDtcbiAgfVxuICBpZiAobGFzdEluZGV4IDwgdGV4dC5sZW5ndGgpIHtcbiAgICB0b2tlbnMucHVzaChKU09OLnN0cmluZ2lmeSh0ZXh0LnNsaWNlKGxhc3RJbmRleCkpKTtcbiAgfVxuICByZXR1cm4gdG9rZW5zLmpvaW4oJysnKVxufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gdHJhbnNmb3JtTm9kZSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNDbGFzcyA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdjbGFzcycpO1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0aWNDbGFzcykge1xuICAgIHZhciBleHByZXNzaW9uID0gcGFyc2VUZXh0KHN0YXRpY0NsYXNzLCBvcHRpb25zLmRlbGltaXRlcnMpO1xuICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICB3YXJuKFxuICAgICAgICBcImNsYXNzPVxcXCJcIiArIHN0YXRpY0NsYXNzICsgXCJcXFwiOiBcIiArXG4gICAgICAgICdJbnRlcnBvbGF0aW9uIGluc2lkZSBhdHRyaWJ1dGVzIGhhcyBiZWVuIHJlbW92ZWQuICcgK1xuICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBjbGFzcz1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmNsYXNzPVwidmFsXCI+LidcbiAgICAgICk7XG4gICAgfVxuICB9XG4gIGlmIChzdGF0aWNDbGFzcykge1xuICAgIGVsLnN0YXRpY0NsYXNzID0gSlNPTi5zdHJpbmdpZnkoc3RhdGljQ2xhc3MpO1xuICB9XG4gIHZhciBjbGFzc0JpbmRpbmcgPSBnZXRCaW5kaW5nQXR0cihlbCwgJ2NsYXNzJywgZmFsc2UgLyogZ2V0U3RhdGljICovKTtcbiAgaWYgKGNsYXNzQmluZGluZykge1xuICAgIGVsLmNsYXNzQmluZGluZyA9IGNsYXNzQmluZGluZztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5EYXRhIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljQ2xhc3MpIHtcbiAgICBkYXRhICs9IFwic3RhdGljQ2xhc3M6XCIgKyAoZWwuc3RhdGljQ2xhc3MpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLmNsYXNzQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJjbGFzczpcIiArIChlbC5jbGFzc0JpbmRpbmcpICsgXCIsXCI7XG4gIH1cbiAgcmV0dXJuIGRhdGFcbn1cblxudmFyIGtsYXNzJDEgPSB7XG4gIHN0YXRpY0tleXM6IFsnc3RhdGljQ2xhc3MnXSxcbiAgdHJhbnNmb3JtTm9kZTogdHJhbnNmb3JtTm9kZSxcbiAgZ2VuRGF0YTogZ2VuRGF0YVxufTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRyYW5zZm9ybU5vZGUkMSAoZWwsIG9wdGlvbnMpIHtcbiAgdmFyIHdhcm4gPSBvcHRpb25zLndhcm4gfHwgYmFzZVdhcm47XG4gIHZhciBzdGF0aWNTdHlsZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzdHlsZScpO1xuICBpZiAoc3RhdGljU3R5bGUpIHtcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgdmFyIGV4cHJlc3Npb24gPSBwYXJzZVRleHQoc3RhdGljU3R5bGUsIG9wdGlvbnMuZGVsaW1pdGVycyk7XG4gICAgICBpZiAoZXhwcmVzc2lvbikge1xuICAgICAgICB3YXJuKFxuICAgICAgICAgIFwic3R5bGU9XFxcIlwiICsgc3RhdGljU3R5bGUgKyBcIlxcXCI6IFwiICtcbiAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAnVXNlIHYtYmluZCBvciB0aGUgY29sb24gc2hvcnRoYW5kIGluc3RlYWQuIEZvciBleGFtcGxlLCAnICtcbiAgICAgICAgICAnaW5zdGVhZCBvZiA8ZGl2IHN0eWxlPVwie3sgdmFsIH19XCI+LCB1c2UgPGRpdiA6c3R5bGU9XCJ2YWxcIj4uJ1xuICAgICAgICApO1xuICAgICAgfVxuICAgIH1cbiAgICBlbC5zdGF0aWNTdHlsZSA9IEpTT04uc3RyaW5naWZ5KHBhcnNlU3R5bGVUZXh0KHN0YXRpY1N0eWxlKSk7XG4gIH1cblxuICB2YXIgc3R5bGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzdHlsZScsIGZhbHNlIC8qIGdldFN0YXRpYyAqLyk7XG4gIGlmIChzdHlsZUJpbmRpbmcpIHtcbiAgICBlbC5zdHlsZUJpbmRpbmcgPSBzdHlsZUJpbmRpbmc7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQxIChlbCkge1xuICB2YXIgZGF0YSA9ICcnO1xuICBpZiAoZWwuc3RhdGljU3R5bGUpIHtcbiAgICBkYXRhICs9IFwic3RhdGljU3R5bGU6XCIgKyAoZWwuc3RhdGljU3R5bGUpICsgXCIsXCI7XG4gIH1cbiAgaWYgKGVsLnN0eWxlQmluZGluZykge1xuICAgIGRhdGEgKz0gXCJzdHlsZTooXCIgKyAoZWwuc3R5bGVCaW5kaW5nKSArIFwiKSxcIjtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG52YXIgc3R5bGUkMSA9IHtcbiAgc3RhdGljS2V5czogWydzdGF0aWNTdHlsZSddLFxuICB0cmFuc2Zvcm1Ob2RlOiB0cmFuc2Zvcm1Ob2RlJDEsXG4gIGdlbkRhdGE6IGdlbkRhdGEkMVxufTtcblxuLyogICovXG5cbnZhciBkZWNvZGVyO1xuXG52YXIgaGUgPSB7XG4gIGRlY29kZTogZnVuY3Rpb24gZGVjb2RlIChodG1sKSB7XG4gICAgZGVjb2RlciA9IGRlY29kZXIgfHwgZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnZGl2Jyk7XG4gICAgZGVjb2Rlci5pbm5lckhUTUwgPSBodG1sO1xuICAgIHJldHVybiBkZWNvZGVyLnRleHRDb250ZW50XG4gIH1cbn07XG5cbi8qICAqL1xuXG52YXIgaXNVbmFyeVRhZyA9IG1ha2VNYXAoXG4gICdhcmVhLGJhc2UsYnIsY29sLGVtYmVkLGZyYW1lLGhyLGltZyxpbnB1dCxpc2luZGV4LGtleWdlbiwnICtcbiAgJ2xpbmssbWV0YSxwYXJhbSxzb3VyY2UsdHJhY2ssd2JyJ1xuKTtcblxuLy8gRWxlbWVudHMgdGhhdCB5b3UgY2FuLCBpbnRlbnRpb25hbGx5LCBsZWF2ZSBvcGVuXG4vLyAoYW5kIHdoaWNoIGNsb3NlIHRoZW1zZWx2ZXMpXG52YXIgY2FuQmVMZWZ0T3BlblRhZyA9IG1ha2VNYXAoXG4gICdjb2xncm91cCxkZCxkdCxsaSxvcHRpb25zLHAsdGQsdGZvb3QsdGgsdGhlYWQsdHIsc291cmNlJ1xuKTtcblxuLy8gSFRNTDUgdGFncyBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbmRpY2VzLmh0bWwjZWxlbWVudHMtM1xuLy8gUGhyYXNpbmcgQ29udGVudCBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9kb20uaHRtbCNwaHJhc2luZy1jb250ZW50XG52YXIgaXNOb25QaHJhc2luZ1RhZyA9IG1ha2VNYXAoXG4gICdhZGRyZXNzLGFydGljbGUsYXNpZGUsYmFzZSxibG9ja3F1b3RlLGJvZHksY2FwdGlvbixjb2wsY29sZ3JvdXAsZGQsJyArXG4gICdkZXRhaWxzLGRpYWxvZyxkaXYsZGwsZHQsZmllbGRzZXQsZmlnY2FwdGlvbixmaWd1cmUsZm9vdGVyLGZvcm0sJyArXG4gICdoMSxoMixoMyxoNCxoNSxoNixoZWFkLGhlYWRlcixoZ3JvdXAsaHIsaHRtbCxsZWdlbmQsbGksbWVudWl0ZW0sbWV0YSwnICtcbiAgJ29wdGdyb3VwLG9wdGlvbixwYXJhbSxycCxydCxzb3VyY2Usc3R5bGUsc3VtbWFyeSx0Ym9keSx0ZCx0Zm9vdCx0aCx0aGVhZCwnICtcbiAgJ3RpdGxlLHRyLHRyYWNrJ1xuKTtcblxuLyoqXG4gKiBOb3QgdHlwZS1jaGVja2luZyB0aGlzIGZpbGUgYmVjYXVzZSBpdCdzIG1vc3RseSB2ZW5kb3IgY29kZS5cbiAqL1xuXG4vKiFcbiAqIEhUTUwgUGFyc2VyIEJ5IEpvaG4gUmVzaWcgKGVqb2huLm9yZylcbiAqIE1vZGlmaWVkIGJ5IEp1cml5IFwia2FuZ2F4XCIgWmF5dHNldlxuICogT3JpZ2luYWwgY29kZSBieSBFcmlrIEFydmlkc3NvbiwgTW96aWxsYSBQdWJsaWMgTGljZW5zZVxuICogaHR0cDovL2VyaWsuZWFlLm5ldC9zaW1wbGVodG1scGFyc2VyL3NpbXBsZWh0bWxwYXJzZXIuanNcbiAqL1xuXG4vLyBSZWd1bGFyIEV4cHJlc3Npb25zIGZvciBwYXJzaW5nIHRhZ3MgYW5kIGF0dHJpYnV0ZXNcbnZhciBhdHRyaWJ1dGUgPSAvXlxccyooW15cXHNcIic8PlxcLz1dKykoPzpcXHMqKD0pXFxzKig/OlwiKFteXCJdKilcIit8JyhbXiddKiknK3woW15cXHNcIic9PD5gXSspKSk/Lztcbi8vIGNvdWxkIHVzZSBodHRwczovL3d3dy53My5vcmcvVFIvMTk5OS9SRUMteG1sLW5hbWVzLTE5OTkwMTE0LyNOVC1RTmFtZVxuLy8gYnV0IGZvciBWdWUgdGVtcGxhdGVzIHdlIGNhbiBlbmZvcmNlIGEgc2ltcGxlIGNoYXJzZXRcbnZhciBuY25hbWUgPSAnW2EtekEtWl9dW1xcXFx3XFxcXC1cXFxcLl0qJztcbnZhciBxbmFtZUNhcHR1cmUgPSBcIigoPzpcIiArIG5jbmFtZSArIFwiXFxcXDopP1wiICsgbmNuYW1lICsgXCIpXCI7XG52YXIgc3RhcnRUYWdPcGVuID0gbmV3IFJlZ0V4cCgoXCJePFwiICsgcW5hbWVDYXB0dXJlKSk7XG52YXIgc3RhcnRUYWdDbG9zZSA9IC9eXFxzKihcXC8/KT4vO1xudmFyIGVuZFRhZyA9IG5ldyBSZWdFeHAoKFwiXjxcXFxcL1wiICsgcW5hbWVDYXB0dXJlICsgXCJbXj5dKj5cIikpO1xudmFyIGRvY3R5cGUgPSAvXjwhRE9DVFlQRSBbXj5dKz4vaTtcbnZhciBjb21tZW50ID0gL148IS0tLztcbnZhciBjb25kaXRpb25hbENvbW1lbnQgPSAvXjwhXFxbLztcblxudmFyIElTX1JFR0VYX0NBUFRVUklOR19CUk9LRU4gPSBmYWxzZTtcbid4Jy5yZXBsYWNlKC94KC4pPy9nLCBmdW5jdGlvbiAobSwgZykge1xuICBJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOID0gZyA9PT0gJyc7XG59KTtcblxuLy8gU3BlY2lhbCBFbGVtZW50cyAoY2FuIGNvbnRhaW4gYW55dGhpbmcpXG52YXIgaXNQbGFpblRleHRFbGVtZW50ID0gbWFrZU1hcCgnc2NyaXB0LHN0eWxlLHRleHRhcmVhJywgdHJ1ZSk7XG52YXIgcmVDYWNoZSA9IHt9O1xuXG52YXIgZGVjb2RpbmdNYXAgPSB7XG4gICcmbHQ7JzogJzwnLFxuICAnJmd0Oyc6ICc+JyxcbiAgJyZxdW90Oyc6ICdcIicsXG4gICcmYW1wOyc6ICcmJyxcbiAgJyYjMTA7JzogJ1xcbicsXG4gICcmIzk7JzogJ1xcdCdcbn07XG52YXIgZW5jb2RlZEF0dHIgPSAvJig/Omx0fGd0fHF1b3R8YW1wKTsvZztcbnZhciBlbmNvZGVkQXR0cldpdGhOZXdMaW5lcyA9IC8mKD86bHR8Z3R8cXVvdHxhbXB8IzEwfCM5KTsvZztcblxuLy8gIzU5OTJcbnZhciBpc0lnbm9yZU5ld2xpbmVUYWcgPSBtYWtlTWFwKCdwcmUsdGV4dGFyZWEnLCB0cnVlKTtcbnZhciBzaG91bGRJZ25vcmVGaXJzdE5ld2xpbmUgPSBmdW5jdGlvbiAodGFnLCBodG1sKSB7IHJldHVybiB0YWcgJiYgaXNJZ25vcmVOZXdsaW5lVGFnKHRhZykgJiYgaHRtbFswXSA9PT0gJ1xcbic7IH07XG5cbmZ1bmN0aW9uIGRlY29kZUF0dHIgKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcykge1xuICB2YXIgcmUgPSBzaG91bGREZWNvZGVOZXdsaW5lcyA/IGVuY29kZWRBdHRyV2l0aE5ld0xpbmVzIDogZW5jb2RlZEF0dHI7XG4gIHJldHVybiB2YWx1ZS5yZXBsYWNlKHJlLCBmdW5jdGlvbiAobWF0Y2gpIHsgcmV0dXJuIGRlY29kaW5nTWFwW21hdGNoXTsgfSlcbn1cblxuZnVuY3Rpb24gcGFyc2VIVE1MIChodG1sLCBvcHRpb25zKSB7XG4gIHZhciBzdGFjayA9IFtdO1xuICB2YXIgZXhwZWN0SFRNTCA9IG9wdGlvbnMuZXhwZWN0SFRNTDtcbiAgdmFyIGlzVW5hcnlUYWckJDEgPSBvcHRpb25zLmlzVW5hcnlUYWcgfHwgbm87XG4gIHZhciBjYW5CZUxlZnRPcGVuVGFnJCQxID0gb3B0aW9ucy5jYW5CZUxlZnRPcGVuVGFnIHx8IG5vO1xuICB2YXIgaW5kZXggPSAwO1xuICB2YXIgbGFzdCwgbGFzdFRhZztcbiAgd2hpbGUgKGh0bWwpIHtcbiAgICBsYXN0ID0gaHRtbDtcbiAgICAvLyBNYWtlIHN1cmUgd2UncmUgbm90IGluIGEgcGxhaW50ZXh0IGNvbnRlbnQgZWxlbWVudCBsaWtlIHNjcmlwdC9zdHlsZVxuICAgIGlmICghbGFzdFRhZyB8fCAhaXNQbGFpblRleHRFbGVtZW50KGxhc3RUYWcpKSB7XG4gICAgICB2YXIgdGV4dEVuZCA9IGh0bWwuaW5kZXhPZignPCcpO1xuICAgICAgaWYgKHRleHRFbmQgPT09IDApIHtcbiAgICAgICAgLy8gQ29tbWVudDpcbiAgICAgICAgaWYgKGNvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb21tZW50RW5kID0gaHRtbC5pbmRleE9mKCctLT4nKTtcblxuICAgICAgICAgIGlmIChjb21tZW50RW5kID49IDApIHtcbiAgICAgICAgICAgIGlmIChvcHRpb25zLnNob3VsZEtlZXBDb21tZW50KSB7XG4gICAgICAgICAgICAgIG9wdGlvbnMuY29tbWVudChodG1sLnN1YnN0cmluZyg0LCBjb21tZW50RW5kKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBhZHZhbmNlKGNvbW1lbnRFbmQgKyAzKTtcbiAgICAgICAgICAgIGNvbnRpbnVlXG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gaHR0cDovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9Db25kaXRpb25hbF9jb21tZW50I0Rvd25sZXZlbC1yZXZlYWxlZF9jb25kaXRpb25hbF9jb21tZW50XG4gICAgICAgIGlmIChjb25kaXRpb25hbENvbW1lbnQudGVzdChodG1sKSkge1xuICAgICAgICAgIHZhciBjb25kaXRpb25hbEVuZCA9IGh0bWwuaW5kZXhPZignXT4nKTtcblxuICAgICAgICAgIGlmIChjb25kaXRpb25hbEVuZCA+PSAwKSB7XG4gICAgICAgICAgICBhZHZhbmNlKGNvbmRpdGlvbmFsRW5kICsgMik7XG4gICAgICAgICAgICBjb250aW51ZVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICAgIC8vIERvY3R5cGU6XG4gICAgICAgIHZhciBkb2N0eXBlTWF0Y2ggPSBodG1sLm1hdGNoKGRvY3R5cGUpO1xuICAgICAgICBpZiAoZG9jdHlwZU1hdGNoKSB7XG4gICAgICAgICAgYWR2YW5jZShkb2N0eXBlTWF0Y2hbMF0ubGVuZ3RoKTtcbiAgICAgICAgICBjb250aW51ZVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gRW5kIHRhZzpcbiAgICAgICAgdmFyIGVuZFRhZ01hdGNoID0gaHRtbC5tYXRjaChlbmRUYWcpO1xuICAgICAgICBpZiAoZW5kVGFnTWF0Y2gpIHtcbiAgICAgICAgICB2YXIgY3VySW5kZXggPSBpbmRleDtcbiAgICAgICAgICBhZHZhbmNlKGVuZFRhZ01hdGNoWzBdLmxlbmd0aCk7XG4gICAgICAgICAgcGFyc2VFbmRUYWcoZW5kVGFnTWF0Y2hbMV0sIGN1ckluZGV4LCBpbmRleCk7XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuXG4gICAgICAgIC8vIFN0YXJ0IHRhZzpcbiAgICAgICAgdmFyIHN0YXJ0VGFnTWF0Y2ggPSBwYXJzZVN0YXJ0VGFnKCk7XG4gICAgICAgIGlmIChzdGFydFRhZ01hdGNoKSB7XG4gICAgICAgICAgaGFuZGxlU3RhcnRUYWcoc3RhcnRUYWdNYXRjaCk7XG4gICAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShsYXN0VGFnLCBodG1sKSkge1xuICAgICAgICAgICAgYWR2YW5jZSgxKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgY29udGludWVcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICB2YXIgdGV4dCA9ICh2b2lkIDApLCByZXN0ID0gKHZvaWQgMCksIG5leHQgPSAodm9pZCAwKTtcbiAgICAgIGlmICh0ZXh0RW5kID49IDApIHtcbiAgICAgICAgcmVzdCA9IGh0bWwuc2xpY2UodGV4dEVuZCk7XG4gICAgICAgIHdoaWxlIChcbiAgICAgICAgICAhZW5kVGFnLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhc3RhcnRUYWdPcGVuLnRlc3QocmVzdCkgJiZcbiAgICAgICAgICAhY29tbWVudC50ZXN0KHJlc3QpICYmXG4gICAgICAgICAgIWNvbmRpdGlvbmFsQ29tbWVudC50ZXN0KHJlc3QpXG4gICAgICAgICkge1xuICAgICAgICAgIC8vIDwgaW4gcGxhaW4gdGV4dCwgYmUgZm9yZ2l2aW5nIGFuZCB0cmVhdCBpdCBhcyB0ZXh0XG4gICAgICAgICAgbmV4dCA9IHJlc3QuaW5kZXhPZignPCcsIDEpO1xuICAgICAgICAgIGlmIChuZXh0IDwgMCkgeyBicmVhayB9XG4gICAgICAgICAgdGV4dEVuZCArPSBuZXh0O1xuICAgICAgICAgIHJlc3QgPSBodG1sLnNsaWNlKHRleHRFbmQpO1xuICAgICAgICB9XG4gICAgICAgIHRleHQgPSBodG1sLnN1YnN0cmluZygwLCB0ZXh0RW5kKTtcbiAgICAgICAgYWR2YW5jZSh0ZXh0RW5kKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHRleHRFbmQgPCAwKSB7XG4gICAgICAgIHRleHQgPSBodG1sO1xuICAgICAgICBodG1sID0gJyc7XG4gICAgICB9XG5cbiAgICAgIGlmIChvcHRpb25zLmNoYXJzICYmIHRleHQpIHtcbiAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGVuZFRhZ0xlbmd0aCA9IDA7XG4gICAgICB2YXIgc3RhY2tlZFRhZyA9IGxhc3RUYWcudG9Mb3dlckNhc2UoKTtcbiAgICAgIHZhciByZVN0YWNrZWRUYWcgPSByZUNhY2hlW3N0YWNrZWRUYWddIHx8IChyZUNhY2hlW3N0YWNrZWRUYWddID0gbmV3IFJlZ0V4cCgnKFtcXFxcc1xcXFxTXSo/KSg8LycgKyBzdGFja2VkVGFnICsgJ1tePl0qPiknLCAnaScpKTtcbiAgICAgIHZhciByZXN0JDEgPSBodG1sLnJlcGxhY2UocmVTdGFja2VkVGFnLCBmdW5jdGlvbiAoYWxsLCB0ZXh0LCBlbmRUYWcpIHtcbiAgICAgICAgZW5kVGFnTGVuZ3RoID0gZW5kVGFnLmxlbmd0aDtcbiAgICAgICAgaWYgKCFpc1BsYWluVGV4dEVsZW1lbnQoc3RhY2tlZFRhZykgJiYgc3RhY2tlZFRhZyAhPT0gJ25vc2NyaXB0Jykge1xuICAgICAgICAgIHRleHQgPSB0ZXh0XG4gICAgICAgICAgICAucmVwbGFjZSgvPCEtLShbXFxzXFxTXSo/KS0tPi9nLCAnJDEnKVxuICAgICAgICAgICAgLnJlcGxhY2UoLzwhXFxbQ0RBVEFcXFsoW1xcc1xcU10qPyldXT4vZywgJyQxJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHNob3VsZElnbm9yZUZpcnN0TmV3bGluZShzdGFja2VkVGFnLCB0ZXh0KSkge1xuICAgICAgICAgIHRleHQgPSB0ZXh0LnNsaWNlKDEpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNoYXJzKSB7XG4gICAgICAgICAgb3B0aW9ucy5jaGFycyh0ZXh0KTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gJydcbiAgICAgIH0pO1xuICAgICAgaW5kZXggKz0gaHRtbC5sZW5ndGggLSByZXN0JDEubGVuZ3RoO1xuICAgICAgaHRtbCA9IHJlc3QkMTtcbiAgICAgIHBhcnNlRW5kVGFnKHN0YWNrZWRUYWcsIGluZGV4IC0gZW5kVGFnTGVuZ3RoLCBpbmRleCk7XG4gICAgfVxuXG4gICAgaWYgKGh0bWwgPT09IGxhc3QpIHtcbiAgICAgIG9wdGlvbnMuY2hhcnMgJiYgb3B0aW9ucy5jaGFycyhodG1sKTtcbiAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICFzdGFjay5sZW5ndGggJiYgb3B0aW9ucy53YXJuKSB7XG4gICAgICAgIG9wdGlvbnMud2FybigoXCJNYWwtZm9ybWF0dGVkIHRhZyBhdCBlbmQgb2YgdGVtcGxhdGU6IFxcXCJcIiArIGh0bWwgKyBcIlxcXCJcIikpO1xuICAgICAgfVxuICAgICAgYnJlYWtcbiAgICB9XG4gIH1cblxuICAvLyBDbGVhbiB1cCBhbnkgcmVtYWluaW5nIHRhZ3NcbiAgcGFyc2VFbmRUYWcoKTtcblxuICBmdW5jdGlvbiBhZHZhbmNlIChuKSB7XG4gICAgaW5kZXggKz0gbjtcbiAgICBodG1sID0gaHRtbC5zdWJzdHJpbmcobik7XG4gIH1cblxuICBmdW5jdGlvbiBwYXJzZVN0YXJ0VGFnICgpIHtcbiAgICB2YXIgc3RhcnQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnT3Blbik7XG4gICAgaWYgKHN0YXJ0KSB7XG4gICAgICB2YXIgbWF0Y2ggPSB7XG4gICAgICAgIHRhZ05hbWU6IHN0YXJ0WzFdLFxuICAgICAgICBhdHRyczogW10sXG4gICAgICAgIHN0YXJ0OiBpbmRleFxuICAgICAgfTtcbiAgICAgIGFkdmFuY2Uoc3RhcnRbMF0ubGVuZ3RoKTtcbiAgICAgIHZhciBlbmQsIGF0dHI7XG4gICAgICB3aGlsZSAoIShlbmQgPSBodG1sLm1hdGNoKHN0YXJ0VGFnQ2xvc2UpKSAmJiAoYXR0ciA9IGh0bWwubWF0Y2goYXR0cmlidXRlKSkpIHtcbiAgICAgICAgYWR2YW5jZShhdHRyWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmF0dHJzLnB1c2goYXR0cik7XG4gICAgICB9XG4gICAgICBpZiAoZW5kKSB7XG4gICAgICAgIG1hdGNoLnVuYXJ5U2xhc2ggPSBlbmRbMV07XG4gICAgICAgIGFkdmFuY2UoZW5kWzBdLmxlbmd0aCk7XG4gICAgICAgIG1hdGNoLmVuZCA9IGluZGV4O1xuICAgICAgICByZXR1cm4gbWF0Y2hcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBoYW5kbGVTdGFydFRhZyAobWF0Y2gpIHtcbiAgICB2YXIgdGFnTmFtZSA9IG1hdGNoLnRhZ05hbWU7XG4gICAgdmFyIHVuYXJ5U2xhc2ggPSBtYXRjaC51bmFyeVNsYXNoO1xuXG4gICAgaWYgKGV4cGVjdEhUTUwpIHtcbiAgICAgIGlmIChsYXN0VGFnID09PSAncCcgJiYgaXNOb25QaHJhc2luZ1RhZyh0YWdOYW1lKSkge1xuICAgICAgICBwYXJzZUVuZFRhZyhsYXN0VGFnKTtcbiAgICAgIH1cbiAgICAgIGlmIChjYW5CZUxlZnRPcGVuVGFnJCQxKHRhZ05hbWUpICYmIGxhc3RUYWcgPT09IHRhZ05hbWUpIHtcbiAgICAgICAgcGFyc2VFbmRUYWcodGFnTmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdmFyIHVuYXJ5ID0gaXNVbmFyeVRhZyQkMSh0YWdOYW1lKSB8fCAhIXVuYXJ5U2xhc2g7XG5cbiAgICB2YXIgbCA9IG1hdGNoLmF0dHJzLmxlbmd0aDtcbiAgICB2YXIgYXR0cnMgPSBuZXcgQXJyYXkobCk7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBhcmdzID0gbWF0Y2guYXR0cnNbaV07XG4gICAgICAvLyBoYWNraXNoIHdvcmsgYXJvdW5kIEZGIGJ1ZyBodHRwczovL2J1Z3ppbGxhLm1vemlsbGEub3JnL3Nob3dfYnVnLmNnaT9pZD0zNjk3NzhcbiAgICAgIGlmIChJU19SRUdFWF9DQVBUVVJJTkdfQlJPS0VOICYmIGFyZ3NbMF0uaW5kZXhPZignXCJcIicpID09PSAtMSkge1xuICAgICAgICBpZiAoYXJnc1szXSA9PT0gJycpIHsgZGVsZXRlIGFyZ3NbM107IH1cbiAgICAgICAgaWYgKGFyZ3NbNF0gPT09ICcnKSB7IGRlbGV0ZSBhcmdzWzRdOyB9XG4gICAgICAgIGlmIChhcmdzWzVdID09PSAnJykgeyBkZWxldGUgYXJnc1s1XTsgfVxuICAgICAgfVxuICAgICAgdmFyIHZhbHVlID0gYXJnc1szXSB8fCBhcmdzWzRdIHx8IGFyZ3NbNV0gfHwgJyc7XG4gICAgICB2YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSB0YWdOYW1lID09PSAnYScgJiYgYXJnc1sxXSA9PT0gJ2hyZWYnXG4gICAgICAgID8gb3B0aW9ucy5zaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWZcbiAgICAgICAgOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzO1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGFyZ3NbMV0sXG4gICAgICAgIHZhbHVlOiBkZWNvZGVBdHRyKHZhbHVlLCBzaG91bGREZWNvZGVOZXdsaW5lcylcbiAgICAgIH07XG4gICAgfVxuXG4gICAgaWYgKCF1bmFyeSkge1xuICAgICAgc3RhY2sucHVzaCh7IHRhZzogdGFnTmFtZSwgbG93ZXJDYXNlZFRhZzogdGFnTmFtZS50b0xvd2VyQ2FzZSgpLCBhdHRyczogYXR0cnMgfSk7XG4gICAgICBsYXN0VGFnID0gdGFnTmFtZTtcbiAgICB9XG5cbiAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBhdHRycywgdW5hcnksIG1hdGNoLnN0YXJ0LCBtYXRjaC5lbmQpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIHBhcnNlRW5kVGFnICh0YWdOYW1lLCBzdGFydCwgZW5kKSB7XG4gICAgdmFyIHBvcywgbG93ZXJDYXNlZFRhZ05hbWU7XG4gICAgaWYgKHN0YXJ0ID09IG51bGwpIHsgc3RhcnQgPSBpbmRleDsgfVxuICAgIGlmIChlbmQgPT0gbnVsbCkgeyBlbmQgPSBpbmRleDsgfVxuXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGxvd2VyQ2FzZWRUYWdOYW1lID0gdGFnTmFtZS50b0xvd2VyQ2FzZSgpO1xuICAgIH1cblxuICAgIC8vIEZpbmQgdGhlIGNsb3Nlc3Qgb3BlbmVkIHRhZyBvZiB0aGUgc2FtZSB0eXBlXG4gICAgaWYgKHRhZ05hbWUpIHtcbiAgICAgIGZvciAocG9zID0gc3RhY2subGVuZ3RoIC0gMTsgcG9zID49IDA7IHBvcy0tKSB7XG4gICAgICAgIGlmIChzdGFja1twb3NdLmxvd2VyQ2FzZWRUYWcgPT09IGxvd2VyQ2FzZWRUYWdOYW1lKSB7XG4gICAgICAgICAgYnJlYWtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICAvLyBJZiBubyB0YWcgbmFtZSBpcyBwcm92aWRlZCwgY2xlYW4gc2hvcFxuICAgICAgcG9zID0gMDtcbiAgICB9XG5cbiAgICBpZiAocG9zID49IDApIHtcbiAgICAgIC8vIENsb3NlIGFsbCB0aGUgb3BlbiBlbGVtZW50cywgdXAgdGhlIHN0YWNrXG4gICAgICBmb3IgKHZhciBpID0gc3RhY2subGVuZ3RoIC0gMTsgaSA+PSBwb3M7IGktLSkge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgICAgICAgIChpID4gcG9zIHx8ICF0YWdOYW1lKSAmJlxuICAgICAgICAgIG9wdGlvbnMud2FyblxuICAgICAgICApIHtcbiAgICAgICAgICBvcHRpb25zLndhcm4oXG4gICAgICAgICAgICAoXCJ0YWcgPFwiICsgKHN0YWNrW2ldLnRhZykgKyBcIj4gaGFzIG5vIG1hdGNoaW5nIGVuZCB0YWcuXCIpXG4gICAgICAgICAgKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgICBvcHRpb25zLmVuZChzdGFja1tpXS50YWcsIHN0YXJ0LCBlbmQpO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSB0aGUgb3BlbiBlbGVtZW50cyBmcm9tIHRoZSBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoID0gcG9zO1xuICAgICAgbGFzdFRhZyA9IHBvcyAmJiBzdGFja1twb3MgLSAxXS50YWc7XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ2JyJykge1xuICAgICAgaWYgKG9wdGlvbnMuc3RhcnQpIHtcbiAgICAgICAgb3B0aW9ucy5zdGFydCh0YWdOYW1lLCBbXSwgdHJ1ZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChsb3dlckNhc2VkVGFnTmFtZSA9PT0gJ3AnKSB7XG4gICAgICBpZiAob3B0aW9ucy5zdGFydCkge1xuICAgICAgICBvcHRpb25zLnN0YXJ0KHRhZ05hbWUsIFtdLCBmYWxzZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgICBpZiAob3B0aW9ucy5lbmQpIHtcbiAgICAgICAgb3B0aW9ucy5lbmQodGFnTmFtZSwgc3RhcnQsIGVuZCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG52YXIgb25SRSA9IC9eQHxedi1vbjovO1xudmFyIGRpclJFID0gL152LXxeQHxeOi87XG52YXIgZm9yQWxpYXNSRSA9IC8oLio/KVxccysoPzppbnxvZilcXHMrKC4qKS87XG52YXIgZm9ySXRlcmF0b3JSRSA9IC9cXCgoXFx7W159XSpcXH18W14se10qKSwoW14sXSopKD86LChbXixdKikpP1xcKS87XG52YXIgc3RyaXBQYXJlbnNSRSA9IC9eXFwofFxcKSQvZztcblxudmFyIGFyZ1JFID0gLzooLiopJC87XG52YXIgYmluZFJFID0gL146fF52LWJpbmQ6LztcbnZhciBtb2RpZmllclJFID0gL1xcLlteLl0rL2c7XG5cbnZhciBkZWNvZGVIVE1MQ2FjaGVkID0gY2FjaGVkKGhlLmRlY29kZSk7XG5cbi8vIGNvbmZpZ3VyYWJsZSBzdGF0ZVxudmFyIHdhcm4kMjtcbnZhciBkZWxpbWl0ZXJzO1xudmFyIHRyYW5zZm9ybXM7XG52YXIgcHJlVHJhbnNmb3JtcztcbnZhciBwb3N0VHJhbnNmb3JtcztcbnZhciBwbGF0Zm9ybUlzUHJlVGFnO1xudmFyIHBsYXRmb3JtTXVzdFVzZVByb3A7XG52YXIgcGxhdGZvcm1HZXRUYWdOYW1lc3BhY2U7XG5cblxuXG5mdW5jdGlvbiBjcmVhdGVBU1RFbGVtZW50IChcbiAgdGFnLFxuICBhdHRycyxcbiAgcGFyZW50XG4pIHtcbiAgcmV0dXJuIHtcbiAgICB0eXBlOiAxLFxuICAgIHRhZzogdGFnLFxuICAgIGF0dHJzTGlzdDogYXR0cnMsXG4gICAgYXR0cnNNYXA6IG1ha2VBdHRyc01hcChhdHRycyksXG4gICAgcGFyZW50OiBwYXJlbnQsXG4gICAgY2hpbGRyZW46IFtdXG4gIH1cbn1cblxuLyoqXG4gKiBDb252ZXJ0IEhUTUwgc3RyaW5nIHRvIEFTVC5cbiAqL1xuZnVuY3Rpb24gcGFyc2UgKFxuICB0ZW1wbGF0ZSxcbiAgb3B0aW9uc1xuKSB7XG4gIHdhcm4kMiA9IG9wdGlvbnMud2FybiB8fCBiYXNlV2FybjtcblxuICBwbGF0Zm9ybUlzUHJlVGFnID0gb3B0aW9ucy5pc1ByZVRhZyB8fCBubztcbiAgcGxhdGZvcm1NdXN0VXNlUHJvcCA9IG9wdGlvbnMubXVzdFVzZVByb3AgfHwgbm87XG4gIHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlID0gb3B0aW9ucy5nZXRUYWdOYW1lc3BhY2UgfHwgbm87XG5cbiAgdHJhbnNmb3JtcyA9IHBsdWNrTW9kdWxlRnVuY3Rpb24ob3B0aW9ucy5tb2R1bGVzLCAndHJhbnNmb3JtTm9kZScpO1xuICBwcmVUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwcmVUcmFuc2Zvcm1Ob2RlJyk7XG4gIHBvc3RUcmFuc2Zvcm1zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdwb3N0VHJhbnNmb3JtTm9kZScpO1xuXG4gIGRlbGltaXRlcnMgPSBvcHRpb25zLmRlbGltaXRlcnM7XG5cbiAgdmFyIHN0YWNrID0gW107XG4gIHZhciBwcmVzZXJ2ZVdoaXRlc3BhY2UgPSBvcHRpb25zLnByZXNlcnZlV2hpdGVzcGFjZSAhPT0gZmFsc2U7XG4gIHZhciByb290O1xuICB2YXIgY3VycmVudFBhcmVudDtcbiAgdmFyIGluVlByZSA9IGZhbHNlO1xuICB2YXIgaW5QcmUgPSBmYWxzZTtcbiAgdmFyIHdhcm5lZCA9IGZhbHNlO1xuXG4gIGZ1bmN0aW9uIHdhcm5PbmNlIChtc2cpIHtcbiAgICBpZiAoIXdhcm5lZCkge1xuICAgICAgd2FybmVkID0gdHJ1ZTtcbiAgICAgIHdhcm4kMihtc2cpO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGVuZFByZSAoZWxlbWVudCkge1xuICAgIC8vIGNoZWNrIHByZSBzdGF0ZVxuICAgIGlmIChlbGVtZW50LnByZSkge1xuICAgICAgaW5WUHJlID0gZmFsc2U7XG4gICAgfVxuICAgIGlmIChwbGF0Zm9ybUlzUHJlVGFnKGVsZW1lbnQudGFnKSkge1xuICAgICAgaW5QcmUgPSBmYWxzZTtcbiAgICB9XG4gIH1cblxuICBwYXJzZUhUTUwodGVtcGxhdGUsIHtcbiAgICB3YXJuOiB3YXJuJDIsXG4gICAgZXhwZWN0SFRNTDogb3B0aW9ucy5leHBlY3RIVE1MLFxuICAgIGlzVW5hcnlUYWc6IG9wdGlvbnMuaXNVbmFyeVRhZyxcbiAgICBjYW5CZUxlZnRPcGVuVGFnOiBvcHRpb25zLmNhbkJlTGVmdE9wZW5UYWcsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IG9wdGlvbnMuc2hvdWxkRGVjb2RlTmV3bGluZXMsXG4gICAgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmOiBvcHRpb25zLnNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICBzaG91bGRLZWVwQ29tbWVudDogb3B0aW9ucy5jb21tZW50cyxcbiAgICBzdGFydDogZnVuY3Rpb24gc3RhcnQgKHRhZywgYXR0cnMsIHVuYXJ5KSB7XG4gICAgICAvLyBjaGVjayBuYW1lc3BhY2UuXG4gICAgICAvLyBpbmhlcml0IHBhcmVudCBucyBpZiB0aGVyZSBpcyBvbmVcbiAgICAgIHZhciBucyA9IChjdXJyZW50UGFyZW50ICYmIGN1cnJlbnRQYXJlbnQubnMpIHx8IHBsYXRmb3JtR2V0VGFnTmFtZXNwYWNlKHRhZyk7XG5cbiAgICAgIC8vIGhhbmRsZSBJRSBzdmcgYnVnXG4gICAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICAgIGlmIChpc0lFICYmIG5zID09PSAnc3ZnJykge1xuICAgICAgICBhdHRycyA9IGd1YXJkSUVTVkdCdWcoYXR0cnMpO1xuICAgICAgfVxuXG4gICAgICB2YXIgZWxlbWVudCA9IGNyZWF0ZUFTVEVsZW1lbnQodGFnLCBhdHRycywgY3VycmVudFBhcmVudCk7XG4gICAgICBpZiAobnMpIHtcbiAgICAgICAgZWxlbWVudC5ucyA9IG5zO1xuICAgICAgfVxuXG4gICAgICBpZiAoaXNGb3JiaWRkZW5UYWcoZWxlbWVudCkgJiYgIWlzU2VydmVyUmVuZGVyaW5nKCkpIHtcbiAgICAgICAgZWxlbWVudC5mb3JiaWRkZW4gPSB0cnVlO1xuICAgICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgICAnVGVtcGxhdGVzIHNob3VsZCBvbmx5IGJlIHJlc3BvbnNpYmxlIGZvciBtYXBwaW5nIHRoZSBzdGF0ZSB0byB0aGUgJyArXG4gICAgICAgICAgJ1VJLiBBdm9pZCBwbGFjaW5nIHRhZ3Mgd2l0aCBzaWRlLWVmZmVjdHMgaW4geW91ciB0ZW1wbGF0ZXMsIHN1Y2ggYXMgJyArXG4gICAgICAgICAgXCI8XCIgKyB0YWcgKyBcIj5cIiArICcsIGFzIHRoZXkgd2lsbCBub3QgYmUgcGFyc2VkLidcbiAgICAgICAgKTtcbiAgICAgIH1cblxuICAgICAgLy8gYXBwbHkgcHJlLXRyYW5zZm9ybXNcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlVHJhbnNmb3Jtcy5sZW5ndGg7IGkrKykge1xuICAgICAgICBlbGVtZW50ID0gcHJlVHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICAgICAgfVxuXG4gICAgICBpZiAoIWluVlByZSkge1xuICAgICAgICBwcm9jZXNzUHJlKGVsZW1lbnQpO1xuICAgICAgICBpZiAoZWxlbWVudC5wcmUpIHtcbiAgICAgICAgICBpblZQcmUgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBpZiAocGxhdGZvcm1Jc1ByZVRhZyhlbGVtZW50LnRhZykpIHtcbiAgICAgICAgaW5QcmUgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKGluVlByZSkge1xuICAgICAgICBwcm9jZXNzUmF3QXR0cnMoZWxlbWVudCk7XG4gICAgICB9IGVsc2UgaWYgKCFlbGVtZW50LnByb2Nlc3NlZCkge1xuICAgICAgICAvLyBzdHJ1Y3R1cmFsIGRpcmVjdGl2ZXNcbiAgICAgICAgcHJvY2Vzc0ZvcihlbGVtZW50KTtcbiAgICAgICAgcHJvY2Vzc0lmKGVsZW1lbnQpO1xuICAgICAgICBwcm9jZXNzT25jZShlbGVtZW50KTtcbiAgICAgICAgLy8gZWxlbWVudC1zY29wZSBzdHVmZlxuICAgICAgICBwcm9jZXNzRWxlbWVudChlbGVtZW50LCBvcHRpb25zKTtcbiAgICAgIH1cblxuICAgICAgZnVuY3Rpb24gY2hlY2tSb290Q29uc3RyYWludHMgKGVsKSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKGVsLnRhZyA9PT0gJ3Nsb3QnIHx8IGVsLnRhZyA9PT0gJ3RlbXBsYXRlJykge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIFwiQ2Fubm90IHVzZSA8XCIgKyAoZWwudGFnKSArIFwiPiBhcyBjb21wb25lbnQgcm9vdCBlbGVtZW50IGJlY2F1c2UgaXQgbWF5IFwiICtcbiAgICAgICAgICAgICAgJ2NvbnRhaW4gbXVsdGlwbGUgbm9kZXMuJ1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKGVsLmF0dHJzTWFwLmhhc093blByb3BlcnR5KCd2LWZvcicpKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0Nhbm5vdCB1c2Ugdi1mb3Igb24gc3RhdGVmdWwgY29tcG9uZW50IHJvb3QgZWxlbWVudCBiZWNhdXNlICcgK1xuICAgICAgICAgICAgICAnaXQgcmVuZGVycyBtdWx0aXBsZSBlbGVtZW50cy4nXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICAvLyB0cmVlIG1hbmFnZW1lbnRcbiAgICAgIGlmICghcm9vdCkge1xuICAgICAgICByb290ID0gZWxlbWVudDtcbiAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMocm9vdCk7XG4gICAgICB9IGVsc2UgaWYgKCFzdGFjay5sZW5ndGgpIHtcbiAgICAgICAgLy8gYWxsb3cgcm9vdCBlbGVtZW50cyB3aXRoIHYtaWYsIHYtZWxzZS1pZiBhbmQgdi1lbHNlXG4gICAgICAgIGlmIChyb290LmlmICYmIChlbGVtZW50LmVsc2VpZiB8fCBlbGVtZW50LmVsc2UpKSB7XG4gICAgICAgICAgY2hlY2tSb290Q29uc3RyYWludHMoZWxlbWVudCk7XG4gICAgICAgICAgYWRkSWZDb25kaXRpb24ocm9vdCwge1xuICAgICAgICAgICAgZXhwOiBlbGVtZW50LmVsc2VpZixcbiAgICAgICAgICAgIGJsb2NrOiBlbGVtZW50XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm5PbmNlKFxuICAgICAgICAgICAgXCJDb21wb25lbnQgdGVtcGxhdGUgc2hvdWxkIGNvbnRhaW4gZXhhY3RseSBvbmUgcm9vdCBlbGVtZW50LiBcIiArXG4gICAgICAgICAgICBcIklmIHlvdSBhcmUgdXNpbmcgdi1pZiBvbiBtdWx0aXBsZSBlbGVtZW50cywgXCIgK1xuICAgICAgICAgICAgXCJ1c2Ugdi1lbHNlLWlmIHRvIGNoYWluIHRoZW0gaW5zdGVhZC5cIlxuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGlmIChjdXJyZW50UGFyZW50ICYmICFlbGVtZW50LmZvcmJpZGRlbikge1xuICAgICAgICBpZiAoZWxlbWVudC5lbHNlaWYgfHwgZWxlbWVudC5lbHNlKSB7XG4gICAgICAgICAgcHJvY2Vzc0lmQ29uZGl0aW9ucyhlbGVtZW50LCBjdXJyZW50UGFyZW50KTtcbiAgICAgICAgfSBlbHNlIGlmIChlbGVtZW50LnNsb3RTY29wZSkgeyAvLyBzY29wZWQgc2xvdFxuICAgICAgICAgIGN1cnJlbnRQYXJlbnQucGxhaW4gPSBmYWxzZTtcbiAgICAgICAgICB2YXIgbmFtZSA9IGVsZW1lbnQuc2xvdFRhcmdldCB8fCAnXCJkZWZhdWx0XCInOyhjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzIHx8IChjdXJyZW50UGFyZW50LnNjb3BlZFNsb3RzID0ge30pKVtuYW1lXSA9IGVsZW1lbnQ7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY3VycmVudFBhcmVudC5jaGlsZHJlbi5wdXNoKGVsZW1lbnQpO1xuICAgICAgICAgIGVsZW1lbnQucGFyZW50ID0gY3VycmVudFBhcmVudDtcbiAgICAgICAgfVxuICAgICAgfVxuICAgICAgaWYgKCF1bmFyeSkge1xuICAgICAgICBjdXJyZW50UGFyZW50ID0gZWxlbWVudDtcbiAgICAgICAgc3RhY2sucHVzaChlbGVtZW50KTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGVuZFByZShlbGVtZW50KTtcbiAgICAgIH1cbiAgICAgIC8vIGFwcGx5IHBvc3QtdHJhbnNmb3Jtc1xuICAgICAgZm9yICh2YXIgaSQxID0gMDsgaSQxIDwgcG9zdFRyYW5zZm9ybXMubGVuZ3RoOyBpJDErKykge1xuICAgICAgICBwb3N0VHJhbnNmb3Jtc1tpJDFdKGVsZW1lbnQsIG9wdGlvbnMpO1xuICAgICAgfVxuICAgIH0sXG5cbiAgICBlbmQ6IGZ1bmN0aW9uIGVuZCAoKSB7XG4gICAgICAvLyByZW1vdmUgdHJhaWxpbmcgd2hpdGVzcGFjZVxuICAgICAgdmFyIGVsZW1lbnQgPSBzdGFja1tzdGFjay5sZW5ndGggLSAxXTtcbiAgICAgIHZhciBsYXN0Tm9kZSA9IGVsZW1lbnQuY2hpbGRyZW5bZWxlbWVudC5jaGlsZHJlbi5sZW5ndGggLSAxXTtcbiAgICAgIGlmIChsYXN0Tm9kZSAmJiBsYXN0Tm9kZS50eXBlID09PSAzICYmIGxhc3ROb2RlLnRleHQgPT09ICcgJyAmJiAhaW5QcmUpIHtcbiAgICAgICAgZWxlbWVudC5jaGlsZHJlbi5wb3AoKTtcbiAgICAgIH1cbiAgICAgIC8vIHBvcCBzdGFja1xuICAgICAgc3RhY2subGVuZ3RoIC09IDE7XG4gICAgICBjdXJyZW50UGFyZW50ID0gc3RhY2tbc3RhY2subGVuZ3RoIC0gMV07XG4gICAgICBlbmRQcmUoZWxlbWVudCk7XG4gICAgfSxcblxuICAgIGNoYXJzOiBmdW5jdGlvbiBjaGFycyAodGV4dCkge1xuICAgICAgaWYgKCFjdXJyZW50UGFyZW50KSB7XG4gICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICAgICAgaWYgKHRleHQgPT09IHRlbXBsYXRlKSB7XG4gICAgICAgICAgICB3YXJuT25jZShcbiAgICAgICAgICAgICAgJ0NvbXBvbmVudCB0ZW1wbGF0ZSByZXF1aXJlcyBhIHJvb3QgZWxlbWVudCwgcmF0aGVyIHRoYW4ganVzdCB0ZXh0LidcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfSBlbHNlIGlmICgodGV4dCA9IHRleHQudHJpbSgpKSkge1xuICAgICAgICAgICAgd2Fybk9uY2UoXG4gICAgICAgICAgICAgIChcInRleHQgXFxcIlwiICsgdGV4dCArIFwiXFxcIiBvdXRzaWRlIHJvb3QgZWxlbWVudCB3aWxsIGJlIGlnbm9yZWQuXCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm5cbiAgICAgIH1cbiAgICAgIC8vIElFIHRleHRhcmVhIHBsYWNlaG9sZGVyIGJ1Z1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAoaXNJRSAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LnRhZyA9PT0gJ3RleHRhcmVhJyAmJlxuICAgICAgICBjdXJyZW50UGFyZW50LmF0dHJzTWFwLnBsYWNlaG9sZGVyID09PSB0ZXh0XG4gICAgICApIHtcbiAgICAgICAgcmV0dXJuXG4gICAgICB9XG4gICAgICB2YXIgY2hpbGRyZW4gPSBjdXJyZW50UGFyZW50LmNoaWxkcmVuO1xuICAgICAgdGV4dCA9IGluUHJlIHx8IHRleHQudHJpbSgpXG4gICAgICAgID8gaXNUZXh0VGFnKGN1cnJlbnRQYXJlbnQpID8gdGV4dCA6IGRlY29kZUhUTUxDYWNoZWQodGV4dClcbiAgICAgICAgLy8gb25seSBwcmVzZXJ2ZSB3aGl0ZXNwYWNlIGlmIGl0cyBub3QgcmlnaHQgYWZ0ZXIgYSBzdGFydGluZyB0YWdcbiAgICAgICAgOiBwcmVzZXJ2ZVdoaXRlc3BhY2UgJiYgY2hpbGRyZW4ubGVuZ3RoID8gJyAnIDogJyc7XG4gICAgICBpZiAodGV4dCkge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbjtcbiAgICAgICAgaWYgKCFpblZQcmUgJiYgdGV4dCAhPT0gJyAnICYmIChleHByZXNzaW9uID0gcGFyc2VUZXh0KHRleHQsIGRlbGltaXRlcnMpKSkge1xuICAgICAgICAgIGNoaWxkcmVuLnB1c2goe1xuICAgICAgICAgICAgdHlwZTogMixcbiAgICAgICAgICAgIGV4cHJlc3Npb246IGV4cHJlc3Npb24sXG4gICAgICAgICAgICB0ZXh0OiB0ZXh0XG4gICAgICAgICAgfSk7XG4gICAgICAgIH0gZWxzZSBpZiAodGV4dCAhPT0gJyAnIHx8ICFjaGlsZHJlbi5sZW5ndGggfHwgY2hpbGRyZW5bY2hpbGRyZW4ubGVuZ3RoIC0gMV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgICAgY2hpbGRyZW4ucHVzaCh7XG4gICAgICAgICAgICB0eXBlOiAzLFxuICAgICAgICAgICAgdGV4dDogdGV4dFxuICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSxcbiAgICBjb21tZW50OiBmdW5jdGlvbiBjb21tZW50ICh0ZXh0KSB7XG4gICAgICBjdXJyZW50UGFyZW50LmNoaWxkcmVuLnB1c2goe1xuICAgICAgICB0eXBlOiAzLFxuICAgICAgICB0ZXh0OiB0ZXh0LFxuICAgICAgICBpc0NvbW1lbnQ6IHRydWVcbiAgICAgIH0pO1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiByb290XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NQcmUgKGVsKSB7XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1wcmUnKSAhPSBudWxsKSB7XG4gICAgZWwucHJlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmF3QXR0cnMgKGVsKSB7XG4gIHZhciBsID0gZWwuYXR0cnNMaXN0Lmxlbmd0aDtcbiAgaWYgKGwpIHtcbiAgICB2YXIgYXR0cnMgPSBlbC5hdHRycyA9IG5ldyBBcnJheShsKTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGw7IGkrKykge1xuICAgICAgYXR0cnNbaV0gPSB7XG4gICAgICAgIG5hbWU6IGVsLmF0dHJzTGlzdFtpXS5uYW1lLFxuICAgICAgICB2YWx1ZTogSlNPTi5zdHJpbmdpZnkoZWwuYXR0cnNMaXN0W2ldLnZhbHVlKVxuICAgICAgfTtcbiAgICB9XG4gIH0gZWxzZSBpZiAoIWVsLnByZSkge1xuICAgIC8vIG5vbiByb290IG5vZGUgaW4gcHJlIGJsb2NrcyB3aXRoIG5vIGF0dHJpYnV0ZXNcbiAgICBlbC5wbGFpbiA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0VsZW1lbnQgKGVsZW1lbnQsIG9wdGlvbnMpIHtcbiAgcHJvY2Vzc0tleShlbGVtZW50KTtcblxuICAvLyBkZXRlcm1pbmUgd2hldGhlciB0aGlzIGlzIGEgcGxhaW4gZWxlbWVudCBhZnRlclxuICAvLyByZW1vdmluZyBzdHJ1Y3R1cmFsIGF0dHJpYnV0ZXNcbiAgZWxlbWVudC5wbGFpbiA9ICFlbGVtZW50LmtleSAmJiAhZWxlbWVudC5hdHRyc0xpc3QubGVuZ3RoO1xuXG4gIHByb2Nlc3NSZWYoZWxlbWVudCk7XG4gIHByb2Nlc3NTbG90KGVsZW1lbnQpO1xuICBwcm9jZXNzQ29tcG9uZW50KGVsZW1lbnQpO1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICBlbGVtZW50ID0gdHJhbnNmb3Jtc1tpXShlbGVtZW50LCBvcHRpb25zKSB8fCBlbGVtZW50O1xuICB9XG4gIHByb2Nlc3NBdHRycyhlbGVtZW50KTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0tleSAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEJpbmRpbmdBdHRyKGVsLCAna2V5Jyk7XG4gIGlmIChleHApIHtcbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHdhcm4kMihcIjx0ZW1wbGF0ZT4gY2Fubm90IGJlIGtleWVkLiBQbGFjZSB0aGUga2V5IG9uIHJlYWwgZWxlbWVudHMgaW5zdGVhZC5cIik7XG4gICAgfVxuICAgIGVsLmtleSA9IGV4cDtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzUmVmIChlbCkge1xuICB2YXIgcmVmID0gZ2V0QmluZGluZ0F0dHIoZWwsICdyZWYnKTtcbiAgaWYgKHJlZikge1xuICAgIGVsLnJlZiA9IHJlZjtcbiAgICBlbC5yZWZJbkZvciA9IGNoZWNrSW5Gb3IoZWwpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NGb3IgKGVsKSB7XG4gIHZhciBleHA7XG4gIGlmICgoZXhwID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZm9yJykpKSB7XG4gICAgdmFyIGluTWF0Y2ggPSBleHAubWF0Y2goZm9yQWxpYXNSRSk7XG4gICAgaWYgKCFpbk1hdGNoKSB7XG4gICAgICBwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmIHdhcm4kMihcbiAgICAgICAgKFwiSW52YWxpZCB2LWZvciBleHByZXNzaW9uOiBcIiArIGV4cClcbiAgICAgICk7XG4gICAgICByZXR1cm5cbiAgICB9XG4gICAgZWwuZm9yID0gaW5NYXRjaFsyXS50cmltKCk7XG4gICAgdmFyIGFsaWFzID0gaW5NYXRjaFsxXS50cmltKCk7XG4gICAgdmFyIGl0ZXJhdG9yTWF0Y2ggPSBhbGlhcy5tYXRjaChmb3JJdGVyYXRvclJFKTtcbiAgICBpZiAoaXRlcmF0b3JNYXRjaCkge1xuICAgICAgZWwuYWxpYXMgPSBpdGVyYXRvck1hdGNoWzFdLnRyaW0oKTtcbiAgICAgIGVsLml0ZXJhdG9yMSA9IGl0ZXJhdG9yTWF0Y2hbMl0udHJpbSgpO1xuICAgICAgaWYgKGl0ZXJhdG9yTWF0Y2hbM10pIHtcbiAgICAgICAgZWwuaXRlcmF0b3IyID0gaXRlcmF0b3JNYXRjaFszXS50cmltKCk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIGVsLmFsaWFzID0gYWxpYXMucmVwbGFjZShzdHJpcFBhcmVuc1JFLCAnJyk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHByb2Nlc3NJZiAoZWwpIHtcbiAgdmFyIGV4cCA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICd2LWlmJyk7XG4gIGlmIChleHApIHtcbiAgICBlbC5pZiA9IGV4cDtcbiAgICBhZGRJZkNvbmRpdGlvbihlbCwge1xuICAgICAgZXhwOiBleHAsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIHtcbiAgICBpZiAoZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZScpICE9IG51bGwpIHtcbiAgICAgIGVsLmVsc2UgPSB0cnVlO1xuICAgIH1cbiAgICB2YXIgZWxzZWlmID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3YtZWxzZS1pZicpO1xuICAgIGlmIChlbHNlaWYpIHtcbiAgICAgIGVsLmVsc2VpZiA9IGVsc2VpZjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0lmQ29uZGl0aW9ucyAoZWwsIHBhcmVudCkge1xuICB2YXIgcHJldiA9IGZpbmRQcmV2RWxlbWVudChwYXJlbnQuY2hpbGRyZW4pO1xuICBpZiAocHJldiAmJiBwcmV2LmlmKSB7XG4gICAgYWRkSWZDb25kaXRpb24ocHJldiwge1xuICAgICAgZXhwOiBlbC5lbHNlaWYsXG4gICAgICBibG9jazogZWxcbiAgICB9KTtcbiAgfSBlbHNlIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgd2FybiQyKFxuICAgICAgXCJ2LVwiICsgKGVsLmVsc2VpZiA/ICgnZWxzZS1pZj1cIicgKyBlbC5lbHNlaWYgKyAnXCInKSA6ICdlbHNlJykgKyBcIiBcIiArXG4gICAgICBcInVzZWQgb24gZWxlbWVudCA8XCIgKyAoZWwudGFnKSArIFwiPiB3aXRob3V0IGNvcnJlc3BvbmRpbmcgdi1pZi5cIlxuICAgICk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZmluZFByZXZFbGVtZW50IChjaGlsZHJlbikge1xuICB2YXIgaSA9IGNoaWxkcmVuLmxlbmd0aDtcbiAgd2hpbGUgKGktLSkge1xuICAgIGlmIChjaGlsZHJlbltpXS50eXBlID09PSAxKSB7XG4gICAgICByZXR1cm4gY2hpbGRyZW5baV1cbiAgICB9IGVsc2Uge1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgY2hpbGRyZW5baV0udGV4dCAhPT0gJyAnKSB7XG4gICAgICAgIHdhcm4kMihcbiAgICAgICAgICBcInRleHQgXFxcIlwiICsgKGNoaWxkcmVuW2ldLnRleHQudHJpbSgpKSArIFwiXFxcIiBiZXR3ZWVuIHYtaWYgYW5kIHYtZWxzZSgtaWYpIFwiICtcbiAgICAgICAgICBcIndpbGwgYmUgaWdub3JlZC5cIlxuICAgICAgICApO1xuICAgICAgfVxuICAgICAgY2hpbGRyZW4ucG9wKCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGFkZElmQ29uZGl0aW9uIChlbCwgY29uZGl0aW9uKSB7XG4gIGlmICghZWwuaWZDb25kaXRpb25zKSB7XG4gICAgZWwuaWZDb25kaXRpb25zID0gW107XG4gIH1cbiAgZWwuaWZDb25kaXRpb25zLnB1c2goY29uZGl0aW9uKTtcbn1cblxuZnVuY3Rpb24gcHJvY2Vzc09uY2UgKGVsKSB7XG4gIHZhciBvbmNlJCQxID0gZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Ytb25jZScpO1xuICBpZiAob25jZSQkMSAhPSBudWxsKSB7XG4gICAgZWwub25jZSA9IHRydWU7XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc1Nsb3QgKGVsKSB7XG4gIGlmIChlbC50YWcgPT09ICdzbG90Jykge1xuICAgIGVsLnNsb3ROYW1lID0gZ2V0QmluZGluZ0F0dHIoZWwsICduYW1lJyk7XG4gICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgZWwua2V5KSB7XG4gICAgICB3YXJuJDIoXG4gICAgICAgIFwiYGtleWAgZG9lcyBub3Qgd29yayBvbiA8c2xvdD4gYmVjYXVzZSBzbG90cyBhcmUgYWJzdHJhY3Qgb3V0bGV0cyBcIiArXG4gICAgICAgIFwiYW5kIGNhbiBwb3NzaWJseSBleHBhbmQgaW50byBtdWx0aXBsZSBlbGVtZW50cy4gXCIgK1xuICAgICAgICBcIlVzZSB0aGUga2V5IG9uIGEgd3JhcHBpbmcgZWxlbWVudCBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgfSBlbHNlIHtcbiAgICB2YXIgc2xvdFNjb3BlO1xuICAgIGlmIChlbC50YWcgPT09ICd0ZW1wbGF0ZScpIHtcbiAgICAgIHNsb3RTY29wZSA9IGdldEFuZFJlbW92ZUF0dHIoZWwsICdzY29wZScpO1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzbG90U2NvcGUpIHtcbiAgICAgICAgd2FybiQyKFxuICAgICAgICAgIFwidGhlIFxcXCJzY29wZVxcXCIgYXR0cmlidXRlIGZvciBzY29wZWQgc2xvdHMgaGF2ZSBiZWVuIGRlcHJlY2F0ZWQgYW5kIFwiICtcbiAgICAgICAgICBcInJlcGxhY2VkIGJ5IFxcXCJzbG90LXNjb3BlXFxcIiBzaW5jZSAyLjUuIFRoZSBuZXcgXFxcInNsb3Qtc2NvcGVcXFwiIGF0dHJpYnV0ZSBcIiArXG4gICAgICAgICAgXCJjYW4gYWxzbyBiZSB1c2VkIG9uIHBsYWluIGVsZW1lbnRzIGluIGFkZGl0aW9uIHRvIDx0ZW1wbGF0ZT4gdG8gXCIgK1xuICAgICAgICAgIFwiZGVub3RlIHNjb3BlZCBzbG90cy5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGUgfHwgZ2V0QW5kUmVtb3ZlQXR0cihlbCwgJ3Nsb3Qtc2NvcGUnKTtcbiAgICB9IGVsc2UgaWYgKChzbG90U2NvcGUgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAnc2xvdC1zY29wZScpKSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBlbC5hdHRyc01hcFsndi1mb3InXSkge1xuICAgICAgICB3YXJuJDIoXG4gICAgICAgICAgXCJBbWJpZ3VvdXMgY29tYmluZWQgdXNhZ2Ugb2Ygc2xvdC1zY29wZSBhbmQgdi1mb3Igb24gPFwiICsgKGVsLnRhZykgKyBcIj4gXCIgK1xuICAgICAgICAgIFwiKHYtZm9yIHRha2VzIGhpZ2hlciBwcmlvcml0eSkuIFVzZSBhIHdyYXBwZXIgPHRlbXBsYXRlPiBmb3IgdGhlIFwiICtcbiAgICAgICAgICBcInNjb3BlZCBzbG90IHRvIG1ha2UgaXQgY2xlYXJlci5cIixcbiAgICAgICAgICB0cnVlXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBlbC5zbG90U2NvcGUgPSBzbG90U2NvcGU7XG4gICAgfVxuICAgIHZhciBzbG90VGFyZ2V0ID0gZ2V0QmluZGluZ0F0dHIoZWwsICdzbG90Jyk7XG4gICAgaWYgKHNsb3RUYXJnZXQpIHtcbiAgICAgIGVsLnNsb3RUYXJnZXQgPSBzbG90VGFyZ2V0ID09PSAnXCJcIicgPyAnXCJkZWZhdWx0XCInIDogc2xvdFRhcmdldDtcbiAgICAgIC8vIHByZXNlcnZlIHNsb3QgYXMgYW4gYXR0cmlidXRlIGZvciBuYXRpdmUgc2hhZG93IERPTSBjb21wYXRcbiAgICAgIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHMuXG4gICAgICBpZiAoZWwudGFnICE9PSAndGVtcGxhdGUnICYmICFlbC5zbG90U2NvcGUpIHtcbiAgICAgICAgYWRkQXR0cihlbCwgJ3Nsb3QnLCBzbG90VGFyZ2V0KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJvY2Vzc0NvbXBvbmVudCAoZWwpIHtcbiAgdmFyIGJpbmRpbmc7XG4gIGlmICgoYmluZGluZyA9IGdldEJpbmRpbmdBdHRyKGVsLCAnaXMnKSkpIHtcbiAgICBlbC5jb21wb25lbnQgPSBiaW5kaW5nO1xuICB9XG4gIGlmIChnZXRBbmRSZW1vdmVBdHRyKGVsLCAnaW5saW5lLXRlbXBsYXRlJykgIT0gbnVsbCkge1xuICAgIGVsLmlubGluZVRlbXBsYXRlID0gdHJ1ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBwcm9jZXNzQXR0cnMgKGVsKSB7XG4gIHZhciBsaXN0ID0gZWwuYXR0cnNMaXN0O1xuICB2YXIgaSwgbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIG1vZGlmaWVycywgaXNQcm9wO1xuICBmb3IgKGkgPSAwLCBsID0gbGlzdC5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICBuYW1lID0gcmF3TmFtZSA9IGxpc3RbaV0ubmFtZTtcbiAgICB2YWx1ZSA9IGxpc3RbaV0udmFsdWU7XG4gICAgaWYgKGRpclJFLnRlc3QobmFtZSkpIHtcbiAgICAgIC8vIG1hcmsgZWxlbWVudCBhcyBkeW5hbWljXG4gICAgICBlbC5oYXNCaW5kaW5ncyA9IHRydWU7XG4gICAgICAvLyBtb2RpZmllcnNcbiAgICAgIG1vZGlmaWVycyA9IHBhcnNlTW9kaWZpZXJzKG5hbWUpO1xuICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG1vZGlmaWVyUkUsICcnKTtcbiAgICAgIH1cbiAgICAgIGlmIChiaW5kUkUudGVzdChuYW1lKSkgeyAvLyB2LWJpbmRcbiAgICAgICAgbmFtZSA9IG5hbWUucmVwbGFjZShiaW5kUkUsICcnKTtcbiAgICAgICAgdmFsdWUgPSBwYXJzZUZpbHRlcnModmFsdWUpO1xuICAgICAgICBpc1Byb3AgPSBmYWxzZTtcbiAgICAgICAgaWYgKG1vZGlmaWVycykge1xuICAgICAgICAgIGlmIChtb2RpZmllcnMucHJvcCkge1xuICAgICAgICAgICAgaXNQcm9wID0gdHJ1ZTtcbiAgICAgICAgICAgIG5hbWUgPSBjYW1lbGl6ZShuYW1lKTtcbiAgICAgICAgICAgIGlmIChuYW1lID09PSAnaW5uZXJIdG1sJykgeyBuYW1lID0gJ2lubmVySFRNTCc7IH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKG1vZGlmaWVycy5jYW1lbCkge1xuICAgICAgICAgICAgbmFtZSA9IGNhbWVsaXplKG5hbWUpO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAobW9kaWZpZXJzLnN5bmMpIHtcbiAgICAgICAgICAgIGFkZEhhbmRsZXIoXG4gICAgICAgICAgICAgIGVsLFxuICAgICAgICAgICAgICAoXCJ1cGRhdGU6XCIgKyAoY2FtZWxpemUobmFtZSkpKSxcbiAgICAgICAgICAgICAgZ2VuQXNzaWdubWVudENvZGUodmFsdWUsIFwiJGV2ZW50XCIpXG4gICAgICAgICAgICApO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNQcm9wIHx8IChcbiAgICAgICAgICAhZWwuY29tcG9uZW50ICYmIHBsYXRmb3JtTXVzdFVzZVByb3AoZWwudGFnLCBlbC5hdHRyc01hcC50eXBlLCBuYW1lKVxuICAgICAgICApKSB7XG4gICAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgdmFsdWUpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIGFkZEF0dHIoZWwsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChvblJFLnRlc3QobmFtZSkpIHsgLy8gdi1vblxuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKG9uUkUsICcnKTtcbiAgICAgICAgYWRkSGFuZGxlcihlbCwgbmFtZSwgdmFsdWUsIG1vZGlmaWVycywgZmFsc2UsIHdhcm4kMik7XG4gICAgICB9IGVsc2UgeyAvLyBub3JtYWwgZGlyZWN0aXZlc1xuICAgICAgICBuYW1lID0gbmFtZS5yZXBsYWNlKGRpclJFLCAnJyk7XG4gICAgICAgIC8vIHBhcnNlIGFyZ1xuICAgICAgICB2YXIgYXJnTWF0Y2ggPSBuYW1lLm1hdGNoKGFyZ1JFKTtcbiAgICAgICAgdmFyIGFyZyA9IGFyZ01hdGNoICYmIGFyZ01hdGNoWzFdO1xuICAgICAgICBpZiAoYXJnKSB7XG4gICAgICAgICAgbmFtZSA9IG5hbWUuc2xpY2UoMCwgLShhcmcubGVuZ3RoICsgMSkpO1xuICAgICAgICB9XG4gICAgICAgIGFkZERpcmVjdGl2ZShlbCwgbmFtZSwgcmF3TmFtZSwgdmFsdWUsIGFyZywgbW9kaWZpZXJzKTtcbiAgICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgbmFtZSA9PT0gJ21vZGVsJykge1xuICAgICAgICAgIGNoZWNrRm9yQWxpYXNNb2RlbChlbCwgdmFsdWUpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIGxpdGVyYWwgYXR0cmlidXRlXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICB2YXIgZXhwcmVzc2lvbiA9IHBhcnNlVGV4dCh2YWx1ZSwgZGVsaW1pdGVycyk7XG4gICAgICAgIGlmIChleHByZXNzaW9uKSB7XG4gICAgICAgICAgd2FybiQyKFxuICAgICAgICAgICAgbmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiOiBcIiArXG4gICAgICAgICAgICAnSW50ZXJwb2xhdGlvbiBpbnNpZGUgYXR0cmlidXRlcyBoYXMgYmVlbiByZW1vdmVkLiAnICtcbiAgICAgICAgICAgICdVc2Ugdi1iaW5kIG9yIHRoZSBjb2xvbiBzaG9ydGhhbmQgaW5zdGVhZC4gRm9yIGV4YW1wbGUsICcgK1xuICAgICAgICAgICAgJ2luc3RlYWQgb2YgPGRpdiBpZD1cInt7IHZhbCB9fVwiPiwgdXNlIDxkaXYgOmlkPVwidmFsXCI+LidcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICBhZGRBdHRyKGVsLCBuYW1lLCBKU09OLnN0cmluZ2lmeSh2YWx1ZSkpO1xuICAgICAgLy8gIzY4ODcgZmlyZWZveCBkb2Vzbid0IHVwZGF0ZSBtdXRlZCBzdGF0ZSBpZiBzZXQgdmlhIGF0dHJpYnV0ZVxuICAgICAgLy8gZXZlbiBpbW1lZGlhdGVseSBhZnRlciBlbGVtZW50IGNyZWF0aW9uXG4gICAgICBpZiAoIWVsLmNvbXBvbmVudCAmJlxuICAgICAgICAgIG5hbWUgPT09ICdtdXRlZCcgJiZcbiAgICAgICAgICBwbGF0Zm9ybU11c3RVc2VQcm9wKGVsLnRhZywgZWwuYXR0cnNNYXAudHlwZSwgbmFtZSkpIHtcbiAgICAgICAgYWRkUHJvcChlbCwgbmFtZSwgJ3RydWUnKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tJbkZvciAoZWwpIHtcbiAgdmFyIHBhcmVudCA9IGVsO1xuICB3aGlsZSAocGFyZW50KSB7XG4gICAgaWYgKHBhcmVudC5mb3IgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWVcbiAgICB9XG4gICAgcGFyZW50ID0gcGFyZW50LnBhcmVudDtcbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuZnVuY3Rpb24gcGFyc2VNb2RpZmllcnMgKG5hbWUpIHtcbiAgdmFyIG1hdGNoID0gbmFtZS5tYXRjaChtb2RpZmllclJFKTtcbiAgaWYgKG1hdGNoKSB7XG4gICAgdmFyIHJldCA9IHt9O1xuICAgIG1hdGNoLmZvckVhY2goZnVuY3Rpb24gKG0pIHsgcmV0W20uc2xpY2UoMSldID0gdHJ1ZTsgfSk7XG4gICAgcmV0dXJuIHJldFxuICB9XG59XG5cbmZ1bmN0aW9uIG1ha2VBdHRyc01hcCAoYXR0cnMpIHtcbiAgdmFyIG1hcCA9IHt9O1xuICBmb3IgKHZhciBpID0gMCwgbCA9IGF0dHJzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgIGlmIChcbiAgICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiZcbiAgICAgIG1hcFthdHRyc1tpXS5uYW1lXSAmJiAhaXNJRSAmJiAhaXNFZGdlXG4gICAgKSB7XG4gICAgICB3YXJuJDIoJ2R1cGxpY2F0ZSBhdHRyaWJ1dGU6ICcgKyBhdHRyc1tpXS5uYW1lKTtcbiAgICB9XG4gICAgbWFwW2F0dHJzW2ldLm5hbWVdID0gYXR0cnNbaV0udmFsdWU7XG4gIH1cbiAgcmV0dXJuIG1hcFxufVxuXG4vLyBmb3Igc2NyaXB0IChlLmcuIHR5cGU9XCJ4L3RlbXBsYXRlXCIpIG9yIHN0eWxlLCBkbyBub3QgZGVjb2RlIGNvbnRlbnRcbmZ1bmN0aW9uIGlzVGV4dFRhZyAoZWwpIHtcbiAgcmV0dXJuIGVsLnRhZyA9PT0gJ3NjcmlwdCcgfHwgZWwudGFnID09PSAnc3R5bGUnXG59XG5cbmZ1bmN0aW9uIGlzRm9yYmlkZGVuVGFnIChlbCkge1xuICByZXR1cm4gKFxuICAgIGVsLnRhZyA9PT0gJ3N0eWxlJyB8fFxuICAgIChlbC50YWcgPT09ICdzY3JpcHQnICYmIChcbiAgICAgICFlbC5hdHRyc01hcC50eXBlIHx8XG4gICAgICBlbC5hdHRyc01hcC50eXBlID09PSAndGV4dC9qYXZhc2NyaXB0J1xuICAgICkpXG4gIClcbn1cblxudmFyIGllTlNCdWcgPSAvXnhtbG5zOk5TXFxkKy87XG52YXIgaWVOU1ByZWZpeCA9IC9eTlNcXGQrOi87XG5cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICovXG5mdW5jdGlvbiBndWFyZElFU1ZHQnVnIChhdHRycykge1xuICB2YXIgcmVzID0gW107XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgYXR0cnMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgYXR0ciA9IGF0dHJzW2ldO1xuICAgIGlmICghaWVOU0J1Zy50ZXN0KGF0dHIubmFtZSkpIHtcbiAgICAgIGF0dHIubmFtZSA9IGF0dHIubmFtZS5yZXBsYWNlKGllTlNQcmVmaXgsICcnKTtcbiAgICAgIHJlcy5wdXNoKGF0dHIpO1xuICAgIH1cbiAgfVxuICByZXR1cm4gcmVzXG59XG5cbmZ1bmN0aW9uIGNoZWNrRm9yQWxpYXNNb2RlbCAoZWwsIHZhbHVlKSB7XG4gIHZhciBfZWwgPSBlbDtcbiAgd2hpbGUgKF9lbCkge1xuICAgIGlmIChfZWwuZm9yICYmIF9lbC5hbGlhcyA9PT0gdmFsdWUpIHtcbiAgICAgIHdhcm4kMihcbiAgICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtbW9kZWw9XFxcIlwiICsgdmFsdWUgKyBcIlxcXCI+OiBcIiArXG4gICAgICAgIFwiWW91IGFyZSBiaW5kaW5nIHYtbW9kZWwgZGlyZWN0bHkgdG8gYSB2LWZvciBpdGVyYXRpb24gYWxpYXMuIFwiICtcbiAgICAgICAgXCJUaGlzIHdpbGwgbm90IGJlIGFibGUgdG8gbW9kaWZ5IHRoZSB2LWZvciBzb3VyY2UgYXJyYXkgYmVjYXVzZSBcIiArXG4gICAgICAgIFwid3JpdGluZyB0byB0aGUgYWxpYXMgaXMgbGlrZSBtb2RpZnlpbmcgYSBmdW5jdGlvbiBsb2NhbCB2YXJpYWJsZS4gXCIgK1xuICAgICAgICBcIkNvbnNpZGVyIHVzaW5nIGFuIGFycmF5IG9mIG9iamVjdHMgYW5kIHVzZSB2LW1vZGVsIG9uIGFuIG9iamVjdCBwcm9wZXJ0eSBpbnN0ZWFkLlwiXG4gICAgICApO1xuICAgIH1cbiAgICBfZWwgPSBfZWwucGFyZW50O1xuICB9XG59XG5cbi8qICAqL1xuXG4vKipcbiAqIEV4cGFuZCBpbnB1dFt2LW1vZGVsXSB3aXRoIGR5YW5taWMgdHlwZSBiaW5kaW5ncyBpbnRvIHYtaWYtZWxzZSBjaGFpbnNcbiAqIFR1cm4gdGhpczpcbiAqICAgPGlucHV0IHYtbW9kZWw9XCJkYXRhW3R5cGVdXCIgOnR5cGU9XCJ0eXBlXCI+XG4gKiBpbnRvIHRoaXM6XG4gKiAgIDxpbnB1dCB2LWlmPVwidHlwZSA9PT0gJ2NoZWNrYm94J1wiIHR5cGU9XCJjaGVja2JveFwiIHYtbW9kZWw9XCJkYXRhW3R5cGVdXCI+XG4gKiAgIDxpbnB1dCB2LWVsc2UtaWY9XCJ0eXBlID09PSAncmFkaW8nXCIgdHlwZT1cInJhZGlvXCIgdi1tb2RlbD1cImRhdGFbdHlwZV1cIj5cbiAqICAgPGlucHV0IHYtZWxzZSA6dHlwZT1cInR5cGVcIiB2LW1vZGVsPVwiZGF0YVt0eXBlXVwiPlxuICovXG5cbmZ1bmN0aW9uIHByZVRyYW5zZm9ybU5vZGUgKGVsLCBvcHRpb25zKSB7XG4gIGlmIChlbC50YWcgPT09ICdpbnB1dCcpIHtcbiAgICB2YXIgbWFwID0gZWwuYXR0cnNNYXA7XG4gICAgaWYgKG1hcFsndi1tb2RlbCddICYmIChtYXBbJ3YtYmluZDp0eXBlJ10gfHwgbWFwWyc6dHlwZSddKSkge1xuICAgICAgdmFyIHR5cGVCaW5kaW5nID0gZ2V0QmluZGluZ0F0dHIoZWwsICd0eXBlJyk7XG4gICAgICB2YXIgaWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1pZicsIHRydWUpO1xuICAgICAgdmFyIGlmQ29uZGl0aW9uRXh0cmEgPSBpZkNvbmRpdGlvbiA/IChcIiYmKFwiICsgaWZDb25kaXRpb24gKyBcIilcIikgOiBcIlwiO1xuICAgICAgdmFyIGhhc0Vsc2UgPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlJywgdHJ1ZSkgIT0gbnVsbDtcbiAgICAgIHZhciBlbHNlSWZDb25kaXRpb24gPSBnZXRBbmRSZW1vdmVBdHRyKGVsLCAndi1lbHNlLWlmJywgdHJ1ZSk7XG4gICAgICAvLyAxLiBjaGVja2JveFxuICAgICAgdmFyIGJyYW5jaDAgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgLy8gcHJvY2VzcyBmb3Igb24gdGhlIG1haW4gbm9kZVxuICAgICAgcHJvY2Vzc0ZvcihicmFuY2gwKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMCwgJ3R5cGUnLCAnY2hlY2tib3gnKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDAsIG9wdGlvbnMpO1xuICAgICAgYnJhbmNoMC5wcm9jZXNzZWQgPSB0cnVlOyAvLyBwcmV2ZW50IGl0IGZyb20gZG91YmxlLXByb2Nlc3NlZFxuICAgICAgYnJhbmNoMC5pZiA9IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0nY2hlY2tib3gnXCIgKyBpZkNvbmRpdGlvbkV4dHJhO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IGJyYW5jaDAuaWYsXG4gICAgICAgIGJsb2NrOiBicmFuY2gwXG4gICAgICB9KTtcbiAgICAgIC8vIDIuIGFkZCByYWRpbyBlbHNlLWlmIGNvbmRpdGlvblxuICAgICAgdmFyIGJyYW5jaDEgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gxLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMSwgJ3R5cGUnLCAncmFkaW8nKTtcbiAgICAgIHByb2Nlc3NFbGVtZW50KGJyYW5jaDEsIG9wdGlvbnMpO1xuICAgICAgYWRkSWZDb25kaXRpb24oYnJhbmNoMCwge1xuICAgICAgICBleHA6IFwiKFwiICsgdHlwZUJpbmRpbmcgKyBcIik9PT0ncmFkaW8nXCIgKyBpZkNvbmRpdGlvbkV4dHJhLFxuICAgICAgICBibG9jazogYnJhbmNoMVxuICAgICAgfSk7XG4gICAgICAvLyAzLiBvdGhlclxuICAgICAgdmFyIGJyYW5jaDIgPSBjbG9uZUFTVEVsZW1lbnQoZWwpO1xuICAgICAgZ2V0QW5kUmVtb3ZlQXR0cihicmFuY2gyLCAndi1mb3InLCB0cnVlKTtcbiAgICAgIGFkZFJhd0F0dHIoYnJhbmNoMiwgJzp0eXBlJywgdHlwZUJpbmRpbmcpO1xuICAgICAgcHJvY2Vzc0VsZW1lbnQoYnJhbmNoMiwgb3B0aW9ucyk7XG4gICAgICBhZGRJZkNvbmRpdGlvbihicmFuY2gwLCB7XG4gICAgICAgIGV4cDogaWZDb25kaXRpb24sXG4gICAgICAgIGJsb2NrOiBicmFuY2gyXG4gICAgICB9KTtcblxuICAgICAgaWYgKGhhc0Vsc2UpIHtcbiAgICAgICAgYnJhbmNoMC5lbHNlID0gdHJ1ZTtcbiAgICAgIH0gZWxzZSBpZiAoZWxzZUlmQ29uZGl0aW9uKSB7XG4gICAgICAgIGJyYW5jaDAuZWxzZWlmID0gZWxzZUlmQ29uZGl0aW9uO1xuICAgICAgfVxuXG4gICAgICByZXR1cm4gYnJhbmNoMFxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjbG9uZUFTVEVsZW1lbnQgKGVsKSB7XG4gIHJldHVybiBjcmVhdGVBU1RFbGVtZW50KGVsLnRhZywgZWwuYXR0cnNMaXN0LnNsaWNlKCksIGVsLnBhcmVudClcbn1cblxuZnVuY3Rpb24gYWRkUmF3QXR0ciAoZWwsIG5hbWUsIHZhbHVlKSB7XG4gIGVsLmF0dHJzTWFwW25hbWVdID0gdmFsdWU7XG4gIGVsLmF0dHJzTGlzdC5wdXNoKHsgbmFtZTogbmFtZSwgdmFsdWU6IHZhbHVlIH0pO1xufVxuXG52YXIgbW9kZWwkMiA9IHtcbiAgcHJlVHJhbnNmb3JtTm9kZTogcHJlVHJhbnNmb3JtTm9kZVxufTtcblxudmFyIG1vZHVsZXMkMSA9IFtcbiAga2xhc3MkMSxcbiAgc3R5bGUkMSxcbiAgbW9kZWwkMlxuXTtcblxuLyogICovXG5cbmZ1bmN0aW9uIHRleHQgKGVsLCBkaXIpIHtcbiAgaWYgKGRpci52YWx1ZSkge1xuICAgIGFkZFByb3AoZWwsICd0ZXh0Q29udGVudCcsIChcIl9zKFwiICsgKGRpci52YWx1ZSkgKyBcIilcIikpO1xuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBodG1sIChlbCwgZGlyKSB7XG4gIGlmIChkaXIudmFsdWUpIHtcbiAgICBhZGRQcm9wKGVsLCAnaW5uZXJIVE1MJywgKFwiX3MoXCIgKyAoZGlyLnZhbHVlKSArIFwiKVwiKSk7XG4gIH1cbn1cblxudmFyIGRpcmVjdGl2ZXMkMSA9IHtcbiAgbW9kZWw6IG1vZGVsLFxuICB0ZXh0OiB0ZXh0LFxuICBodG1sOiBodG1sXG59O1xuXG4vKiAgKi9cblxudmFyIGJhc2VPcHRpb25zID0ge1xuICBleHBlY3RIVE1MOiB0cnVlLFxuICBtb2R1bGVzOiBtb2R1bGVzJDEsXG4gIGRpcmVjdGl2ZXM6IGRpcmVjdGl2ZXMkMSxcbiAgaXNQcmVUYWc6IGlzUHJlVGFnLFxuICBpc1VuYXJ5VGFnOiBpc1VuYXJ5VGFnLFxuICBtdXN0VXNlUHJvcDogbXVzdFVzZVByb3AsXG4gIGNhbkJlTGVmdE9wZW5UYWc6IGNhbkJlTGVmdE9wZW5UYWcsXG4gIGlzUmVzZXJ2ZWRUYWc6IGlzUmVzZXJ2ZWRUYWcsXG4gIGdldFRhZ05hbWVzcGFjZTogZ2V0VGFnTmFtZXNwYWNlLFxuICBzdGF0aWNLZXlzOiBnZW5TdGF0aWNLZXlzKG1vZHVsZXMkMSlcbn07XG5cbi8qICAqL1xuXG52YXIgaXNTdGF0aWNLZXk7XG52YXIgaXNQbGF0Zm9ybVJlc2VydmVkVGFnO1xuXG52YXIgZ2VuU3RhdGljS2V5c0NhY2hlZCA9IGNhY2hlZChnZW5TdGF0aWNLZXlzJDEpO1xuXG4vKipcbiAqIEdvYWwgb2YgdGhlIG9wdGltaXplcjogd2FsayB0aGUgZ2VuZXJhdGVkIHRlbXBsYXRlIEFTVCB0cmVlXG4gKiBhbmQgZGV0ZWN0IHN1Yi10cmVlcyB0aGF0IGFyZSBwdXJlbHkgc3RhdGljLCBpLmUuIHBhcnRzIG9mXG4gKiB0aGUgRE9NIHRoYXQgbmV2ZXIgbmVlZHMgdG8gY2hhbmdlLlxuICpcbiAqIE9uY2Ugd2UgZGV0ZWN0IHRoZXNlIHN1Yi10cmVlcywgd2UgY2FuOlxuICpcbiAqIDEuIEhvaXN0IHRoZW0gaW50byBjb25zdGFudHMsIHNvIHRoYXQgd2Ugbm8gbG9uZ2VyIG5lZWQgdG9cbiAqICAgIGNyZWF0ZSBmcmVzaCBub2RlcyBmb3IgdGhlbSBvbiBlYWNoIHJlLXJlbmRlcjtcbiAqIDIuIENvbXBsZXRlbHkgc2tpcCB0aGVtIGluIHRoZSBwYXRjaGluZyBwcm9jZXNzLlxuICovXG5mdW5jdGlvbiBvcHRpbWl6ZSAocm9vdCwgb3B0aW9ucykge1xuICBpZiAoIXJvb3QpIHsgcmV0dXJuIH1cbiAgaXNTdGF0aWNLZXkgPSBnZW5TdGF0aWNLZXlzQ2FjaGVkKG9wdGlvbnMuc3RhdGljS2V5cyB8fCAnJyk7XG4gIGlzUGxhdGZvcm1SZXNlcnZlZFRhZyA9IG9wdGlvbnMuaXNSZXNlcnZlZFRhZyB8fCBubztcbiAgLy8gZmlyc3QgcGFzczogbWFyayBhbGwgbm9uLXN0YXRpYyBub2Rlcy5cbiAgbWFya1N0YXRpYyQxKHJvb3QpO1xuICAvLyBzZWNvbmQgcGFzczogbWFyayBzdGF0aWMgcm9vdHMuXG4gIG1hcmtTdGF0aWNSb290cyhyb290LCBmYWxzZSk7XG59XG5cbmZ1bmN0aW9uIGdlblN0YXRpY0tleXMkMSAoa2V5cykge1xuICByZXR1cm4gbWFrZU1hcChcbiAgICAndHlwZSx0YWcsYXR0cnNMaXN0LGF0dHJzTWFwLHBsYWluLHBhcmVudCxjaGlsZHJlbixhdHRycycgK1xuICAgIChrZXlzID8gJywnICsga2V5cyA6ICcnKVxuICApXG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWMkMSAobm9kZSkge1xuICBub2RlLnN0YXRpYyA9IGlzU3RhdGljKG5vZGUpO1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgLy8gZG8gbm90IG1ha2UgY29tcG9uZW50IHNsb3QgY29udGVudCBzdGF0aWMuIHRoaXMgYXZvaWRzXG4gICAgLy8gMS4gY29tcG9uZW50cyBub3QgYWJsZSB0byBtdXRhdGUgc2xvdCBub2Rlc1xuICAgIC8vIDIuIHN0YXRpYyBzbG90IGNvbnRlbnQgZmFpbHMgZm9yIGhvdC1yZWxvYWRpbmdcbiAgICBpZiAoXG4gICAgICAhaXNQbGF0Zm9ybVJlc2VydmVkVGFnKG5vZGUudGFnKSAmJlxuICAgICAgbm9kZS50YWcgIT09ICdzbG90JyAmJlxuICAgICAgbm9kZS5hdHRyc01hcFsnaW5saW5lLXRlbXBsYXRlJ10gPT0gbnVsbFxuICAgICkge1xuICAgICAgcmV0dXJuXG4gICAgfVxuICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgIHZhciBjaGlsZCA9IG5vZGUuY2hpbGRyZW5baV07XG4gICAgICBtYXJrU3RhdGljJDEoY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5zdGF0aWMpIHtcbiAgICAgICAgbm9kZS5zdGF0aWMgPSBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKG5vZGUuaWZDb25kaXRpb25zKSB7XG4gICAgICBmb3IgKHZhciBpJDEgPSAxLCBsJDEgPSBub2RlLmlmQ29uZGl0aW9ucy5sZW5ndGg7IGkkMSA8IGwkMTsgaSQxKyspIHtcbiAgICAgICAgdmFyIGJsb2NrID0gbm9kZS5pZkNvbmRpdGlvbnNbaSQxXS5ibG9jaztcbiAgICAgICAgbWFya1N0YXRpYyQxKGJsb2NrKTtcbiAgICAgICAgaWYgKCFibG9jay5zdGF0aWMpIHtcbiAgICAgICAgICBub2RlLnN0YXRpYyA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIG1hcmtTdGF0aWNSb290cyAobm9kZSwgaXNJbkZvcikge1xuICBpZiAobm9kZS50eXBlID09PSAxKSB7XG4gICAgaWYgKG5vZGUuc3RhdGljIHx8IG5vZGUub25jZSkge1xuICAgICAgbm9kZS5zdGF0aWNJbkZvciA9IGlzSW5Gb3I7XG4gICAgfVxuICAgIC8vIEZvciBhIG5vZGUgdG8gcXVhbGlmeSBhcyBhIHN0YXRpYyByb290LCBpdCBzaG91bGQgaGF2ZSBjaGlsZHJlbiB0aGF0XG4gICAgLy8gYXJlIG5vdCBqdXN0IHN0YXRpYyB0ZXh0LiBPdGhlcndpc2UgdGhlIGNvc3Qgb2YgaG9pc3Rpbmcgb3V0IHdpbGxcbiAgICAvLyBvdXR3ZWlnaCB0aGUgYmVuZWZpdHMgYW5kIGl0J3MgYmV0dGVyIG9mZiB0byBqdXN0IGFsd2F5cyByZW5kZXIgaXQgZnJlc2guXG4gICAgaWYgKG5vZGUuc3RhdGljICYmIG5vZGUuY2hpbGRyZW4ubGVuZ3RoICYmICEoXG4gICAgICBub2RlLmNoaWxkcmVuLmxlbmd0aCA9PT0gMSAmJlxuICAgICAgbm9kZS5jaGlsZHJlblswXS50eXBlID09PSAzXG4gICAgKSkge1xuICAgICAgbm9kZS5zdGF0aWNSb290ID0gdHJ1ZTtcbiAgICAgIHJldHVyblxuICAgIH0gZWxzZSB7XG4gICAgICBub2RlLnN0YXRpY1Jvb3QgPSBmYWxzZTtcbiAgICB9XG4gICAgaWYgKG5vZGUuY2hpbGRyZW4pIHtcbiAgICAgIGZvciAodmFyIGkgPSAwLCBsID0gbm9kZS5jaGlsZHJlbi5sZW5ndGg7IGkgPCBsOyBpKyspIHtcbiAgICAgICAgbWFya1N0YXRpY1Jvb3RzKG5vZGUuY2hpbGRyZW5baV0sIGlzSW5Gb3IgfHwgISFub2RlLmZvcik7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChub2RlLmlmQ29uZGl0aW9ucykge1xuICAgICAgZm9yICh2YXIgaSQxID0gMSwgbCQxID0gbm9kZS5pZkNvbmRpdGlvbnMubGVuZ3RoOyBpJDEgPCBsJDE7IGkkMSsrKSB7XG4gICAgICAgIG1hcmtTdGF0aWNSb290cyhub2RlLmlmQ29uZGl0aW9uc1tpJDFdLmJsb2NrLCBpc0luRm9yKTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNTdGF0aWMgKG5vZGUpIHtcbiAgaWYgKG5vZGUudHlwZSA9PT0gMikgeyAvLyBleHByZXNzaW9uXG4gICAgcmV0dXJuIGZhbHNlXG4gIH1cbiAgaWYgKG5vZGUudHlwZSA9PT0gMykgeyAvLyB0ZXh0XG4gICAgcmV0dXJuIHRydWVcbiAgfVxuICByZXR1cm4gISEobm9kZS5wcmUgfHwgKFxuICAgICFub2RlLmhhc0JpbmRpbmdzICYmIC8vIG5vIGR5bmFtaWMgYmluZGluZ3NcbiAgICAhbm9kZS5pZiAmJiAhbm9kZS5mb3IgJiYgLy8gbm90IHYtaWYgb3Igdi1mb3Igb3Igdi1lbHNlXG4gICAgIWlzQnVpbHRJblRhZyhub2RlLnRhZykgJiYgLy8gbm90IGEgYnVpbHQtaW5cbiAgICBpc1BsYXRmb3JtUmVzZXJ2ZWRUYWcobm9kZS50YWcpICYmIC8vIG5vdCBhIGNvbXBvbmVudFxuICAgICFpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvcihub2RlKSAmJlxuICAgIE9iamVjdC5rZXlzKG5vZGUpLmV2ZXJ5KGlzU3RhdGljS2V5KVxuICApKVxufVxuXG5mdW5jdGlvbiBpc0RpcmVjdENoaWxkT2ZUZW1wbGF0ZUZvciAobm9kZSkge1xuICB3aGlsZSAobm9kZS5wYXJlbnQpIHtcbiAgICBub2RlID0gbm9kZS5wYXJlbnQ7XG4gICAgaWYgKG5vZGUudGFnICE9PSAndGVtcGxhdGUnKSB7XG4gICAgICByZXR1cm4gZmFsc2VcbiAgICB9XG4gICAgaWYgKG5vZGUuZm9yKSB7XG4gICAgICByZXR1cm4gdHJ1ZVxuICAgIH1cbiAgfVxuICByZXR1cm4gZmFsc2Vcbn1cblxuLyogICovXG5cbnZhciBmbkV4cFJFID0gL15cXHMqKFtcXHckX10rfFxcKFteKV0qP1xcKSlcXHMqPT58XmZ1bmN0aW9uXFxzKlxcKC87XG52YXIgc2ltcGxlUGF0aFJFID0gL15cXHMqW0EtWmEtel8kXVtcXHckXSooPzpcXC5bQS1aYS16XyRdW1xcdyRdKnxcXFsnLio/J118XFxbXCIuKj9cIl18XFxbXFxkK118XFxbW0EtWmEtel8kXVtcXHckXSpdKSpcXHMqJC87XG5cbi8vIGtleUNvZGUgYWxpYXNlc1xudmFyIGtleUNvZGVzID0ge1xuICBlc2M6IDI3LFxuICB0YWI6IDksXG4gIGVudGVyOiAxMyxcbiAgc3BhY2U6IDMyLFxuICB1cDogMzgsXG4gIGxlZnQ6IDM3LFxuICByaWdodDogMzksXG4gIGRvd246IDQwLFxuICAnZGVsZXRlJzogWzgsIDQ2XVxufTtcblxuLy8gIzQ4Njg6IG1vZGlmaWVycyB0aGF0IHByZXZlbnQgdGhlIGV4ZWN1dGlvbiBvZiB0aGUgbGlzdGVuZXJcbi8vIG5lZWQgdG8gZXhwbGljaXRseSByZXR1cm4gbnVsbCBzbyB0aGF0IHdlIGNhbiBkZXRlcm1pbmUgd2hldGhlciB0byByZW1vdmVcbi8vIHRoZSBsaXN0ZW5lciBmb3IgLm9uY2VcbnZhciBnZW5HdWFyZCA9IGZ1bmN0aW9uIChjb25kaXRpb24pIHsgcmV0dXJuIChcImlmKFwiICsgY29uZGl0aW9uICsgXCIpcmV0dXJuIG51bGw7XCIpOyB9O1xuXG52YXIgbW9kaWZpZXJDb2RlID0ge1xuICBzdG9wOiAnJGV2ZW50LnN0b3BQcm9wYWdhdGlvbigpOycsXG4gIHByZXZlbnQ6ICckZXZlbnQucHJldmVudERlZmF1bHQoKTsnLFxuICBzZWxmOiBnZW5HdWFyZChcIiRldmVudC50YXJnZXQgIT09ICRldmVudC5jdXJyZW50VGFyZ2V0XCIpLFxuICBjdHJsOiBnZW5HdWFyZChcIiEkZXZlbnQuY3RybEtleVwiKSxcbiAgc2hpZnQ6IGdlbkd1YXJkKFwiISRldmVudC5zaGlmdEtleVwiKSxcbiAgYWx0OiBnZW5HdWFyZChcIiEkZXZlbnQuYWx0S2V5XCIpLFxuICBtZXRhOiBnZW5HdWFyZChcIiEkZXZlbnQubWV0YUtleVwiKSxcbiAgbGVmdDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMFwiKSxcbiAgbWlkZGxlOiBnZW5HdWFyZChcIididXR0b24nIGluICRldmVudCAmJiAkZXZlbnQuYnV0dG9uICE9PSAxXCIpLFxuICByaWdodDogZ2VuR3VhcmQoXCInYnV0dG9uJyBpbiAkZXZlbnQgJiYgJGV2ZW50LmJ1dHRvbiAhPT0gMlwiKVxufTtcblxuZnVuY3Rpb24gZ2VuSGFuZGxlcnMgKFxuICBldmVudHMsXG4gIGlzTmF0aXZlLFxuICB3YXJuXG4pIHtcbiAgdmFyIHJlcyA9IGlzTmF0aXZlID8gJ25hdGl2ZU9uOnsnIDogJ29uOnsnO1xuICBmb3IgKHZhciBuYW1lIGluIGV2ZW50cykge1xuICAgIHJlcyArPSBcIlxcXCJcIiArIG5hbWUgKyBcIlxcXCI6XCIgKyAoZ2VuSGFuZGxlcihuYW1lLCBldmVudHNbbmFtZV0pKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpICsgJ30nXG59XG5cbmZ1bmN0aW9uIGdlbkhhbmRsZXIgKFxuICBuYW1lLFxuICBoYW5kbGVyXG4pIHtcbiAgaWYgKCFoYW5kbGVyKSB7XG4gICAgcmV0dXJuICdmdW5jdGlvbigpe30nXG4gIH1cblxuICBpZiAoQXJyYXkuaXNBcnJheShoYW5kbGVyKSkge1xuICAgIHJldHVybiAoXCJbXCIgKyAoaGFuZGxlci5tYXAoZnVuY3Rpb24gKGhhbmRsZXIpIHsgcmV0dXJuIGdlbkhhbmRsZXIobmFtZSwgaGFuZGxlcik7IH0pLmpvaW4oJywnKSkgKyBcIl1cIilcbiAgfVxuXG4gIHZhciBpc01ldGhvZFBhdGggPSBzaW1wbGVQYXRoUkUudGVzdChoYW5kbGVyLnZhbHVlKTtcbiAgdmFyIGlzRnVuY3Rpb25FeHByZXNzaW9uID0gZm5FeHBSRS50ZXN0KGhhbmRsZXIudmFsdWUpO1xuXG4gIGlmICghaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICByZXR1cm4gaXNNZXRob2RQYXRoIHx8IGlzRnVuY3Rpb25FeHByZXNzaW9uXG4gICAgICA/IGhhbmRsZXIudmFsdWVcbiAgICAgIDogKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIChoYW5kbGVyLnZhbHVlKSArIFwifVwiKSAvLyBpbmxpbmUgc3RhdGVtZW50XG4gIH0gZWxzZSB7XG4gICAgdmFyIGNvZGUgPSAnJztcbiAgICB2YXIgZ2VuTW9kaWZpZXJDb2RlID0gJyc7XG4gICAgdmFyIGtleXMgPSBbXTtcbiAgICBmb3IgKHZhciBrZXkgaW4gaGFuZGxlci5tb2RpZmllcnMpIHtcbiAgICAgIGlmIChtb2RpZmllckNvZGVba2V5XSkge1xuICAgICAgICBnZW5Nb2RpZmllckNvZGUgKz0gbW9kaWZpZXJDb2RlW2tleV07XG4gICAgICAgIC8vIGxlZnQvcmlnaHRcbiAgICAgICAgaWYgKGtleUNvZGVzW2tleV0pIHtcbiAgICAgICAgICBrZXlzLnB1c2goa2V5KTtcbiAgICAgICAgfVxuICAgICAgfSBlbHNlIGlmIChrZXkgPT09ICdleGFjdCcpIHtcbiAgICAgICAgdmFyIG1vZGlmaWVycyA9IChoYW5kbGVyLm1vZGlmaWVycyk7XG4gICAgICAgIGdlbk1vZGlmaWVyQ29kZSArPSBnZW5HdWFyZChcbiAgICAgICAgICBbJ2N0cmwnLCAnc2hpZnQnLCAnYWx0JywgJ21ldGEnXVxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuICFtb2RpZmllcnNba2V5TW9kaWZpZXJdOyB9KVxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoa2V5TW9kaWZpZXIpIHsgcmV0dXJuIChcIiRldmVudC5cIiArIGtleU1vZGlmaWVyICsgXCJLZXlcIik7IH0pXG4gICAgICAgICAgICAuam9pbignfHwnKVxuICAgICAgICApO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAga2V5cy5wdXNoKGtleSk7XG4gICAgICB9XG4gICAgfVxuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgY29kZSArPSBnZW5LZXlGaWx0ZXIoa2V5cyk7XG4gICAgfVxuICAgIC8vIE1ha2Ugc3VyZSBtb2RpZmllcnMgbGlrZSBwcmV2ZW50IGFuZCBzdG9wIGdldCBleGVjdXRlZCBhZnRlciBrZXkgZmlsdGVyaW5nXG4gICAgaWYgKGdlbk1vZGlmaWVyQ29kZSkge1xuICAgICAgY29kZSArPSBnZW5Nb2RpZmllckNvZGU7XG4gICAgfVxuICAgIHZhciBoYW5kbGVyQ29kZSA9IGlzTWV0aG9kUGF0aFxuICAgICAgPyBoYW5kbGVyLnZhbHVlICsgJygkZXZlbnQpJ1xuICAgICAgOiBpc0Z1bmN0aW9uRXhwcmVzc2lvblxuICAgICAgICA/IChcIihcIiArIChoYW5kbGVyLnZhbHVlKSArIFwiKSgkZXZlbnQpXCIpXG4gICAgICAgIDogaGFuZGxlci52YWx1ZTtcbiAgICByZXR1cm4gKFwiZnVuY3Rpb24oJGV2ZW50KXtcIiArIGNvZGUgKyBoYW5kbGVyQ29kZSArIFwifVwiKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbktleUZpbHRlciAoa2V5cykge1xuICByZXR1cm4gKFwiaWYoISgnYnV0dG9uJyBpbiAkZXZlbnQpJiZcIiArIChrZXlzLm1hcChnZW5GaWx0ZXJDb2RlKS5qb2luKCcmJicpKSArIFwiKXJldHVybiBudWxsO1wiKVxufVxuXG5mdW5jdGlvbiBnZW5GaWx0ZXJDb2RlIChrZXkpIHtcbiAgdmFyIGtleVZhbCA9IHBhcnNlSW50KGtleSwgMTApO1xuICBpZiAoa2V5VmFsKSB7XG4gICAgcmV0dXJuIChcIiRldmVudC5rZXlDb2RlIT09XCIgKyBrZXlWYWwpXG4gIH1cbiAgdmFyIGNvZGUgPSBrZXlDb2Rlc1trZXldO1xuICByZXR1cm4gKFxuICAgIFwiX2soJGV2ZW50LmtleUNvZGUsXCIgK1xuICAgIChKU09OLnN0cmluZ2lmeShrZXkpKSArIFwiLFwiICtcbiAgICAoSlNPTi5zdHJpbmdpZnkoY29kZSkpICsgXCIsXCIgK1xuICAgIFwiJGV2ZW50LmtleSlcIlxuICApXG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBvbiAoZWwsIGRpcikge1xuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBkaXIubW9kaWZpZXJzKSB7XG4gICAgd2FybihcInYtb24gd2l0aG91dCBhcmd1bWVudCBkb2VzIG5vdCBzdXBwb3J0IG1vZGlmaWVycy5cIik7XG4gIH1cbiAgZWwud3JhcExpc3RlbmVycyA9IGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJfZyhcIiArIGNvZGUgKyBcIixcIiArIChkaXIudmFsdWUpICsgXCIpXCIpOyB9O1xufVxuXG4vKiAgKi9cblxuZnVuY3Rpb24gYmluZCQxIChlbCwgZGlyKSB7XG4gIGVsLndyYXBEYXRhID0gZnVuY3Rpb24gKGNvZGUpIHtcbiAgICByZXR1cm4gKFwiX2IoXCIgKyBjb2RlICsgXCIsJ1wiICsgKGVsLnRhZykgKyBcIicsXCIgKyAoZGlyLnZhbHVlKSArIFwiLFwiICsgKGRpci5tb2RpZmllcnMgJiYgZGlyLm1vZGlmaWVycy5wcm9wID8gJ3RydWUnIDogJ2ZhbHNlJykgKyAoZGlyLm1vZGlmaWVycyAmJiBkaXIubW9kaWZpZXJzLnN5bmMgPyAnLHRydWUnIDogJycpICsgXCIpXCIpXG4gIH07XG59XG5cbi8qICAqL1xuXG52YXIgYmFzZURpcmVjdGl2ZXMgPSB7XG4gIG9uOiBvbixcbiAgYmluZDogYmluZCQxLFxuICBjbG9hazogbm9vcFxufTtcblxuLyogICovXG5cbnZhciBDb2RlZ2VuU3RhdGUgPSBmdW5jdGlvbiBDb2RlZ2VuU3RhdGUgKG9wdGlvbnMpIHtcbiAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgdGhpcy53YXJuID0gb3B0aW9ucy53YXJuIHx8IGJhc2VXYXJuO1xuICB0aGlzLnRyYW5zZm9ybXMgPSBwbHVja01vZHVsZUZ1bmN0aW9uKG9wdGlvbnMubW9kdWxlcywgJ3RyYW5zZm9ybUNvZGUnKTtcbiAgdGhpcy5kYXRhR2VuRm5zID0gcGx1Y2tNb2R1bGVGdW5jdGlvbihvcHRpb25zLm1vZHVsZXMsICdnZW5EYXRhJyk7XG4gIHRoaXMuZGlyZWN0aXZlcyA9IGV4dGVuZChleHRlbmQoe30sIGJhc2VEaXJlY3RpdmVzKSwgb3B0aW9ucy5kaXJlY3RpdmVzKTtcbiAgdmFyIGlzUmVzZXJ2ZWRUYWcgPSBvcHRpb25zLmlzUmVzZXJ2ZWRUYWcgfHwgbm87XG4gIHRoaXMubWF5YmVDb21wb25lbnQgPSBmdW5jdGlvbiAoZWwpIHsgcmV0dXJuICFpc1Jlc2VydmVkVGFnKGVsLnRhZyk7IH07XG4gIHRoaXMub25jZUlkID0gMDtcbiAgdGhpcy5zdGF0aWNSZW5kZXJGbnMgPSBbXTtcbn07XG5cblxuXG5mdW5jdGlvbiBnZW5lcmF0ZSAoXG4gIGFzdCxcbiAgb3B0aW9uc1xuKSB7XG4gIHZhciBzdGF0ZSA9IG5ldyBDb2RlZ2VuU3RhdGUob3B0aW9ucyk7XG4gIHZhciBjb2RlID0gYXN0ID8gZ2VuRWxlbWVudChhc3QsIHN0YXRlKSA6ICdfYyhcImRpdlwiKSc7XG4gIHJldHVybiB7XG4gICAgcmVuZGVyOiAoXCJ3aXRoKHRoaXMpe3JldHVybiBcIiArIGNvZGUgKyBcIn1cIiksXG4gICAgc3RhdGljUmVuZGVyRm5zOiBzdGF0ZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5FbGVtZW50IChlbCwgc3RhdGUpIHtcbiAgaWYgKGVsLnN0YXRpY1Jvb3QgJiYgIWVsLnN0YXRpY1Byb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLm9uY2UgJiYgIWVsLm9uY2VQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuT25jZShlbCwgc3RhdGUpXG4gIH0gZWxzZSBpZiAoZWwuZm9yICYmICFlbC5mb3JQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuRm9yKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5pZiAmJiAhZWwuaWZQcm9jZXNzZWQpIHtcbiAgICByZXR1cm4gZ2VuSWYoZWwsIHN0YXRlKVxuICB9IGVsc2UgaWYgKGVsLnRhZyA9PT0gJ3RlbXBsYXRlJyAmJiAhZWwuc2xvdFRhcmdldCkge1xuICAgIHJldHVybiBnZW5DaGlsZHJlbihlbCwgc3RhdGUpIHx8ICd2b2lkIDAnXG4gIH0gZWxzZSBpZiAoZWwudGFnID09PSAnc2xvdCcpIHtcbiAgICByZXR1cm4gZ2VuU2xvdChlbCwgc3RhdGUpXG4gIH0gZWxzZSB7XG4gICAgLy8gY29tcG9uZW50IG9yIGVsZW1lbnRcbiAgICB2YXIgY29kZTtcbiAgICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgICBjb2RlID0gZ2VuQ29tcG9uZW50KGVsLmNvbXBvbmVudCwgZWwsIHN0YXRlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGRhdGEgPSBlbC5wbGFpbiA/IHVuZGVmaW5lZCA6IGdlbkRhdGEkMihlbCwgc3RhdGUpO1xuXG4gICAgICB2YXIgY2hpbGRyZW4gPSBlbC5pbmxpbmVUZW1wbGF0ZSA/IG51bGwgOiBnZW5DaGlsZHJlbihlbCwgc3RhdGUsIHRydWUpO1xuICAgICAgY29kZSA9IFwiX2MoJ1wiICsgKGVsLnRhZykgKyBcIidcIiArIChkYXRhID8gKFwiLFwiICsgZGF0YSkgOiAnJykgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIjtcbiAgICB9XG4gICAgLy8gbW9kdWxlIHRyYW5zZm9ybXNcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLnRyYW5zZm9ybXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvZGUgPSBzdGF0ZS50cmFuc2Zvcm1zW2ldKGVsLCBjb2RlKTtcbiAgICB9XG4gICAgcmV0dXJuIGNvZGVcbiAgfVxufVxuXG4vLyBob2lzdCBzdGF0aWMgc3ViLXRyZWVzIG91dFxuZnVuY3Rpb24gZ2VuU3RhdGljIChlbCwgc3RhdGUsIG9uY2UkJDEpIHtcbiAgZWwuc3RhdGljUHJvY2Vzc2VkID0gdHJ1ZTtcbiAgc3RhdGUuc3RhdGljUmVuZGVyRm5zLnB1c2goKFwid2l0aCh0aGlzKXtyZXR1cm4gXCIgKyAoZ2VuRWxlbWVudChlbCwgc3RhdGUpKSArIFwifVwiKSk7XG4gIHJldHVybiAoXCJfbShcIiArIChzdGF0ZS5zdGF0aWNSZW5kZXJGbnMubGVuZ3RoIC0gMSkgKyBcIixcIiArIChlbC5zdGF0aWNJbkZvciA/ICd0cnVlJyA6ICdmYWxzZScpICsgXCIsXCIgKyAob25jZSQkMSA/ICd0cnVlJyA6ICdmYWxzZScpICsgXCIpXCIpXG59XG5cbi8vIHYtb25jZVxuZnVuY3Rpb24gZ2VuT25jZSAoZWwsIHN0YXRlKSB7XG4gIGVsLm9uY2VQcm9jZXNzZWQgPSB0cnVlO1xuICBpZiAoZWwuaWYgJiYgIWVsLmlmUHJvY2Vzc2VkKSB7XG4gICAgcmV0dXJuIGdlbklmKGVsLCBzdGF0ZSlcbiAgfSBlbHNlIGlmIChlbC5zdGF0aWNJbkZvcikge1xuICAgIHZhciBrZXkgPSAnJztcbiAgICB2YXIgcGFyZW50ID0gZWwucGFyZW50O1xuICAgIHdoaWxlIChwYXJlbnQpIHtcbiAgICAgIGlmIChwYXJlbnQuZm9yKSB7XG4gICAgICAgIGtleSA9IHBhcmVudC5rZXk7XG4gICAgICAgIGJyZWFrXG4gICAgICB9XG4gICAgICBwYXJlbnQgPSBwYXJlbnQucGFyZW50O1xuICAgIH1cbiAgICBpZiAoIWtleSkge1xuICAgICAgcHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBzdGF0ZS53YXJuKFxuICAgICAgICBcInYtb25jZSBjYW4gb25seSBiZSB1c2VkIGluc2lkZSB2LWZvciB0aGF0IGlzIGtleWVkLiBcIlxuICAgICAgKTtcbiAgICAgIHJldHVybiBnZW5FbGVtZW50KGVsLCBzdGF0ZSlcbiAgICB9XG4gICAgcmV0dXJuIChcIl9vKFwiICsgKGdlbkVsZW1lbnQoZWwsIHN0YXRlKSkgKyBcIixcIiArIChzdGF0ZS5vbmNlSWQrKykgKyBcIixcIiArIGtleSArIFwiKVwiKVxuICB9IGVsc2Uge1xuICAgIHJldHVybiBnZW5TdGF0aWMoZWwsIHN0YXRlLCB0cnVlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlbklmIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgZWwuaWZQcm9jZXNzZWQgPSB0cnVlOyAvLyBhdm9pZCByZWN1cnNpb25cbiAgcmV0dXJuIGdlbklmQ29uZGl0aW9ucyhlbC5pZkNvbmRpdGlvbnMuc2xpY2UoKSwgc3RhdGUsIGFsdEdlbiwgYWx0RW1wdHkpXG59XG5cbmZ1bmN0aW9uIGdlbklmQ29uZGl0aW9ucyAoXG4gIGNvbmRpdGlvbnMsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEVtcHR5XG4pIHtcbiAgaWYgKCFjb25kaXRpb25zLmxlbmd0aCkge1xuICAgIHJldHVybiBhbHRFbXB0eSB8fCAnX2UoKSdcbiAgfVxuXG4gIHZhciBjb25kaXRpb24gPSBjb25kaXRpb25zLnNoaWZ0KCk7XG4gIGlmIChjb25kaXRpb24uZXhwKSB7XG4gICAgcmV0dXJuIChcIihcIiArIChjb25kaXRpb24uZXhwKSArIFwiKT9cIiArIChnZW5UZXJuYXJ5RXhwKGNvbmRpdGlvbi5ibG9jaykpICsgXCI6XCIgKyAoZ2VuSWZDb25kaXRpb25zKGNvbmRpdGlvbnMsIHN0YXRlLCBhbHRHZW4sIGFsdEVtcHR5KSkpXG4gIH0gZWxzZSB7XG4gICAgcmV0dXJuIChcIlwiICsgKGdlblRlcm5hcnlFeHAoY29uZGl0aW9uLmJsb2NrKSkpXG4gIH1cblxuICAvLyB2LWlmIHdpdGggdi1vbmNlIHNob3VsZCBnZW5lcmF0ZSBjb2RlIGxpa2UgKGEpP19tKDApOl9tKDEpXG4gIGZ1bmN0aW9uIGdlblRlcm5hcnlFeHAgKGVsKSB7XG4gICAgcmV0dXJuIGFsdEdlblxuICAgICAgPyBhbHRHZW4oZWwsIHN0YXRlKVxuICAgICAgOiBlbC5vbmNlXG4gICAgICAgID8gZ2VuT25jZShlbCwgc3RhdGUpXG4gICAgICAgIDogZ2VuRWxlbWVudChlbCwgc3RhdGUpXG4gIH1cbn1cblxuZnVuY3Rpb24gZ2VuRm9yIChcbiAgZWwsXG4gIHN0YXRlLFxuICBhbHRHZW4sXG4gIGFsdEhlbHBlclxuKSB7XG4gIHZhciBleHAgPSBlbC5mb3I7XG4gIHZhciBhbGlhcyA9IGVsLmFsaWFzO1xuICB2YXIgaXRlcmF0b3IxID0gZWwuaXRlcmF0b3IxID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMSkpIDogJyc7XG4gIHZhciBpdGVyYXRvcjIgPSBlbC5pdGVyYXRvcjIgPyAoXCIsXCIgKyAoZWwuaXRlcmF0b3IyKSkgOiAnJztcblxuICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJlxuICAgIHN0YXRlLm1heWJlQ29tcG9uZW50KGVsKSAmJlxuICAgIGVsLnRhZyAhPT0gJ3Nsb3QnICYmXG4gICAgZWwudGFnICE9PSAndGVtcGxhdGUnICYmXG4gICAgIWVsLmtleVxuICApIHtcbiAgICBzdGF0ZS53YXJuKFxuICAgICAgXCI8XCIgKyAoZWwudGFnKSArIFwiIHYtZm9yPVxcXCJcIiArIGFsaWFzICsgXCIgaW4gXCIgKyBleHAgKyBcIlxcXCI+OiBjb21wb25lbnQgbGlzdHMgcmVuZGVyZWQgd2l0aCBcIiArXG4gICAgICBcInYtZm9yIHNob3VsZCBoYXZlIGV4cGxpY2l0IGtleXMuIFwiICtcbiAgICAgIFwiU2VlIGh0dHBzOi8vdnVlanMub3JnL2d1aWRlL2xpc3QuaHRtbCNrZXkgZm9yIG1vcmUgaW5mby5cIixcbiAgICAgIHRydWUgLyogdGlwICovXG4gICAgKTtcbiAgfVxuXG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gKGFsdEhlbHBlciB8fCAnX2wnKSArIFwiKChcIiArIGV4cCArIFwiKSxcIiArXG4gICAgXCJmdW5jdGlvbihcIiArIGFsaWFzICsgaXRlcmF0b3IxICsgaXRlcmF0b3IyICsgXCIpe1wiICtcbiAgICAgIFwicmV0dXJuIFwiICsgKChhbHRHZW4gfHwgZ2VuRWxlbWVudCkoZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuRGF0YSQyIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRhdGEgPSAneyc7XG5cbiAgLy8gZGlyZWN0aXZlcyBmaXJzdC5cbiAgLy8gZGlyZWN0aXZlcyBtYXkgbXV0YXRlIHRoZSBlbCdzIG90aGVyIHByb3BlcnRpZXMgYmVmb3JlIHRoZXkgYXJlIGdlbmVyYXRlZC5cbiAgdmFyIGRpcnMgPSBnZW5EaXJlY3RpdmVzKGVsLCBzdGF0ZSk7XG4gIGlmIChkaXJzKSB7IGRhdGEgKz0gZGlycyArICcsJzsgfVxuXG4gIC8vIGtleVxuICBpZiAoZWwua2V5KSB7XG4gICAgZGF0YSArPSBcImtleTpcIiArIChlbC5rZXkpICsgXCIsXCI7XG4gIH1cbiAgLy8gcmVmXG4gIGlmIChlbC5yZWYpIHtcbiAgICBkYXRhICs9IFwicmVmOlwiICsgKGVsLnJlZikgKyBcIixcIjtcbiAgfVxuICBpZiAoZWwucmVmSW5Gb3IpIHtcbiAgICBkYXRhICs9IFwicmVmSW5Gb3I6dHJ1ZSxcIjtcbiAgfVxuICAvLyBwcmVcbiAgaWYgKGVsLnByZSkge1xuICAgIGRhdGEgKz0gXCJwcmU6dHJ1ZSxcIjtcbiAgfVxuICAvLyByZWNvcmQgb3JpZ2luYWwgdGFnIG5hbWUgZm9yIGNvbXBvbmVudHMgdXNpbmcgXCJpc1wiIGF0dHJpYnV0ZVxuICBpZiAoZWwuY29tcG9uZW50KSB7XG4gICAgZGF0YSArPSBcInRhZzpcXFwiXCIgKyAoZWwudGFnKSArIFwiXFxcIixcIjtcbiAgfVxuICAvLyBtb2R1bGUgZGF0YSBnZW5lcmF0aW9uIGZ1bmN0aW9uc1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHN0YXRlLmRhdGFHZW5GbnMubGVuZ3RoOyBpKyspIHtcbiAgICBkYXRhICs9IHN0YXRlLmRhdGFHZW5GbnNbaV0oZWwpO1xuICB9XG4gIC8vIGF0dHJpYnV0ZXNcbiAgaWYgKGVsLmF0dHJzKSB7XG4gICAgZGF0YSArPSBcImF0dHJzOntcIiArIChnZW5Qcm9wcyhlbC5hdHRycykpICsgXCJ9LFwiO1xuICB9XG4gIC8vIERPTSBwcm9wc1xuICBpZiAoZWwucHJvcHMpIHtcbiAgICBkYXRhICs9IFwiZG9tUHJvcHM6e1wiICsgKGdlblByb3BzKGVsLnByb3BzKSkgKyBcIn0sXCI7XG4gIH1cbiAgLy8gZXZlbnQgaGFuZGxlcnNcbiAgaWYgKGVsLmV2ZW50cykge1xuICAgIGRhdGEgKz0gKGdlbkhhbmRsZXJzKGVsLmV2ZW50cywgZmFsc2UsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIGlmIChlbC5uYXRpdmVFdmVudHMpIHtcbiAgICBkYXRhICs9IChnZW5IYW5kbGVycyhlbC5uYXRpdmVFdmVudHMsIHRydWUsIHN0YXRlLndhcm4pKSArIFwiLFwiO1xuICB9XG4gIC8vIHNsb3QgdGFyZ2V0XG4gIC8vIG9ubHkgZm9yIG5vbi1zY29wZWQgc2xvdHNcbiAgaWYgKGVsLnNsb3RUYXJnZXQgJiYgIWVsLnNsb3RTY29wZSkge1xuICAgIGRhdGEgKz0gXCJzbG90OlwiICsgKGVsLnNsb3RUYXJnZXQpICsgXCIsXCI7XG4gIH1cbiAgLy8gc2NvcGVkIHNsb3RzXG4gIGlmIChlbC5zY29wZWRTbG90cykge1xuICAgIGRhdGEgKz0gKGdlblNjb3BlZFNsb3RzKGVsLnNjb3BlZFNsb3RzLCBzdGF0ZSkpICsgXCIsXCI7XG4gIH1cbiAgLy8gY29tcG9uZW50IHYtbW9kZWxcbiAgaWYgKGVsLm1vZGVsKSB7XG4gICAgZGF0YSArPSBcIm1vZGVsOnt2YWx1ZTpcIiArIChlbC5tb2RlbC52YWx1ZSkgKyBcIixjYWxsYmFjazpcIiArIChlbC5tb2RlbC5jYWxsYmFjaykgKyBcIixleHByZXNzaW9uOlwiICsgKGVsLm1vZGVsLmV4cHJlc3Npb24pICsgXCJ9LFwiO1xuICB9XG4gIC8vIGlubGluZS10ZW1wbGF0ZVxuICBpZiAoZWwuaW5saW5lVGVtcGxhdGUpIHtcbiAgICB2YXIgaW5saW5lVGVtcGxhdGUgPSBnZW5JbmxpbmVUZW1wbGF0ZShlbCwgc3RhdGUpO1xuICAgIGlmIChpbmxpbmVUZW1wbGF0ZSkge1xuICAgICAgZGF0YSArPSBpbmxpbmVUZW1wbGF0ZSArIFwiLFwiO1xuICAgIH1cbiAgfVxuICBkYXRhID0gZGF0YS5yZXBsYWNlKC8sJC8sICcnKSArICd9JztcbiAgLy8gdi1iaW5kIGRhdGEgd3JhcFxuICBpZiAoZWwud3JhcERhdGEpIHtcbiAgICBkYXRhID0gZWwud3JhcERhdGEoZGF0YSk7XG4gIH1cbiAgLy8gdi1vbiBkYXRhIHdyYXBcbiAgaWYgKGVsLndyYXBMaXN0ZW5lcnMpIHtcbiAgICBkYXRhID0gZWwud3JhcExpc3RlbmVycyhkYXRhKTtcbiAgfVxuICByZXR1cm4gZGF0YVxufVxuXG5mdW5jdGlvbiBnZW5EaXJlY3RpdmVzIChlbCwgc3RhdGUpIHtcbiAgdmFyIGRpcnMgPSBlbC5kaXJlY3RpdmVzO1xuICBpZiAoIWRpcnMpIHsgcmV0dXJuIH1cbiAgdmFyIHJlcyA9ICdkaXJlY3RpdmVzOlsnO1xuICB2YXIgaGFzUnVudGltZSA9IGZhbHNlO1xuICB2YXIgaSwgbCwgZGlyLCBuZWVkUnVudGltZTtcbiAgZm9yIChpID0gMCwgbCA9IGRpcnMubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgZGlyID0gZGlyc1tpXTtcbiAgICBuZWVkUnVudGltZSA9IHRydWU7XG4gICAgdmFyIGdlbiA9IHN0YXRlLmRpcmVjdGl2ZXNbZGlyLm5hbWVdO1xuICAgIGlmIChnZW4pIHtcbiAgICAgIC8vIGNvbXBpbGUtdGltZSBkaXJlY3RpdmUgdGhhdCBtYW5pcHVsYXRlcyBBU1QuXG4gICAgICAvLyByZXR1cm5zIHRydWUgaWYgaXQgYWxzbyBuZWVkcyBhIHJ1bnRpbWUgY291bnRlcnBhcnQuXG4gICAgICBuZWVkUnVudGltZSA9ICEhZ2VuKGVsLCBkaXIsIHN0YXRlLndhcm4pO1xuICAgIH1cbiAgICBpZiAobmVlZFJ1bnRpbWUpIHtcbiAgICAgIGhhc1J1bnRpbWUgPSB0cnVlO1xuICAgICAgcmVzICs9IFwie25hbWU6XFxcIlwiICsgKGRpci5uYW1lKSArIFwiXFxcIixyYXdOYW1lOlxcXCJcIiArIChkaXIucmF3TmFtZSkgKyBcIlxcXCJcIiArIChkaXIudmFsdWUgPyAoXCIsdmFsdWU6KFwiICsgKGRpci52YWx1ZSkgKyBcIiksZXhwcmVzc2lvbjpcIiArIChKU09OLnN0cmluZ2lmeShkaXIudmFsdWUpKSkgOiAnJykgKyAoZGlyLmFyZyA/IChcIixhcmc6XFxcIlwiICsgKGRpci5hcmcpICsgXCJcXFwiXCIpIDogJycpICsgKGRpci5tb2RpZmllcnMgPyAoXCIsbW9kaWZpZXJzOlwiICsgKEpTT04uc3RyaW5naWZ5KGRpci5tb2RpZmllcnMpKSkgOiAnJykgKyBcIn0sXCI7XG4gICAgfVxuICB9XG4gIGlmIChoYXNSdW50aW1lKSB7XG4gICAgcmV0dXJuIHJlcy5zbGljZSgwLCAtMSkgKyAnXSdcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5JbmxpbmVUZW1wbGF0ZSAoZWwsIHN0YXRlKSB7XG4gIHZhciBhc3QgPSBlbC5jaGlsZHJlblswXTtcbiAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgKFxuICAgIGVsLmNoaWxkcmVuLmxlbmd0aCAhPT0gMSB8fCBhc3QudHlwZSAhPT0gMVxuICApKSB7XG4gICAgc3RhdGUud2FybignSW5saW5lLXRlbXBsYXRlIGNvbXBvbmVudHMgbXVzdCBoYXZlIGV4YWN0bHkgb25lIGNoaWxkIGVsZW1lbnQuJyk7XG4gIH1cbiAgaWYgKGFzdC50eXBlID09PSAxKSB7XG4gICAgdmFyIGlubGluZVJlbmRlckZucyA9IGdlbmVyYXRlKGFzdCwgc3RhdGUub3B0aW9ucyk7XG4gICAgcmV0dXJuIChcImlubGluZVRlbXBsYXRlOntyZW5kZXI6ZnVuY3Rpb24oKXtcIiArIChpbmxpbmVSZW5kZXJGbnMucmVuZGVyKSArIFwifSxzdGF0aWNSZW5kZXJGbnM6W1wiICsgKGlubGluZVJlbmRlckZucy5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7IHJldHVybiAoXCJmdW5jdGlvbigpe1wiICsgY29kZSArIFwifVwiKTsgfSkuam9pbignLCcpKSArIFwiXX1cIilcbiAgfVxufVxuXG5mdW5jdGlvbiBnZW5TY29wZWRTbG90cyAoXG4gIHNsb3RzLFxuICBzdGF0ZVxuKSB7XG4gIHJldHVybiAoXCJzY29wZWRTbG90czpfdShbXCIgKyAoT2JqZWN0LmtleXMoc2xvdHMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XG4gICAgICByZXR1cm4gZ2VuU2NvcGVkU2xvdChrZXksIHNsb3RzW2tleV0sIHN0YXRlKVxuICAgIH0pLmpvaW4oJywnKSkgKyBcIl0pXCIpXG59XG5cbmZ1bmN0aW9uIGdlblNjb3BlZFNsb3QgKFxuICBrZXksXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIGlmIChlbC5mb3IgJiYgIWVsLmZvclByb2Nlc3NlZCkge1xuICAgIHJldHVybiBnZW5Gb3JTY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKVxuICB9XG4gIHZhciBmbiA9IFwiZnVuY3Rpb24oXCIgKyAoU3RyaW5nKGVsLnNsb3RTY29wZSkpICsgXCIpe1wiICtcbiAgICBcInJldHVybiBcIiArIChlbC50YWcgPT09ICd0ZW1wbGF0ZSdcbiAgICAgID8gZWwuaWZcbiAgICAgICAgPyAoKGVsLmlmKSArIFwiP1wiICsgKGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSkgfHwgJ3VuZGVmaW5lZCcpICsgXCI6dW5kZWZpbmVkXCIpXG4gICAgICAgIDogZ2VuQ2hpbGRyZW4oZWwsIHN0YXRlKSB8fCAndW5kZWZpbmVkJ1xuICAgICAgOiBnZW5FbGVtZW50KGVsLCBzdGF0ZSkpICsgXCJ9XCI7XG4gIHJldHVybiAoXCJ7a2V5OlwiICsga2V5ICsgXCIsZm46XCIgKyBmbiArIFwifVwiKVxufVxuXG5mdW5jdGlvbiBnZW5Gb3JTY29wZWRTbG90IChcbiAga2V5LFxuICBlbCxcbiAgc3RhdGVcbikge1xuICB2YXIgZXhwID0gZWwuZm9yO1xuICB2YXIgYWxpYXMgPSBlbC5hbGlhcztcbiAgdmFyIGl0ZXJhdG9yMSA9IGVsLml0ZXJhdG9yMSA/IChcIixcIiArIChlbC5pdGVyYXRvcjEpKSA6ICcnO1xuICB2YXIgaXRlcmF0b3IyID0gZWwuaXRlcmF0b3IyID8gKFwiLFwiICsgKGVsLml0ZXJhdG9yMikpIDogJyc7XG4gIGVsLmZvclByb2Nlc3NlZCA9IHRydWU7IC8vIGF2b2lkIHJlY3Vyc2lvblxuICByZXR1cm4gXCJfbCgoXCIgKyBleHAgKyBcIiksXCIgK1xuICAgIFwiZnVuY3Rpb24oXCIgKyBhbGlhcyArIGl0ZXJhdG9yMSArIGl0ZXJhdG9yMiArIFwiKXtcIiArXG4gICAgICBcInJldHVybiBcIiArIChnZW5TY29wZWRTbG90KGtleSwgZWwsIHN0YXRlKSkgK1xuICAgICd9KSdcbn1cblxuZnVuY3Rpb24gZ2VuQ2hpbGRyZW4gKFxuICBlbCxcbiAgc3RhdGUsXG4gIGNoZWNrU2tpcCxcbiAgYWx0R2VuRWxlbWVudCxcbiAgYWx0R2VuTm9kZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmNoaWxkcmVuO1xuICBpZiAoY2hpbGRyZW4ubGVuZ3RoKSB7XG4gICAgdmFyIGVsJDEgPSBjaGlsZHJlblswXTtcbiAgICAvLyBvcHRpbWl6ZSBzaW5nbGUgdi1mb3JcbiAgICBpZiAoY2hpbGRyZW4ubGVuZ3RoID09PSAxICYmXG4gICAgICBlbCQxLmZvciAmJlxuICAgICAgZWwkMS50YWcgIT09ICd0ZW1wbGF0ZScgJiZcbiAgICAgIGVsJDEudGFnICE9PSAnc2xvdCdcbiAgICApIHtcbiAgICAgIHJldHVybiAoYWx0R2VuRWxlbWVudCB8fCBnZW5FbGVtZW50KShlbCQxLCBzdGF0ZSlcbiAgICB9XG4gICAgdmFyIG5vcm1hbGl6YXRpb25UeXBlID0gY2hlY2tTa2lwXG4gICAgICA/IGdldE5vcm1hbGl6YXRpb25UeXBlKGNoaWxkcmVuLCBzdGF0ZS5tYXliZUNvbXBvbmVudClcbiAgICAgIDogMDtcbiAgICB2YXIgZ2VuID0gYWx0R2VuTm9kZSB8fCBnZW5Ob2RlO1xuICAgIHJldHVybiAoXCJbXCIgKyAoY2hpbGRyZW4ubWFwKGZ1bmN0aW9uIChjKSB7IHJldHVybiBnZW4oYywgc3RhdGUpOyB9KS5qb2luKCcsJykpICsgXCJdXCIgKyAobm9ybWFsaXphdGlvblR5cGUgPyAoXCIsXCIgKyBub3JtYWxpemF0aW9uVHlwZSkgOiAnJykpXG4gIH1cbn1cblxuLy8gZGV0ZXJtaW5lIHRoZSBub3JtYWxpemF0aW9uIG5lZWRlZCBmb3IgdGhlIGNoaWxkcmVuIGFycmF5LlxuLy8gMDogbm8gbm9ybWFsaXphdGlvbiBuZWVkZWRcbi8vIDE6IHNpbXBsZSBub3JtYWxpemF0aW9uIG5lZWRlZCAocG9zc2libGUgMS1sZXZlbCBkZWVwIG5lc3RlZCBhcnJheSlcbi8vIDI6IGZ1bGwgbm9ybWFsaXphdGlvbiBuZWVkZWRcbmZ1bmN0aW9uIGdldE5vcm1hbGl6YXRpb25UeXBlIChcbiAgY2hpbGRyZW4sXG4gIG1heWJlQ29tcG9uZW50XG4pIHtcbiAgdmFyIHJlcyA9IDA7XG4gIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgZWwgPSBjaGlsZHJlbltpXTtcbiAgICBpZiAoZWwudHlwZSAhPT0gMSkge1xuICAgICAgY29udGludWVcbiAgICB9XG4gICAgaWYgKG5lZWRzTm9ybWFsaXphdGlvbihlbCkgfHxcbiAgICAgICAgKGVsLmlmQ29uZGl0aW9ucyAmJiBlbC5pZkNvbmRpdGlvbnMuc29tZShmdW5jdGlvbiAoYykgeyByZXR1cm4gbmVlZHNOb3JtYWxpemF0aW9uKGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDI7XG4gICAgICBicmVha1xuICAgIH1cbiAgICBpZiAobWF5YmVDb21wb25lbnQoZWwpIHx8XG4gICAgICAgIChlbC5pZkNvbmRpdGlvbnMgJiYgZWwuaWZDb25kaXRpb25zLnNvbWUoZnVuY3Rpb24gKGMpIHsgcmV0dXJuIG1heWJlQ29tcG9uZW50KGMuYmxvY2spOyB9KSkpIHtcbiAgICAgIHJlcyA9IDE7XG4gICAgfVxuICB9XG4gIHJldHVybiByZXNcbn1cblxuZnVuY3Rpb24gbmVlZHNOb3JtYWxpemF0aW9uIChlbCkge1xuICByZXR1cm4gZWwuZm9yICE9PSB1bmRlZmluZWQgfHwgZWwudGFnID09PSAndGVtcGxhdGUnIHx8IGVsLnRhZyA9PT0gJ3Nsb3QnXG59XG5cbmZ1bmN0aW9uIGdlbk5vZGUgKG5vZGUsIHN0YXRlKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICByZXR1cm4gZ2VuRWxlbWVudChub2RlLCBzdGF0ZSlcbiAgfSBpZiAobm9kZS50eXBlID09PSAzICYmIG5vZGUuaXNDb21tZW50KSB7XG4gICAgcmV0dXJuIGdlbkNvbW1lbnQobm9kZSlcbiAgfSBlbHNlIHtcbiAgICByZXR1cm4gZ2VuVGV4dChub2RlKVxuICB9XG59XG5cbmZ1bmN0aW9uIGdlblRleHQgKHRleHQpIHtcbiAgcmV0dXJuIChcIl92KFwiICsgKHRleHQudHlwZSA9PT0gMlxuICAgID8gdGV4dC5leHByZXNzaW9uIC8vIG5vIG5lZWQgZm9yICgpIGJlY2F1c2UgYWxyZWFkeSB3cmFwcGVkIGluIF9zKClcbiAgICA6IHRyYW5zZm9ybVNwZWNpYWxOZXdsaW5lcyhKU09OLnN0cmluZ2lmeSh0ZXh0LnRleHQpKSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuQ29tbWVudCAoY29tbWVudCkge1xuICByZXR1cm4gKFwiX2UoXCIgKyAoSlNPTi5zdHJpbmdpZnkoY29tbWVudC50ZXh0KSkgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuU2xvdCAoZWwsIHN0YXRlKSB7XG4gIHZhciBzbG90TmFtZSA9IGVsLnNsb3ROYW1lIHx8ICdcImRlZmF1bHRcIic7XG4gIHZhciBjaGlsZHJlbiA9IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSk7XG4gIHZhciByZXMgPSBcIl90KFwiICsgc2xvdE5hbWUgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJyk7XG4gIHZhciBhdHRycyA9IGVsLmF0dHJzICYmIChcIntcIiArIChlbC5hdHRycy5tYXAoZnVuY3Rpb24gKGEpIHsgcmV0dXJuICgoY2FtZWxpemUoYS5uYW1lKSkgKyBcIjpcIiArIChhLnZhbHVlKSk7IH0pLmpvaW4oJywnKSkgKyBcIn1cIik7XG4gIHZhciBiaW5kJCQxID0gZWwuYXR0cnNNYXBbJ3YtYmluZCddO1xuICBpZiAoKGF0dHJzIHx8IGJpbmQkJDEpICYmICFjaGlsZHJlbikge1xuICAgIHJlcyArPSBcIixudWxsXCI7XG4gIH1cbiAgaWYgKGF0dHJzKSB7XG4gICAgcmVzICs9IFwiLFwiICsgYXR0cnM7XG4gIH1cbiAgaWYgKGJpbmQkJDEpIHtcbiAgICByZXMgKz0gKGF0dHJzID8gJycgOiAnLG51bGwnKSArIFwiLFwiICsgYmluZCQkMTtcbiAgfVxuICByZXR1cm4gcmVzICsgJyknXG59XG5cbi8vIGNvbXBvbmVudE5hbWUgaXMgZWwuY29tcG9uZW50LCB0YWtlIGl0IGFzIGFyZ3VtZW50IHRvIHNodW4gZmxvdydzIHBlc3NpbWlzdGljIHJlZmluZW1lbnRcbmZ1bmN0aW9uIGdlbkNvbXBvbmVudCAoXG4gIGNvbXBvbmVudE5hbWUsXG4gIGVsLFxuICBzdGF0ZVxuKSB7XG4gIHZhciBjaGlsZHJlbiA9IGVsLmlubGluZVRlbXBsYXRlID8gbnVsbCA6IGdlbkNoaWxkcmVuKGVsLCBzdGF0ZSwgdHJ1ZSk7XG4gIHJldHVybiAoXCJfYyhcIiArIGNvbXBvbmVudE5hbWUgKyBcIixcIiArIChnZW5EYXRhJDIoZWwsIHN0YXRlKSkgKyAoY2hpbGRyZW4gPyAoXCIsXCIgKyBjaGlsZHJlbikgOiAnJykgKyBcIilcIilcbn1cblxuZnVuY3Rpb24gZ2VuUHJvcHMgKHByb3BzKSB7XG4gIHZhciByZXMgPSAnJztcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBwcm9wcy5sZW5ndGg7IGkrKykge1xuICAgIHZhciBwcm9wID0gcHJvcHNbaV07XG4gICAgcmVzICs9IFwiXFxcIlwiICsgKHByb3AubmFtZSkgKyBcIlxcXCI6XCIgKyAodHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzKHByb3AudmFsdWUpKSArIFwiLFwiO1xuICB9XG4gIHJldHVybiByZXMuc2xpY2UoMCwgLTEpXG59XG5cbi8vICMzODk1LCAjNDI2OFxuZnVuY3Rpb24gdHJhbnNmb3JtU3BlY2lhbE5ld2xpbmVzICh0ZXh0KSB7XG4gIHJldHVybiB0ZXh0XG4gICAgLnJlcGxhY2UoL1xcdTIwMjgvZywgJ1xcXFx1MjAyOCcpXG4gICAgLnJlcGxhY2UoL1xcdTIwMjkvZywgJ1xcXFx1MjAyOScpXG59XG5cbi8qICAqL1xuXG4vLyB0aGVzZSBrZXl3b3JkcyBzaG91bGQgbm90IGFwcGVhciBpbnNpZGUgZXhwcmVzc2lvbnMsIGJ1dCBvcGVyYXRvcnMgbGlrZVxuLy8gdHlwZW9mLCBpbnN0YW5jZW9mIGFuZCBpbiBhcmUgYWxsb3dlZFxudmFyIHByb2hpYml0ZWRLZXl3b3JkUkUgPSBuZXcgUmVnRXhwKCdcXFxcYicgKyAoXG4gICdkbyxpZixmb3IsbGV0LG5ldyx0cnksdmFyLGNhc2UsZWxzZSx3aXRoLGF3YWl0LGJyZWFrLGNhdGNoLGNsYXNzLGNvbnN0LCcgK1xuICAnc3VwZXIsdGhyb3csd2hpbGUseWllbGQsZGVsZXRlLGV4cG9ydCxpbXBvcnQscmV0dXJuLHN3aXRjaCxkZWZhdWx0LCcgK1xuICAnZXh0ZW5kcyxmaW5hbGx5LGNvbnRpbnVlLGRlYnVnZ2VyLGZ1bmN0aW9uLGFyZ3VtZW50cydcbikuc3BsaXQoJywnKS5qb2luKCdcXFxcYnxcXFxcYicpICsgJ1xcXFxiJyk7XG5cbi8vIHRoZXNlIHVuYXJ5IG9wZXJhdG9ycyBzaG91bGQgbm90IGJlIHVzZWQgYXMgcHJvcGVydHkvbWV0aG9kIG5hbWVzXG52YXIgdW5hcnlPcGVyYXRvcnNSRSA9IG5ldyBSZWdFeHAoJ1xcXFxiJyArIChcbiAgJ2RlbGV0ZSx0eXBlb2Ysdm9pZCdcbikuc3BsaXQoJywnKS5qb2luKCdcXFxccypcXFxcKFteXFxcXCldKlxcXFwpfFxcXFxiJykgKyAnXFxcXHMqXFxcXChbXlxcXFwpXSpcXFxcKScpO1xuXG4vLyBzdHJpcCBzdHJpbmdzIGluIGV4cHJlc3Npb25zXG52YXIgc3RyaXBTdHJpbmdSRSA9IC8nKD86W14nXFxcXF18XFxcXC4pKid8XCIoPzpbXlwiXFxcXF18XFxcXC4pKlwifGAoPzpbXmBcXFxcXXxcXFxcLikqXFwkXFx7fFxcfSg/OlteYFxcXFxdfFxcXFwuKSpgfGAoPzpbXmBcXFxcXXxcXFxcLikqYC9nO1xuXG4vLyBkZXRlY3QgcHJvYmxlbWF0aWMgZXhwcmVzc2lvbnMgaW4gYSB0ZW1wbGF0ZVxuZnVuY3Rpb24gZGV0ZWN0RXJyb3JzIChhc3QpIHtcbiAgdmFyIGVycm9ycyA9IFtdO1xuICBpZiAoYXN0KSB7XG4gICAgY2hlY2tOb2RlKGFzdCwgZXJyb3JzKTtcbiAgfVxuICByZXR1cm4gZXJyb3JzXG59XG5cbmZ1bmN0aW9uIGNoZWNrTm9kZSAobm9kZSwgZXJyb3JzKSB7XG4gIGlmIChub2RlLnR5cGUgPT09IDEpIHtcbiAgICBmb3IgKHZhciBuYW1lIGluIG5vZGUuYXR0cnNNYXApIHtcbiAgICAgIGlmIChkaXJSRS50ZXN0KG5hbWUpKSB7XG4gICAgICAgIHZhciB2YWx1ZSA9IG5vZGUuYXR0cnNNYXBbbmFtZV07XG4gICAgICAgIGlmICh2YWx1ZSkge1xuICAgICAgICAgIGlmIChuYW1lID09PSAndi1mb3InKSB7XG4gICAgICAgICAgICBjaGVja0Zvcihub2RlLCAoXCJ2LWZvcj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2UgaWYgKG9uUkUudGVzdChuYW1lKSkge1xuICAgICAgICAgICAgY2hlY2tFdmVudCh2YWx1ZSwgKG5hbWUgKyBcIj1cXFwiXCIgKyB2YWx1ZSArIFwiXFxcIlwiKSwgZXJyb3JzKTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY2hlY2tFeHByZXNzaW9uKHZhbHVlLCAobmFtZSArIFwiPVxcXCJcIiArIHZhbHVlICsgXCJcXFwiXCIpLCBlcnJvcnMpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgICBpZiAobm9kZS5jaGlsZHJlbikge1xuICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBub2RlLmNoaWxkcmVuLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGNoZWNrTm9kZShub2RlLmNoaWxkcmVuW2ldLCBlcnJvcnMpO1xuICAgICAgfVxuICAgIH1cbiAgfSBlbHNlIGlmIChub2RlLnR5cGUgPT09IDIpIHtcbiAgICBjaGVja0V4cHJlc3Npb24obm9kZS5leHByZXNzaW9uLCBub2RlLnRleHQsIGVycm9ycyk7XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFdmVudCAoZXhwLCB0ZXh0LCBlcnJvcnMpIHtcbiAgdmFyIHN0aXBwZWQgPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJyk7XG4gIHZhciBrZXl3b3JkTWF0Y2ggPSBzdGlwcGVkLm1hdGNoKHVuYXJ5T3BlcmF0b3JzUkUpO1xuICBpZiAoa2V5d29yZE1hdGNoICYmIHN0aXBwZWQuY2hhckF0KGtleXdvcmRNYXRjaC5pbmRleCAtIDEpICE9PSAnJCcpIHtcbiAgICBlcnJvcnMucHVzaChcbiAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCB1bmFyeSBvcGVyYXRvciBhcyBwcm9wZXJ0eSBuYW1lOiBcIiArXG4gICAgICBcIlxcXCJcIiArIChrZXl3b3JkTWF0Y2hbMF0pICsgXCJcXFwiIGluIGV4cHJlc3Npb24gXCIgKyAodGV4dC50cmltKCkpXG4gICAgKTtcbiAgfVxuICBjaGVja0V4cHJlc3Npb24oZXhwLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0ZvciAobm9kZSwgdGV4dCwgZXJyb3JzKSB7XG4gIGNoZWNrRXhwcmVzc2lvbihub2RlLmZvciB8fCAnJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuYWxpYXMsICd2LWZvciBhbGlhcycsIHRleHQsIGVycm9ycyk7XG4gIGNoZWNrSWRlbnRpZmllcihub2RlLml0ZXJhdG9yMSwgJ3YtZm9yIGl0ZXJhdG9yJywgdGV4dCwgZXJyb3JzKTtcbiAgY2hlY2tJZGVudGlmaWVyKG5vZGUuaXRlcmF0b3IyLCAndi1mb3IgaXRlcmF0b3InLCB0ZXh0LCBlcnJvcnMpO1xufVxuXG5mdW5jdGlvbiBjaGVja0lkZW50aWZpZXIgKFxuICBpZGVudCxcbiAgdHlwZSxcbiAgdGV4dCxcbiAgZXJyb3JzXG4pIHtcbiAgaWYgKHR5cGVvZiBpZGVudCA9PT0gJ3N0cmluZycpIHtcbiAgICB0cnkge1xuICAgICAgbmV3IEZ1bmN0aW9uKChcInZhciBcIiArIGlkZW50ICsgXCI9X1wiKSk7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgZXJyb3JzLnB1c2goKFwiaW52YWxpZCBcIiArIHR5cGUgKyBcIiBcXFwiXCIgKyBpZGVudCArIFwiXFxcIiBpbiBleHByZXNzaW9uOiBcIiArICh0ZXh0LnRyaW0oKSkpKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY2hlY2tFeHByZXNzaW9uIChleHAsIHRleHQsIGVycm9ycykge1xuICB0cnkge1xuICAgIG5ldyBGdW5jdGlvbigoXCJyZXR1cm4gXCIgKyBleHApKTtcbiAgfSBjYXRjaCAoZSkge1xuICAgIHZhciBrZXl3b3JkTWF0Y2ggPSBleHAucmVwbGFjZShzdHJpcFN0cmluZ1JFLCAnJykubWF0Y2gocHJvaGliaXRlZEtleXdvcmRSRSk7XG4gICAgaWYgKGtleXdvcmRNYXRjaCkge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiYXZvaWQgdXNpbmcgSmF2YVNjcmlwdCBrZXl3b3JkIGFzIHByb3BlcnR5IG5hbWU6IFwiICtcbiAgICAgICAgXCJcXFwiXCIgKyAoa2V5d29yZE1hdGNoWzBdKSArIFwiXFxcIlxcbiAgUmF3IGV4cHJlc3Npb246IFwiICsgKHRleHQudHJpbSgpKVxuICAgICAgKTtcbiAgICB9IGVsc2Uge1xuICAgICAgZXJyb3JzLnB1c2goXG4gICAgICAgIFwiaW52YWxpZCBleHByZXNzaW9uOiBcIiArIChlLm1lc3NhZ2UpICsgXCIgaW5cXG5cXG5cIiArXG4gICAgICAgIFwiICAgIFwiICsgZXhwICsgXCJcXG5cXG5cIiArXG4gICAgICAgIFwiICBSYXcgZXhwcmVzc2lvbjogXCIgKyAodGV4dC50cmltKCkpICsgXCJcXG5cIlxuICAgICAgKTtcbiAgICB9XG4gIH1cbn1cblxuLyogICovXG5cbmZ1bmN0aW9uIGNyZWF0ZUZ1bmN0aW9uIChjb2RlLCBlcnJvcnMpIHtcbiAgdHJ5IHtcbiAgICByZXR1cm4gbmV3IEZ1bmN0aW9uKGNvZGUpXG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGVycm9ycy5wdXNoKHsgZXJyOiBlcnIsIGNvZGU6IGNvZGUgfSk7XG4gICAgcmV0dXJuIG5vb3BcbiAgfVxufVxuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuIChjb21waWxlKSB7XG4gIHZhciBjYWNoZSA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG5cbiAgcmV0dXJuIGZ1bmN0aW9uIGNvbXBpbGVUb0Z1bmN0aW9ucyAoXG4gICAgdGVtcGxhdGUsXG4gICAgb3B0aW9ucyxcbiAgICB2bVxuICApIHtcbiAgICBvcHRpb25zID0gZXh0ZW5kKHt9LCBvcHRpb25zKTtcbiAgICB2YXIgd2FybiQkMSA9IG9wdGlvbnMud2FybiB8fCB3YXJuO1xuICAgIGRlbGV0ZSBvcHRpb25zLndhcm47XG5cbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgLy8gZGV0ZWN0IHBvc3NpYmxlIENTUCByZXN0cmljdGlvblxuICAgICAgdHJ5IHtcbiAgICAgICAgbmV3IEZ1bmN0aW9uKCdyZXR1cm4gMScpO1xuICAgICAgfSBjYXRjaCAoZSkge1xuICAgICAgICBpZiAoZS50b1N0cmluZygpLm1hdGNoKC91bnNhZmUtZXZhbHxDU1AvKSkge1xuICAgICAgICAgIHdhcm4kJDEoXG4gICAgICAgICAgICAnSXQgc2VlbXMgeW91IGFyZSB1c2luZyB0aGUgc3RhbmRhbG9uZSBidWlsZCBvZiBWdWUuanMgaW4gYW4gJyArXG4gICAgICAgICAgICAnZW52aXJvbm1lbnQgd2l0aCBDb250ZW50IFNlY3VyaXR5IFBvbGljeSB0aGF0IHByb2hpYml0cyB1bnNhZmUtZXZhbC4gJyArXG4gICAgICAgICAgICAnVGhlIHRlbXBsYXRlIGNvbXBpbGVyIGNhbm5vdCB3b3JrIGluIHRoaXMgZW52aXJvbm1lbnQuIENvbnNpZGVyICcgK1xuICAgICAgICAgICAgJ3JlbGF4aW5nIHRoZSBwb2xpY3kgdG8gYWxsb3cgdW5zYWZlLWV2YWwgb3IgcHJlLWNvbXBpbGluZyB5b3VyICcgK1xuICAgICAgICAgICAgJ3RlbXBsYXRlcyBpbnRvIHJlbmRlciBmdW5jdGlvbnMuJ1xuICAgICAgICAgICk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyBjaGVjayBjYWNoZVxuICAgIHZhciBrZXkgPSBvcHRpb25zLmRlbGltaXRlcnNcbiAgICAgID8gU3RyaW5nKG9wdGlvbnMuZGVsaW1pdGVycykgKyB0ZW1wbGF0ZVxuICAgICAgOiB0ZW1wbGF0ZTtcbiAgICBpZiAoY2FjaGVba2V5XSkge1xuICAgICAgcmV0dXJuIGNhY2hlW2tleV1cbiAgICB9XG5cbiAgICAvLyBjb21waWxlXG4gICAgdmFyIGNvbXBpbGVkID0gY29tcGlsZSh0ZW1wbGF0ZSwgb3B0aW9ucyk7XG5cbiAgICAvLyBjaGVjayBjb21waWxhdGlvbiBlcnJvcnMvdGlwc1xuICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nKSB7XG4gICAgICBpZiAoY29tcGlsZWQuZXJyb3JzICYmIGNvbXBpbGVkLmVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkVycm9yIGNvbXBpbGluZyB0ZW1wbGF0ZTpcXG5cXG5cIiArIHRlbXBsYXRlICsgXCJcXG5cXG5cIiArXG4gICAgICAgICAgY29tcGlsZWQuZXJyb3JzLm1hcChmdW5jdGlvbiAoZSkgeyByZXR1cm4gKFwiLSBcIiArIGUpOyB9KS5qb2luKCdcXG4nKSArICdcXG4nLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgICBpZiAoY29tcGlsZWQudGlwcyAmJiBjb21waWxlZC50aXBzLmxlbmd0aCkge1xuICAgICAgICBjb21waWxlZC50aXBzLmZvckVhY2goZnVuY3Rpb24gKG1zZykgeyByZXR1cm4gdGlwKG1zZywgdm0pOyB9KTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICAvLyB0dXJuIGNvZGUgaW50byBmdW5jdGlvbnNcbiAgICB2YXIgcmVzID0ge307XG4gICAgdmFyIGZuR2VuRXJyb3JzID0gW107XG4gICAgcmVzLnJlbmRlciA9IGNyZWF0ZUZ1bmN0aW9uKGNvbXBpbGVkLnJlbmRlciwgZm5HZW5FcnJvcnMpO1xuICAgIHJlcy5zdGF0aWNSZW5kZXJGbnMgPSBjb21waWxlZC5zdGF0aWNSZW5kZXJGbnMubWFwKGZ1bmN0aW9uIChjb2RlKSB7XG4gICAgICByZXR1cm4gY3JlYXRlRnVuY3Rpb24oY29kZSwgZm5HZW5FcnJvcnMpXG4gICAgfSk7XG5cbiAgICAvLyBjaGVjayBmdW5jdGlvbiBnZW5lcmF0aW9uIGVycm9ycy5cbiAgICAvLyB0aGlzIHNob3VsZCBvbmx5IGhhcHBlbiBpZiB0aGVyZSBpcyBhIGJ1ZyBpbiB0aGUgY29tcGlsZXIgaXRzZWxmLlxuICAgIC8vIG1vc3RseSBmb3IgY29kZWdlbiBkZXZlbG9wbWVudCB1c2VcbiAgICAvKiBpc3RhbmJ1bCBpZ25vcmUgaWYgKi9cbiAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgaWYgKCghY29tcGlsZWQuZXJyb3JzIHx8ICFjb21waWxlZC5lcnJvcnMubGVuZ3RoKSAmJiBmbkdlbkVycm9ycy5sZW5ndGgpIHtcbiAgICAgICAgd2FybiQkMShcbiAgICAgICAgICBcIkZhaWxlZCB0byBnZW5lcmF0ZSByZW5kZXIgZnVuY3Rpb246XFxuXFxuXCIgK1xuICAgICAgICAgIGZuR2VuRXJyb3JzLm1hcChmdW5jdGlvbiAocmVmKSB7XG4gICAgICAgICAgICB2YXIgZXJyID0gcmVmLmVycjtcbiAgICAgICAgICAgIHZhciBjb2RlID0gcmVmLmNvZGU7XG5cbiAgICAgICAgICAgIHJldHVybiAoKGVyci50b1N0cmluZygpKSArIFwiIGluXFxuXFxuXCIgKyBjb2RlICsgXCJcXG5cIik7XG4gICAgICAgIH0pLmpvaW4oJ1xcbicpLFxuICAgICAgICAgIHZtXG4gICAgICAgICk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIChjYWNoZVtrZXldID0gcmVzKVxuICB9XG59XG5cbi8qICAqL1xuXG5mdW5jdGlvbiBjcmVhdGVDb21waWxlckNyZWF0b3IgKGJhc2VDb21waWxlKSB7XG4gIHJldHVybiBmdW5jdGlvbiBjcmVhdGVDb21waWxlciAoYmFzZU9wdGlvbnMpIHtcbiAgICBmdW5jdGlvbiBjb21waWxlIChcbiAgICAgIHRlbXBsYXRlLFxuICAgICAgb3B0aW9uc1xuICAgICkge1xuICAgICAgdmFyIGZpbmFsT3B0aW9ucyA9IE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMpO1xuICAgICAgdmFyIGVycm9ycyA9IFtdO1xuICAgICAgdmFyIHRpcHMgPSBbXTtcbiAgICAgIGZpbmFsT3B0aW9ucy53YXJuID0gZnVuY3Rpb24gKG1zZywgdGlwKSB7XG4gICAgICAgICh0aXAgPyB0aXBzIDogZXJyb3JzKS5wdXNoKG1zZyk7XG4gICAgICB9O1xuXG4gICAgICBpZiAob3B0aW9ucykge1xuICAgICAgICAvLyBtZXJnZSBjdXN0b20gbW9kdWxlc1xuICAgICAgICBpZiAob3B0aW9ucy5tb2R1bGVzKSB7XG4gICAgICAgICAgZmluYWxPcHRpb25zLm1vZHVsZXMgPVxuICAgICAgICAgICAgKGJhc2VPcHRpb25zLm1vZHVsZXMgfHwgW10pLmNvbmNhdChvcHRpb25zLm1vZHVsZXMpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG1lcmdlIGN1c3RvbSBkaXJlY3RpdmVzXG4gICAgICAgIGlmIChvcHRpb25zLmRpcmVjdGl2ZXMpIHtcbiAgICAgICAgICBmaW5hbE9wdGlvbnMuZGlyZWN0aXZlcyA9IGV4dGVuZChcbiAgICAgICAgICAgIE9iamVjdC5jcmVhdGUoYmFzZU9wdGlvbnMuZGlyZWN0aXZlcyksXG4gICAgICAgICAgICBvcHRpb25zLmRpcmVjdGl2ZXNcbiAgICAgICAgICApO1xuICAgICAgICB9XG4gICAgICAgIC8vIGNvcHkgb3RoZXIgb3B0aW9uc1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gb3B0aW9ucykge1xuICAgICAgICAgIGlmIChrZXkgIT09ICdtb2R1bGVzJyAmJiBrZXkgIT09ICdkaXJlY3RpdmVzJykge1xuICAgICAgICAgICAgZmluYWxPcHRpb25zW2tleV0gPSBvcHRpb25zW2tleV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIHZhciBjb21waWxlZCA9IGJhc2VDb21waWxlKHRlbXBsYXRlLCBmaW5hbE9wdGlvbnMpO1xuICAgICAgaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicpIHtcbiAgICAgICAgZXJyb3JzLnB1c2guYXBwbHkoZXJyb3JzLCBkZXRlY3RFcnJvcnMoY29tcGlsZWQuYXN0KSk7XG4gICAgICB9XG4gICAgICBjb21waWxlZC5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICBjb21waWxlZC50aXBzID0gdGlwcztcbiAgICAgIHJldHVybiBjb21waWxlZFxuICAgIH1cblxuICAgIHJldHVybiB7XG4gICAgICBjb21waWxlOiBjb21waWxlLFxuICAgICAgY29tcGlsZVRvRnVuY3Rpb25zOiBjcmVhdGVDb21waWxlVG9GdW5jdGlvbkZuKGNvbXBpbGUpXG4gICAgfVxuICB9XG59XG5cbi8qICAqL1xuXG4vLyBgY3JlYXRlQ29tcGlsZXJDcmVhdG9yYCBhbGxvd3MgY3JlYXRpbmcgY29tcGlsZXJzIHRoYXQgdXNlIGFsdGVybmF0aXZlXG4vLyBwYXJzZXIvb3B0aW1pemVyL2NvZGVnZW4sIGUuZyB0aGUgU1NSIG9wdGltaXppbmcgY29tcGlsZXIuXG4vLyBIZXJlIHdlIGp1c3QgZXhwb3J0IGEgZGVmYXVsdCBjb21waWxlciB1c2luZyB0aGUgZGVmYXVsdCBwYXJ0cy5cbnZhciBjcmVhdGVDb21waWxlciA9IGNyZWF0ZUNvbXBpbGVyQ3JlYXRvcihmdW5jdGlvbiBiYXNlQ29tcGlsZSAoXG4gIHRlbXBsYXRlLFxuICBvcHRpb25zXG4pIHtcbiAgdmFyIGFzdCA9IHBhcnNlKHRlbXBsYXRlLnRyaW0oKSwgb3B0aW9ucyk7XG4gIG9wdGltaXplKGFzdCwgb3B0aW9ucyk7XG4gIHZhciBjb2RlID0gZ2VuZXJhdGUoYXN0LCBvcHRpb25zKTtcbiAgcmV0dXJuIHtcbiAgICBhc3Q6IGFzdCxcbiAgICByZW5kZXI6IGNvZGUucmVuZGVyLFxuICAgIHN0YXRpY1JlbmRlckZuczogY29kZS5zdGF0aWNSZW5kZXJGbnNcbiAgfVxufSk7XG5cbi8qICAqL1xuXG52YXIgcmVmJDEgPSBjcmVhdGVDb21waWxlcihiYXNlT3B0aW9ucyk7XG52YXIgY29tcGlsZVRvRnVuY3Rpb25zID0gcmVmJDEuY29tcGlsZVRvRnVuY3Rpb25zO1xuXG4vKiAgKi9cblxuLy8gY2hlY2sgd2hldGhlciBjdXJyZW50IGJyb3dzZXIgZW5jb2RlcyBhIGNoYXIgaW5zaWRlIGF0dHJpYnV0ZSB2YWx1ZXNcbnZhciBkaXY7XG5mdW5jdGlvbiBnZXRTaG91bGREZWNvZGUgKGhyZWYpIHtcbiAgZGl2ID0gZGl2IHx8IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2RpdicpO1xuICBkaXYuaW5uZXJIVE1MID0gaHJlZiA/IFwiPGEgaHJlZj1cXFwiXFxuXFxcIi8+XCIgOiBcIjxkaXYgYT1cXFwiXFxuXFxcIi8+XCI7XG4gIHJldHVybiBkaXYuaW5uZXJIVE1MLmluZGV4T2YoJyYjMTA7JykgPiAwXG59XG5cbi8vICMzNjYzOiBJRSBlbmNvZGVzIG5ld2xpbmVzIGluc2lkZSBhdHRyaWJ1dGUgdmFsdWVzIHdoaWxlIG90aGVyIGJyb3dzZXJzIGRvbid0XG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXMgPSBpbkJyb3dzZXIgPyBnZXRTaG91bGREZWNvZGUoZmFsc2UpIDogZmFsc2U7XG4vLyAjNjgyODogY2hyb21lIGVuY29kZXMgY29udGVudCBpbiBhW2hyZWZdXG52YXIgc2hvdWxkRGVjb2RlTmV3bGluZXNGb3JIcmVmID0gaW5Ccm93c2VyID8gZ2V0U2hvdWxkRGVjb2RlKHRydWUpIDogZmFsc2U7XG5cbi8qICAqL1xuXG52YXIgaWRUb1RlbXBsYXRlID0gY2FjaGVkKGZ1bmN0aW9uIChpZCkge1xuICB2YXIgZWwgPSBxdWVyeShpZCk7XG4gIHJldHVybiBlbCAmJiBlbC5pbm5lckhUTUxcbn0pO1xuXG52YXIgbW91bnQgPSBWdWUkMy5wcm90b3R5cGUuJG1vdW50O1xuVnVlJDMucHJvdG90eXBlLiRtb3VudCA9IGZ1bmN0aW9uIChcbiAgZWwsXG4gIGh5ZHJhdGluZ1xuKSB7XG4gIGVsID0gZWwgJiYgcXVlcnkoZWwpO1xuXG4gIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICBpZiAoZWwgPT09IGRvY3VtZW50LmJvZHkgfHwgZWwgPT09IGRvY3VtZW50LmRvY3VtZW50RWxlbWVudCkge1xuICAgIHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSAncHJvZHVjdGlvbicgJiYgd2FybihcbiAgICAgIFwiRG8gbm90IG1vdW50IFZ1ZSB0byA8aHRtbD4gb3IgPGJvZHk+IC0gbW91bnQgdG8gbm9ybWFsIGVsZW1lbnRzIGluc3RlYWQuXCJcbiAgICApO1xuICAgIHJldHVybiB0aGlzXG4gIH1cblxuICB2YXIgb3B0aW9ucyA9IHRoaXMuJG9wdGlvbnM7XG4gIC8vIHJlc29sdmUgdGVtcGxhdGUvZWwgYW5kIGNvbnZlcnQgdG8gcmVuZGVyIGZ1bmN0aW9uXG4gIGlmICghb3B0aW9ucy5yZW5kZXIpIHtcbiAgICB2YXIgdGVtcGxhdGUgPSBvcHRpb25zLnRlbXBsYXRlO1xuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgaWYgKHR5cGVvZiB0ZW1wbGF0ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgaWYgKHRlbXBsYXRlLmNoYXJBdCgwKSA9PT0gJyMnKSB7XG4gICAgICAgICAgdGVtcGxhdGUgPSBpZFRvVGVtcGxhdGUodGVtcGxhdGUpO1xuICAgICAgICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAqL1xuICAgICAgICAgIGlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gJ3Byb2R1Y3Rpb24nICYmICF0ZW1wbGF0ZSkge1xuICAgICAgICAgICAgd2FybihcbiAgICAgICAgICAgICAgKFwiVGVtcGxhdGUgZWxlbWVudCBub3QgZm91bmQgb3IgaXMgZW1wdHk6IFwiICsgKG9wdGlvbnMudGVtcGxhdGUpKSxcbiAgICAgICAgICAgICAgdGhpc1xuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAodGVtcGxhdGUubm9kZVR5cGUpIHtcbiAgICAgICAgdGVtcGxhdGUgPSB0ZW1wbGF0ZS5pbm5lckhUTUw7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJykge1xuICAgICAgICAgIHdhcm4oJ2ludmFsaWQgdGVtcGxhdGUgb3B0aW9uOicgKyB0ZW1wbGF0ZSwgdGhpcyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXNcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGVsKSB7XG4gICAgICB0ZW1wbGF0ZSA9IGdldE91dGVySFRNTChlbCk7XG4gICAgfVxuICAgIGlmICh0ZW1wbGF0ZSkge1xuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlJyk7XG4gICAgICB9XG5cbiAgICAgIHZhciByZWYgPSBjb21waWxlVG9GdW5jdGlvbnModGVtcGxhdGUsIHtcbiAgICAgICAgc2hvdWxkRGVjb2RlTmV3bGluZXM6IHNob3VsZERlY29kZU5ld2xpbmVzLFxuICAgICAgICBzaG91bGREZWNvZGVOZXdsaW5lc0ZvckhyZWY6IHNob3VsZERlY29kZU5ld2xpbmVzRm9ySHJlZixcbiAgICAgICAgZGVsaW1pdGVyczogb3B0aW9ucy5kZWxpbWl0ZXJzLFxuICAgICAgICBjb21tZW50czogb3B0aW9ucy5jb21tZW50c1xuICAgICAgfSwgdGhpcyk7XG4gICAgICB2YXIgcmVuZGVyID0gcmVmLnJlbmRlcjtcbiAgICAgIHZhciBzdGF0aWNSZW5kZXJGbnMgPSByZWYuc3RhdGljUmVuZGVyRm5zO1xuICAgICAgb3B0aW9ucy5yZW5kZXIgPSByZW5kZXI7XG4gICAgICBvcHRpb25zLnN0YXRpY1JlbmRlckZucyA9IHN0YXRpY1JlbmRlckZucztcblxuICAgICAgLyogaXN0YW5idWwgaWdub3JlIGlmICovXG4gICAgICBpZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgIT09ICdwcm9kdWN0aW9uJyAmJiBjb25maWcucGVyZm9ybWFuY2UgJiYgbWFyaykge1xuICAgICAgICBtYXJrKCdjb21waWxlIGVuZCcpO1xuICAgICAgICBtZWFzdXJlKChcInZ1ZSBcIiArICh0aGlzLl9uYW1lKSArIFwiIGNvbXBpbGVcIiksICdjb21waWxlJywgJ2NvbXBpbGUgZW5kJyk7XG4gICAgICB9XG4gICAgfVxuICB9XG4gIHJldHVybiBtb3VudC5jYWxsKHRoaXMsIGVsLCBoeWRyYXRpbmcpXG59O1xuXG4vKipcbiAqIEdldCBvdXRlckhUTUwgb2YgZWxlbWVudHMsIHRha2luZyBjYXJlXG4gKiBvZiBTVkcgZWxlbWVudHMgaW4gSUUgYXMgd2VsbC5cbiAqL1xuZnVuY3Rpb24gZ2V0T3V0ZXJIVE1MIChlbCkge1xuICBpZiAoZWwub3V0ZXJIVE1MKSB7XG4gICAgcmV0dXJuIGVsLm91dGVySFRNTFxuICB9IGVsc2Uge1xuICAgIHZhciBjb250YWluZXIgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdkaXYnKTtcbiAgICBjb250YWluZXIuYXBwZW5kQ2hpbGQoZWwuY2xvbmVOb2RlKHRydWUpKTtcbiAgICByZXR1cm4gY29udGFpbmVyLmlubmVySFRNTFxuICB9XG59XG5cblZ1ZSQzLmNvbXBpbGUgPSBjb21waWxlVG9GdW5jdGlvbnM7XG5cbm1vZHVsZS5leHBvcnRzID0gVnVlJDM7XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9ub2RlX21vZHVsZXMvdnVlL2Rpc3QvdnVlLmNvbW1vbi5qcyIsIlxuLyoqXG4gKiBWdWVtaXQgY2xhc3MuXG4gKlxuICogQGF1dGhvciBHdXN0YXZvIE9jYW50byA8Z3VzdGF2b29jYW50b0BnbWFpbC5jb20+XG4gKiBAbGljZW5zZSBodHRwczovL2dpdGh1Yi5jb20vZ29jYW50by92dWVtaXQvYmxvYi9tYXN0ZXIvTElDRU5TRVxuICovXG5cbmltcG9ydCBWdWUgZnJvbSAndnVlJ1xuXG5jbGFzcyBWdWVtaXRcbntcbiAgICAvKipcblx0ICogQ3JlYXRlcyBhIG5ldyBFdmVudCBpbnN0YW5jZS5cblx0ICpcblx0ICogQHJldHVybiB7Vm9pZH1cblx0ICovXG4gICAgY29uc3RydWN0b3IoKVxuICAgIHtcbiAgICAgICAgLyoqXG5cdFx0ICogVGhlIFZ1ZSBpbnN0YW5jZS5cblx0XHQgKlxuXHRcdCAqIEB0eXBlIHtWdWV9XG5cdFx0ICovXG4gICAgICAgIHRoaXMudnVlID0gbmV3IFZ1ZSgpXG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIEZpcmVzIGEgZ2l2ZW4gZXZlbnQvcy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBkYXRhXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuICAgIGZpcmUoZXZlbnQsIGRhdGEgPSBudWxsKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudnVlLiRlbWl0KGUsIGRhdGEpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52dWUuJGVtaXQoZXZlbnQsIGRhdGEpXG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIExpc3RlbnMgZm9yIGEgZ2l2ZW4gZXZlbnQvcy5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuICAgIGxpc3RlbihldmVudCwgY2FsbGJhY2spXG4gICAge1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIHJldHVybiBldmVudC5mb3JFYWNoKChlKSA9PiB7XG4gICAgICAgICAgICAgICAgdGhpcy52dWUuJG9uKGUsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudnVlLiRvbihldmVudCwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIExpc3RlbnMgZm9yIGEgZ2l2ZW4gZXZlbnQvcyBmb3Igb25lIHRpbWUgb25seS5cblx0ICpcblx0ICogQHBhcmFtIHtPYmplY3R9IGV2ZW50XG5cdCAqIEBwYXJhbSB7RnVuY3Rpb259IGNhbGxiYWNrXG5cdCAqIEByZXR1cm4ge1ZvaWR9XG5cdCAqL1xuICAgIGxpc3Rlbk9uY2UoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudnVlLiRvbmNlKGUsIGNhbGxiYWNrKVxuICAgICAgICAgICAgfSlcbiAgICAgICAgfVxuXG4gICAgICAgIHRoaXMudnVlLiRvbmNlKGV2ZW50LCBjYWxsYmFjaylcbiAgICB9XG5cbiAgICAvKipcblx0ICogUmVtb3ZlcyBsaXN0ZW5lcnMgZm9yIGEgZ2l2ZW4gZXZlbnQvcyBhbmQgY2FsbGJhY2suXG5cdCAqXG5cdCAqIEBwYXJhbSB7T2JqZWN0fSBldmVudFxuXHQgKiBAcGFyYW0ge0Z1bmN0aW9ufSBjYWxsYmFja1xuXHQgKiBAcmV0dXJuIHtWb2lkfVxuXHQgKi9cbiAgICByZW1vdmUoZXZlbnQsIGNhbGxiYWNrKVxuICAgIHtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnQuZm9yRWFjaCgoZSkgPT4ge1xuICAgICAgICAgICAgICAgIHRoaXMudnVlLiRvZmYoZSwgY2FsbGJhY2spXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52dWUuJG9mZihldmVudCwgY2FsbGJhY2spXG4gICAgfVxuXG4gICAgLyoqXG5cdCAqIFJlbW92ZXMgYWxsIGxpc3RlbmVycyBmb3IgYSBnaXZlbiBldmVudC9zLlxuXHQgKlxuXHQgKiBAcGFyYW0ge09iamVjdH0gZXZlbnRcblx0ICogQHJldHVybiB7Vm9pZH1cblx0ICovXG4gICAgcmVtb3ZlTGlzdGVuZXJzRnJvbShldmVudClcbiAgICB7XG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KGV2ZW50KSkge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50LmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzLnZ1ZS4kb2ZmKGUpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG5cbiAgICAgICAgdGhpcy52dWUuJG9mZihldmVudClcbiAgICB9XG5cbiAgICAvKipcblx0ICogUmVtb3ZlcyBhbGwgZXZlbnQgbGlzdGVuZXJzLlxuXHQgKlxuXHQgKiBAcmV0dXJuIHtWb2lkfVxuXHQgKi9cbiAgICByZW1vdmVBbGwoKVxuICAgIHtcbiAgICAgICAgdGhpcy52dWUuJG9mZigpXG4gICAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cyA9IG5ldyBWdWVtaXQoKVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vbm9kZV9tb2R1bGVzL3Z1ZW1pdC9zcmMvVnVlbWl0LmpzIiwidmFyIGc7XHJcblxyXG4vLyBUaGlzIHdvcmtzIGluIG5vbi1zdHJpY3QgbW9kZVxyXG5nID0gKGZ1bmN0aW9uKCkge1xyXG5cdHJldHVybiB0aGlzO1xyXG59KSgpO1xyXG5cclxudHJ5IHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIGV2YWwgaXMgYWxsb3dlZCAoc2VlIENTUClcclxuXHRnID0gZyB8fCBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCkgfHwgKDEsZXZhbCkoXCJ0aGlzXCIpO1xyXG59IGNhdGNoKGUpIHtcclxuXHQvLyBUaGlzIHdvcmtzIGlmIHRoZSB3aW5kb3cgcmVmZXJlbmNlIGlzIGF2YWlsYWJsZVxyXG5cdGlmKHR5cGVvZiB3aW5kb3cgPT09IFwib2JqZWN0XCIpXHJcblx0XHRnID0gd2luZG93O1xyXG59XHJcblxyXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXHJcbi8vIFdlIHJldHVybiB1bmRlZmluZWQsIGluc3RlYWQgb2Ygbm90aGluZyBoZXJlLCBzbyBpdCdzXHJcbi8vIGVhc2llciB0byBoYW5kbGUgdGhpcyBjYXNlLiBpZighZ2xvYmFsKSB7IC4uLn1cclxuXHJcbm1vZHVsZS5leHBvcnRzID0gZztcclxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vICh3ZWJwYWNrKS9idWlsZGluL2dsb2JhbC5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xudmFyIF9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3tcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOnRydWUsXFxcInByZXNldHNcXFwiOltbXFxcImVudlxcXCIse1xcXCJtb2R1bGVzXFxcIjpmYWxzZSxcXFwidGFyZ2V0c1xcXCI6e1xcXCJicm93c2Vyc1xcXCI6W1xcXCI+IDIlXFxcIl0sXFxcInVnbGlmeVxcXCI6dHJ1ZX19XV0sXFxcInBsdWdpbnNcXFwiOltcXFwidHJhbnNmb3JtLW9iamVjdC1yZXN0LXNwcmVhZFxcXCIsW1xcXCJ0cmFuc2Zvcm0tcnVudGltZVxcXCIse1xcXCJwb2x5ZmlsbFxcXCI6ZmFsc2UsXFxcImhlbHBlcnNcXFwiOmZhbHNlfV1dfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi9jb250YWluZXIudnVlXCIpXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSBudWxsXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9hc3NldHMvanMvTWFpbi9jb250YWluZXIudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0yMzZkMTRmZFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTIzNmQxNGZkXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvTWFpbi9jb250YWluZXIudnVlXG4vLyBtb2R1bGUgaWQgPSAuL3Jlc291cmNlcy9hc3NldHMvanMvTWFpbi9jb250YWluZXIudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIHNjYW5Gb3JNaXNzaW5nKCkge1xuICAgICAgICAgICAgYXhpb3MuZ2V0KHRoaXMuc2NhbkZvck1pc3NpbmdSb3V0ZSlcbiAgICAgICAgICAgICAgICAudGhlbigoe2RhdGF9KSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmKGRhdGEubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgRXZlbnRIdWIuZmlyZSgnc2Nhbl9jb21wbGV0ZScsIHt0YWI6IHRoaXMuYWN0aXZlVGFifSlcbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZEFqYXgoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGFkZE5ld0xvY2FsZSgpIHtcbiAgICAgICAgICAgIGlmICghdGhpcy5uZXdfbG9jYWxlKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMubWlzc2luZ1ZhbCgpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy4kcmVmcy5sb2NhbGUuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBheGlvcy5wb3N0KHRoaXMuYWRkTmV3TG9jYWxlUm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGVfbmFtZSc6IHRoaXMubmV3X2xvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJyA6IHRoaXMuc2VsZWN0ZWREaXJOYW1lIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9KS50aGVuKCh7ZGF0YX0pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd05vdGlmKGRhdGEubWVzc2FnZSwgJ2RhbmdlcicpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dOb3RpZihkYXRhLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGwoWyduZXdfbG9jYWxlJ10pXG4gICAgICAgICAgICAgICAgICAgIEV2ZW50SHViLmZpcmUoJ25ld19sb2NhbGVfYWRkZWQnLCB7dGFiOiB0aGlzLmFjdGl2ZVRhYn0pXG5cbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZEFqYXgoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGFkZE5ld0ZpbGUoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV3X2ZpbGUpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW5nVmFsKClcbiAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgaWYgKCF0aGlzLm5ld19maWxlLmluY2x1ZGVzKCcucGhwJykpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5taXNzaW5nVmFsKCcucGhwID8hIScpXG4gICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIGlmICghdGhpcy4kcmVmcy5maWxlLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IGZpbGVfbmFtZSA9IHRoaXMubmV3X2ZpbGVcblxuICAgICAgICAgICAgICAgIGF4aW9zLnBvc3QodGhpcy5hZGROZXdGaWxlUm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGVfbmFtZSc6IGZpbGVfbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJyA6IHRoaXMuc2VsZWN0ZWREaXJOYW1lIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9KS50aGVuKCh7ZGF0YX0pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuc2hvd05vdGlmKGRhdGEubWVzc2FnZSwgJ2RhbmdlcicpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNob3dOb3RpZihkYXRhLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVzZXRBbGwoWyduZXdfZmlsZScsICdmaWxlc0xpc3QnXSlcblxuICAgICAgICAgICAgICAgICAgICBFdmVudEh1Yi5maXJlKCduZXdfZmlsZV9hZGRlZCcsIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhYjogdGhpcy5hY3RpdmVUYWIsXG4gICAgICAgICAgICAgICAgICAgICAgICB2YWw6IGZpbGVfbmFtZVxuICAgICAgICAgICAgICAgICAgICB9KVxuXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5mYWlsZWRBamF4KClcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICBhZGROZXdWZW5kb3IoKSB7XG4gICAgICAgICAgICBpZiAoIXRoaXMubmV3X3ZlbmRvcikge1xuICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLm1pc3NpbmdWYWwoKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoIXRoaXMuJHJlZnMudmVuZG9yLmRpc2FibGVkKSB7XG4gICAgICAgICAgICAgICAgbGV0IHZlbmRvcl9uYW1lID0gdGhpcy5uZXdfdmVuZG9yXG5cbiAgICAgICAgICAgICAgICBheGlvcy5wb3N0KHRoaXMuYWRkTmV3VmVuZG9yUm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJyA6IHZlbmRvcl9uYW1lXG4gICAgICAgICAgICAgICAgfSkudGhlbigoe2RhdGF9KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnNob3dOb3RpZihkYXRhLm1lc3NhZ2UsICdkYW5nZXInKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zaG93Tm90aWYoZGF0YS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWxsKFsnbmV3X3ZlbmRvciddKVxuICAgICAgICAgICAgICAgICAgICBFdmVudEh1Yi5maXJlKCduZXdfdmVuZG9yX2FkZGVkJywgdmVuZG9yX25hbWUpXG5cbiAgICAgICAgICAgICAgICB9KS5jYXRjaCgoZXJyKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnNvbGUuZXJyb3IoZXJyKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLmZhaWxlZEFqYXgoKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG59XG5cblxuXG4vLyBXRUJQQUNLIEZPT1RFUiAvL1xuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL01haW4vZm9ybXMuanMiLCJ2YXIgZGlzcG9zZWQgPSBmYWxzZVxudmFyIG5vcm1hbGl6ZUNvbXBvbmVudCA9IHJlcXVpcmUoXCIhLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL2NvbXBvbmVudC1ub3JtYWxpemVyXCIpXG4vKiBzY3JpcHQgKi9cbnZhciBfX3Z1ZV9zY3JpcHRfXyA9IHJlcXVpcmUoXCIhIWJhYmVsLWxvYWRlcj97XFxcImNhY2hlRGlyZWN0b3J5XFxcIjp0cnVlLFxcXCJwcmVzZXRzXFxcIjpbW1xcXCJlbnZcXFwiLHtcXFwibW9kdWxlc1xcXCI6ZmFsc2UsXFxcInRhcmdldHNcXFwiOntcXFwiYnJvd3NlcnNcXFwiOltcXFwiPiAyJVxcXCJdLFxcXCJ1Z2xpZnlcXFwiOnRydWV9fV1dLFxcXCJwbHVnaW5zXFxcIjpbXFxcInRyYW5zZm9ybS1vYmplY3QtcmVzdC1zcHJlYWRcXFwiLFtcXFwidHJhbnNmb3JtLXJ1bnRpbWVcXFwiLHtcXFwicG9seWZpbGxcXFwiOmZhbHNlLFxcXCJoZWxwZXJzXFxcIjpmYWxzZX1dXX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c2NyaXB0JmluZGV4PTAmYnVzdENhY2hlIS4vZGVmYXVsdC52dWVcIilcbi8qIHRlbXBsYXRlICovXG52YXIgX192dWVfdGVtcGxhdGVfXyA9IHJlcXVpcmUoXCIhIS4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi90ZW1wbGF0ZS1jb21waWxlci9pbmRleD97XFxcImlkXFxcIjpcXFwiZGF0YS12LWY0MzY5M2ZjXFxcIixcXFwiaGFzU2NvcGVkXFxcIjpmYWxzZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL2RlZmF1bHQudnVlXCIpXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9hc3NldHMvanMvVGFicy9kZWZhdWx0LnZ1ZVwiXG5pZiAoQ29tcG9uZW50LmVzTW9kdWxlICYmIE9iamVjdC5rZXlzKENvbXBvbmVudC5lc01vZHVsZSkuc29tZShmdW5jdGlvbiAoa2V5KSB7ICByZXR1cm4ga2V5ICE9PSBcImRlZmF1bHRcIiAmJiBrZXkuc3Vic3RyKDAsIDIpICE9PSBcIl9fXCJ9KSkgeyAgY29uc29sZS5lcnJvcihcIm5hbWVkIGV4cG9ydHMgYXJlIG5vdCBzdXBwb3J0ZWQgaW4gKi52dWUgZmlsZXMuXCIpfVxuXG4vKiBob3QgcmVsb2FkICovXG5pZiAobW9kdWxlLmhvdCkgeyhmdW5jdGlvbiAoKSB7XG4gIHZhciBob3RBUEkgPSByZXF1aXJlKFwidnVlLWhvdC1yZWxvYWQtYXBpXCIpXG4gIGhvdEFQSS5pbnN0YWxsKHJlcXVpcmUoXCJ2dWVcIiksIGZhbHNlKVxuICBpZiAoIWhvdEFQSS5jb21wYXRpYmxlKSByZXR1cm5cbiAgbW9kdWxlLmhvdC5hY2NlcHQoKVxuICBpZiAoIW1vZHVsZS5ob3QuZGF0YSkge1xuICAgIGhvdEFQSS5jcmVhdGVSZWNvcmQoXCJkYXRhLXYtZjQzNjkzZmNcIiwgQ29tcG9uZW50Lm9wdGlvbnMpXG4gIH0gZWxzZSB7XG4gICAgaG90QVBJLnJlbG9hZChcImRhdGEtdi1mNDM2OTNmY1wiLCBDb21wb25lbnQub3B0aW9ucylcbicgKyAnICB9XG4gIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoZGF0YSkge1xuICAgIGRpc3Bvc2VkID0gdHJ1ZVxuICB9KVxufSkoKX1cblxubW9kdWxlLmV4cG9ydHMgPSBDb21wb25lbnQuZXhwb3J0c1xuXG5cblxuLy8vLy8vLy8vLy8vLy8vLy8vXG4vLyBXRUJQQUNLIEZPT1RFUlxuLy8gLi9yZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvZGVmYXVsdC52dWVcbi8vIG1vZHVsZSBpZCA9IC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL2RlZmF1bHQudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsImV4cG9ydCBkZWZhdWx0IHtcbiAgICBkYXRhKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgcm91dGVzOiB7XG4gICAgICAgICAgICAgICAgZmlsZXNSb3V0ZSA6IHRoaXMuJHBhcmVudC5maWxlc1JvdXRlLFxuICAgICAgICAgICAgICAgIHNlbGVjdGVkRmlsZURhdGFSb3V0ZSA6IHRoaXMuJHBhcmVudC5zZWxlY3RlZEZpbGVEYXRhUm91dGUsXG4gICAgICAgICAgICAgICAgZGVsZXRlRmlsZVJvdXRlIDogdGhpcy4kcGFyZW50LmRlbGV0ZUZpbGVSb3V0ZSxcbiAgICAgICAgICAgICAgICBkZWxldGVMb2NhbGVSb3V0ZSA6IHRoaXMuJHBhcmVudC5kZWxldGVMb2NhbGVSb3V0ZSxcbiAgICAgICAgICAgICAgICBzYXZlRmlsZVJvdXRlIDogdGhpcy4kcGFyZW50LnNhdmVGaWxlUm91dGVcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBmaWxlczogW10sXG4gICAgICAgICAgICBzZWxlY3RlZEZpbGU6ICcnLFxuICAgICAgICAgICAgbG9jYWxlczogW10sXG4gICAgICAgICAgICBzZWxlY3RlZEZpbGVEYXRhOiAnJyxcbiAgICAgICAgICAgIHNlbGVjdGVkRmlsZURhdGFDbG9uZTogJycsXG4gICAgICAgICAgICBuZXdLZXlzOiAnJyxcbiAgICAgICAgICAgIGRhdGFDaGFuZ2VkOiBmYWxzZSxcbiAgICAgICAgICAgIG5ld0l0ZW1Db3VudGVyOiAwLFxuICAgICAgICAgICAga2V5VG9Db3B5IDogJycsXG4gICAgICAgICAgICBjdXJyZW50SW5wdXRSZWY6ICcnXG4gICAgICAgIH1cbiAgICB9LFxuICAgIG1vdW50ZWQoKSB7XG4gICAgICAgIHRoaXMuJHRpcHB5LmZvcmNlVXBkYXRlSHRtbCgpXG5cbiAgICAgICAgRXZlbnRIdWIubGlzdGVuKCdscy1maWxlJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLnRhYiA9PSB0aGlzLmdldFRhYk5hbWUoKSkge1xuICAgICAgICAgICAgICAgIHNldFRpbWVvdXQoKCkgPT4ge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZSA9IGRhdGEudmFsXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGRhdGEudmFsID09ICcnICYmIHRoaXMuZ2V0VGFiTmFtZSgpLmluY2x1ZGVzKCd2ZW5kb3InKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy4kcGFyZW50LmZpbGVzTGlzdCA9IFtdXG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9LCA1MClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBFdmVudEh1Yi5saXN0ZW4oJ3NjYW5fY29tcGxldGUnLCAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgaWYgKGRhdGEudGFiID09IHRoaXMuZ2V0VGFiTmFtZSgpICYmIHRoaXMuc2VsZWN0ZWRGaWxlICE9PSAnJykge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RmlsZUNvbnRlbnQoKVxuICAgICAgICAgICAgfVxuICAgICAgICB9KVxuXG4gICAgICAgIEV2ZW50SHViLmxpc3RlbignbmV3X2xvY2FsZV9hZGRlZCcsIChkYXRhKSA9PiB7XG4gICAgICAgICAgICBpZiAoZGF0YS50YWIgPT0gdGhpcy5nZXRUYWJOYW1lKCkpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmdldEZpbGVDb250ZW50KClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICBFdmVudEh1Yi5saXN0ZW4oJ25ld19maWxlX2FkZGVkJywgKGRhdGEpID0+IHtcbiAgICAgICAgICAgIGlmIChkYXRhLnRhYiA9PSB0aGlzLmdldFRhYk5hbWUoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZ2V0RmlsZXMoKVxuXG4gICAgICAgICAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlID0gZGF0YS52YWxcbiAgICAgICAgICAgICAgICB9LCA1MClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSlcblxuICAgICAgICAvLyBiZWZvcmUgcmVmcmVzaFxuICAgICAgICB3aW5kb3cub25iZWZvcmV1bmxvYWQgPSAoKSA9PiB7XG4gICAgICAgICAgICBpZiAodGhpcy5kYXRhQ2hhbmdlZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjb25maXJtKCdDb25maXJtIHJlZnJlc2gnKVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICAgICAgLy8gY29weSB0byBjbGlwYm9hcmRcbiAgICAgICAgZG9jdW1lbnQuYm9keS5vbmNsaWNrID0gKGUpID0+IHtcbiAgICAgICAgICAgIGUgPSB3aW5kb3cuZXZlbnQgPyBlLnNyY0VsZW1lbnQgOiBlLnRhcmdldFxuICAgICAgICAgICAgaWYgKGUuY2xhc3NOYW1lICYmIGUuY2xhc3NOYW1lLmluZGV4T2YoJ2MyYycpICE9IC0xKSB7XG4gICAgICAgICAgICAgICAgdGhpcy4kY29weVRleHQodGhpcy5rZXlUb0NvcHkpXG4gICAgICAgICAgICAgICAgdGhpcy5yZWZvY3VzKClcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sXG4gICAgYWN0aXZhdGVkKCkge1xuICAgICAgICBpZiAodGhpcy4kcGFyZW50LmFjdGl2ZVRhYiA9PSB0aGlzLmdldFRhYk5hbWUoKSkge1xuICAgICAgICAgICAgdGhpcy4kcGFyZW50LmRpcnNMaXN0ID0gdGhpcy5kaXJzXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuc2VsZWN0ZWREaXJOYW1lID0gdGhpcy5zZWxlY3RlZERpclxuICAgICAgICAgICAgdGhpcy4kcGFyZW50LmxvY2FsZXNMaXN0ID0gdGhpcy5sb2NhbGVzXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuc2VsZWN0ZWRGaWxlTmFtZSA9IHRoaXMuc2VsZWN0ZWRGaWxlXG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQuZmlsZXNMaXN0ID0gdGhpcy5maWxlc1xuICAgICAgICB9XG4gICAgfSxcbiAgICBtZXRob2RzOiB7XG4gICAgICAgIC8vIGRhdGFcbiAgICAgICAgZ2V0RmlsZUNvbnRlbnQoKSB7XG4gICAgICAgICAgICBheGlvcy5wb3N0KHRoaXMucm91dGVzLnNlbGVjdGVkRmlsZURhdGFSb3V0ZSwge1xuICAgICAgICAgICAgICAgICdmaWxlX25hbWUnOiB0aGlzLnNlbGVjdGVkRmlsZSB8fCBudWxsLFxuICAgICAgICAgICAgICAgICdkaXJfbmFtZSc6IHRoaXMuc2VsZWN0ZWREaXIgfHwgbnVsbFxuICAgICAgICAgICAgfSkudGhlbigoe2RhdGF9KSA9PiB7XG5cbiAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5yZXNldEFsbChbJ3NlbGVjdGVkRmlsZScsICdmaWxlcyddKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlcyA9IGRhdGEubWVzc2FnZS5sb2NhbGVzXG4gICAgICAgICAgICAgICAgbGV0IGFsbCA9IGRhdGEubWVzc2FnZS5hbGxcbiAgICAgICAgICAgICAgICBpZiAoYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc2VsZWN0ZWRGaWxlRGF0YSA9IGFsbFxuICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRmlsZURhdGFDbG9uZSA9IEpTT04ucGFyc2UoSlNPTi5zdHJpbmdpZnkoYWxsKSlcbiAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICB0aGlzLiRwYXJlbnQuZmFpbGVkQWpheCgpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9LFxuXG4gICAgICAgIC8vIHNoYXJlZC1jb250ZW50XG4gICAgICAgIHRyYW5zKGtleSkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWV0aG9kKCd0cmFucycsIGtleSkgfHwgJydcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0VGFiTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLiRvcHRpb25zLm5hbWVcbiAgICAgICAgfSxcbiAgICAgICAgcmVzZXRBbGwoaXRlbXMpIHtcbiAgICAgICAgICAgIGl0ZW1zLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICB0aGlzW2VdID0gJydcbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIHNob3dOb3RpZihtc2csIHMgPSAnc3VjY2VzcycpIHtcbiAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdzaG93Tm90aWYnLCAobXNnLCBzKSlcbiAgICAgICAgfSxcbiAgICAgICAgZmFpbGVkQWpheCgpIHtcbiAgICAgICAgICAgIHRoaXMuc2hvd05vdGlmKHRoaXMudHJhbnMoJ2FqYXhfZXJyb3InKSwgJ2JsYWNrJylcbiAgICAgICAgfSxcbiAgICAgICAgcGFyZW50TWV0aG9kKG1ldGhvZF9uYW1lLCBhcmdzID0gbnVsbCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuJHBhcmVudFttZXRob2RfbmFtZV0oYXJncylcbiAgICAgICAgfSxcblxuICAgICAgICAvLyBjb3B5IGtleVxuICAgICAgICBnZXRGaWxlTmFtZSgpIHtcbiAgICAgICAgICAgIHJldHVybiB0aGlzLnNlbGVjdGVkRmlsZS5yZXBsYWNlKC8oLlteLl0qKSQvLCAnJylcbiAgICAgICAgfSxcbiAgICAgICAgZ2V0S2V5KGtleSkge1xuICAgICAgICAgICAgbGV0IHN0ciA9IHRoaXMuZ2V0VGFiTmFtZSgpLmluY2x1ZGVzKCd2ZW5kb3InKVxuICAgICAgICAgICAgICAgID8gYCR7dGhpcy5zZWxlY3RlZERpcn06OiR7dGhpcy5nZXRGaWxlTmFtZSgpfS4ke2tleX1gXG4gICAgICAgICAgICAgICAgOiBgJHt0aGlzLmdldEZpbGVOYW1lKCl9LiR7a2V5fWBcblxuICAgICAgICAgICAgbGV0IHJlcCA9IHRoaXMuJHBhcmVudC5zZWxlY3RlZEtleUZvcm1hdCAhPT0gJydcbiAgICAgICAgICAgICAgICA/IHRoaXMuJHBhcmVudC5zZWxlY3RlZEtleUZvcm1hdC5yZXBsYWNlKCd2YWx1ZScsIHN0cilcbiAgICAgICAgICAgICAgICA6IGAnJHtzdHJ9J2BcblxuICAgICAgICAgICAgcmV0dXJuIHJlcFxuICAgICAgICB9LFxuICAgICAgICByZWZvY3VzKCkge1xuICAgICAgICAgICAgaWYgKHRoaXMuY3VycmVudElucHV0UmVmKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3VycmVudElucHV0UmVmLnRhcmdldC5mb2N1cygpXG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9LFxuICAgIHdhdGNoOiB7XG4gICAgICAgIHNlbGVjdGVkRmlsZURhdGFDbG9uZSh2YWwpIHtcbiAgICAgICAgICAgIHRoaXMuJG5leHRUaWNrKCgpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAoT2JqZWN0LmtleXModmFsKS5sZW5ndGggPT0gMCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0QWxsKFsnbmV3S2V5cyddKVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pXG4gICAgICAgIH0sXG4gICAgICAgIGxvY2FsZXModmFsKSB7XG4gICAgICAgICAgICB0aGlzLiRwYXJlbnQubG9jYWxlc0xpc3QgPSB2YWxcbiAgICAgICAgfSxcbiAgICAgICAgc2VsZWN0ZWRGaWxlKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcGFyZW50LnNlbGVjdGVkRmlsZU5hbWUgPSB2YWxcbiAgICAgICAgICAgIHRoaXMuZGF0YUNoYW5nZWQgPSBmYWxzZVxuICAgICAgICAgICAgdGhpcy5yZXNldEFsbChbJ25ld0tleXMnLCAnY3VycmVudElucHV0UmVmJywgJ2tleVRvQ29weSddKVxuXG4gICAgICAgICAgICBpZiAodmFsKSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuZ2V0VGFiTmFtZSgpLmluY2x1ZGVzKCd2ZW5kb3InKSAmJiAhdGhpcy5zZWxlY3RlZERpck5hbWUpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuXG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgdGhpcy5nZXRGaWxlQ29udGVudCgpXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIGZpbGVzKHZhbCkge1xuICAgICAgICAgICAgdGhpcy4kcGFyZW50LmZpbGVzTGlzdCA9IHZhbFxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL29wcy5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG5mdW5jdGlvbiBpbmplY3RTdHlsZSAoc3NyQ29udGV4dCkge1xuICBpZiAoZGlzcG9zZWQpIHJldHVyblxuICByZXF1aXJlKFwiISF2dWUtc3R5bGUtbG9hZGVyIWNzcy1sb2FkZXI/c291cmNlTWFwIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zdHlsZS1jb21waWxlci9pbmRleD97XFxcInZ1ZVxcXCI6dHJ1ZSxcXFwiaWRcXFwiOlxcXCJkYXRhLXYtMzE0MzMzYzRcXFwiLFxcXCJzY29wZWRcXFwiOnRydWUsXFxcImhhc0lubGluZUNvbmZpZ1xcXCI6dHJ1ZX0hLi4vLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9c3R5bGVzJmluZGV4PTAmYnVzdENhY2hlIS4vY29udGVudC52dWVcIilcbn1cbnZhciBub3JtYWxpemVDb21wb25lbnQgPSByZXF1aXJlKFwiIS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9jb21wb25lbnQtbm9ybWFsaXplclwiKVxuLyogc2NyaXB0ICovXG52YXIgX192dWVfc2NyaXB0X18gPSByZXF1aXJlKFwiISFiYWJlbC1sb2FkZXI/e1xcXCJjYWNoZURpcmVjdG9yeVxcXCI6dHJ1ZSxcXFwicHJlc2V0c1xcXCI6W1tcXFwiZW52XFxcIix7XFxcIm1vZHVsZXNcXFwiOmZhbHNlLFxcXCJ0YXJnZXRzXFxcIjp7XFxcImJyb3dzZXJzXFxcIjpbXFxcIj4gMiVcXFwiXSxcXFwidWdsaWZ5XFxcIjp0cnVlfX1dXSxcXFwicGx1Z2luc1xcXCI6W1xcXCJ0cmFuc2Zvcm0tb2JqZWN0LXJlc3Qtc3ByZWFkXFxcIixbXFxcInRyYW5zZm9ybS1ydW50aW1lXFxcIix7XFxcInBvbHlmaWxsXFxcIjpmYWxzZSxcXFwiaGVscGVyc1xcXCI6ZmFsc2V9XV19IS4uLy4uLy4uLy4uLy4uL25vZGVfbW9kdWxlcy92dWUtbG9hZGVyL2xpYi9zZWxlY3Rvcj90eXBlPXNjcmlwdCZpbmRleD0wJmJ1c3RDYWNoZSEuL2NvbnRlbnQudnVlXCIpXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0zMTQzMzNjNFxcXCIsXFxcImhhc1Njb3BlZFxcXCI6dHJ1ZSxcXFwiYnVibGVcXFwiOntcXFwidHJhbnNmb3Jtc1xcXCI6e319fSEuLi8uLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT10ZW1wbGF0ZSZpbmRleD0wJmJ1c3RDYWNoZSEuL2NvbnRlbnQudnVlXCIpXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gaW5qZWN0U3R5bGVcbi8qIHNjb3BlSWQgKi9cbnZhciBfX3Z1ZV9zY29wZUlkX18gPSBcImRhdGEtdi0zMTQzMzNjNFwiXG4vKiBtb2R1bGVJZGVudGlmaWVyIChzZXJ2ZXIgb25seSkgKi9cbnZhciBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fID0gbnVsbFxudmFyIENvbXBvbmVudCA9IG5vcm1hbGl6ZUNvbXBvbmVudChcbiAgX192dWVfc2NyaXB0X18sXG4gIF9fdnVlX3RlbXBsYXRlX18sXG4gIF9fdnVlX3RlbXBsYXRlX2Z1bmN0aW9uYWxfXyxcbiAgX192dWVfc3R5bGVzX18sXG4gIF9fdnVlX3Njb3BlSWRfXyxcbiAgX192dWVfbW9kdWxlX2lkZW50aWZpZXJfX1xuKVxuQ29tcG9uZW50Lm9wdGlvbnMuX19maWxlID0gXCJyZXNvdXJjZXMvYXNzZXRzL2pzL1RhYnMvc2hhcmVkL2NvbnRlbnQudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0zMTQzMzNjNFwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTMxNDMzM2M0XCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy9zaGFyZWQvY29udGVudC52dWVcbi8vIG1vZHVsZSBpZCA9IC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9jb250ZW50LnZ1ZVxuLy8gbW9kdWxlIGNodW5rcyA9IDAiLCJleHBvcnQgZGVmYXVsdCB7XG4gICAgbWV0aG9kczoge1xuICAgICAgICByZW1vdmVTZWxlY3RlZEZpbGUoKSB7XG4gICAgICAgICAgICBpZiAoY29uZmlybSh0aGlzLnRyYW5zKCd5b3Vfc3VyZV9maWxlJykpKSB7XG5cbiAgICAgICAgICAgICAgICBsZXQgcmVtb3ZlZEZpbGUgPSB0aGlzLnNlbGVjdGVkRmlsZVxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RGlyID0gdGhpcy5zZWxlY3RlZERpclxuICAgICAgICAgICAgICAgIGxldCBjdXJyZW50RmlsZXMgPSBPYmplY3QudmFsdWVzKHRoaXMuZmlsZXMpXG4gICAgICAgICAgICAgICAgbGV0IGxhc3RJdGVtID0gY3VycmVudEZpbGVzLmxlbmd0aCA9PSAxICYmIGN1cnJlbnRGaWxlc1swXSA9PSByZW1vdmVkRmlsZVxuXG4gICAgICAgICAgICAgICAgYXhpb3MucG9zdCh0aGlzLnJvdXRlcy5kZWxldGVGaWxlUm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2ZpbGVfbmFtZSc6IHJlbW92ZWRGaWxlLFxuICAgICAgICAgICAgICAgICAgICAnZGlyX25hbWUnOiBjdXJyZW50RGlyIHx8IG51bGxcbiAgICAgICAgICAgICAgICB9KS50aGVuKCh7ZGF0YX0pID0+IHtcblxuICAgICAgICAgICAgICAgICAgICBpZiAoIWRhdGEuc3VjY2Vzcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMucGFyZW50TWV0aG9kKCdzaG93Tm90aWYnLCAoZGF0YS5tZXNzYWdlLCAnZGFuZ2VyJykpXG4gICAgICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgnc2hvd05vdGlmJywgZGF0YS5tZXNzYWdlKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgncmVzZXRBbGwnLCBbJ3NlbGVjdGVkRmlsZScsICdzZWxlY3RlZERpciddKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnJlc2V0RGF0YSgpXG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKGxhc3RJdGVtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnNlbGVjdGVkRGlyID0gY3VycmVudERpclxuXG4gICAgICAgICAgICAgICAgICAgICAgICAvLyByZW1vdmUgbG9jYWxlcyBhcyB0aGV5IGFyZSB1c2VsZXNzXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5sb2NhbGVzLmZvckVhY2goKGUpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLnJlbW92ZUxvY2FsZShlLCAneScpXG4gICAgICAgICAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5sb2NhbGVzID0gW11cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZERpciA9IGN1cnJlbnREaXJcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZXRob2QoJ2dldEZpbGVzJylcblxuICAgICAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc29sZS5lcnJvcihlcnIpXG4gICAgICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdmYWlsZWRBamF4JylcbiAgICAgICAgICAgICAgICB9KVxuICAgICAgICAgICAgfVxuICAgICAgICB9LFxuICAgICAgICByZW1vdmVMb2NhbGUobG9jYWxlLCBvdmVycmlkZSA9IG51bGwpIHtcbiAgICAgICAgICAgIGlmIChvdmVycmlkZSB8fCBjb25maXJtKHRoaXMudHJhbnMoJ3lvdV9zdXJlX2xvY2FsZScpKSkge1xuICAgICAgICAgICAgICAgIGF4aW9zLnBvc3QodGhpcy5yb3V0ZXMuZGVsZXRlTG9jYWxlUm91dGUsIHtcbiAgICAgICAgICAgICAgICAgICAgJ2xvY2FsZSc6IGxvY2FsZSxcbiAgICAgICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJzogdGhpcy5zZWxlY3RlZERpciB8fCBudWxsXG4gICAgICAgICAgICAgICAgfSkudGhlbigoe2RhdGF9KSA9PiB7XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFkYXRhLnN1Y2Nlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudE1ldGhvZCgnc2hvd05vdGlmJywgKGRhdGEubWVzc2FnZSwgJ2RhbmdlcicpKVxuICAgICAgICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFvdmVycmlkZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZXRob2QoJ3Nob3dOb3RpZicsIGRhdGEubWVzc2FnZSlcbiAgICAgICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgICAgIHRoaXMubG9jYWxlcy5zcGxpY2UobG9jYWxlLCAxKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgnZ2V0RmlsZUNvbnRlbnQnKVxuXG4gICAgICAgICAgICAgICAgfSkuY2F0Y2goKGVycikgPT4ge1xuICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wYXJlbnRNZXRob2QoJ2ZhaWxlZEFqYXgnKVxuICAgICAgICAgICAgICAgIH0pXG4gICAgICAgICAgICB9XG4gICAgICAgIH0sXG4gICAgICAgIHN1Ym1pdE5ld0RhdGEoKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5kb250SGF2ZURhdGEoKSkge1xuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdzaG93Tm90aWYnLCAodGhpcy50cmFucygnZW1wdHlfZmlsZScpLCAnd2FybmluZycpKVxuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBheGlvcy5wb3N0KHRoaXMucm91dGVzLnNhdmVGaWxlUm91dGUsIHtcbiAgICAgICAgICAgICAgICAnZmlsZV9uYW1lJzogdGhpcy5zZWxlY3RlZEZpbGUsXG4gICAgICAgICAgICAgICAgJ2Rpcl9uYW1lJzogdGhpcy5zZWxlY3RlZERpciB8fCBudWxsLFxuICAgICAgICAgICAgICAgIGRhdGE6IHRoaXMuZm9ybWF0RGF0YSgpXG4gICAgICAgICAgICB9KS50aGVuKCh7ZGF0YX0pID0+IHtcblxuICAgICAgICAgICAgICAgIGlmICghZGF0YS5zdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0aGlzLnBhcmVudE1ldGhvZCgnc2hvd05vdGlmJywgKGRhdGEubWVzc2FnZSwgJ2RhbmdlcicpKVxuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHRoaXMucGFyZW50TWV0aG9kKCdzaG93Tm90aWYnLCBkYXRhLm1lc3NhZ2UpXG4gICAgICAgICAgICAgICAgdGhpcy5kYXRhQ2hhbmdlZCA9IGZhbHNlXG4gICAgICAgICAgICAgICAgdGhpcy5zZWxlY3RlZEZpbGVEYXRhID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5zZWxlY3RlZEZpbGVEYXRhQ2xvbmUpXG5cbiAgICAgICAgICAgIH0pLmNhdGNoKChlcnIpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVycilcbiAgICAgICAgICAgICAgICB0aGlzLnBhcmVudE1ldGhvZCgnZmFpbGVkQWpheCcpXG4gICAgICAgICAgICB9KVxuICAgICAgICB9XG4gICAgfVxufVxuXG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9UYWJzL3NoYXJlZC9mb3Jtcy5qcyIsInZhciBkaXNwb3NlZCA9IGZhbHNlXG52YXIgbm9ybWFsaXplQ29tcG9uZW50ID0gcmVxdWlyZShcIiEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvY29tcG9uZW50LW5vcm1hbGl6ZXJcIilcbi8qIHNjcmlwdCAqL1xudmFyIF9fdnVlX3NjcmlwdF9fID0gcmVxdWlyZShcIiEhYmFiZWwtbG9hZGVyP3tcXFwiY2FjaGVEaXJlY3RvcnlcXFwiOnRydWUsXFxcInByZXNldHNcXFwiOltbXFxcImVudlxcXCIse1xcXCJtb2R1bGVzXFxcIjpmYWxzZSxcXFwidGFyZ2V0c1xcXCI6e1xcXCJicm93c2Vyc1xcXCI6W1xcXCI+IDIlXFxcIl0sXFxcInVnbGlmeVxcXCI6dHJ1ZX19XV0sXFxcInBsdWdpbnNcXFwiOltcXFwidHJhbnNmb3JtLW9iamVjdC1yZXN0LXNwcmVhZFxcXCIsW1xcXCJ0cmFuc2Zvcm0tcnVudGltZVxcXCIse1xcXCJwb2x5ZmlsbFxcXCI6ZmFsc2UsXFxcImhlbHBlcnNcXFwiOmZhbHNlfV1dfSEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvc2VsZWN0b3I/dHlwZT1zY3JpcHQmaW5kZXg9MCZidXN0Q2FjaGUhLi92ZW5kb3IudnVlXCIpXG4vKiB0ZW1wbGF0ZSAqL1xudmFyIF9fdnVlX3RlbXBsYXRlX18gPSByZXF1aXJlKFwiISEuLi8uLi8uLi8uLi9ub2RlX21vZHVsZXMvdnVlLWxvYWRlci9saWIvdGVtcGxhdGUtY29tcGlsZXIvaW5kZXg/e1xcXCJpZFxcXCI6XFxcImRhdGEtdi0wNjIzMzVkMlxcXCIsXFxcImhhc1Njb3BlZFxcXCI6ZmFsc2UsXFxcImJ1YmxlXFxcIjp7XFxcInRyYW5zZm9ybXNcXFwiOnt9fX0hLi4vLi4vLi4vLi4vbm9kZV9tb2R1bGVzL3Z1ZS1sb2FkZXIvbGliL3NlbGVjdG9yP3R5cGU9dGVtcGxhdGUmaW5kZXg9MCZidXN0Q2FjaGUhLi92ZW5kb3IudnVlXCIpXG4vKiB0ZW1wbGF0ZSBmdW5jdGlvbmFsICovXG52YXIgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fID0gZmFsc2Vcbi8qIHN0eWxlcyAqL1xudmFyIF9fdnVlX3N0eWxlc19fID0gbnVsbFxuLyogc2NvcGVJZCAqL1xudmFyIF9fdnVlX3Njb3BlSWRfXyA9IG51bGxcbi8qIG1vZHVsZUlkZW50aWZpZXIgKHNlcnZlciBvbmx5KSAqL1xudmFyIF9fdnVlX21vZHVsZV9pZGVudGlmaWVyX18gPSBudWxsXG52YXIgQ29tcG9uZW50ID0gbm9ybWFsaXplQ29tcG9uZW50KFxuICBfX3Z1ZV9zY3JpcHRfXyxcbiAgX192dWVfdGVtcGxhdGVfXyxcbiAgX192dWVfdGVtcGxhdGVfZnVuY3Rpb25hbF9fLFxuICBfX3Z1ZV9zdHlsZXNfXyxcbiAgX192dWVfc2NvcGVJZF9fLFxuICBfX3Z1ZV9tb2R1bGVfaWRlbnRpZmllcl9fXG4pXG5Db21wb25lbnQub3B0aW9ucy5fX2ZpbGUgPSBcInJlc291cmNlcy9hc3NldHMvanMvVGFicy92ZW5kb3IudnVlXCJcbmlmIChDb21wb25lbnQuZXNNb2R1bGUgJiYgT2JqZWN0LmtleXMoQ29tcG9uZW50LmVzTW9kdWxlKS5zb21lKGZ1bmN0aW9uIChrZXkpIHsgIHJldHVybiBrZXkgIT09IFwiZGVmYXVsdFwiICYmIGtleS5zdWJzdHIoMCwgMikgIT09IFwiX19cIn0pKSB7ICBjb25zb2xlLmVycm9yKFwibmFtZWQgZXhwb3J0cyBhcmUgbm90IHN1cHBvcnRlZCBpbiAqLnZ1ZSBmaWxlcy5cIil9XG5cbi8qIGhvdCByZWxvYWQgKi9cbmlmIChtb2R1bGUuaG90KSB7KGZ1bmN0aW9uICgpIHtcbiAgdmFyIGhvdEFQSSA9IHJlcXVpcmUoXCJ2dWUtaG90LXJlbG9hZC1hcGlcIilcbiAgaG90QVBJLmluc3RhbGwocmVxdWlyZShcInZ1ZVwiKSwgZmFsc2UpXG4gIGlmICghaG90QVBJLmNvbXBhdGlibGUpIHJldHVyblxuICBtb2R1bGUuaG90LmFjY2VwdCgpXG4gIGlmICghbW9kdWxlLmhvdC5kYXRhKSB7XG4gICAgaG90QVBJLmNyZWF0ZVJlY29yZChcImRhdGEtdi0wNjIzMzVkMlwiLCBDb21wb25lbnQub3B0aW9ucylcbiAgfSBlbHNlIHtcbiAgICBob3RBUEkucmVsb2FkKFwiZGF0YS12LTA2MjMzNWQyXCIsIENvbXBvbmVudC5vcHRpb25zKVxuJyArICcgIH1cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgZGlzcG9zZWQgPSB0cnVlXG4gIH0pXG59KSgpfVxuXG5tb2R1bGUuZXhwb3J0cyA9IENvbXBvbmVudC5leHBvcnRzXG5cblxuXG4vLy8vLy8vLy8vLy8vLy8vLy9cbi8vIFdFQlBBQ0sgRk9PVEVSXG4vLyAuL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy92ZW5kb3IudnVlXG4vLyBtb2R1bGUgaWQgPSAuL3Jlc291cmNlcy9hc3NldHMvanMvVGFicy92ZW5kb3IudnVlXG4vLyBtb2R1bGUgY2h1bmtzID0gMCIsIi8qICAgICAgICAgICAgICAgIExpYnMgICAgICAgICAgICAgICAgKi9cbndpbmRvdy5WdWUgPSByZXF1aXJlKCd2dWUnKVxud2luZG93LkV2ZW50SHViID0gcmVxdWlyZSgndnVlbWl0JylcblZ1ZS51c2UocmVxdWlyZSgndnVlLXRpcHB5JykpXG5WdWUudXNlKHJlcXVpcmUoJ3Z1ZS1jbGlwYm9hcmQyJykpXG5WdWUudXNlKHJlcXVpcmUoJ3Z1ZS1scycpKVxuXG4vLyBheGlvc1xud2luZG93LmF4aW9zID0gcmVxdWlyZSgnYXhpb3MnKVxuYXhpb3MuZGVmYXVsdHMuaGVhZGVycy5jb21tb24gPSB7XG4gICAgJ1gtQ1NSRi1UT0tFTic6IGRvY3VtZW50LnF1ZXJ5U2VsZWN0b3IoJ21ldGFbbmFtZT1cImNzcmYtdG9rZW5cIl0nKS5nZXRBdHRyaWJ1dGUoJ2NvbnRlbnQnKSxcbiAgICAnWC1SZXF1ZXN0ZWQtV2l0aCc6ICdYTUxIdHRwUmVxdWVzdCdcbn1cbi8vIHZ1ZS1hd2Vzb21lXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL3RyYXNoJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9zZWFyY2gnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2FyY2hpdmUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2dsb2JlJ1xuaW1wb3J0ICd2dWUtYXdlc29tZS9pY29ucy9xcmNvZGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2tleWJvYXJkLW8nXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2ZpbGUnXG5pbXBvcnQgJ3Z1ZS1hd2Vzb21lL2ljb25zL2ZpbGUtbydcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvZmlsZXMtbydcbmltcG9ydCAndnVlLWF3ZXNvbWUvaWNvbnMvZm9sZGVyJ1xuXG5WdWUuY29tcG9uZW50KCdpY29uJywgcmVxdWlyZSgndnVlLWF3ZXNvbWUvY29tcG9uZW50cy9JY29uJykpXG5cbi8qICAgICAgICAgICAgICAgIENvbXBvbmVudHMgICAgICAgICAgICAgICAgKi9cblZ1ZS5jb21wb25lbnQoJ0xpbmdvJywgcmVxdWlyZSgnLi9NYWluL2NvbnRhaW5lcicpKVxuVnVlLmNvbXBvbmVudCgnTXlOb3RpZmljYXRpb24nLCByZXF1aXJlKCd2dWUtbm90aWYnKSlcblxubmV3IFZ1ZSh7XG4gICAgZWw6ICcjYXBwJ1xufSk7XG5cblxuLy8gV0VCUEFDSyBGT09URVIgLy9cbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9qcy9hcHAuanMiLCIvLyByZW1vdmVkIGJ5IGV4dHJhY3QtdGV4dC13ZWJwYWNrLXBsdWdpblxuXG5cbi8vLy8vLy8vLy8vLy8vLy8vL1xuLy8gV0VCUEFDSyBGT09URVJcbi8vIC4vcmVzb3VyY2VzL2Fzc2V0cy9zYXNzL2FwcC5zY3NzXG4vLyBtb2R1bGUgaWQgPSAuL3Jlc291cmNlcy9hc3NldHMvc2Fzcy9hcHAuc2Nzc1xuLy8gbW9kdWxlIGNodW5rcyA9IDAiXSwic291cmNlUm9vdCI6IiJ9